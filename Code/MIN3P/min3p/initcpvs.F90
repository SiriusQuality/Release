!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initcpvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpvs
!c -------------------
!c
!c control parameters for variably saturated flow
!c
!c written by:      Uli Mayer - May 28, 96
!c
!c last modified:   Uli Mayer - July 24, 01
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           deltol_vs          = solver update tolerance             * +
!c           dinc_vs            = increment for numerical             * +
!c                                differentiation
!c           perm_fac(nn)       = scaling factor for permeability     * +
!c                                as a function of porosity changes 
!c           restol_vs          = solver residual tolerance           * +
!c           srelfac_vs         = user specified underrelaxation      * +
!c                                factor
!c           sw_star            = anticipated change in saturation    * +
!c                                per time step
!c           tol_vs             = convergence tolerance               * +
!c                                (variably saturated flow)
!c           uvslim             = max. allowed update                 * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           idetail_vs         = solver information level            * +
!c           level_vs           = incomplete factorization level      * +
!c           maxit_vs           = max. number of newton iterations    * +
!c                                (variably saturated flow)
!c           msolvit_vs         = max. number of solver iterations    * +
!c           nn                 = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   * +
!c                                           factor
!c           hydraulic_head     = .true.  -> initial condition in     * +
!c                                           terms of hydraulic head
!c           mass_balance_vs    = .true.  -> compute mass balance     * +
!c                                           (variably_saturated
!c                                            flow)
!c           pressure_head      = .true.  -> initial condition in     * +
!c                                           terms of pressure head
!c           rcm_ordering_vs    = .true.  -> rcm ordering for         * +
!c                                           1d scalar matrix
!c           under_relax        = .true.  -> underrelaxation          * +
!c           upstream           = .true.  -> upstream weighting       * +
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c local:    integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpvs
 
      use parm
      use gen
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, ivol, l_string

      external findstrg, readbloc

      real*8, parameter :: r1 = 1.0d0

      logical found_section, found_subsection
      character*72 subsection
 
!c  define or read control parameters for variably saturated flow
!c  and write to temporary file
   
      section_header = 'control parameters - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for control parameters for variably saturated flow

!c  general control parameters

      mass_balance_vs = .true.
      pressure_head = .false.
      tol_vs = 1.0d-6
      rtol_relbalance_vs = 1.0d100
      rtol_absbalance_vs = 1.0d100
      relbalance_vs = 0.0d0
      absbalance_vs = 0.0d0

      if (variably_saturated) then
        upstream = .true.
      elseif (fully_saturated) then
        upstream = .false.
      end if

!c  Newton iteration

      dinc_vs = 1.0d-4
      maxit_vs = 15
      sw_star = 0.1

!c  underrelaxation

      if (variably_saturated) then
        under_relax = .false.
        comp_relax = .false.
      end if

!c  solver settings

      level_vs = 0
      msolvit_vs = 100
      idetail_vs = 1
      restol_vs = 0.1d0 * tol_vs
      deltol_vs = 0.1d0 * tol_vs
      if(i_solver_type_flow == 0) then
        rcm_ordering_vs = .true.
      else
        rcm_ordering_vs = .false.
      end if

!c  initialize scaling factor for permeability update
 
      do ivol = 1,nngl
        perm_fac(ivol) = r1
      end do

      if (found_section) then

!c  mass balance settings - new definition

        subsection = 'mass balance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
        else
          mass_balance_vs = .false.
        end if

!c  mass balance settings - old definition

        subsection = 'mass balance settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) mass_balance_vs
        end if

        subsection = 'relative mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
        end if

        subsection = 'absolute mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if

        subsection = 'mass balance convergence tolerance settings'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if

!c  input units for boundary and initial conditions

        subsection = 'input units for boundary and initial conditions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'pressure head') then
            pressure_head = .true.
          elseif (subsection.eq.'hydraulic head') then
            pressure_head = .false.
          else
            goto 999
          end if
        end if


        if (variably_saturated) then

!c  upstream weighting - old definition

          subsection = 'upstream weighting'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            read(itmp,*,err=999,end=999) upstream
          end if

!c  upstream weighting - new definition

          subsection = 'centered weighting'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            upstream = .false.
          else
            upstream = .true.
          end if

!c  user specified underrelaxation factor

          subsection = 'user specified underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            read(itmp,*,err=999,end=999) srelfac_vs
          end if

!c  compute underrelaxation factor

          subsection = 'compute underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            comp_relax = .true.
            read(itmp,*,err=999,end=999) uvslim
          end if

!c  newton iteration settings

          subsection = 'newton iteration settings'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            read(itmp,*,err=999,end=999) dinc_vs
            read(itmp,*,err=999,end=999) maxit_vs
            read(itmp,*,err=999,end=999) tol_vs 
            read(itmp,*,err=999,end=999) sw_star
          end if

        end if              !(variably saturated)

!c  solver settings

        subsection = 'solver settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) level_vs 
          read(itmp,*,err=999,end=999) msolvit_vs
          read(itmp,*,err=999,end=999) idetail_vs
          read(itmp,*,err=999,end=999) restol_vs
          read(itmp,*,err=999,end=999) deltol_vs
          read(itmp,*,err=998,end=998) rcm_ordering_vs      !old
        end if

 998    subsection = 'natural ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .false.
        end if
        
        subsection = 'rcm ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .true.
        end if

      end if                 !(found_section)

!c  assign related control parameters

      if (.not.pressure_head) then
         hydraulic_head = .true.
      end if
      
      if (b_enable_output .and. b_enable_output_gen) then

!c  write control parameters for reactive transport
!c  to generic output file
 
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

      if (pressure_head) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'pressure head'
      elseif (hydraulic_head) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'hydraulic head'
      end if

      if (variably_saturated) then    
        if (upstream) then
          write(igen,'(a)')                                       &
     &    'upstream weighting of relative permeabilities        '
        else
          write(igen,'(a)')                                       &
     &    'centered weighting of relative permeabilities        '
        end if

        if (under_relax) then
          if (comp_relax) then
            write(igen,'(a)')                                     &
     &      'computation of underrelaxation factor                '
            write(igen,'(a,1pe10.3)')                             &
     &      'max. allowed update                             = ', &
     &       uvslim 
          else
            write(igen,'(a,1pe10.3)')                             &
     &      'user specified underrelaxation factor           = ', &
     &       srelfac_vs
          end if
        end if
   
        write(igen,'(a,1pe10.3)')                                 &
     &  'increment for numerical differentiation         = ',     &
     &   dinc_vs
        write(igen,'(a,i10)')                                     &
     &  'max. number of newton iterations                = ',     &
     &   maxit_vs
        write(igen,'(a,1pe10.3)')                                 &
     &  'convergence tolerance                           = ',     &
     &   tol_vs
        write(igen,'(a,1pe10.3)')                                 &
     &  'anticipated change in saturation per time step  = ',     &
     &   sw_star
      end if
      write(igen,'(a,i10)')                                       &
     &'incomplete factorization level                  = ',       &
     & level_vs
      write(igen,'(a,i10)')                                       &
     &'max. number of solver iterations                = ',       &
     & msolvit_vs
      write(igen,'(a,i10)')                                       &
     &'solver information level                        = ',       &
     & idetail_vs
      write(igen,'(a,1pe10.3)')                                   &
     &'solver residual tolerance                       = ',       &
     & restol_vs  
      write(igen,'(a,1pe10.3)')                                   &
     &'solver update tolerance                         = ',       &
     & deltol_vs
      if (rcm_ordering_vs) then
        write(igen,'(a)')'reverse Cuthill McKee ordering'
      else
        write(igen,'(a)')'natural ordering'
      end if
      
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file in initcpvs'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
