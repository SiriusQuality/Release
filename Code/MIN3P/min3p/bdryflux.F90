!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/bdryflux.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function bdryflux
!c ------------------------
!c
!c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!c have to add storage here ...... for transient conditions
!c i.e. do local mass balance ....(only needed for seepage face in case 
!c switching bewteen types)
!c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!c compute water flux across boundary control volumes
!c
!c written by:      Uli Mayer - September 5, 96
!c
!c last modified:   Tom Henderson - March 24, 2003
!c                  added point source
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           bdryflux           = water flux across boundary face     * + 
!c
!c           integer*4:
!c           ----------
!c           ivol               = pointer to current control volume   + -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           hhead(nn)          = hydraulic head                      + -
!c           relperm(nn)        = relative permeability               + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  + -
!c
!c           integer*4:
!c           ----------
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           iups(ncon-1)       = upstream pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           upstream           = .true.  -> upstream weighting       + -
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c        
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control 
!c                                volumes)
!c           icon               = counter (off-diagonal 
!c                                connections)
!c           iend               = pointer (end)
!c           istart             = pointer (start) 
!c           jvol               = pointer (column in 1d-scalar 
!c                                matrix)
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit
!c                                search
!c
!c external: fluxvs    = water flux at interface for variably
!c                       saturated conditions
!c           fluxfs    = water flux at interface for fully
!c                       saturated conditions
!c ----------------------------------------------------------------------
 
      real*8 function bdryflux(ivol)
 
      use parm
      use gen
#ifdef OPENMP
      use omp_lib 
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
 
      implicit none
      
      integer :: i1, ibvs, icon, istart, iend, ivol, jvol
      
      real*8 :: fluxvs, fluxfs
      
#ifdef OPENMP
      real*8 :: vsflux_loc
      character*1 :: iups_loc
#endif

      real*8, parameter :: r0 = 0.0d0 
      
      external ::  fluxvs, fluxfs

      bdryflux = r0             !initialize boundary flux
      ibvs = ivol2bvs(ivol)
      
      if (ibvs == 0) then
        return
      end if

!      if (ibvs == 0) then
!        if (rank == 0) then  
!          write(ilog,*) ' warning .....................'
!          write(ilog,*) ' no water flux across boundary'
!          !write(igen,*) ' warning .....................'
!          !write(igen,*) ' no water flux across boundary'
!        end if
!#ifdef PETSC
!        call petsc_mpi_finalize
!#endif
!        stop
!      end if

!c  compute water flux across boundary

!c  fluxes at first type control volumes or zero pressure seepage
!c  control volumes

     if ((btypevs(ibvs).eq.'first').or.    & !first type (Dirichlet)
        ((btypevs(ibvs).eq.'seepage').and. & !first type (seepage)
         (bcondvs(ibvs).lt.r0))) then

       istart = iavs(ivol)+1     !pointer - start of row
       iend = iavs(ivol+1)-1     !pointer - end of row
       icon = 0                  !counter (connections)

       do i1=istart,iend         !loop over connections

         jvol = javs(i1)         !column pointer
         icon = icon+1           !counter (connections)

!c  consistent with upstream weighting

         if (upstream) then
#ifdef OPENMP
           iups_loc = 'i'                           !h_i >= h_j
           if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
             iups_loc = 'j'
           end if
#else
           iups(icon) = 'i'                         !h_i >= h_j
           if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
             iups(icon) = 'j'
           end if
#endif
         end if

!c  water flux calculations

         if (variably_saturated) then
#ifdef OPENMP
           vsflux_loc = - fluxvs(upstream,                     & 
                                  hhead(ivol),hhead(jvol),       &
                                  relperm(ivol),relperm(jvol),   &
                                  iups_loc,cinfvs_a(i1))
#else
           vsflux(icon) = - fluxvs(upstream,                     & 
                                  hhead(ivol),hhead(jvol),       &
                                  relperm(ivol),relperm(jvol),   &
                                  iups(icon),cinfvs_a(i1))
#endif
         elseif (fully_saturated) then
#ifdef OPENMP
           vsflux_loc = - fluxfs(uvsnew(ivol),uvsnew(jvol),    &
                                  cinfvs_a(i1))
#else
           vsflux(icon) = - fluxfs(uvsnew(ivol),uvsnew(jvol),    &
                                  cinfvs_a(i1))
#endif
         end if
#ifdef OPENMP
         bdryflux = bdryflux + vsflux_loc
#else
         bdryflux = bdryflux + vsflux(icon)
#endif

       end do                    !loop over connections

!c        write(idbg,*) 'bdryflux',bdryflux

!c  fluxes at specified flux control volumes

     elseif ((btypevs(ibvs).eq.'second') .or. &
         (btypevs(ibvs).eq.'point')) then   

       if (b_water_freezing) then
         if (tempnew(ivol) > water_freezing_temper) then
           bdryflux = bcondvs(ibvs)
         else
           bdryflux = 0.0d0
         end if
       else
         bdryflux = bcondvs(ibvs)
       end if

     end if                      !boundary type (flow)
 
    return
    end
