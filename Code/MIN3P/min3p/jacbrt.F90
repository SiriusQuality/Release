!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacbrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacbrt
!c -----------------
!c
!c modifed for density dependent flow 
!c
!c incorporate Dirichlet, Neumann and Cauchy type boundary condition in 
!c Jacobian matrix and rhs vector for reactive transport
!c
!c
!c written by:      Uli Mayer - August 20, 96
!c
!c last modified:   Tom Henderson - January 26, 2007
!c                  Lump 'point' BC with Cauchy BC to simulate pumping well
!c                  
!c                  Sergi Molins - May 2, 2006 
!c                                 tried to include DGM diff + advection 
!c                                 in 'mixed' type b.c. section without success
!c                  Sergi Molins - June 12, 2006
!c                                 gsatmin = 0.0 (larger values cause DGM/ MS
!c                                 modules to fail under saturated conditions)
!c                                 relpgij passed to dgm_dfluxdg.f
!c
!c                  Danyang Su   - March 27, 2014
!c                               Add gas advection, modified from Sergi Molins's codes
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           art(njart)         = jacobian matrix                     + +
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third type b.c. -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (gaseous phase)
!c                                third type b.c. -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for + -
!c                                diffusive mass fluxes across
!c                                boundary (excluding diffusion
!c                                coefficient)
!c           brt(nn*n)          = rhs vector                          + +
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           c(nc,nn)            = concentrations of free species      + -
!c                                - old time level [moles/l water]
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           gamma(nc+nx,nn)    = activity coefficients of free       + -
!c                                species
!c           dinc_rt            = factor to compute increment for     + -
!c                                numerical differentiation
!c           dtotcflux(n)       = derivatives of total mass fluxes    * +
!c                                (water phase)
!c           dtotgflux(n)       = derivatives of total mass fluxes    * +
!c                                (gaseous phase)
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles/l air]
!c           pornew(nn)         = porosity                            + -
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                (new time level)
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                (new time level)
!c           sionnew(nn)        = ionic strength                      + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgnew(n,nn)      = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totcflux(n)        = total mass fluxes (aqueous phase)   * +
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * +
!c
!c           integer*4:
!c           ----------
!c           iart(nn*n+1)       = row pointer array for art           + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           igen               = unit number, generic output file    + -
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook file           + -
!c           jabrt(nbrt)        = pointer array - boundary conditions + -
!c                                (reactive transport)
!c           lart(njavs+1)      = pointer array                       + -
!c           kadbl(n,n)         = pointer array for conversion to     + -
!c                                sparse format (diagonal block
!c                                matrices)
!c           kaobl(n,n)         = pointer array for conversion        + -
!c                                to sparse format
!c                                (off-diagonal block matrices)
!c           kart(njart)        = mapping pointer
!c                                (global block -> nd-scalar)         + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 + -
!c           n                  = number of primary unknowns          + -
!c           nbrt               = number of specified boundary        + -
!c                                control volumes
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (free advective mass
!c                                            outflux for aqueous
!c                                            phase)
!c                                'third'  = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c           prefix             = prefix name for all I/O files       + -
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c           zone_name          = name of zone                        * *
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c
!c chem.f:   real*8:
!c           -------
!c           acth2omin          = min. activity for h2o
!c           adav               = coefficient for Davies equation     + -
!c           bdav               = coefficient for Davies equation     + -
!c           cinc(nc,nthreads)  = incremented free species            * +
!c                                concentrations
!c                                [moles/l water]
!c           cxinc(nx,nthreads) = secondary aqueous species           * +
!c                                concentrations dependent on
!c                                incremented free species
!c                                concentrations
!c                                [moles/l water]
!c           chargec(ic)        = charge of free species              + -
!c           chargex(ix)        = charge of secondary aqueous         + -
!c                                species
!c           dhac(ic)           = debye-huckel a for free species     + -
!c           dhbc(ic)           = debye-huckel b for free species     + -
!c           dhax(ix)           = debye-huckel a for secondary        + -
!c                                aqueous species
!c           dhbx(ix)           = debye-huckel b for secondary        + -
!c                                aqueous species
!c           dhad(nthreads)     = Debye Huckel constant a_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhbd(nthreads)     = Debye Huckel constant b_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dtotc(n,ntheads)   = derivatives of total aqueous        * *
!c                                component concentrations
!c                                [moles/l water]
!c           dtotg(n)           = derivatives of total gaseous        * *
!c                                component concentrations
!c                                [moles/l air]
!c           eqr(nr,nthreads)   = equilibrium constant for redox      + -
!c                                couple reaction equation
!c           eqx(nx,nthreads)   = equilibrium constants for           + -
!c                                aqueous complexes
!c           ginc(ng,nthreads)  = gas concentrations dependent on     * *
!c                                incremented free species
!c                                concentrations
!c                                [moles/l air]
!c           totcn(n,nthreads)  = total aqueous component             + -
!c                                concentrations
!c                                - new time level, [moles/l water]
!c           xnug(ng*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of gases from
!c                                free species
!c           xnur(nr*nc)        = stoichiometric coefficient of       + -
!c                                component in redox couple
!c                                reaction equation
!c           xnux(nx*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of aqueous complexes
!c                                from components
!c
!c           integer*4:
!c           ----------
!c           iaga(ng+1)         = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           iarc(nr+1)         = row pointer array to                + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iax(nx+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in
!c                                secondary aqueous species
!c           jaga(ng*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           jarc(nr*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           jax(nx*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in secondary aqueous
!c                                species
!c           nc                 = number of components                + -
!c           nr                 = number of redox couples             + -
!c           nx                 = number of secondary aqueous species + -
!c
!c           logical:
!c           --------
!c           analyt_deriv_rt    = .true.  -> form derivatives         + -
!c                                           analytically
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           namec(nc)          = component names                     + -
!c           namex(nx)          = names of secondary aqueous species  + -
!c
!c dens.f:   logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c           bdyinfrt_da        = boundary influence coefficient
!c                                for diffusive mass flux (aqueous
!c                                phase)
!c           bdyinfrt_dg        = boundary influence coefficient
!c                                for diffusive mass flux (gaseous
!c                                phase)
!c           diff_eff           = effective diffusion coefficient
!c           drtinc             = increment for numerical 
!c                                differentiation
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           i2                 = pointer (entries in ja, a arrays
!c                                         for nd-scalar matrix)
!c           ibl                = counter (rows of block matrix)
!c           ibrt               = counter (boundary control volumes)
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           ir                 = counter (redox couples)
!c           ix                 = counter (aqueous complexes)
!c           idiag              = pointer (diagonal entry - global
!c                                         scalar matrix)
!c           iend               = pointer (end)
!c           iend2              = pointer (end)
!c           irow               = pointer (row in global scalar 
!c                                         matrix)
!c           istart             = pointer (start) 
!c           istart2            = pointer (start) 
!c           ivol               = pointer to current control volume
!c           jbl                = counter (columns of block matrix)
!c           ldiag              = pointer (diagonal block in global
!c                                         block matrix)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: acoff     = compute activity coefficient 
!c           bdryflux  = compute water flux across boundary control 
!c                       volumes
!c           comptotc  = comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           ddbdflux  = compute water flux across boundary control 
!c                       volumes - density dependent flow
!c           diffcoff  = compute effective diffusion coefficient
!c           dtotconc  = compute numerical derivative of total aqueous
!c                       component concentrations
!c           atotconc  = compute analytical derivatives of total aqueous
!c                       component concentrations
!c           dtotcong  = compute derivative of total gaseous
!c                       component concentrations
!c           fluxd     = diffusive/dispersive flux
!c           gasconc   = compute gas concentrations based on
!c                       concentrations of free species
!c           secspec   = compute aqueous complex concentration 
!c                       based on concentrations of free species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totconc   = compute total aqueous component 
!c                       concentrations based on concentrations 
!c                       of free species and secondary aqueous 
!c                       species
!c ----------------------------------------------------------------------
 
      subroutine jacbrt
 
      use parm
      use gen
      use phys
      use chem
      use dens
      use dgml
#ifdef OPENMP
      use omp_lib 
#endif      
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: idiag, i1, i2, ibl, ibvs, icol, ierr, ig, info_debug, &
                 ibrt, ivol, ic, ir, ix, istart, iend, istart2, iend2, &
                 irow, iaq, jbl, ldiag, i, j
      
      real*8 :: acoff, area_ivol, ddbdflux, bdryflux, bdyinfrt_da,     &
                bdyinfrt_dg, dgflux, dfluxvg, diff_eff, diffcoff,      &
                drtinc, fluxd, fluxvg, gasm, gasp_m, gasd_m, gasv,     &
                gasp, gasdiff2, diffcoff_g
      
      integer :: tid

      external acoff, bdryflux, comptotc, ddbdflux,     &
               diffcoff,dtotcong, fluxd,                & 
               secspec, totconc,                        &
               gasm, gasd_m, gasp_m, gasv, giups_brt,   &
               wgprop, wgpropd, gasp
!cprovi-------------------------------------------------------------------
!cprovi This variables was added by Sergio Andres Bea Jofre 
!cprovi-------------------------------------------------------------------      
      real*8             inoutflow
      logical            compute_diff
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmall=1.0d-1,      &
                           rverysmall=1.0d-30, gsatmin=0.0d0
     
!cdsu added for dgm model
!c dgm variables and initialization
      integer*4 :: ipvt(ng)
	  real*8    :: dgm_gflux(nc), dgm_dgflux(nc)
	  real*8    :: ludecomp(ng,ng), fmat(ng)

!c ms variables	
	  real*8    :: ms_gflux(nc), ms_dgflux(nc), neflux(nc),            &
                   lumat2(ng-1,ng-1)
      real*8 :: so_av, cinfrt, mdens_g_inc, dgmfrac(ng)
      
!cdsu-------------------------------------------------------------------
!cdsu---------------------Gas transport variables-----------------------
!cdsu-------------------------------------------------------------------
      character*12 :: spt_weight
      real*8 ::                   &
     &       gsatijbrt          , &
     &       gporijbrt          , &
     &       tauijbrt           , &
     &       mdens_g_ivol       , &
     &       mdens_g_brt        , &
     &       gpivol_ivol        , &
     &       gdens_ivol         , &
     &       gvisc_ivol         , &
     &       gpivol_brt         , &
     &       gdens_brt          , &
     &       gvisc_brt          , &
     &       relpgij            , & 
     &       densgij            , &           
     &       viscgij            , &
     &       gpij               , &
     &       dgpivol            , &
     &       dmdens_i           , &
     &       ddens_i            , &
     &       wfac 
     
     
!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------      
      real (type_r8), allocatable :: bdyinfrt_da_ic(:)
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
      
        !>interface of atotconc
        subroutine atotconc(c,cx,jbl)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          integer(type_i4) :: jbl    
        end subroutine atotconc
      
        !>interface dtotconc
        subroutine dtotconc(c,cx,drtinc,jbl,izn_opt)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8) :: drtinc
          integer(type_i4) :: jbl
          integer, optional :: izn_opt
        end subroutine dtotconc
                 
        !>interface gasconc
        subroutine gasconc(c,gammac,g,ig,tempkel)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8) :: g
          integer(type_i4) :: ig
          real(type_r8) :: tempkel
        end subroutine gasconc
        
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel
        end subroutine tcorr
        
        !>interface of gcreact           
        subroutine gcreact(cnew,cold,cx,gammac,gammax,gnew,sw,sa,por,   &
                        igen,ilog,idbg,tec_header,prefix,l_prfx,        &
                        zone_name,l_zone_name) 
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: cnew
          real(type_r8), dimension(*) :: cold
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: gnew
          real (type_r8) :: sw
          real (type_r8) :: sa
          real (type_r8) :: por
          integer(type_i4) :: igen
          integer(type_i4) :: ilog
          integer(type_i4) :: idbg
          logical :: tec_header
          character*72 :: prefix
          integer(type_i4) :: l_prfx
          character*72 :: zone_name
          integer(type_i4) :: l_zone_name      
         end subroutine

        !>interface of jacbevap
        !subroutine jacbevap(ivol,typeequation)
        !  integer, intent(in)           :: ivol 
        !  character(len=*), intent(in)  :: typeequation  
        !end subroutine jacbevap
        
      end interface   
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      gsatijbrt = r0
  
      allocate (bdyinfrt_da_ic(nc), stat = ierr)
      bdyinfrt_da_ic(1:nc) = r0
      call checkerr(ierr,'bdyinfrt_da_ic',ilog)
!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------
      if(iter_rt.eq.1) then
        info_debug = 0
      else
        info_debug = 0 
      end if      

#ifdef DEBUG
      if(info_debug > 10) then
          write(idbg, *) "--> totgflux ", totgflux
      end if
#endif
      
!c    assign gas advection spatial weighting
      spt_weight = spatial_weighting
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_jacbrt == 1)                     &
    !$omp num_threads(numofthreads_matrix_react)                      &
    !$omp default(shared)                                             &
    !$omp private(tid, i2, ibl, ibrt, ibvs, ic, idiag, iend, iend2,   &
    !$omp iaq, ig, ir, irow, istart, istart2, ivol, ix, jbl, ldiag,   &
    !$omp gsatijbrt, gporijbrt, tauijbrt, mdens_g_ivol,               &     !Gas transport variables
    !$omp mdens_g_brt, gpivol_ivol, gdens_ivol, gvisc_ivol,           &
    !$omp gpivol_brt, gdens_brt, gvisc_brt, totgnew_brt,              &
    !$omp gmfrac_ivol, gmfrac_brt, scalfac_aq, totgmfrac_ivol,        &
    !$omp totgmfrac_brt, iupsgbrt, totgij, gij,                       &     
    !$omp dgpivol, dmdens_i, ddens_i, dg, wfac,                       &
    !$omp cinfrt, ms_gflux, ms_dgflux, dgm_gflux, dgm_dgflux,         &
    !$omp dgmfrac, fmat, ipvt, ludecomp, lumat2, neflux,              &
    !$omp mdens_g_inc, so_av)                                         &     !End of Gas transport variables
    !$omp firstprivate(area_ivol, bdyinfrt_da, bdyinfrt_da_ic,        &
    !$omp bdyinfrt_dg, compute_diff, diff_eff, drtinc,                &
    !$omp dtotcflux, dtotg, dtotgflux, inoutflow,                     &
    !$omp totcflux, totgflux, zone_name)        
    
#endif      
!c  loop over boundary control volumes
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif

      do ibrt = 1,nbrt
          
#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif

        ivol = jabrt(ibrt)

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

        if (temp_field.or.heat_transport) then
          call tcorr(tkel(ivol))
        end if
 
!c ----------------------------------------------------------------------
!c Dirichlet type boundary condition
!c  -> fixed free species concentration
!c  -> put 1 on diagonal, zero out rest of row and rhs
!c ----------------------------------------------------------------------

        if (btypert(ivol).eq.'first') then  !boundary types

!c  temperature correction for boundary concentrations

          if (temp_field.or.heat_transport) then

            do ic = 1,nc-1
              totcn(ic,tid) = totcnew(ic,ivol)
              totco(ic,tid) = totcold(ic,ivol)
            end do
            
            do iaq=1,naq
              scalfac_aq(iaq)=scalfac_aq_ivol(iaq,ivol)
            end do 

            zone_name = 'temperature-correction'
            call gcreact(cnew(1,ivol),c(1,ivol),cx(1,ivol),       &
                         gamma(1,ivol),gamma(nc+1,ivol),          &
                         gnew(1,ivol),sanew(ivol),sgnew(ivol),    &
                         pornew(ivol),igen,ilog,idbg,tec_header,  &
                         prefix,l_prfx,zone_name,l_zone_name)
          end if

          istart = (ivol-1)*n+1           !pointer - first row
          iend = ivol*n                   !pointer - last row

          do irow = istart,iend           !loop over rows
            istart2 = iart(irow)+1        !pointer - start of row
            iend2 = iart(irow+1)-1        !pointer - end of row
            idiag = iart(irow)            !pointer - diagonal

            art(idiag) = r1
            do i1=istart2,iend2          
              art(i1) = r0                !modify jacobian matrix
            end do
            brt(irow) = r0                !modify rhs-vector
          end do
          
#ifdef DEBUG
          if(info_debug > 20) then
              write(idbg, *)                                          &
              "--> brt first boundary type, istart, iend, brt ",      &
              istart, iend, brt(istart:iend)
          end if 
#endif

!c ----------------------------------------------------------------------
!c  Neumann type boundary condition
!c  -> advective mass flux across outflow boundary
!c     modify rhs-vector and Jacobian matrix
!c ----------------------------------------------------------------------
 
        elseif (btypert(ivol).eq.'second') then

!c  modify rhs-vector

          istart = (ivol-1)*n+1           !pointer - first row
          iend = ivol*n                   !pointer - last row

          ic = 0
          do irow = istart,iend           !rows (global scalar matrix)
            ic = ic+1
            if (component_type(ic).eq.'aqueous') then
            if (density_dependence) then

                totcflux(ic) = ddbdflux(ivol) * totcnew(ic,ivol)
                brt(irow) = brt(irow) + totcflux(ic)              
              else

                totcflux(ic) = bdryflux(ivol) * totcnew(ic,ivol)
                brt(irow) = brt(irow) + totcflux(ic)
              end if
#ifdef DEBUG
              if(info_debug > 20) then
                write(idbg, *)                                        & 
                "--> brt second boundary type, irow, brt ",           &
                irow, brt(irow)
              end if
#endif
            end if
          end do

          idiag = iavs(ivol)        !diagonal pointer - block matrix

!c  compute derivatives of total mass flux across boundary

!c  temporary storage for free species concentrations

          do ic=1,nc
            cinc(ic,tid) = cnew(ic,ivol)
          end do

          do jbl=1,n                !loop over columns of block matrix

!c  compute increment for numerical differentiation

            drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column

            cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  recompute activity coefficients

            if (update_activity(tid).eq.'double_update') then
!cprovi----------------------------------------------       
               if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
                     call pitzer (phase,gamma(1:nc,ivol),             &
     &                            gamma(nc+1:nc+nx,ivol),             &
     &                            cnew(1:nc,ivol),cx(1:nx,ivol),      &
     &                            nc,nx,ilog)
             else
!c  for free species
                     do ic=1,nc
                         gamma(ic,ivol) = acoff(cnew(1,ivol),         &
     &                                    cx(1,ivol),                 &
     &                                    sionnew(ivol),chargec(ic),  &
     &                                    dhac(ic),dhbc(ic),          &
     &                                    dhad(tid),dhbd(tid),        &
     &                                    adav,bdav,acth2omin,nc,     &
     &                                    nx,namec(ic),namec)
                     end do

!c  for aqueous complexes

                     do ix=1,nx
                        gamma(nc+ix,ivol) = acoff(cnew(1,ivol),       &
     &                                      cx(1,ivol),               &
     &                                      sionnew(ivol),chargex(ix),&
     &                                      dhax(ix),dhbx(ix),        &
     &                                      dhad(tid),dhbd(tid),      &
     &                                      adav,bdav,acth2omin,      &
     &                                      nc,nx,namex(ix),namec)
                     end do

               end if       
          
          end if
      
!c  equilibrium redox reactions, compute concentrations of dependent
!c  species of redox couples with incremented free species
!c  concentrations

            if (redox_equil.and.nr.gt.0) then
              do ir=1,nr
                ic = n+ir
                call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),    &
                gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
              end do
            end if

!c  compute aqueous complex concentrations with incremented free
!c  species concentrations

            do ix=1,nx
              call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),     &
              gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
            end do

!c  compute total aqueous component concentrations with incremented
!c  free species concentrations

            if (analyt_deriv_rt) then
              call atotconc(cnew(1,ivol),cx(1,ivol),jbl)      
            else
              call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl)
            end if

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotc(:,tid))
            end if

!c  modify current column of jacobian matrix

            do ibl=1,n            !loop over rows (block matrix)

              if (kaobl(ibl,jbl).ne.0) then          !skip zero entries
              
              
!cprovi-------------------------------------------------------------------
!cprovi Bubbles use component dependent diff coefficient if speciifed
!cprovi-------------------------------------------------------------------
              if (diff_coff) then
                bdyinfrt_da = bdyinfrt_da_ic(jbl)
             end if
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!c  - derivative of total mass flux across boundary

                if (density_dependence) then
                  dtotcflux(ibl) = ddbdflux(ivol) * dtotc(ibl,tid)
              else
                  dtotcflux(ibl) = bdryflux(ivol) * dtotc(ibl,tid)
              end if  
              end if              !skip zero entries
            end do                !loop over components

!c  - get pointer for global block matrix

            ldiag = lart(idiag)  !diagonal pointer - global block matrix
            do ibl=1,n           !loop over rows of block matrix

!c  - skip zero entries, here only mobile species are considered,
!c    kaobl has to be used therefore to skip zero entries
!c    the pointer i2 jhas to be computed using kadbl nevertheless

              if (kaobl(ibl,jbl).ne.0) then           !skip zero entries

!c  - get pointer for assembly in n-d scalar matrix

                i2 = kart(ldiag+kadbl(ibl,jbl)-1)

                if (component_type(ibl).eq.'aqueous') then
                  art(i2) = art(i2) - cnew(jbl,ivol) * dtotcflux(ibl)
                end if

              end if                !skip zero entries
            end do                  !loop over rows of block matrix

!c  "unshift" free species concentration of current column

            cinc(jbl,tid) = cnew(jbl,ivol) 

          end do                    !loop over columns of block matrix


!c ----------------------------------------------------------------------
!c  Point (well) and Cauchy type boundary conditions 
!c  -> specified advective flux for aqueous phase
!c     modify rhs-vector only
!c
!c  Modified to consider temporal switch in flow boundary condition from
!c  inflow to outflow: Henry variable density problem & pumping well
!c 
!c  Requires replacement of third type reactive transport boundary condition
!c  with second type boundary conditions if outflow occurs at the boundary
!c ----------------------------------------------------------------------

        elseif ((btypert(ivol).eq.'third').or.    &
     &          (btypert(ivol).eq.'point')) then
          
          if (evaporation) then
              ibvs = ivol2bvs(ivol)
              if(ibvs==0) then
                  if (rank == 0) then
                    write(ilog,*)'error in boundary cond.'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
              end if 
              if (btypevs(ibvs)=='atmospheric') then 
                   area_ivol=bcondvs(ibvs)
                   !cprovi---------------------------------------------------
                   !cprovi Change the inflow/for m3/day
                   !cprovi---------------------------------------------------
                !  call jacbevap(ivol,' ') 
                   inoutflow = totwflux_atm*area_ivol/ref_dens
                   if (inoutflow<r0) then
                     inoutflow=r0
                   end if
              else
                   if (density_dependence) then
                      inoutflow = ddbdflux(ivol)          
                 else
                      inoutflow = bdryflux(ivol)          
                 end if 
              end if
          else
            if (density_dependence) then
              inoutflow = ddbdflux(ivol)          
          else
              inoutflow = bdryflux(ivol)          
          end if    
          end if

!c  calculate boundary flux vector
          do ic = 1,n
            totcflux(ic) = inoutflow*bcondrt_a(ic,ibrt)          
          end do

!c  third type boundary condition: mass influx at boundary

            if (inoutflow>r0) then  

!c  modify rhs-vector

              istart = (ivol-1)*n+1           !pointer - first row
              iend = ivol*n                   !pointer - last row

              ic = 0
              do irow = istart,iend           !loop over rows
                ic = ic+1
                if (component_type(ic).eq.'aqueous') then
                  brt(irow) = brt(irow) + totcflux(ic)
                end if
              end do
              
#ifdef DEBUG
              if(info_debug > 20) then
                  write(idbg, *)                                      &
                  "--> brt third inoutflow > 0, istart, iend, brt ",  &
                  istart, iend, brt(istart:iend)
              end if
#endif

          elseif (inoutflow<=r0) then 

!c  treat as Neumann type boundary condition
!c  advective mass flux across outflow boundary
!c  modify rhs-vector and Jacobian matrix

              istart = (ivol-1)*n+1           !pointer - first row
              iend = ivol*n                   !pointer - last row

              ic = 0
              do irow = istart,iend           !rows (global scalar matrix)
                ic = ic+1
                if (component_type(ic).eq.'aqueous') then
                  if (density_dependence) then

                    totcflux(ic) = ddbdflux(ivol) * totcnew(ic,ivol)
                    brt(irow) = brt(irow) + totcflux(ic)              
                  else

                    totcflux(ic) = bdryflux(ivol) * totcnew(ic,ivol)
                    brt(irow) = brt(irow) + totcflux(ic)
                  end if
#ifdef DEBUG
                  if(info_debug > 20) then
                      write(idbg, *)                                      &
                      "--> brt third inoutflow <= 0 aqueous, ",           &
                      "irow, brt ", irow, brt(irow)
                  end if 
#endif
                end if
              end do
              
              idiag = iavs(ivol)        !diagonal pointer - block matrix

!c  compute derivatives of total mass flux across boundary

!c  temporary storage for free species concentrations

              do ic=1,nc
                cinc(ic,tid) = cnew(ic,ivol)
              end do

              do jbl=1,n                !loop over columns of block matrix

!c  compute increment for numerical differentiation

                drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column

                cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  recompute activity coefficients

                if (update_activity(tid).eq.'double_update') then

!cprovi----------------------------------------------       
              if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
                           call pitzer (phase,gamma(1:nc,ivol),       &
     &                            gamma(nc+1:nc+nx,ivol),             &
     &                            cnew(1:nc,ivol),cx(1:nx,ivol),      &
     &                            nc,nx,ilog)
             else
!c  for free species
             
                  do ic=1,nc
                    gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),   &
     &                                     sionnew(ivol),chargec(ic), &
     &                                     dhac(ic),dhbc(ic),         &
     &                                     dhad(tid),dhbd(tid),       &
     &                                     adav,bdav,acth2omin,       &
     &                                     nc,nx,namec(ic),namec)
                  end do

!c  for aqueous complexes

                  do ix=1,nx
                    gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
     &                                      sionnew(ivol),chargex(ix),&
     &                                      dhax(ix),dhbx(ix),        &
     &                                      dhad(tid),dhbd(tid),      &
     &                                      adav,bdav,acth2omin,      &
     &                                      nc,nx,namex(ix),namec)
                  end do
                  
               end if
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
                end if

!c  equilibrium redox reactions, compute concentrations of dependent
!c  species of redox couples with incremented free species
!c  concentrations

                if (redox_equil.and.nr.gt.0) then
                  do ir=1,nr
                    ic = n+ir
                    call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),&
                    gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
                  end do
                end if

!c  compute aqueous complex concentrations with incremented free
!c  species concentrations

                do ix=1,nx
                  call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid), &
                  gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
                end do

!c  compute total aqueous component concentrations with incremented
!c  free species concentrations

                if (analyt_deriv_rt) then
                  call atotconc(cnew(1,ivol),cx(1,ivol),jbl)
                else
                  call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl)
                end if

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

                if (redox_equil.and.nr.gt.0) then
                  call comptotc(dtotc(:,tid))
                end if

!c  modify current column of jacobian matrix

                do ibl=1,n            !loop over rows (block matrix)

                  if (kaobl(ibl,jbl).ne.0) then          !skip zero entries

!c  - derivative of total mass flux across boundary

                    if (density_dependence) then
                      dtotcflux(ibl) = ddbdflux(ivol) * dtotc(ibl,tid)
                    else
                      dtotcflux(ibl) = bdryflux(ivol) * dtotc(ibl,tid)
                    end if  
                  end if              !skip zero entries
                end do                !loop over components

!c  - get pointer for global block matrix

                ldiag = lart(idiag)  !diagonal pointer - global block matrix
                do ibl=1,n           !loop over rows of block matrix

!c  - skip zero entries, here only mobile species are considered,
!c    kaobl has to be used therefore to skip zero entries
!c    the pointer i2 jhas to be computed using kadbl nevertheless

                  if (kaobl(ibl,jbl).ne.0) then           !skip zero entries

!c  - get pointer for assembly in n-d scalar matrix

                    i2 = kart(ldiag+kadbl(ibl,jbl)-1)

                    if (component_type(ibl).eq.'aqueous') then
                      art(i2) = art(i2) - cnew(jbl,ivol)          &
     &                           * dtotcflux(ibl)
                    end if

                  end if                !skip zero entries
                end do                  !loop over rows of block matrix

!c  "unshift" free species concentration of current column

                cinc(jbl,tid) = cnew(jbl,ivol) 

              end do                    !loop over columns of block matrix

            end if  !if (bdryflux(ivol) .gt. r0
!cprovi-------------
        !  end if  !density_dependence

!c ----------------------------------------------------------------------
!c  mixed boundary condition: 
!c  -> specified advective flux and free diffusive flux across 
!c     boundary for aqueous phase and gaseous phase
!c     modify rhs-vector and Jacobian matrix
!c ----------------------------------------------------------------------
        elseif (btypert(ivol).eq.'mixed') then
!cprovi-----------------------------------------------------------------
!cprovi calculate boundary influence coeffcient for diffusive
!cprovi mass flux across boundary
!cprovi-------------------------------------------------------------   
        compute_diff = .true.       
        if (evaporation) then
              ibvs = ivol2bvs(ivol)
              !cprovi--------------------------------------------------
              !cprovi Check the boundary index for flow
              !cprovi--------------------------------------------------
              if(ibvs==0) then
                  if (rank == 0) then
                    write(ilog,*)'error in boundary cond.'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
              end if 
              if (btypevs(ibvs)=='atmospheric') then 
                   !cprovi---------------------------------------------------
                   !cprovi If the boundary condition for flow was defined 
                   !cprovi as atmospheric, then not compute the diffusive 
                   !cprovi fluxes
                   !cprovi---------------------------------------------------
                   compute_diff = .false.
                   area_ivol=bcondvs(ibvs)
                   !cprovi---------------------------------------------------
                   !cprovi Change the inflow/for m3/day
                   !cprovi---------------------------------------------------
               !   call jacbevap(ivol,' ') 
                   
                   inoutflow = totwflux_atm*area_ivol/ref_dens      !totwflux_atm is calculated in jacbevap, how? DSU
                   !cprovi---------------------------------------------------
                   !cprovi Set to zero when the flow>0 
                   !cprovi---------------------------------------------------
                   if (inoutflow<r0) then
                     inoutflow = r0
                   end if
                   
              else
                   if (density_dependence) then
                      inoutflow = ddbdflux(ivol)          
                 else
                      inoutflow = bdryflux(ivol)          
                 end if
              end if
         else
            if (density_dependence) then
              inoutflow = ddbdflux(ivol)          
          else
              inoutflow = bdryflux(ivol)          
          end if    
         end if  ! evaporation 
         
         so_av=dmin1(r1, sonew(ivol))
         
!cprovi-------------------------------------------------------------          
!cprovi Compute diffusive fluxes only when the boundary condition
!cprovi for flow is different than atmospheric 
!cprovi-------------------------------------------------------------      
       if (compute_diff) then 
           if (.not.diff_coff) then
                 diff_eff = diffcoff(diff_a, sanew(ivol),pornew(ivol),&
                            tortuosity_corr,assigned_tau,             &
                            tau(ivol)*tau_fac(ivol),                  &
                            type_tortuosity,marchies(ivol),so_av)
                 bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
           else
               do ic = 1,nc
                    diff_eff = diffcoff(diff_ic(ic), sanew(ivol),     &
                               pornew(ivol),tortuosity_corr,          &
                               assigned_tau,tau(ivol)*tau_fac(ivol),  &
                               type_tortuosity,marchies(ivol),so_av)
                  bdyinfrt_da_ic(ic) = diff_eff * bdycrt_d(ibrt)
               end do
           end if    
       else 
           if (diff_coff) then
              bdyinfrt_da_ic(1:nc) = r0
             else
              bdyinfrt_da = r0
           end if       
       end if   ! compute_diff   
!cprovi-------------------------------------------------------------          
!cprovi gaseous phase
!cprovi-------------------------------------------------------------
          if (ng>0) then
            diff_eff = diffcoff_g(diff_g, sgnew(ivol),pornew(ivol),   &
                                tortuosity_corr,assigned_tau,         &
                                tau(ivol)*tau_fac(ivol),              &
                                type_tortuosity,marchies(ivol),       &
                                gas_tortuosity,so_av)
            bdyinfrt_dg = diff_eff * bdycrt_d(ibrt)
            
            !variables for gas transport
            if(gas_advection .or. dgm .or. maxwell) then
                
                gsatijbrt = sgnew(ivol)
                gporijbrt = pornew(ivol)*sgnew(ivol)
                tauijbrt  = diff_eff / gporijbrt !/ diff_g
                
!c              total concentration of gas components at the boundary node
                call totconcg(gbrt,totgnew_brt)           
                
!c-------------------------------------------------------------------------
!c              calculate gas properties + molar fractions

                mdens_g_ivol  = gasm(ng, gnew(1,ivol))            ! gas molar dens
                mdens_g_brt   = gasm(ng, gbrt(1,ibrt))            ! gas molar dens               

                do ig=1,ng
                    gmfrac_ivol(ig) = gnew(ig,ivol) / mdens_g_ivol  ! molar fractions
                                                                    ! gas species
                    gmfrac_brt(ig)  = gbrt(ig,ibrt) / mdens_g_brt   ! molar fractions
                                                                    ! gas species
                enddo
         
                do ic=1,n
                    totgmfrac_ivol(ic) = totgnew(ic,ivol) /           &
                                         mdens_g_ivol               ! gas molar frac for components
                                                            
                    totgmfrac_brt(ic)  = totgnew_brt(ic)  /           &
                                         mdens_g_brt                ! gas molar frac for components
                enddo
      
                gpivol_ivol = gasp_m(mdens_g_ivol,ivol)             ! gas pressure
                gdens_ivol  = gasd_m(mdens_g_ivol,gmfrac_ivol)      ! gas density
                gvisc_ivol  = gasv(gmfrac_ivol)                     ! gas viscosity 

                gpivol_brt  = gasp_m(mdens_g_brt,ivol)              ! gas pressure
                gdens_brt   = gasd_m(mdens_g_brt,gmfrac_ivol)       ! gas density
                gvisc_brt   = gasv(gmfrac_brt)                      ! gas viscosity 

!c           decide on the upstream node
                if (spt_weight.eq.'upstream') then
            
                    call giups_brt(gpivol_ivol   , gpivol_brt  ,      &
     &                             zg(ivol)      , zgbrt(ibrt) ,      &
     &                             gdens_ivol    , gdens_brt   ,      &
     &                             iupsgbrt(ibrt), gacc)
                endif
!c-------------------------------------------------------------------------
            
!c              calculate gas properties at interface according to weighting scheme
                call wgprop(totgnew(1,ivol),totgnew_brt,totgij   ,    &
     &                  gnew(:,ivol)   ,gbrt(:,ibrt)   ,gij      ,    &
     &                  gmfrac_ivol    ,gmfrac_brt     ,gmfracij ,    &
     &                  relpermg(ivol) ,relpermg(ivol) ,relpgij  ,    &
     &                  gdens_ivol     ,gdens_brt      ,densgij  ,    &
     &                  gvisc_ivol     ,gvisc_brt      ,viscgij  ,    &
     &                  gpivol_ivol    ,gpivol_brt     ,gpij     ,    &
     &                  zg(ivol)       ,zgbrt(ibrt)    ,              &
     &                  spt_weight     ,iupsgbrt(ibrt) ,              &
     &                  nc             ,ng             ,gacc     )
                
            end if
            
!c --------- DGM module ---------------------------------------------------------
!c           solve A F = B
!c           computes fluxes F of all gas components at current c.v. interphase
          
		    if (dgm) then
		    
		      call dgm_fluxdg (gnew(1,ivol)     ,gbrt(1,ibrt)   ,      &
     &                         gij              ,gmfracij       ,      &
     &                         zg(ivol)         ,zgbrt(ibrt)    ,      &
     &                         densgij          ,gpij           ,      &
     &                         tkel(ivol)       ,permbrt(ibrt)  ,      &
     &                         relpgij          ,tauijbrt       ,      &
     &                         gporijbrt        ,dijbrt(ibrt)   ,      &
     &                         rverysmall       ,                      &
     &                         ludecomp         ,                      &
     &                         fmat             ,ipvt           ,      &
     &                         dgm_gflux        ,neflux         )
            
!c --------- Maxwell Stefan module ----------------------------------------------

		    else if (maxwell) then
            
	          call ms_fluxdg (gnew(1,ivol)      ,gbrt(1,ibrt)   ,      &
     &                        gij               ,gmfracij       ,      &
     &                        zg(ivol)          ,zgbrt(ibrt)    ,      &
     &                        densgij           ,gpij           ,      &
     &                        tkel(ivol)        ,tauijbrt       ,      &
     &                        gporijbrt         ,dijbrt(ibrt)   ,      &
     &                        rverysmall        ,                      &
     &                        ludecomp          ,                      &
     &                        fmat              ,                      &
     &                        ipvt              ,equimolar      ,      &
     &                        ms_gflux          ,neflux         )
            
	        endif
            
          end if

!c  modify rhs-vector

          do ic = 1,n
!cprovi--------------------------------------------------------          
!cprovi Bubbles use component dependent diff coefficient if 
!cprovi speciifed
!cprovi-------------------------------------------------------
            if (diff_coff) then
              bdyinfrt_da = bdyinfrt_da_ic(ic)
            end if
!cprovi-------------------------------------------------------
!cprovi  aqueous phase - compute advective and diffusive 
!cprovi flux across boundary
!cprovi-------------------------------------------------------
          if (b_fluxd_mixed_bcond(ivol)) then
            totcflux(ic) = inoutflow * bcondrt_a(ic,ibrt) +           & ! advective
     &                     fluxd(totcnew(ic,ivol),                    & ! diffusive 
     &                           bcondrt_a(ic,ibrt),                  &
     &                           bdyinfrt_da)
          else
            totcflux(ic) = inoutflow * bcondrt_a(ic,ibrt)               ! advective
          end if      
!cprovi--------------------------------------------------------           
#ifdef DEBUG
            if(info_debug > 10) then
                write(idbg, *)                                        &
                "--> inoutflow, bcondrt_a(ic,ibrt), totcflux(ic), ",  &
                "totcnew(ic,ivol), bcondrt_a(ic,ibrt), bdyinfrt_da",  &
                inoutflow, bcondrt_a(ic,ibrt), totcflux(ic),          &
                totcnew(ic,ivol), bcondrt_a(ic,ibrt), bdyinfrt_da
            end if
#endif

!cdsy----------------------------------------------------------
!cdsu    gaseous phase - compute advective flux across boundary

!cprovi  gaseous phase - compute diffusive flux across boundary
!cprovi--------------------------------------------------------
            if (ng>0) then
                
#ifdef DEBUG
              if(info_debug > 10) then
                write(idbg, *) "--> ic, totgflux(ic)",  ic, totgflux(ic)
              end if
#endif
              
              totgflux(ic) = r0
                
!c            advective flux
              if (gas_advection) then

                if (gsatijbrt.gt.gsatmin) then
                
                  totgflux(ic) = fluxvg(gpivol_ivol ,gpivol_brt  ,    &
     &                                  zg(ivol)    ,zgbrt(ibrt) ,    &
     &                                  totgij(ic)  ,relpgij     ,    &
     &                                  densgij     ,viscgij     ,    &
     &                                  cinfvs_gbrt(ibrt)        ,    &
     &                                  gas_gravity ,gacc)
                endif

              endif ! gas advection
              
!c             diffusive flux - ficks law / dgm / stefan-maxwell

              if ((.not.dgm).and.(.not.maxwell)) then

                if (blanc_diff_g) then
!c               diffusion coefficient calc'd with LeBlanc's law
                  cinfrt = bdyinfrt_dg * gasdiff2                      &
     &                                ( gmfrac_ivol     ,gmfrac_brt  , &
     &                                  gpivol_ivol     ,gpivol_brt  , &
     &                                  zg(ivol)        ,zgbrt(ibrt) , &
     &                                  gdens_ivol      ,gdens_brt   , &
     &                                  ic              ,              &
     &                                  iupsgbrt(ibrt)  ,spt_weight  )

			    else 
!c                single constant diffusion
	              cinfrt = bdyinfrt_dg
			    endif    

!c diffusion expressed in terms of concentration gradients
                totgflux(ic) = totgflux(ic)                            &
     &                       + fluxd(totgnew(ic,ivol),                 &   !diffusive flux
     &                               bcondrt_g(ic,ibrt),               &
     &                               cinfrt)                               !bdyinfrt_dg
     
                     
!c ------- DGM module -----------------------------------------------------------

		      else if (dgm) then
 
!c               check if there is gas phase
                if (gporijbrt.lt.rverysmall) then
!c               no gas phase 
                else
                  totgflux(ic) = totgflux(ic)                          &
     &                         + diff_eff                              &
     &                         * dijbrt(ibrt)                          &
     &                         * dgm_gflux(ic)
!     &                         / tauijbrt
!     &                         / gporijbrt

	            endif

!c ------- Maxwell Stefan module -------------------------------------------------

		      else if (maxwell) then

!c               check if there is gas phase
                if (gporijbrt.lt.rverysmall) then
!c                no gas phase 
                else
                  totgflux(ic) = totgflux(ic)                          &
     &                         + diff_eff                              &
     &                         * dijbrt(ibrt)                          &
     &                         * ms_gflux(ic)
!     &                         / tauijbrt
!     &                         / gporijbrt
	            endif

              end if                 

    
#ifdef DEBUG
              if(info_debug > 10) then
                  write(idbg, *)                                      &
                  "--> totgflux(ic), totgnew(ic,ivol), ",             &
                  "bcondrt_g(ic,ibrt), bdyinfrt_dg",                  &
                  totgflux(ic), totgnew(ic,ivol), bcondrt_g(ic,ibrt), &
                  bdyinfrt_dg
              end if
#endif
              
            end if

          end do

!c  modify rhs vector

          istart = (ivol-1)*n+1           !pointer - first row
          iend = ivol*n                   !pointer - last row

          ic = 0
          do irow = istart,iend           !loop over rows

           ic = ic+1                      !pointer to primary unknown

!c  aqueous phase

            if (component_type(ic).eq.'aqueous') then
              brt(irow) = brt(irow) + totcflux(ic)
            end if
#ifdef DEBUG
            if(info_debug > 20) then
              write(idbg, *)                                          &
              "--> irow, ic, brt(irow), totcflux(ic)",                &
              irow, ic, brt(irow), totcflux(ic)
            end if
#endif

!c  gaseous phase

            if (ng.gt.0) then
              brt(irow) = brt(irow) + totgflux(ic)
            end if
            
#ifdef DEBUG
            if(info_debug > 20) then
              write(idbg, *)                                          &
              "--> irow, ic, brt(irow), totgflux(ic)",                &
              irow, ic, brt(irow), totgflux(ic)
            end if 
#endif

          end do                           !loop over rows
          
#ifdef DEBUG
          if(info_debug > 20) then
              write(idbg, *)                                          &
              "--> right hand side: istart, iend ",  istart, iend
              write(idbg, *) " --> right hand side vector: ",         &
              brt(istart:iend)
          end if
#endif

!c  modify Jacobian matrix

!c  compute derivatives of total mass flux across boundary

          idiag = iavs(ivol)        !diagonal pointer - block matrix

!c  temporary storage for free species concentrations

          do ic=1,nc
            cinc(ic,tid) = cnew(ic,ivol)
          end do

          do jbl=1,n                !loop over columns of block matrix

!c  compute increment for numerical differentiation

            drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column

            cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  recompute activity coefficients

            if (update_activity(tid).eq.'double_update') then
!cprovi----------------------------------------------       
               if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
                       call pitzer (phase,gamma(1:nc,ivol),           &
     &                              gamma(nc+1:nc+nx,ivol),           &
     &                              cnew(1:nc,ivol),cx(1:nx,ivol),    &
     &                              nc,nx,ilog)
             else
!c  for free species

                  do ic=1,nc
                       gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
     &                                  sionnew(ivol),chargec(ic),    &
     &                                  dhac(ic),dhbc(ic),            &
     &                                  dhad(tid),dhbd(tid),          &
     &                                  adav,bdav,acth2omin,nc,       &
     &                                  nx,namec(ic),namec)
                  end do

!c  for secondary aqueous species

                  do ix=1,nx
                    gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
     &                                  sionnew(ivol),chargex(ix),    &
     &                                  dhax(ix),dhbx(ix),            &
     &                                  dhad(tid),dhbd(tid),          &
     &                                  adav,bdav,acth2omin,nc,       &
     &                                  nx,namex(ix),namec)
                  end do

               end if 
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
            end if

!c  equilibrium redox reactions, compute concentrations of dependent
!c  species of redox couples with incremented free species
!c  concentrations

            if (redox_equil.and.nr.gt.0) then
              do ir=1,nr
                ic = n+ir
                call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),    &
                gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
              end do
            end if

!c  compute aqueous complex concentrations with incremented free
!c  species concentrations

            do ix=1,nx
              call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),     &
              gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
            end do

!c  compute derivative of total aqueous component concentrations 

            if (analyt_deriv_rt) then
              call atotconc(cnew(1,ivol),cx(1,ivol),jbl)
            else
              call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl)
            end if

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotc(:,tid))
            end if

!c  compute derivative of total gaseous component concentrations

            if (ng.ne.0) then

!c  compute gas concentrations with incremented free species
!c  concentrations

              do ig = 1,ng
                call gasconc(cinc(:,tid),gamma(1,ivol),ginc(ig,tid),  &
                     ig,tkel(ivol))
              end do

!c  compute derivatives of total gaseous component concentrations

              call dtotcong(gnew(1,ivol),ginc(:,tid),dtotg,xnug,      &
                            drtinc,iaga,jaga,nc,ng,jbl,namec)

!c  compress derivative of total gaseous component concentration
!c  vector in case of redox equilibrium reactions

              if (redox_equil.and.nr.gt.0) then
                call comptotc(dtotg)
              end if

            end if

!c  compute numerical derivatives for each gas wrt primary unknown incremented
            if (ng.gt.0 .and. (gas_advection.or.dgm.or.maxwell)) then
            
              do ig = 1,ng
                dg(ig) = (ginc(ig,tid) - gnew(ig,ivol)) / drtinc
              end do
              
              dgpivol  = gasp(ng,dg,ivol)          
              dmdens_i = gasm(ng,dg)
              ddens_i  = gasd_m(dmdens_i,gmfrac(:,ivol)) 
              
!c  for dgm module calculations:
!c  calculate gas molar densities and mole fractions
              mdens_g_inc = gasm(ng,ginc(:,tid))                    !gas molar density
		
	 	      do ig=1,ng
                dgmfrac(ig) = (ginc(ig,tid)/mdens_g_inc-gmfrac(ig,ivol))/  &
                               drtinc
              enddo
    
!             calculate gas properties at interface according to weighting scheme
              call wgpropd(totgnew(1,ivol),totgnew_brt    ,totgij ,    &
     &                    relpermg(ivol) ,relpermg(ivol) ,relpgij  ,   &
     &                    gdens_ivol     ,gdens_brt      ,densgij  ,   &
     &                    gvisc_ivol     ,gvisc_brt      ,viscgij  ,   &
     &                    gpivol_ivol    ,gpivol_brt     ,gpij     ,   &
     &                    zg(ivol)       ,zgbrt(ibrt)    ,             &
     &                    spt_weight     ,iupsgbrt(ibrt) ,wfac     ,   &
     &                    nc             ,ng             ,gacc     )
               
!c ----- DGM module -------------------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
		      if (dgm) then
			  
                call dgm_dfluxdg (gnew(1,ivol)      ,gbrt(1,ibrt)  ,       &
     &                            dg                ,dgmfrac       ,       &
     &                            zg(ivol)          ,zgbrt(ibrt)   ,       &
     &                            densgij           ,gpij          ,       &
     &                            tkel(ivol)        ,relpgij       ,       &
     &                            tauijbrt          ,gporijbrt     ,       &
     &                            dijbrt(ibrt)      ,rverysmall    ,       &
     &                            wfac              ,ipvt          ,       &
     &                            ludecomp          ,fmat          ,       &
     &                            dgm_dgflux    )
	          
		      endif

!c ----- Maxwell Stefan module --------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
		      if (maxwell) then
              
	            do i=1,ng-1
	              do j=1,ng-1
	                lumat2(i,j)=ludecomp(i,j)
	              enddo
                enddo
			    
	            call ms_dfluxdg  (gnew(1,ivol),gbrt(1,ibrt),           &
     &                              dg          ,dgmfrac     ,         &
     &                              zg(ivol)    ,zgbrt(ibrt) ,         &
     &                              densgij     ,gpij        ,         &
     &                              tkel(ivol)  ,tauijbrt    ,         &
     &                              gporijbrt   ,dijbrt(ibrt),         &
     &                              rverysmall  ,wfac        ,         &
     &                              ipvt        ,equimolar   ,         &
     &                              lumat2      ,fmat        ,         &
     &                              ms_gflux    ,ms_dgflux   )
              
              endif
              
            endif

!c  modify current column of Jacobian matrix

            do ibl=1,n            !loop over rows (block matrix)

              if (kaobl(ibl,jbl).ne.0) then          !skip zero entries

!c  - derivative of total mass flux across boundary

!c  - aqueous phase (advective component is constant and has 
!c                   therefore no influence)

                dtotcflux(ibl) = - fluxd(dtotc(ibl,tid),r0,           & 
     &                             bdyinfrt_da)

!c  - gaseous phase

                if (ng.ne.0) then
                    
                  dgflux = r0  
                    
                  if (gas_advection) then
                   
                    if (gsatijbrt.gt.gsatmin) then
        
                      dgflux = dfluxvg(totgij(ibl)  ,dtotg(ibl)    ,    &
    &                                  gpivol_ivol  ,gpivol_brt    ,    &
    &                                  dgpivol      ,                   &
    &                                  zg(ivol)     ,zgbrt(ibrt)   ,    &
    &                                  densgij      ,ddens_i       ,    &
    &                                  viscgij      ,relpgij       ,    &
    &                                  cinfvs_gbrt(ibrt), wfac     ,    &
    &                                  gas_gravity, gacc           )
                    
                    endif
      
                  endif ! gas advection
                    
!c--------ficks law, business as usual------------------------------------   

                  if ((.not.dgm).and.(.not.maxwell)) then

                    if (blanc_diff_g) then
!c                   diffusion coefficient calc'd with LeBlanc's law
                      cinfrt = bdyinfrt_dg * gasdiff2                  &  
     &                                     (gmfrac_ivol   ,gmfrac_brt ,&
     &                                      gpivol_ivol   ,gpivol_brt ,&
     &                                      zg(ivol)      ,zgbrt(ibrt),&
     &                                      gdens_ivol    ,gdens_brt  ,&
     &                                      ic            ,            &
     &                                      iupsgbrt(ibrt),spt_weight )		  		      
			        else 
!c                     single constant diffusion
	                  cinfrt = bdyinfrt_dg
			        endif 

!c diffusive as function of concentration gradients 
     			    dgflux = dgflux                                    &
     &                     - fluxd (dtotg(ibl),r0,                     &! diffusive flux
     &                              cinfrt)                             ! bdyinfrt_dg
                  
!c ----- DGM module -------------------------------------------------------------
                
                  else if (dgm) then
                      
!c                   check if there is gas phase
                    if (gporijbrt.lt.rverysmall) then
!c                   no gas phase 
                    else
                      dgflux = dgflux                                  &
     &                       + diff_eff                                &
     &                       * dijbrt(ibrt)                            &
     &                       * dgm_dgflux(ibl)
!     &                       / tauijbrt
!     &                       / gporijbrt
                    endif

!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------
                
			      else if (maxwell) then

!c                   check if there is gas phase
                    if (gporijbrt.lt.rverysmall) then
!c                   no gas phase 
                    else
                      dgflux = dgflux                                  &
     &                       + diff_eff                                &
     &                       * dijbrt(ibrt)                            &
     &                       * ms_dgflux(ibl)
!     &                       / tauijbrt
!     &                       / gporijbrt
                    endif

                  end if 
                 
                  dtotgflux(ibl) = dgflux
                  
                end if
  
              end if              !skip zero entries
            end do                !loop over components

!c  - get pointer for global block matrix

            ldiag = lart(idiag)  !diagonal pointer - global block matrix
            do ibl=1,n           !loop over rows of block matrix

!c  - skip zero entries, here only mobile species are considered,
!c    kaobl has to be used therefore to skip zero entries
!c    the pointer i2 has to be computed using kadbl nevertheless

              if (kaobl(ibl,jbl).ne.0) then           !skip zero entries

!c  - get pointer for assembly in n-d scalar matrix

                i2 = kart(ldiag+kadbl(ibl,jbl)-1)

                if (component_type(ibl).eq.'aqueous') then
                  art(i2) = art(i2) + cnew(jbl,ivol) * dtotcflux(ibl)
                end if

                if (ng.gt.0) then
                  art(i2) = art(i2) + cnew(jbl,ivol) * dtotgflux(ibl)
                end if

              end if                !skip zero entries
            end do                  !loop over rows of block matrix

!c  "unshift" free species concentration of current column

            cinc(jbl,tid) = cnew(jbl,ivol) 

          end do                    !loop over columns of block matrix

       end if                      !boundary types
       
!   10 continue       

      end do                        !loop - boundary control volumes 
      
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif      

!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then
        irow = 0
        do ivol=1,nngl
          do ic=1,n
            irow = irow+1
            write(idbg,'(a,2x,a,i5,i5,a,1pd12.5)')                    &
     &            namec(ic),'b(',ivol,ic,') = ',brt(irow)/cvol(ivol)
          end do
        end do
        do ivol=1,nngl
          do ic = 1,n
            irow=(ivol-1)*n+ic
            istart = iart(irow)
            iend   = iart(irow+1)-1            
            write(idbg,*) iart(irow)
            i2 = 0
            do i1 = istart,iend
              i2 = i2+1
              if (i2.gt.n) then
                i2 = i2-n
              end if
              icol = jart(i1)
              write(idbg,'(a,2x,a,2x,a,i5,i5,a,1pd12.5)')             &
     &              namec(ic),namec(i2),'a(',irow,icol,') = ',        &
     &                           art(i1)/cvol(ivol)
            end do
          end do
        end do
        write(idbg,*)
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
#endif
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------      
      deallocate(bdyinfrt_da_ic)
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------      
      return
      end
