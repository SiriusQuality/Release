!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacrt
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (reactive transport)
!c
!c modified for density dependent flow
!c
!c written by:      Uli Mayer - Aug 15, 96
!c
!c last modified:   Uli Mayer - December 5, 96
!c                  Uli Mayer - November 12, 01
!c                  added new database format
!c                  for dissolution-precipitation reactions
!c
!c                  Tom Henderson - October 22, 2002
!c                  Sergi Molins - January 20, 2003
!c                  added advective transport of (ideal) gases
!c                  Sergi Molins - May 2, 2006
!c                  added multi-component diffusion
!c                  Sergi Molins - June 12, 2006
!c                  gsatmin = 0.0 (larger values cause DGM/ MS
!c                  modules to fail under saturated conditions)
!c                  relpgij passed to dgm_dfluxdg.f
!c
!c                  Danyang Su - March 27, 2014
!c                  Add gas advection, modified from Sergi Molins's codes
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c bbls.f    real*8
!c           --------
!c   
!c           integer*4
!c           ---------
!c           ibub               = counter for inner bubble iteration loop
!c
!c           logical
!c           -------
!c           update_component(nc)    = .true.-> component is an assigned gas
!c                                    component or h+ and totcnew is updated in jacrt
!c                                    .false.-> totcnew is not updated in jacrt
!c  
!c gen.f:    real*8:
!c           -------
!c           astor(n)           = storage term (non-competitive       * +
!c                                sorption)
!c           area(nm,nn)        = specific reactive surface area of   + - 
!c                                mineral (global system)
!c           art(njart)         = jacobian matrix                     + -
!c           brt(nn*n)          = rhs vector                          + -
!c           cflux(ncon,n)      = interfacial mass fluxes             * *
!c                                (aqueous phase)
!c           cinfrt_da(njavs)   = influence coefficients              + -
!c                                (dispersion - aqueous phase)
!c           cinfrt_dg(njavs)   = influence coefficients              + -
!c                                (diffusion - gaseous phase)
!c           cinfrt_va(njavs)   = influence coefficients              + -
!c                                (advection - aqueous phase)
!c           cinfrt_g(njavs)    = influence coefficients              + -
!c                                (advection - gaseous phase)
!c           hhead(nn)          = hydraulic head                      + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity (meq/100g) + -
!c                                - global system
!c           cstor(n)           = storage term (aqueous phase)        * *
!c           cvol(nn)           = nodal volumes                       + -
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           delt               = time step                           + -
!c           dinc_rt            = factor to compute increment for     + -
!c                                numerical differentiation
!c           dtotcflux(n)       = derivatives of total mass fluxes    * +
!c                                (aqueous phase)
!c           dtotgflux(n)       = derivatives of total mass fluxes    * +
!c                                (gaseous phase)
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + +
!c                                species
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           gflux(ncon,n)      = interfacial mass fluxes             * *
!c                                (gaseous phase)
!c           gstor(n)           = storage term (gaseous phase)        * *
!c           phi(nm,nn)         = volume fractions of minerals        + -
!c           phiold(nm,nn)      = volume fractions of minerals        + -
!c                                (old time level)
!c           pornew(nn)         = porosity                            + -
!c           ratemdp(nm,nn)     = absolute dissolution-precipitation  * +
!c                                rates of minerals
!c           sionnew(nn)        = ionic strength of solution          + +
!c                                - new time level
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            + -
!c                                - old time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcflux(n)        = total mass fluxes (water phase)     * *
!c           totcnew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * *
!c           totgnew(nc,nn)      = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totgold(nc,nn)      = total gaseous component             + -
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totmdp(n,nn)       = total source/sink term towards      * +
!c                                total aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c           totsnew(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component 
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component 
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c
!c           added for gas advection and multi-component diffusion
!c
!c           deltaij(njavs)     = distance between i-j                + -
!c           gmfrac(ng,nn)      = gas molar fractions at c.v. i       * +
!c           gporij(njavs)      = gas filled porosity                 + -
!c           relpermg(nn)       = relative permeability (gas phase)   * +
!c           tauij(njavs)       = tortuosity (gas phase)              + -
!c           
!c           integer*4:
!c           ----------
!c           i2up(nn)           = pointer array to second upstream    + -
!c                                point
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           idbg               = unit number - debugging file        + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           lart(njavs+1)      = pointer array                       + -
!c           kadbl(n,n)         = pointer array for conversion to     + -
!c                                sparse format (diagonal block
!c                                matrices)
!c           kaobl(n,n)         = pointer array for conversion        + -
!c                                to sparse format
!c                                (off-diagonal block matrices)
!c           kart(njart)        = mapping pointer                     + -
!c                                (global block -> nd-scalar)
!c           nn                 = total number of control volumes     + -
!c           n                  = number of primary unknowns          + -
!c     
!c           logical:
!c           --------
!c           analyt_deriv_rt    = .true.  -> form derivatives         + -
!c                                           analytically
!c
!c
!c chem.f:   real*8:
!c           -------
!c           cinc(nc,nthreads)  = incremented free species            * *
!c                                concentrations
!c                                [moles/l water]
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           cmcmin(nm,nthreads)= min. concentration of minerals      + -
!c                                [moles/l bulk]
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           csb_ion(nsb_ion,nthreads)
!c                              = concentrations of sorbed species    * *
!c                                - new time level (ion-exchange)
!c           csb_surf(nsb_surf,nthreads) 
!c                              = concentrations of sorbed species    * *
!c                                - new time level (surface-complex)
!c           cxinc(nx,nthreads) = secondary aqueous species           * *
!c                                concentrations dependent on
!c                                incremented free species
!c                                concentrations
!c                                [moles/l water]
!c           dcsb(nsb)          = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species
!c           dcsb_ion(nsb_ion,nthreads)  
!c                              = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species (ion-exchange)
!c           dcsb_surf(nsb_surf,nthreads)
!c                              = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species (surface-complex)
!c           dratedp(nm,nthreads)        
!c                              = derivatives of absolute             * *
!c                                dissolution-precipitation
!c                                rates of minerals
!c                                [moles/(l bulk*day)]
!c           dtota(n)           = derivatives of total sorbed         * +
!c                                component concentrations
!c                                (non-competitive sorption)
!c                                [moles/l bulk]
!c           dtotaq(nc-1,nthreads)       
!c                              = derivative of total source-sink     * *
!c                                term towards total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           totaq(nc-1,nthreads) 
!c                              = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           dtotc(n,nthreads)  = derivatives of total aqueous        * *
!c                                component concentrations
!c                                [moles/l water]
!c           dtotcf(n,nthreads) = derivatives of total aqueous
!c                                component concentrations
!c                                times porosity correstion 
!c                                factors for hMCD model [moles/l h2o]
!c           dtotdp(n,nthreads) = derivatives of total source/sink    * *
!c                                term towards aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c                                [moles/(l bulk*day)]
!c           dtotor(n)          = derivatives of total source/sink    * *
!c                                term towards aqueous component
!c                                concentrations due to 
!c                                oxidation/reduction reactions
!c                                [moles/(l bulk*day)]
!c           dtotg(n)           = derivatives of total gaseous        * *
!c                                component concentrations
!c                                [moles/l air]
!c           dtotsb(n)          = derivatives of total source/sink    * *
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c           dtotsb_ion(n,nthreads)      
!c                              = derivatives of total source/sink    * *
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c                                (ion-exchange)
!c           dtotsb_surf(n,nthreads)     
!c                              = derivatives of total source/sink    * *
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c                                (surface-complex)
!c           eqm(nm,nthreads)   = equilibrium constants for minerals  + -
!c           eqr(nr,nthreads)   = equilibrium constant for redox      + -
!c                                couple reaction equation
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           eqx(nx,nthreads)   = equilibrium constants for           + -
!c                                aqueous complexes
!c           ginc(ng,nthreads)  = gas concentrations dependent on     * *
!c                                incremented free species
!c                                concentrations
!c                                [moles/l air]
!c           rateaq(naq,nthreads) 
!c                              = reaction rates of intra-aqueous     * *
!c                                kinetic reaction
!c           rateor(nr,nthreads)= oxidation-reduction rate for        * *
!c                                redox couple [moles/(l h2o*day)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           satm(nm,nthreads)  = saturation indices                  * *
!c           supsatm(nm)        = level of supersaturation required   + -
!c                                for precipitation [log cycles]
!c           tinyrate           = set reaction rates to zero,         + -
!c                                if smaller than tinyrate
!c           totcinc(n,nthreads)= total aqueous component             * +
!c                                concentrations - new time level
!c                                incremented [moles/l water]
!c           totdp(n,nthreads)  = total source/sink term towards      * *
!c                                total aqueous component 
!c                                concentrations due to mineral 
!c                                dissolution-precipitation 
!c                                reactions [moles/(l bulk*day)]
!c           totor(nc-1)        = total source/sink term towards      * *
!c                                aqueous component concentrations
!c                                due to oxidation/reduction
!c                                reactions [moles/(l bulk*day)]
!c           totrateg(nc-1)     = total rate for removal of aqueous   * *
!c                                components due to degassing
!c                                [mol L^-1 s^-1]
!c           totsb(n)           = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to sorption
!c                                reactions [moles/(l bulk*day)]
!c           totsb_ion(n)       = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to sorption
!c                                reactions [moles/(l bulk*day)]
!c                                (ion-exchange)
!c           totsb_surf(n)      = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to sorption
!c                                reactions [moles/(l bulk*day)]
!c                                (surface-complex)
!c           xnug(ng*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of gases from
!c                                free species
!c           xnum(nm*nc)        = stoichiometric coefficients of      + -
!c                                components in mineral
!c           xnur(nr*nc)        = stoichiometric coefficient of       + -
!c                                component in redox couple
!c                                reaction equation
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c           xnux(nx*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of aqueous complexes
!c                                from components
!c
!c           integer*4:
!c           ----------
!c           iaga(ng+1)         = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           iam(nm+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in mineral
!c           iarc(nr+1)         = row pointer array to                + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           iax(nx+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in aqueous complexes
!c           jaga(ng*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           jam(nm*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           jarc(nr*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jax(nx*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in aqueous complexes
!c           naq                = number of intra-aqueous kinetic     + -
!c                                reactions
!c           nc                 = number of components including h2o  + -
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nx                 = number of aqueous complexes         + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           far_from_equil(nm) = .true.  -> far from equilibrium     + -
!c           gas_removal        = .true.  -> degassing of dissolved   + -
!c                                           gases, if confining
!c                                           pressure exceeded
!c           new_database       = .true.  -> use new database format  + -
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c
!c dens.f:   logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c multidiff.f90
!c            real*8:
!c           -------
!c           electromignew(n,nn)   
!c                              = electromigration induced 
!c                                  concentration change (MCD)
!c           delecmigrationnew(nn,nthreads) 
!c                              = derivative of electromigration 
!c                                  induced concentration change (MCD)
!c           totviscnew(n,nn)   = total 'dynamic viscocity' term
!c              dtotviscnew(nn,nthreads)     
!c                              = derivative of total 'dynamic viscocity' 
!c             cinfrt_mcd(njavs)    = influence coefficient of multicomponent 
!c                                  diffusion (MCD)
!c             mdiff_ic(nc)        = diffusion coefficient of free 
!c                                  aqueous species
!c             mdiff_ix(nx)        = diffusion coefficient of secondary 
!c                                aqeous complexes
!c             mdiff_ic_cvol(nc, njavs)
!c                              = averaged diffusion coefficient of free 
!c                                  aqueous species
!c             mdiff_ix_cvol(nc, njavs)
!c                              = averaged diffusion coefficient of  
!c                                secondary aqueous species
!c           logical:
!c           --------
!c             multi_diff         = .true. -> multicomponent diffusion (MCD)
!c         hmulti_diff = .true. -> hybrid multicomponent diffusion (hMCD)
!c
!c biol.f:   real*8:
!c           -------
!c           rootdens           = root density at a given ivol !FG sept 2021
!c local:    real*8:
!c           -------
!c           dgflux             = derivative of interfacial mass
!c                                flux (gaseous phase)
!c           dissvol            = mineral mass to be dissolved
!c           dcflux             = derivative of interfacial mass
!c                                flux (aqueous phase)
!c           drtinc             = increment for numerical 
!c                                differentiation
!c           dgstor             = derivative of storage term
!c                                (gaseous phase)
!c           dcstor             = derivative of storage term 
!c                                (water phase)
!c           r0                 = constant
!c           r1                 = constant
!c           small              = small increment
!c
!c added for gas transport:
!c
!c           densgij            = gas density at interface i-j
!c           dgm_dgflux(nc)     = derivative of diffusive flux        * +
!c                                (as computed w/ DGM)
!c           dgmfrac(ng)        = derivative of gas molar fraction    * +
!c           dgm_gflux(nc)      = diffusive flux (as computed w/DGM)  * +
!c           fmat(ng,ncon)      = right hand side DGM system          * +
!c           gacc               = gravity                             + -
!c           gdens(nn)          = gas density at control volume i     * +
!c           gij                = gas concentration at i-j            * +
!c           gmfracij           = gas molar fractions at i-j          * +
!c           gmfrac_inc(ng)     = incremented gas molar fraction      * +
!c           gpivol(nn)         = gas pressure at control volume i    * +
!c           gsatmin            = constant
!c           gvisc(ivol)        = gas viscosity at control vol i      * +
!c           ludecomp(ng,ng,ncon) = LU decomp of matrix of DGM system * +
!c           lumat2(ng-1,ng-1)  = LU decomp of matrix of Maxwell sys  * +
!c           mdens_g_inc        = incremented gas density             * +
!c           ms_dgflux(nc)      = derivative of diffusive flux        * +
!c                                (as computed w/ stefan-maxwell)     * +
!c           ms_gflux(nc)       = diffusive flux (as computed w/S-M)  * +
!c           neflux(nc)         = non-equimolar flux for multi-comp   * +
!c                                diffusion
!c           relpgij            = relative perm (gas) at i-j          * +
!c           totgij             = total gas concentrations of         * +
!c                                components at interface i-j         * +
!c           rverysmall         = constant 
!c           viscgij            = gas viscosity at interface i-j      * +
!c           wfac               = weighting factor for gas transport  * +
!c
!c           character:
!c           ----------
!c           spt_weight         = spatial weighting for gas transp    * +
!c           spwt2              = spatial weighting for gas transp    * +
!c           integer*4:
!c           ----------
!c           i1                 = counter (entries in ja, a arrays 
!c                                         for 1d-scalar matrix)
!c           i2                 = pointer (entries in ja, a arrays
!c                                         for nd-scalar matrix)
!c           iaq                = counter (intra-aqueous kinetic 
!c                                         reactions)
!c           ibl                = counter (rows of block matrix)
!c           ic                 = counter (components)
!c           icon               = pointer (off-diagonal connections)
!c           idiag              = pointer (diagonal of 1d-scalar 
!c                                         matrix)
!c           iend               = pointer (last off-diagonal entry 
!c                                         in row for 1d-scalar 
!c                                         matrix)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           ir                 = counter (redox couples)
!c           isb                = counter (sorbed species)
!c           irow               = pointer (row in rhs-vector)
!c           istart             = pointer (first off diagonal entry 
!c                                         in row for 1d-scalar 
!c                                         matrix)
!c           isym               = symmetry pointer (1d-scalar 
!c                                                  matrix)
!c           ivol               = counter (control volumes)
!c           ix                 = counter (complexed species)
!c           jbl                = counter (columns of block matrix)
!c           jvol               = pointer (column in 1d-scalar 
!c                                         matrix)
!c           ldiag              = pointer (diagonal block in global 
!c                                         block matrix)
!c           lsym               = symmetry pointer (global block 
!c                                                  matrix)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: acoff     = compute activity coefficient
!c           bulkconc  = convert from [moles/l water] to 
!c                       [moles/l bulk]
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           drategas  = compute derivatives of degassing rates
!c           drategdd  = compute derivatives of degassing rates
!c                       density dependent flow
!c           drateint  = compute derivative of reaction rate
!c                       of intra-aqueous kinetic reaction
!c           drateint_new  = compute derivative of reaction rate
!c                       of intra-aqueous kinetic reaction (new
!c                       database format)
!c           dratemin  = compute numerical derivative of absolute 
!c                       dissolution-precipitation rates of minerals
!c           dratemin_new  = compute numerical derivative of absolute 
!c                       dissolution-precipitation rates of minerals
!c                       (new database format)
!c           aratemin  = compute analytical derivative of absolute 
!c                       dissolution- precipitation rates of minerals
!c           draterdx  = compute derivative of total oxidation/
!c                       reduction rates for redox couples in terms 
!c                       of total aqueous component concentrations
!c           dtotconc  = compute numerical derivatives of total aqueous
!c                       component concentrations
!c           atotconc  = compute analytical derivatives of total aqueous
!c                       component concentrations
!c           dtotcong  = compute derivative of total gaseous
!c                       component concentrations
!c           fluxd     = diffusive/dispersive flux
!c           fluxv     = advective flux
!c           fluxv_vl  = advective flux (Van Leer flux limiter)
!c           gasconc   = compute gas concentrations based on 
!c                       concentrations of free species
!c           molconc   = compute average molar concentration for 
!c                       organic mixture
!c           rategas   = compute degassing rates
!c           rategasd  = compute degassing rates for density
!c                       dependent flow
!c           rateint   = compute rate for intra-aqueous kinetic 
!c                       reactions
!c           rateint_new   = compute rate for intra-aqueous kinetic 
!c                       reactions (new database format)
!c           ratemin   = compute absolute dissolution-precipitation
!c                       rates of minerals
!c           ratemin_new  = compute absolute dissolution-precipitation
!c                       rates of minerals (new database format)
!c           rateredx  = compute oxidation/reduction rates for 
!c                       redox couples
!c           rhsrt     = construct rhs-vector (reactive transport)
!c           secspec   = compute aqueous complex concentration
!c                       based on concentrations of free species
!c           sorbspc   = compute concentration of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations 
!c                       of free species and secondary aqueous 
!c                       species
!c           totconcg  = compute total gaseous component 
!c                       concentrations based on concentrations 
!c                       of gases
!c           totint    = compute total source-sink terms towards
!c                       total aqueous component concentrations
!c                       due to intra-aqueous reactions
!c           totmin    = compute total source/sink terms towards 
!c                       towards total aqueous component concentrations
!c                       due to mineral dissolution-precipitation 
!c                       reactions in [moles/(l bulk x day)]
!c           totredx   = compute total source/sink terms towards 
!c                       total aqueous component concentrations
!c                       due to oxidation/reduction reactions
!c                       in [moles/(l bulk x day)]
!c           totsorb   = compute total sorbed component concentrations
!c                       [moles/l bulk]
!c           updtsvap  = update secondary variables in aqueous 
!c                       phase
!c ----------------------------------------------------------------------
!c
!c  added for gas advection and multi-component diffusion:
!c
!c           dfluxvg     = compute derivative of gas advective fluxes
!c           dgm_dfluxdg = compute derivative of gas diffusive fluxes
!c                         with Dusty Gas Model
!c           dgm_fluxdg  = compute gas diffusive fluxes
!c                         with Dusty Gas Model
!c           fluxvg      = compute gas advective fluxes
!c           gasdiff2    = compute diffusion coefficients with LeBlancs
!c                         approximation (Ficks law)
!c           gasd_m      = compute gas density
!c           gasp_m      = compute gas pressure 
!c           gasv        = compute gas viscosity
!c           ms_dfluxdg  = compute derivative of gas diffusive fluxes
!c                         with Stefan-Maxwell
!c           ms_fluxdg   = compute gas diffusive fluxes
!c                         with Stefan-Maxwell
!c           wgprop      = calculate variables for flux calculations 
!c                         at the interface using the correspoding 
!c                         spatial weighting 
!c           wgpropd     = calculate variables for calculations of the
!c                         derivative of fluxes at the interface using
!c                         the correspoding spatial weighting 
!c 
!c ----------------------------------------------------------------------
 
      subroutine jacrt
 
      use parm
      use gen
      use chem
      use dens
      use bbls
      use dgml
      use biol !FG sept 2021
      use phys, only : mdens_g, blanc_diff_g

#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      
      implicit none
      
      integer :: tid, chunk
      integer :: ivol_track, ivol_gbl
      real*8 :: rtimespan
      real*8 :: dissvol
      real*8 :: dummy      
     
!cdsu-------------------------------------------------------------------
!cdsu---------------------Gas transport variables-----------------------
!cdsu-------------------------------------------------------------------
      character*12 :: spt_weight
      
      real*8 ::                   &
     &       relpgij            , & 
     &       densgij            , &          
     &       viscgij            , & 
     &       gpij               , &  
     &       dgpivol            , & 
     &       dmdens_i           , & 
     &       ddens_i            , & 
     &       wfac                 
      
      integer :: i1, i2, iaq, ibl, icol, icon, ir, info_debug, ivol,   &
                 izn, ig, isb, im, ic, ix, idiag, istart, iend, irow,  &
                 isym, istop, im2, ldiag, lsym, jbl, jvol, i, j
      real*8 :: acoff, bulkconc, cputime, dcstor, dgstor, drtinc,      &
                dcflux, dgflux, dfluxvg, gasp, gasp_m, gasd_m,         &
                gasm, gasv, distance, fluxvg, fluxd, fluxv_vl,         &
                gasdiff2
      
!c dgm variables and initialization
      integer*4 :: ipvt(ng,ncon)
	  real*8    :: dgm_gflux(nc), dgm_dgflux(nc)
	  real*8    :: ludecomp(ng,ng,ncon), fmat(ng,ncon)

!c ms variables	
	  real*8    :: ms_gflux(nc), ms_dgflux(nc), neflux(nc),            &
                   lumat2(ng-1,ng-1)
      real*8 :: so_av, cinfrt, mdens_g_inc, dgmfrac(ng)
      
      external acoff, bulkconc, comptotc, dtotcong,             &
               fluxd, fluxv, fluxv_vl, rateredx, rhsrt,         &
               secspec, sorbspc, totcona, totconc, totconcg,    &
               totmin, totsorb, elecmigration, totconcfac,      &
               dfluxvg, gasm, gasp, gasp_m, gasd_m,             &
               gasv, wgprop, wgpropd, cputime, gasdiff2,        &
               ratemin_new_dbg
            
      real*8 :: r0, r1, small, gsatmin, rverysmall
      parameter (r0 = 0.0d0, r1 = 1.0d0, small = 1.0d-10,       &
                 gsatmin=0.0d0, rverysmall = 1.0d-30)
      

      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface 
        !>interface of atotconc
        subroutine atotconc(c,cx,jbl)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          integer(type_i4) :: jbl      
        end subroutine atotconc
      
        !> interface of ratemin
        subroutine ratemin(totc,c,cx,gammac,gammax,ratem,phim,    &
                           phimold,aream,im) 
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
        end subroutine ratemin  
                           
        !> interface of ratemin_new
        subroutine ratemin_new(totc,c,cx,gammac,gammax,ratem,phim,    &
                               phimold,aream,im) 
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8), dimension(*) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
        end subroutine ratemin_new
      
        !>interface of aratemin
        subroutine aratemin(totc,c,cx,gammac,gammax,ratem,phim,       &
                            phimold,aream,im,jbl,ivol)
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
          integer(type_i4) :: jbl
          integer(type_i4) :: ivol                    
        end subroutine aratemin            
                           
        !>interface of delcmigfunc                   
        subroutine delcmigfunc(elecmignew,elecmignew_pert,drtinc)        
          use parm, only : type_r8
          use chem, only : nc
          real(type_r8) :: elecmignew(nc)
          real(type_r8) :: elecmignew_pert(nc)
          real(type_r8) :: drtinc                           
        end subroutine delcmigfunc
                           
        !>interface of drategas                  
        subroutine drategas(g,tkel,hhead,zg,drtinc)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: g
          real(type_r8) :: tkel
          real(type_r8) :: hhead
          real(type_r8) :: zg
          real(type_r8) :: drtinc     
        end subroutine drategas
        
        !>interface of drategdd
        subroutine drategdd(g,tkel,phead,drtinc)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: g
          real(type_r8) :: tkel
          real(type_r8) :: phead
          real(type_r8) :: drtinc     
        end subroutine drategdd
        
        !>interface of drateint
        subroutine drateint(rate,totc,c,gammac,phim,drtinc,iaq,        &
                            scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: phim
          real(type_r8) :: drtinc
          integer(type_i4) :: iaq 
          real(type_r8) :: scalfacaq
        end subroutine drateint
        
        !>interface of drateint_new
        subroutine drateint_new(rate,totc,c,cx,gammac,gammax,phim,    &
                                drtinc,iaq,scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: phim
          real(type_r8) :: drtinc
          integer(type_i4) :: iaq  
          real(type_r8) :: scalfacaq
        end subroutine drateint_new
        
        !>interface of dratemin
        subroutine dratemin(totc,c,cx,gammac,gammax,ratem,phim,      &
                         phimold,aream,drtinc,im,ivol)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8) :: phim
          real(type_r8) :: phimold
          real(type_r8) :: aream
          real(type_r8) :: drtinc
          integer(type_i4) :: im
          integer(type_i4) :: ivol
        end subroutine dratemin
        
        !>interface of dratemin_new
        subroutine dratemin_new(totc,c,cx,gammac,gammax,ratem,phim,  &
                         phimold,aream,drtinc,im,ivol)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8), dimension(*) :: phim
          real(type_r8) :: phimold
          real(type_r8) :: aream
          real(type_r8) :: drtinc
          integer(type_i4) :: im
          integer(type_i4) :: ivol
        end subroutine dratemin_new
        
        !>interface of draterdx
        subroutine draterdx(c,cx,gammac,gammax,drate,totc,drtinc,ir,idbg)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: drate
          real(type_r8), dimension(*) :: totc
          real(type_r8) :: drtinc
          integer(type_i4) :: ir
          integer(type_i4) :: idbg
        end subroutine draterdx
        
        !>interface of dtotconc
        subroutine dtotconc(c,cx,drtinc,jbl,izn_opt)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8) :: drtinc
          integer(type_i4) :: jbl     
          integer, optional :: izn_opt
        end subroutine dtotconc
                           
        !>interface of dtotdyvisc  
        subroutine dtotdyvisc(cd,cdx,diff_cof_ic,diff_cof_ix,drtinc)
          use parm, only : type_r8
          use chem, only : nc, nx
          real(type_r8) :: cd(nc)
          real(type_r8) :: cdx(nx)
          real(type_r8) :: diff_cof_ic(nc)
          real(type_r8) :: diff_cof_ix(nx)
          real(type_r8) :: drtinc
        end subroutine dtotdyvisc
        
        !>interface of gasconc
        subroutine gasconc(c,gammac,g,ig,tempkel)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8) :: g
          integer(type_i4) :: ig
          real(type_r8) :: tempkel    
        end subroutine gasconc
        
        !>interface of molconc
        subroutine molconc(phim)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: phim      
        end subroutine molconc
        
        !>interface of rategas
        subroutine rategas(g,tkel,hhead,zg,sg_loc)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: g
          real(type_r8) :: tkel
          real(type_r8) :: hhead
          real(type_r8) :: zg 
          real(type_r8) :: sg_loc
        end subroutine rategas
        
        !>interface of rategasd
        subroutine rategasd(g,tkel,phead,sg_loc)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: g
          real(type_r8) :: tkel
          real(type_r8) :: phead  
          real(type_r8) :: sg_loc
        end subroutine rategasd        
        
        !>interface of rateint
        subroutine rateint(rate,totc,c,gammac,phim,iaq,scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: phim
          integer(type_i4) :: iaq
          real(type_r8) :: scalfacaq
        end subroutine rateint
        
        !>interface of rateint_new
        subroutine rateint_new(rate,totc,c,cx,gammac,gammax,phim,iaq,  &
                               scalfacaq)
          use parm, only : type_i4, type_r8     
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: phim
          integer(type_i4) :: iaq
          real(type_r8) :: scalfacaq
        end subroutine rateint_new
        
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel 
        end subroutine tcorr
        
        !>interface of totint
        subroutine totint(totintaq,idbg)
          use parm, only : type_i4, type_r8   
          real(type_r8), dimension(*) :: totintaq
          integer(type_i4) :: idbg       
        end subroutine totint
        
        !>interface of totredx
        subroutine totredx(totoxrd,idbg)
          use parm, only : type_i4, type_r8   
          real(type_r8), dimension(*) :: totoxrd
          integer(type_i4) :: idbg
        end subroutine totredx
        
        !>interface of updtsvap
        subroutine updtsvap (c,cx,gammac,gammax,strion)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: strion
        end subroutine updtsvap                  
                           
      end interface   
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      rtimespan = 0.0d0
      dgflux = 0.0d0
      dgstor = 0.0d0
      
!c     initialize spatial weighting variable for gas transport
      spt_weight = spatial_weighting
      
	  astor = 0.0d0
	  cstor = 0.0d0
	  gstor = 0.0d0
	  totaq = 0.0d0
	  totsb_ion = 0.0d0
      totsb_surf = 0.0d0
	  totor = 0.0d0
	  totdp = 0.0d0
	  totrateg = 0.0d0
      

      if(iter_rt.eq.1.and.mtime.eq.1) then
        info_debug = 0
        ivol_track = -1
      else
        info_debug = 0 
        ivol_track = -1
      end if
     
      if (b_prtfile) then
          prt_react_jac_part = 0.0
          prt_react_jac_part(1) = cputime() 
          prt_react_jac_part(6) = cputime()
      end if     
      
    
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_react
      if(mod(nngl, numofthreads_matrix_react) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_react > 1) then
            if(mod(chunk, i_chunksize_factor_react) > 0) then
                chunk = chunk/i_chunksize_factor_react + 1
            else
                chunk = chunk/i_chunksize_factor_react
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_react == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif 

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_jacrt == 1)                      &
    !$omp num_threads(numofthreads_matrix_react)                      &
    !$omp default(shared)                                             &
    !$omp private (tid, i1, i2, iaq, ibl, ic, icon, idiag, iend,      &
    !$omp ig, im, im2, ir, irow, isb, istart, isym, ivol, ivol_gbl,   &
    !$omp istop, ix, izn, jbl, jvol, ldiag, lsym,                     &
    !$omp densgij, dg, dgpivol, dmdens_i, ddens_i, gij,               &   !!Gas advection and dgm model
    !$omp gmfracij, gpij, totgij, relpgij, viscgij, wfac,             &
    !$omp cinfrt, dgm_gflux, ms_gflux, ms_dgflux, fmat, ipvt,         &
    !$omp mdens_g_inc,dgmfrac,neflux, dgm_dgflux, lumat2, ludecomp)   &   !!Gas advection and dgm model
    !$omp firstprivate(astor, cflux, cinfrt_da, cinfrt_da_ic,         &
    !$omp cinfrt_dg, cinfrt_mcd, cinfrt_va,                           &
    !$omp cstor, dcflux, dcstor, dgflux, dgstor,                      &
    !$omp dissvol, distance, drtinc, dtota, dtotcflux,                &
    !$omp dtotg, dtotgflux, dtotor, gflux, gstor,                     &
    !$omp totcflux, totgflux, totor, totrateg,                        &
    !$omp totsb_ion, totsb_surf, totviscnewjvol, vel_lin)                                    
#endif
      
#ifdef DEBUG
      if (info_debug > 10 .and. ivol_track > 0) then
         write(idbg,'(a,1x,10d16.8)')                                 &
               "-->jacrt->gnew(:,ivol_track) A1", gnew(:,ivol_track)
      end if
#endif
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi Update the secondary variables
!cprovi update secondary variables and compute storage, source/sink and 
!cprovi flux terms
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif    

      do ivol = 1,nngl                 !loop over control volumes
          

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif
          
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A2", ivol, gnew(:,ivol)
        end if
#endif 

!cprovi------------------------------------------------------
!cprovi temperature corrections for debye-huckel, equilibrium and 
!cprovi rate constants 
!cprovi We have added the temperature update when energy 
!cprovi balance is solved 
!cprovi------------------------------------------------------           
        if (temp_field.or.heat_transport) then      
          call tcorr(tkel(ivol))
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
              write(idbg, '(a,1x,i10)')                                &
                    "--> check temperature corrections, ivol",         &
                    ivol_gbl
              write(idbg, *) "--> dhad, dhbd", dhad(tid),dhbd(tid)
              write(idbg, *) "--> eqx ", eqx(:,tid)
              write(idbg, *) "--> eqg ", eqg(:,tid)
              write(idbg, *) "--> eqm ", eqm(:,tid)
              write(idbg, *) "--> rated ", rated(:,tid)
              write(idbg, *) "--> eqmx ", eqmx(:,tid)
              write(idbg, *) "--> eqr ", eqr(:,tid)
              write(idbg, *) "--> eqsb_ion ", eqsb_ion(:,tid)
              write(idbg, *) "--> eqsb_surf ", eqsb_surf(:,tid)
              write(idbg, *) "--> eqaq ", eqaq(:,tid)
              write(idbg, *) "--> ratecaq ", ratecaq(:,tid)
            end if
          end if
#endif
        end if
!OPENMP Check: This part is checked via d43_density_dep_heat_solute\henry-hilleke benchmark.       


!c  constant activity coefficients
!c  -> update only concentrations of secondary aqueous species
!c     and compute ionic strength   
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then   
            write(idbg, '(a,1x,i10)')                                  &
                  "-->jacrt->centrations before updtsvap, ivol",       &
                  ivol_gbl
            write(idbg, *) "--> cnew ", cnew(:,ivol)
            write(idbg, *) "--> cx ", cx(:,ivol)
            write(idbg, *) "--> gamma ", gamma(:,ivol)
            write(idbg, *) "--> sionnew ",sionnew(ivol)
            write(idbg, *) "--> dhad ", dhad(tid)
            write(idbg, *) "--> dhbd ", dhbd(tid)
            write(idbg, *) "--> eqr ", eqr(:,tid)
            write(idbg, *) "--> eqx ", eqx(:,tid)
          end if
        end if
#endif

        call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),           & 
     &                gamma(nc+1,ivol),sionnew(ivol))
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A3", ivol, gnew(:,ivol)
        end if
#endif 
        
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track  .or. ivol_track == 0) then   
            write(idbg, '(a,1x,i10)')                                  &
                  "--> check concentrations after updtsvap, ivol",     &
                  ivol_gbl
            write(idbg, *) "--> cnew ", cnew(:,ivol)
            write(idbg, *) "--> cx ", cx(:,ivol)
            write(idbg, *) "--> gamma ", gamma(:,ivol)
            write(idbg, *) "--> sionnew ",sionnew(ivol)
            write(idbg, *) "--> dhad ", dhad(tid)
            write(idbg, *) "--> dhbd ", dhbd(tid)
            write(idbg, *) "--> eqr ", eqr(:,tid)
            write(idbg, *) "--> eqx ", eqx(:,tid)
          end if
        end if
#endif
!OPENMP Check: This part is checked via biomass\chrom-bio benchmark. 
        
!c  variable activity coefficients
!c  -> double update of secondary variables 
!c     - activitiy coefficients
!c     - concentrations of secondary aqueous species
!c     - ionic strength                                                 
 
        if (update_activity(tid).eq.'double_update') then
          call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),         &     
     &                  gamma(nc+1,ivol),sionnew(ivol))
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
              write(idbg, '(a,1x,i10)')                                &
                 "--> check concentrations of secondary: double, ivol",&
                 ivol_gbl
              write(idbg, *) "--> cnew ", cnew(:,ivol)
              write(idbg, *) "--> cx ", cx(:,ivol)
              write(idbg, *) "--> gamma ", gamma(:,ivol)
              write(idbg, *) "--> sionnew ",sionnew(ivol)
              write(idbg, *) "--> dhad ", dhad(tid)
              write(idbg, *) "--> dhbd ", dhbd(tid)
              write(idbg, *) "--> eqr ", eqr(:,tid)
              write(idbg, *) "--> eqx ", eqx(:,tid)
            end if
          end if
#endif
        end if
!OPENMP Check: This part is checked via d6_rt_highly_saline\polyhal-pitz benchmark.  

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A4", ivol, gnew(:,ivol)
        end if
#endif 
   
        
!c  compute total aqueous component concentrations                      

        call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol)) 

!c Calculate the total concentrations times correction factors - new time level !MX
        if (hmulti_diff) then
            izn = mpropvs(ivol)
                
!c  compute total concentrations of aqueous primary and secondary
!c  species times the correction factors
                
            call totconcfac(cnew(1,ivol),cx(1,ivol),totcnewf(1,ivol),izn)

        end if
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A5", ivol, gnew(:,ivol)
        end if
#endif 
        
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg, '(a,1x,i10)')                                  &
               "--> check total aqueous concentrations, ivol", ivol
            write(idbg, *) "--> cnew ", cnew(:,ivol)
            write(idbg, *) "--> cx ", cx(:,ivol)
            write(idbg, *) "--> totcnew ", totcnew(:,ivol)
          end if
        end if
#endif
        
!c  compute total sorbed component concentrations
!c  non-competitive sorption                                            

        if (noncompetitive_sorption) then                                   

          call totcona(totanew(1,ivol),totcnew(1,ivol),               &
     &                 distcoff_rt(1,ivol),sanew(ivol),pornew(ivol))
      
        end if
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A6", ivol, gnew(:,ivol)
        end if
#endif 

!OPENMP Check: This part is checked via retardation benchmark


!c  compress total aqueous and sorbed (non-competitive sorption) 
!c  component concentration vector in case of redox equilibrium 
!c  reactions                                                           

        if (redox_equil.and.nr.gt.0) then
            call comptotc(totcnew(1,ivol))
            if (noncompetitive_sorption) then
                call comptotc(totanew(1,ivol))                              
            end if
        end if
!OPENMP Check: This part is not checked   
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A7", ivol, gnew(:,ivol)
        end if
#endif 

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4,1x,10d16.8)')                           &
                "-->jacrt->tid, eqg(:,tid)", tid, eqg(:,tid)
        end if
#endif 
        
!c  compute gas concentrations and total gaseous component 
!c  concentrations                                                      

        if (ng.gt.0) then

          do ig = 1,ng 
            call gasconc(cnew(1,ivol),gamma(1,ivol),gnew(ig,ivol),ig,  &
     &                   tkel(ivol))
          end do
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
              write(idbg, *) "--> compute gas concentrations, ivol ",  &
                             ivol  
              write(idbg, *) "--> ivol:", ivol
              write(idbg, *) "--> cnew:", cnew(:,ivol)
              write(idbg, *) "--> gamma:", gamma(:,ivol)
              write(idbg, *) "--> gnew:", gnew(:,ivol)
              write(idbg, *) "--> tkel:", tkel(ivol)
            end if
          end if
#endif
          call totconcg(gnew(1,ivol),totgnew(1,ivol))                       

!c  compress total gaseous component concentration vector in case
!c  of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totgnew(1,ivol))
          end if

        end if                 !(ng.gt.0)
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A8", ivol, gnew(:,ivol)
        end if
#endif 
        
!c  compute sorbed concentrations and total sorbed component            
!c  concentrations                                                      

        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
          if (nsb_ion.gt.0) then
            do isb = 1,nsb_ion 
                call sorbspc_m(csb_ion(isb,tid),dummy,cec_g(ivol),    &
                     cec_fraction_g(idx_nsites_ion(isb),ivol),        &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol),cnew(1,ivol),xnusb_ion,xnusb_surf, &
                     iasb_ion,iasb_surf,jasb_ion,jasb_surf,nsb_ion,   &
                     nsb_surf,isb,0,sorption_type_ion,                &
                     sorption_type_surf,sorption_group,isactcexch)
                                      
            end do  !isb
          end if
          
          if(nsb_surf.gt.0) then
            do isb = 1,nsb_surf 
              call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),       &
                   eqsb_ion(:,tid),eqsb_surf(:,tid),                  &
                   gamma(1,ivol),cnew(1,ivol),xnusb_ion,xnusb_surf,   &
                   iasb_ion,iasb_surf,jasb_ion,jasb_surf,nsb_ion,     &
                   nsb_surf,0,isb,sorption_type_ion,                  &
                   sorption_type_surf,sorption_group,isactcexch)
            end do
          end if

          call totsorb(csb_ion(:,tid),csb_surf(:,tid),                &
               chargesb_ion,rhobulk_g(ivol),totsnew_ion(1,ivol),      &
               totsnew_surf(1,ivol),xnusb_ion,xnusb_surf,iasb_ion,    &
               iasb_surf,jasb_ion,jasb_surf,nc,nsb_ion,nsb_surf,      &
               namec)

!c  compress total sorbed component concentration vector in case
!c  of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0.and.nsb_ion.gt.0) then
            call comptotc(totsnew_ion(1,ivol))
          end if
          
          if (redox_equil.and.nr.gt.0.and.nsb_surf.gt.0) then
            call comptotc(totsnew_surf(1,ivol))
          end if

        end if  
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A9", ivol, gnew(:,ivol)
        end if
#endif 
        
!c  compute total source-sink terms towards total concentrations due
!c  to dissolution-precipitation reactons   

#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,'(a,1x,i6,1x,50e16.8)')"-->A ivol ratemdp",     & 
                  ivol, ratemdp(:,ivol)
          end if
#endif
 
        if (nm.gt.0) then        

!c  compute total molar concentration in organic mixture 
          call molconc(phiold(1,ivol))   
          do im=1,nm

!c  overall dissolution-precipitation rate
!c  dissolution   -ve
!c  precipitation +ve

#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,'(a,1x,i4,1x,l)')                               &
                  "-->jacrt->im,pressure_approximation(im)",           &
                  im,pressure_approximation(im)
          end if  
#endif

          if (pressure_approximation(im)) then
              call rate_gasmin(ratemdp(im,ivol),im,ivol,area(im,ivol))
          else if (new_database) then 
!FG sept 2021 - get root density            
               if (root_uptake) then
                  rootdens=rld(ivol)                  
!                  write(*,*) 'jacrt',rootdens, ivol                
               endif
!--------------------------------------------------------------------------
            if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.    &
                ivol_track == 0)) then
              call ratemin_new_dbg(totcnew(1,ivol),cnew(1,ivol),      &
     &                         cx(1,ivol),gamma(1,ivol),              &
     &                         gamma(nc+1,ivol),ratemdp(im,ivol),     &
     &                         phi(1,ivol),phiold(im,ivol),           &
     &                         area(im,ivol),im)
                else
              call ratemin_new(totcnew(1,ivol),cnew(1,ivol),          &
     &                         cx(1,ivol),gamma(1,ivol),              &
     &                         gamma(nc+1,ivol),ratemdp(im,ivol),     &
     &                         phi(1,ivol),phiold(im,ivol),           &
     &                         area(im,ivol),im)
            end if
              
          else

              call ratemin(totcnew(1,ivol),cnew(1,ivol),cx(1,ivol),   &
     &                     gamma(1,ivol),gamma(nc+1,ivol),            &
     &                     ratemdp(im,ivol),phi(im,ivol),             &
     &                     phiold(im,ivol),area(im,ivol),im)
          end if      
          
#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,'(a,1x,i6,1x,50e16.8)')"-->jacrt->A im ratemdp",&
                  im, ratemdp(im,ivol)
          end if  
#endif 

!cdsu  Assign mineral rate for frozen water
            if(b_water_freezing .and. b_water_freezing_ratemin) then
              if (tempnew(ivol) < water_freezing_temper) then
                ratemdp(im,ivol) = water_freezing_ratemin
              end if
            end if

!c  set reaction rate to zero, if absolute value of computed rate 
!c  very small 

            if (dabs(ratemdp(im,ivol)).lt.tinyrate) then

              ratemdp(im,ivol) = r0

            end if
     
!c  use computed dissolution rate only, if sufficient mineral mass
!c  is available, otherwise: assign reaction rate leading to 
!c  depletion of mineral

            dissvol = ratemdp(im,ivol)*delt

            if ((cmnew(im,ivol)+dissvol).lt.(r1+small)*cmcmin(im,tid)) then

              ratemdp(im,ivol) = - (cmnew(im,ivol)-cmcmin(im,tid))/delt

            end if
            
#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,'(a,1x,i6,1x,50e16.8)')"-->jacrt->B im ratemdp",&
                  im, ratemdp(im,ivol)
          end if  
#endif 


!c  set reaction rate to zero, if computed reaction rate indicates
!c  precipitation, but specified level of supersaturation is not 
!c  reached

            if (.not.far_from_equil(im)) then
              if (dlog10(satm(im,tid)).lt.supsatm(im) .and.           &
     &            ratemdp(im,ivol).gt.r0) then

                ratemdp(im,ivol) = r0

              end if
            end if
            
#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,'(a,1x,i6,1x,50e16.8)')"-->jacrt->C im ratemdp",&
                  im, ratemdp(im,ivol)
          end if  
#endif 

          end do             !loop over minerals 
          
!c  use computed dissolution rate only, if sufficient mineral mass
!c  is available, otherwise: assign reaction rate leading to 
!c  depletion of mineral
!c  Isotopes - Feb 2010 Correction - reassign rates based on combined mineralogical parameters

          do im = 1,nm 

            istart = iamp(im)
            istop = iamp(im+1)-1            
             
            dissvol = r0
            
            do i1 = istart,istop
            
              im2 = jamp(i1)
            
              dissvol = dissvol + ratemdp(im2,ivol)*delt
            
            end do
            
            if ((cmnew(im,ivol)+dissvol).lt.                         &
                (r1+small)*cmcmin(im,tid)) then
            
              do i1 = istart,istop
              
               im2 = jamp(i1)
               
               ratemdp(im2,ivol) = -(cmnew(im,ivol)-cmcmin(im,tid))/ &
                       delt/(istop-(istart-1))
               
              end do
            end if
          end do  !loop over minerals

!c  total source/sink terms towards total aqueous component
!c  concentrations due to mineral dissolution precipitation 
!c  reactions                                                           
 
          call totmin(ratemdp(1,ivol),totmdp(1,ivol))
#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,'(a,1x,i6,1x,50e16.8)')"-->jacrt->ivol ratemdp",&
                  ivol, ratemdp(:,ivol)
            write(idbg,'(a,1x,i6,1x,50e16.8)')"-->jacrt->ivol totmdp", &
                  ivol, totmdp(:,ivol)
          end if
#endif 
          
!c  compress source/sink term towards total aqueous component
!c  concentrations due to mineral dissolution-precipitation reactions
!c  in case of redox equilibrium reactions                              

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totmdp(1,ivol))
          end if

        end if                       !(nm.gt.0)
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A10", ivol, gnew(:,ivol)
        end if
#endif 
        
!c  calculate gas properties + molar fractions
        if (ng .gt. 0 .and. (gas_advection .or. dgm .or. maxwell)) then      

          mdens_g(ivol) = gasm(ng, gnew(1,ivol))                   ! gas molar density               

          do ig=1,ng
            gmfrac(ig,ivol) = gnew(ig,ivol) / mdens_g(ivol)    ! molar fractions
          enddo                                                ! gas species
          
          do ic=1,n
            totgmfrac(ic,ivol) = totgnew(ic,ivol) / mdens_g(ivol) ! gas molar frac
          enddo                                                   ! for components
              
          gpivol (ivol) = gasp_m(mdens_g(ivol),ivol)           ! gas pressure
          gdens  (ivol) = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! gas density
          gvisc  (ivol) = gasv(gmfrac(:,ivol))                 ! gas viscosity 
          
#ifdef DEBUG
          if(info_debug > 10 .and. (ivol_gbl == ivol_track .or.        &
              ivol_track == 0)) then    
            write(idbg,'(a,1x,i4, 1x,10d16.8)')                        &
               "-->jacrt->ivol gnew(:,ivol) A11", ivol, gnew(:,ivol)
            write(idbg, *) "->ivol,gmfrac(:,ivol)",ivol,gmfrac(:,ivol)
            write(idbg, *) "->ivol,totgmfrac(:,ivol)",ivol,            &
                           totgmfrac(:,ivol) 
            write(idbg, *) "->ivol,gpivol (ivol)",ivol,gpivol (ivol)
          end if 
#endif 
        end if
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,'(a,1x,i4, 1x,10d16.8)')                          &
                "-->jacrt->ivol gnew(:,ivol) A12", ivol, gnew(:,ivol)
        end if
#endif 
     
      end do                         !loop over control volumes
#ifdef OPENMP
    !$omp end do
#endif

#ifdef DEBUG
        if(info_debug > 10 .and. ivol_track > 0) then
           write(idbg,*) "-->jacrt->gnew(:,ivol_track) B", gnew(:,ivol_track)
          write(idbg, *) "--> gvisc(ivol_track)",  gvisc(ivol_track)
          write(idbg, *) "--> gmfrac(:,ivol_track)", gmfrac(:,ivol_track)          
        end if 
#endif 

      if (b_prtfile .and. tid == 1) then 
       prt_react_jac_part(1) = cputime() - prt_react_jac_part(1)
      end if
    
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi Build the residual and Jacobian matrix
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 

      do ivol = 1,nngl                   !loop over control volumes
          
#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif
          
#ifdef OPENMP    
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif
        if (b_prtfile) then
            if(tid == 1) then
                rtimespan = cputime()
            end if
        end if

!cprovi-----------------------------------------------------------------------------
!cprovi temperature corrections for debye-huckel, equilibrium and rate constants
!cprovi-----------------------------------------------------------------------------       
        if (temp_field.or.heat_transport) then      
          call tcorr(tkel(ivol))
        end if
!cprovi-----------------------------------------------------------------------------
!cprovi Recompute activity coefficients
!cprovi-----------------------------------------------------------------------------
        if (update_activity(tid).eq.'double_update') then
!cprovi----------------------------------------------      
         if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andrs Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 

        call pitzer (phase,gamma(1:nc,ivol),                          &
     &               gamma(nc+1:nc+nx,ivol),                          &
     &               cnew(1:nc,ivol),cx(1:nx,ivol),                   &
     &               nc,nx,ilog)

         else 
!c  --> for free species
          do ic=1,nc
            gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),           &
     &                             sionnew(ivol),chargec(ic),         &
     &                             dhac(ic),dhbc(ic),                 &
     &                             dhad(tid),dhbd(tid),               &
     &                             adav,bdav,acth2omin,nc,            &
     &                             nx,namec(ic),namec)
          end do
        

!c  --> for secondary aqueous species
          do ix=1,nx
            gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),        &
     &                                sionnew(ivol),chargex(ix),      &
     &                                dhax(ix),dhbx(ix),              &
     &                                dhad(tid),dhbd(tid),    &
     &                                adav,bdav,acth2omin,nc,         &
     &                                nx,namex(ix),namec)
          end do
         end if 
        end if

!c  get row pointers

        idiag = iavs(ivol)           !diagonal
        istart = iavs(ivol)+1        !start - off-diagonal connections
        iend = iavs(ivol+1)-1        !end   - off-diagonal connections

!cprovi----------------------------------------------------------------
!cprovi Compute storage term 
!c  compute storage terms (aqueous phase)
!c  exclude non-aqueous components (surface sites) because 
!c  total surface concentrations remain constant
!cprovi----------------------------------------------------------------
        do ic=1,n
!cmx  adding modification factor for effective porosity calculation
!            if (hmulti_diff .or. (epor_diff .and. pornew(ivol) .lt. 0.3 .and.  porold(ivol) .lt. 0.3)) then
            if (hmulti_diff) then

                
                cstor(ic) = cvol(ivol)/delt                         &
     &                * (bulkconc(totcnewf(ic,ivol),                &
     &                            sanew(ivol),                      &
     &                            pornew(ivol))                     &
     &                -  bulkconc(totcoldf(ic,ivol),                &
     &                            saold(ivol),                      &
     &                            porold(ivol)))

            else
                

            cstor(ic) = cvol(ivol)/delt                               &
     &                * (bulkconc(totcnew(ic,ivol),                   &
     &                            sanew(ivol),                        &
     &                            pornew(ivol))                       &
     &                -  bulkconc(totcold(ic,ivol),                   &
     &                            saold(ivol),                        &
     &                            porold(ivol)))
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,'(a,1x,a,1x,6e16.8)')                      &
                      "totcnew(ic,ivol),sanew(ivol),pornew(ivol)",    &
                      "totcold(ic,ivol),saold(ivol),porold(ivol)",    &     
                      totcnew(ic,ivol),sanew(ivol),pornew(ivol),      &   
                      totcold(ic,ivol),saold(ivol),porold(ivol)
              end if
            end if 
#endif
            
            end if 

        end do
!cprovi----------------------------------------------------------------        
!cprovi compute storage terms (gaseous phase)
!cprovi----------------------------------------------------------------

        if (ng>0) then

          do ic=1,n
            gstor(ic) = cvol(ivol)/delt                               &
     &                * (bulkconc(totgnew(ic,ivol),                   &
     &                            sgnew(ivol),                        &
     &                            pornew(ivol))                       &
     &                -  bulkconc(totgold(ic,ivol),                   &
     &                            sgold(ivol),                        &
     &                            porold(ivol)))
          end do

        end if

!c  compute storage terms (non-competitive sorption)

        if (noncompetitive_sorption) then
          do ic = 1,n
          astor(ic) = cvol(ivol)/delt                               &
     &                * (totanew(ic,ivol) - totaold(ic,ivol))
        end do
      end if

!c  compute storage terms (surface complexation and ion exchange)
        
        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
          if (sorption_group.eq.'surface-complexation'.or.(nsb_surf.gt.0.and. &
              sorption_group.eq.'surface-complex and ion-exchange')) then  
              do ic=1,n            


             
                  totsb_surf(ic) = cvol(ivol)/delt                            &
                           * (pornew(ivol)*sanew(ivol)*totsnew_surf(ic,ivol) -  &
                            porold(ivol)*saold(ivol)*totsold_surf(ic,ivol))

        
              end do
          end if
              
          if (sorption_group.eq.'ion-exchange'.or.(nsb_ion.gt.0.and. &
              sorption_group.eq.'surface-complex and ion-exchange')) then  
              do ic=1,n            
                totsb_ion(ic) = cvol(ivol)/delt * (totsnew_ion(ic,ivol) - totsold_ion(ic,ivol))
              end do
          end if

        end if        
        
!c  compute total source-sink terms towards total concentrations due
!c  to intra-aqueous kinetic reactions

        if (naq>0) then

!c  reaction rates of intra-aqueous kinetic reactions

          do iaq = 1,naq
          if (new_database) then
              call rateint_new(rateaq(iaq,tid),totcnew(1,ivol),       &
                               cnew(1,ivol),cx(1,ivol),gamma(1,ivol), &
                               gamma(nc+1,ivol),phi(1,ivol),iaq,      &
                               scalfac_aq_ivol(iaq,ivol))
          else
              call rateint(rateaq(iaq,tid),totcnew(1,ivol),           &
                           cnew(1,ivol),gamma(1,ivol),phi(1,ivol),    &
                           iaq,scalfac_aq_ivol(iaq,ivol))
            end if
          end do
           
!c  total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions
          call totint(totaq(:,tid),idbg)
          
!c  scale total source-sink term due to intra-aqueous kinetic 
!c  reactions

          do ic = 1,n
                totaq(ic,tid) = cvol(ivol) * bulkconc(totaq(ic,tid),  &
     &                                       sanew(ivol),             &
     &                                       pornew(ivol))
          end do

        end if
         
!c  compute degassing rates and total rates for removal of aqueous
!c  components due to degassing [mol L^-1 h2o s^-1]
 
        if (ng.gt.0.and.gas_removal) then
          if (density_dependence) then
            call rategasd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),        &
                          sgnew(ivol))
          else
            call rategas(gnew(1,ivol),tkel(ivol),hhead(ivol),zg(ivol), &
                         sgnew(ivol))
          end if
          call totconcg(rateg(:,tid),totrateg)

!c  scale total rates for removal af aqueous components due to 
!c  degassing [mol L^-1 bulk s^-1]

          do ic = 1,n
            totrateg(ic) = cvol(ivol) * bulkconc(totrateg(ic),        &
     &                                           sanew(ivol),         &
     &                                           pornew(ivol))
          end do

!c  compress total rates for removal of aqueous components
!c  due to degassing in case of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totrateg)
          end if

        end if                   !(ng.gt.0.and.gas_removal)

!c  compute total source-sink terms towards total concentrations due
!c  to kinetically controlled oxidation/reduction reactions

        if (.not.redox_equil.and.nr.gt.0) then

!c  overall oxidation-reduction rates for redox couples

          do ir = 1,nr
            call rateredx(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),      &
     &                    gamma(nc+1,ivol),rateor(ir,tid),            &
     &                    totcnew(1,ivol),ir)
          end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to oxidation-reduction reactions
          call totredx(totor,idbg)
          
!c  scale total source-sink term due to oxidation/reduction reactions

          do ic = 1,n
            totor(ic) = cvol(ivol) * bulkconc(totor(ic),              &
     &                                        sanew(ivol),            &
     &                                        pornew(ivol))    
          end do
        end if 

!c  scale total source-sink term due to dissolution/precipitation 
!c  reactions

        if (nm.gt.0) then
          do ic=1,n
            totdp(ic,tid) = cvol(ivol)*totmdp(ic,ivol)
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,'(a,3e16.8)')                               &
                      "cvol(ivol),totmdp(ic,ivol),totdp(ic)",          &
                      cvol(ivol),totmdp(ic,ivol),totdp(ic,tid)
              end if
            end if 
          end do
        end if
 
!c  compute fluxes between current control volume and adjacent
!c  control volumes and total flux into current control volume

        icon = 0                   !zero counter - connections

        do ic=1,n
          totcflux(ic) = r0        !zero total influx (aqueous phase)
        end do

        if (ng.gt.0) then
          do ic=1,n
            totgflux(ic) = r0      !zero total influx (gaseous phase)
          end do
        end if

        do i1 = istart,iend        !off-diagonal connections

          icon = icon+1            !current connection
          jvol = javs(i1)          !column pointer

!cdsu -------------------------------------------------------
!cdsu                   gas advection
!cdsu--------------------------------------------------------
        if (ng .gt. 0 .and. (gas_advection .or. dgm .or. maxwell)) then  
            
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              write(idbg, *)                                          &
                    "--> A ivol,jvol,gvisc(ivol),gvisc(jvol),viscgij",&
                    ivol,jvol,gvisc(ivol),gvisc(jvol),viscgij
            end if
          end if    
#endif     

!         calculate gas properties at interface according to weighting scheme
          call wgprop(totgnew(1,ivol),totgnew(1,jvol),totgij   ,      &
     &                gnew(1,ivol)   ,gnew(1,jvol)   ,gij      ,      &
     &                gmfrac(1,ivol) ,gmfrac(1,jvol) ,gmfracij ,      &
     &                relpermg(ivol) ,relpermg(jvol) ,relpgij  ,      &
     &                gdens(ivol)    ,gdens(jvol)    ,densgij  ,      &
     &                gvisc(ivol)    ,gvisc(jvol)    ,viscgij  ,      &
     &                gpivol(ivol)   ,gpivol(jvol)   ,gpij     ,      &
     &                zg(ivol)       ,zg(jvol)       ,                &
     &                spt_weight     ,iupsg(i1)      ,                &
     &                nc             ,ng             ,gacc     )
          
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              write(idbg, *)                                          &
                    "--> B ivol,jvol,gvisc(ivol),gvisc(jvol),viscgij",&
                    ivol,jvol,gvisc(ivol),gvisc(jvol),viscgij
            end if
          end if    
#endif
        

!c ----- DGM module -------------------------------------------------------------
!c         solve A F = B
!c         computes fluxes F of all gas components at current c.v. interphase
          
		  if (dgm) then
		    
		    call dgm_fluxdg (gnew(1,ivol)       ,gnew(1,jvol) ,        & 
     &                       gij                ,gmfracij     ,        &
     &                       zg(ivol)           ,zg(jvol)     ,        &
     &                       densgij            ,gpij         ,        &
     &                       tkel(ivol)         ,permij(i1)   ,        &
     &                       relpgij            ,tauij(i1)    ,        &
     &                       gporij(i1)         ,deltaij(i1)  ,        &
     &                       rverysmall         ,                      &
     &                       ludecomp(1,1,icon) ,                      &
     &                       fmat(1,icon)       ,ipvt(1,icon) ,        &
     &                       dgm_gflux          ,neflux       )

!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------

		  else if (maxwell) then
          
	        call ms_fluxdg (gnew(1,ivol)        ,gnew(1,jvol) ,        &
     &                      gij                 ,gmfracij     ,        &
     &                      zg(ivol)            ,zg(jvol)     ,        &
     &                      densgij             ,gpij         ,        &
     &                      tkel(ivol)          ,tauij(i1)    ,        &
     &                      gporij(i1)          ,deltaij(i1)  ,        &
     &                      rverysmall          ,                      &
     &                      ludecomp(1,1,icon)  ,                      &
     &                      fmat(1,icon)        ,                      &
     &                      ipvt(1,icon)        ,equimolar    ,        &
     &                      ms_gflux            ,neflux       )
          
	      endif

        end if
          
! prc -------------------------------------------------------
! prc calculating dynamic visusity for 
! prc multicomponent diffusion flux 
! prc -------------------------------------------------------
    
        
      if (multi_diff) then  
          
            call totdyvisc(cnew(:,ivol),cx(:,ivol),totviscnew(:,ivol), &
     &                     mdiff_ic_cvol(:,i1),mdiff_ix_cvol(:,i1)) 

#ifdef OPENMP         
            call totdyvisc(cnew(:,jvol),cx(:,jvol),totviscnewjvol(:),  &
     &                     mdiff_ic_cvol(:,i1),mdiff_ix_cvol(:,i1))
#else          
            call totdyvisc(cnew(:,jvol),cx(:,jvol),totviscnew(:,jvol), &
     &                     mdiff_ic_cvol(:,i1),mdiff_ix_cvol(:,i1))
#endif            
            
            distance = deltaij(i1)    
            call elecmigration(cnew(:,ivol),cx(:,ivol),cnew(:,jvol),   &
     &                         cx(:,jvol),mdiff_ic_cvol(:,i1),         &
     &                         mdiff_ix_cvol(:,i1),                    &
     &                         electromignew(:,ivol),                  &
     &                         vel_lin(i1),ivol)


      end if

          do ic=1,n                !loop over primary unknowns
          
!cprovi---------------------------------------------------------------
!cprovi Bubbles use component dependent influence coefficient if specified
!cprovi---------------------------------------------------------------
            if (diff_coff) then
             cinfrt_da(i1) = cinfrt_da_ic(i1,ic)
            end if
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!c  compute aqueous phase flux

        if (multi_diff) then 

#ifdef OPENMP

!!cmx  adding modification factor for effective porosity calculation
!            if (epor_diff .and. pornew(ivol) .lt. 0.3 .and.  porold(ivol) .lt. 0.3) then
                                                                      
!                ecinfrt_mcd = 0.0d0
!                ecinfrt_mcd = cinfrt_mcd(i1)*f_epor(ic)
!
!                cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),         & !advective term
!     &                                totcnew(ic,jvol),             &
!     &                                ivol,jvol,                    &
!     &                                cinfrt_va(i1),ic)             &
!     &                     - fluxd(totviscnew(ic,ivol),             &   !diffusive term
!     &                             totviscnewjvol(ic),                &
!     &                             ecinfrt_mcd)                        &
!     &                     - fluxd(electromignew(ic,ivol),r0,        &   !electromigration term
!     &                             ecinfrt_mcd)
!            else
                   cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),        & !advective term
     &                                totcnew(ic,jvol),               &
     &                                ivol,jvol,                      &
     &                                cinfrt_va(i1),ic)               &
     &                     - fluxd(totviscnew(ic,ivol),               & !diffusive term
     &                             totviscnewjvol(ic),                &
     &                             cinfrt_mcd(i1))                    &
     &                     - fluxd(electromignew(ic,ivol),r0,         & !electromigration term
     &                             cinfrt_mcd(i1))
            !end if

#else

!!cmx  adding modification factor for effective porosity calculation
!            if (epor_diff .and. pornew(ivol) .lt. 0.3 .and.  porold(ivol) .lt. 0.3) then
                
!                ecinfrt_mcd = 0.0d0
!                ecinfrt_mcd = cinfrt_mcd(i1)*f_epor(ic)
!        
!                cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),       & !advective term
!     &                                totcnew(ic,jvol),       &
!     &                                ivol,jvol,              &
!     &                                cinfrt_va(i1),ic)       &
!     &                     - fluxd(totviscnew(ic,ivol),     &   !diffusive term
!     &                             totviscnew(ic,jvol),        &
!     &                             ecinfrt_mcd)        &
!     &                     - fluxd(electromignew(ic,ivol),r0,    &   !electromigration term
!     &                             ecinfrt_mcd)        
!            else
                cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),           & !advective term
     &                                totcnew(ic,jvol),               &
     &                                ivol,jvol,                      &
     &                                cinfrt_va(i1),ic)               &
     &                     - fluxd(totviscnew(ic,ivol),               & !diffusive term
     &                             totviscnew(ic,jvol),               &
     &                             cinfrt_mcd(i1))                    &
     &                     - fluxd(electromignew(ic,ivol),r0,         & !electromigration term
     &                             cinfrt_mcd(i1))
            !end if
#endif            
            
        else
           
            cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),               & !advective term
     &                                totcnew(ic,jvol),               &
     &                                ivol,jvol,                      &
     &                                cinfrt_va(i1),ic)               &
     &                     - fluxd(totcnew(ic,ivol),                  & !dispersive term
     &                             totcnew(ic,jvol),                  &
     &                             cinfrt_da(i1))
             
        end if        

!c  total influx

            totcflux(ic) = totcflux(ic) + cflux(icon,ic) 

!c  compute gaseous phase flux and total influx

            if (ng.gt.0) then
                
              gflux(icon,ic) = r0
              
              if (gas_advection) then

                if (gsatij(i1).gt.gsatmin) then
                
                  gflux(icon,ic) = fluxvg(gpivol(ivol),gpivol(jvol),  &
     &                                    zg(ivol)    ,zg(jvol)    ,  &
     &                                    totgij(ic)  ,relpgij     ,  &
     &                                    densgij     ,viscgij     ,  &
     &                                    cinfvs_g(i1),               &
     &                                    gas_gravity ,gacc)
 
                endif
              
              endif ! gas advection 
              
#ifdef DEBUG
              if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                    write(idbg, '(3(a,1x,i6,1x),11(a,1x,e16.8,1x))')   &
                      "ivol",ivol,"jvol",jvol,"ic",ic,"gflux(icon,ic)",&
                      gflux(icon,ic),"totgij(ic)",totgij(ic),          &
                      "viscgij",viscgij,                               &
                      "gpivol(ivol)",gpivol(ivol),"gpivol(jvol)",      &
                      gpivol(jvol),"zg(ivol)",zg(ivol),"zg(jvol)",     &
                      zg(jvol),"relpgij",relpgij,"densgij",densgij,    &
                      "cinfvs_g(i1)",cinfvs_g(i1),"gacc",gacc
                  end if
              end if    
#endif
       
!c--------ficks law, business as usual------------------------------------

              if ((.not.dgm).and.(.not.maxwell)) then

                if (blanc_diff_g) then
!c                diffusion coefficient calc'd with LeBlanc's law
                  cinfrt = cinfrt_dg(i1) * gasdiff2                    &
     &                            (gmfrac(1,ivol), gmfrac(1,jvol),     &
     &                             gpivol(ivol)  , gpivol(jvol)  ,     &
     &                             zg(ivol)      , zg(jvol)      ,     &
     &                             gdens(ivol)   , gdens(jvol)   ,     &
     &                             ic            ,                     &
     &                             iupsg(i1)     , spt_weight    )

			    else 
!c                single constant diffusion
	              cinfrt = cinfrt_dg(i1)
			    endif    

!c diffusion expressed in terms of concentration gradients
    
                gflux(icon,ic) = gflux(icon,ic)                        & !advective flux
     &                         - fluxd(totgnew(ic,ivol),               & !diffusive flux 
     &                                 totgnew(ic,jvol),               &
     &                                 cinfrt)

!c ------- DGM module -----------------------------------------------------------

		      else if (dgm) then
 
!c               check if there is gas phase
                if (gporij(i1).lt.rverysmall .or.                      &
                    relpgij.lt.rverysmall) then
!c               no gas phase 

                else

                  gflux(icon,ic) = gflux(icon,ic)                      &
     &                           + cinfrt_dg(i1)                       &
     &                           * deltaij(i1)                         &
     &                           * dgm_gflux(ic)                       &
     &                           / tauij(i1)                           &
     &                           / gporij(i1)

	            endif

!c ------- Maxwell Stefan module -------------------------------------------------

		      else if (maxwell) then

!c               check if there is gas phase
                if (gporij(i1).lt.rverysmall) then
!c               no gas phase 

                else

                  gflux(icon,ic) = gflux(icon,ic)                      & 
     &                           + cinfrt_dg(i1)                       &
     &                           * deltaij(i1)                         &
     &                           * ms_gflux(ic)                        &
     &                           / tauij(i1)                           &
     &                           / gporij(i1)

	            endif

              end if      
 
              totgflux(ic) = totgflux(ic) + gflux(icon,ic)
#ifdef DEBUG
              if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                    write(idbg, *) "ivol, ic, totgflux(ic)",           &
                    ivol, ic, totgflux(ic)
                  end if
              end if    
#endif
          end if

          end do                   !loop over components
          
        end do                     !off-diagonal connections

!c  construct rhs-vector
 
        do ic = 1,n

          irow = (ivol-1)*n+ic      !pointer - global rhs-vector 

          call rhsrt(naq,ng,nm,nr,nsb_ion,nsb_surf,astor(ic),         &
                     cstor(ic),gstor(ic),totaq(ic,tid),               &
                     totsb_ion(ic),totsb_surf(ic),                    &
                     totor(ic),totdp(ic,tid),                         &
                     totcflux(ic),totgflux(ic),totrateg(ic),          &
                     redox_equil,noncompetitive_sorption,             &
                     component_type(ic),brt(irow))
#ifdef DEBUG
          if(info_debug > 20) then
              
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,'(a,6i6)') "naq,ng,nm,nr,nsb_ion,nsb_surf",&
                  naq,ng,nm,nr,nsb_ion,nsb_surf
                write(idbg,'(a,4e16.8)')                              &
                  "astor(ic),cstor(ic),gstor(ic),totaq(ic)",          &
                  astor(ic),cstor(ic),gstor(ic),totaq(ic,tid)
                write(idbg,'(a,3e16.8)')                              &
                  "totsb_ion(ic),totsb_surf(ic),totor(ic)",           &
                  totsb_ion(ic),totsb_surf(ic),totor(ic)
                write(idbg,'(a,4e16.8)')                              &
                  "totdp(ic),totcflux(ic),totgflux(ic),totrateg(ic)", &
                  totdp(ic,tid),totcflux(ic),totgflux(ic),totrateg(ic)
                write(idbg,'(a,1x,l,1x,l)')                           &
                  "redox_equil,noncompetitive_sorption",              &
                  redox_equil,noncompetitive_sorption
                write(idbg,'(a,1x,i6,1x,e16.8,1x,a)')                 &
                  "irow,brt,component_type(ic)",irow,brt(irow),       &
                  component_type(ic)
              end if
          end if
#endif
        end do

 
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!c  compute derivatives for jacobian matrix

        do ic=1,nc
          cinc(ic,tid) = cnew(ic,ivol)  !extract free species concentrations
        end do                      !for current control volume

        
        !if(info_debug > 0 .and. ittot_rt < 5 .and. ivol == nngl) then 
        !    write(idbg, *) "Openmp test: label 6"
        !    write(idbg, *) "---> brt:"
        !    write(idbg, *) brt
        !end if
  
        if (b_prtfile) then
            if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(2) = prt_react_jac_part(2) + rtimespan
            end if     
        end if
       
        do jbl=1,n               !loop over columns of block matrix
        
          if (b_prtfile) then
              if(tid == 1) then  
                rtimespan = cputime()
              end if  
          end if

!c  compute increment for numerical differentiation

          drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column
 
          cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  equilibrium redox reactions, compute concentrations of dependent
!c  components of redox couples with incremented free species
!c  concentrations

          if (redox_equil.and.nr.gt.0) then
            do ir=1,nr
              ic = n+ir    
              call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),      &
                   gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
            end do
          end if

!c  compute aqueous complex concentrations with incremented free species
!c  concentrations

          do ix=1,nx
            call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),       &
                 gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
          end do
         
!c  compute derivatives of total aqueous component concentrations

          if (analyt_deriv_rt) then
            call atotconc(cnew(1,ivol),cx(1,ivol),jbl)
          else
            if (hmulti_diff) then
                izn = mpropvs(ivol)
                call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,izn)
                call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl)
            else                
                call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl)
        end if
      end if

!c  compute derivative of sorbed concentrations (non-competitive
!c  sorption) and scale total source and sink term 

          if (noncompetitive_sorption) then
          
          call totcona(dtota,dtotc(:,tid),distcoff_rt(1,ivol),        &
     &                 sanew(ivol), pornew(ivol))
          do ic = 1,n
            dtota(ic) = cvol(ivol)/delt * dtota(ic)
          end do 
            
        end if

!c  compress total aqueous and sorbed (noncompetitive sorption)
!c  component concentration vector in case of redox equilibrium 
!c  reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(dtotc(:,tid))
          if (noncompetitive_sorption) then
            call comptotc(dtota)
          end if
          end if

!c  compute gas concentrations with incremented free species 
!c  concentrations 

          if (ng.gt.0) then

            do ig = 1,ng
              call gasconc(cinc(:,tid),gamma(1,ivol),ginc(ig,tid),     &
                   ig,tkel(ivol))
            end do
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                write(idbg, *) "--> compute gas concentrations with ", &
                               "incremented free species"  
                write(idbg, *) "--> cinc", cinc(:,tid)
                write(idbg, *) "--> gamma", gamma(:,ivol)
                write(idbg, *) "--> ginc", ginc(:,tid)
                write(idbg, *) "--> tkel", tkel(ivol)
                write(idbg, *) "--> eqg", eqg(:,tid)
              end if
            end if
#endif

!c  compute derivatives of total gaseous component concentrations 

            call dtotcong(gnew(1,ivol),ginc(:,tid),dtotg,xnug,drtinc, &
     &                    iaga,jaga,nc,ng,jbl,namec)
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                write(idbg, *) "--> compute derivatives of total ",    &
                "gaseous component concentrations"  
                write(idbg, *) "--> ivol,nc,ng,jbl", ivol,nc,ng,jbl
                write(idbg, *) "--> gnew", gnew(:,ivol)
                write(idbg, *) "--> ginc", ginc(:,tid)
                write(idbg, *) "--> dtotg", dtotg
                write(idbg, *) "--> xnug", xnug
                write(idbg, *) "--> drtinc", drtinc
              end if
            end if
#endif

!c  compress derivative of total gaseous component concentration 
!c  vector in case of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotg)
            end if

!c  compute derivatives of degassing rates and derivatives of total 
!c  rates for removal of aqueous components due to degassing 
!c  [mol L^-1 h2o s^-1]

            if (gas_removal) then
              if (density_dependence) then
                call drategdd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),   &
     &                      drtinc)
              else
                call drategas(gnew(1,ivol),tkel(ivol),hhead(ivol),    &
     &                      zg(ivol),drtinc)         
              end if
              call totconcg(rateg(:,tid),totrateg)

!c  scale derivatives of total rates for removal af aqueous components 
!c  due to degassing [mol L^-1 bulk s^-1]

              do ic = 1,n
                totrateg(ic) = cvol(ivol) * bulkconc(totrateg(ic),    &
     &                                               sanew(ivol),     &
     &                                               pornew(ivol))
              end do

!c  compress derivatives of total rates for removal of aqueous components
!c  due to degassing in case of redox equilibrium reactions

              if (redox_equil.and.nr.gt.0) then
                call comptotc(totrateg)
              end if

            end if

          end if

!c  compute partial derivatives of concentrations of sorbed species 
!c  with respect to primary unknowns

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then

            if(nsb_ion.gt.0) then
              do isb = 1,nsb_ion  
                call sorbspc_m(csb_ion(isb,tid),dummy,cec_g(ivol),    &
                     cec_fraction_g(idx_nsites_ion(isb),ivol),        &
                     eqsb_ion(:,tid), eqsb_surf(:,tid),               &
                     gamma(1,ivol),cnew(1,ivol),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,isb,0,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)    
                call sorbspc_m(dcsb_ion(isb,tid),dummy,cec_g(ivol),   &
                     cec_fraction_g(idx_nsites_ion(isb),ivol),        &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol), cinc(:,tid),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,isb,0,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
                dcsb_ion(isb,tid) =                                   &
                    (dcsb_ion(isb,tid) - csb_ion(isb,tid))/drtinc 
              end do
            end if
            
            if(nsb_surf.gt.0) then
              do isb = 1,nsb_surf  
                call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),     &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol),cnew(1,ivol),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,0,isb,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
                call sorbspc(dummy,dcsb_surf(isb,tid),cec_g(ivol),    &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol), cinc(:,tid),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,0,isb,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)                
                dcsb_surf(isb,tid) =                                  &
                    (dcsb_surf(isb,tid) - csb_surf(isb,tid))/drtinc
              end do
            end if

!c  compute derivatives of of total sorbed component concentrations

            call totsorb(dcsb_ion(:,tid),dcsb_surf(:,tid),            &
                         chargesb_ion,rhobulk_g(ivol),                &
                         dtotsb_ion(:,tid),dtotsb_surf(:,tid),        &
                         xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,     &
                         jasb_ion,jasb_surf,nc,nsb_ion,nsb_surf,      &
                         namec)

!c  compress derivative of total sorbed component concentration 
!c  vector in case of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0.and.nsb_ion.gt.0) then
              call comptotc(dtotsb_ion(:,tid)) 
            end if
            
            if (redox_equil.and.nr.gt.0.and.nsb_surf.gt.0) then
              call comptotc(dtotsb_surf(:,tid)) 
            end if

!c  scale total source and sink term towards total aqueous component
!c  concentrations due to sorption reactions
      
            do ic = 1,n
              if(nsb_ion.gt.0) then  
                dtotsb_ion(ic,tid) = cvol(ivol)/delt *                &
                                     dtotsb_ion(ic,tid)
              end if
              if(nsb_surf.gt.0) then  
                dtotsb_surf(ic,tid) = cvol(ivol)/delt *               &
                                      dtotsb_surf(ic,tid)
              end if
              if (nsb_surf.gt.0.and.(sorption_group.eq.               &
                  'surface-complexation'.or. sorption_group.eq.       &
                  'surface-complex and ion-exchange')) then
                dtotsb_surf(ic,tid) = sanew(ivol)*pornew(ivol)*       &
                                      dtotsb_surf(ic,tid)
              end if
            end do

          end if

!c  compute total aqueous component concentrations (incremented),
!c  to be used for computing derivatives of dissolution-precipitation,
!c  oxidation-reduction rates and/or advective fluxes (Van Leer flux
!c  limiter)

          if ((.not.redox_equil.and.nr.gt.0).or.(nm.gt.0).or.         &
     &         naq.gt.0) then
            call totconc(cinc(:,tid),cxinc(:,tid),totcinc(:,tid))
          end if

!c  compute derivatives of intra-aqueous kinetic reactions

          if (naq.gt.0) then

            do iaq = 1,naq
              if (new_database) then
                call drateint_new(rateaq(iaq,tid),totcnew(1,ivol),    & 
                                cnew(1,ivol),cx(1,ivol),gamma(1,ivol),&
                                gamma(nc+1,ivol),phi(1,ivol),         &
                                drtinc,iaq,scalfac_aq_ivol(iaq,ivol))
              else
                
                call drateint(rateaq(iaq,tid),totcnew(1,ivol),        &
                              cnew(1,ivol),gamma(1,ivol),phi(1,ivol), &
                              drtinc,iaq,scalfac_aq_ivol(iaq,ivol))
              end if
            end do

!c  derivative of total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions
            call totint(dtotaq(:,tid),idbg)

!c  scale derivative of total source-sink term due to intra-aqueous 
!c  kinetic reactions

            do ic = 1,n
              dtotaq(ic,tid) = cvol(ivol) * bulkconc(dtotaq(ic,tid),  &
     &                                           sanew(ivol),         &
     &                                           pornew(ivol))        

            end do

          end if

!c  compute derivatives of oxidation-reduction rates

          if (.not.redox_equil.and.nr.gt.0) then

            do ir = 1,nr
              call draterdx(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),    &
     &                      gamma(nc+1,ivol),rateor(ir,tid),          &
     &                      totcnew(1,ivol),drtinc,ir,idbg)
            end do

!c  derivative of total source/sink terms towards total aqueous 
!c  component concentrations due to derivatives of oxidation/reduction 
!c  reactions
            call totredx(dtotor,idbg)
 
!c  scale derivative of total source-sink term due to 
!c  oxidation/reduction reactions

            do ic = 1,n
              dtotor(ic) = cvol(ivol) * bulkconc(dtotor(ic),          &
     &                                           sanew(ivol),         &
     &                                           pornew(ivol))
            end do

          end if

!c  compute derivatives of total source-sink terms towards total 
!c  aqueous component concentrations due to dissolution-precipitation 
!c  reactions 
 
          if (nm.gt.0) then

!c  compute total molar concentration in organic mixture 
            call molconc(phiold(1,ivol))

            do im=1,nm

!c  - compute derivative of rate if:
!c     * sufficient mineral mass is available 
!c     * abs(dissolution-precipitation rate) > 0 
!c    otherwise: set derivative of rate to zero

              dissvol = ratemdp(im,ivol)*delt

              if ((cmnew(im,ivol)+dissvol).lt.                        &
     &            (r1+small)*cmcmin(im,tid).or.                       &
     &            dabs(ratemdp(im,ivol)).lt.tinyrate) then
!cmbalmin            if ((cmnew(im,ivol).le.cmcmin(im).and.
!cmbalmin     &           ratemdp(im,ivol).le.r0).or.
!cmbalmin     &          (dabs(ratemdp(im,ivol)).lt.tinyrate)) then
                
                dratedp(im,tid) = r0
 
              else

                if (analyt_deriv_rt) then

                  call aratemin(totcnew(1,ivol),cnew(1,ivol),         &
     &                          cx(1,ivol),gamma(1,ivol),             &
     &                          gamma(nc+1,ivol),dratedp(im,tid),     &
     &                          phi(im,ivol),phiold(im,ivol),         &
     &                          area(im,ivol),im,jbl,ivol)

                else
                  if (pressure_approximation(im)) then
                    call drate_gasmin(dratedp(im,tid),im,ivol,        &
     &                                area(im,ivol),drtinc)
                
                  else if (new_database) then

                    call dratemin_new(totcnew(1,ivol),cnew(1,ivol),   &  
     &                              cx(1,ivol),gamma(1,ivol),         &
     &                              gamma(nc+1,ivol),dratedp(im,tid), &
     &                              phi(1,ivol),phiold(im,ivol),      &
     &                              area(im,ivol),drtinc,im,ivol)
                  else

                    call dratemin(totcnew(1,ivol),cnew(1,ivol),       &  
     &                          cx(1,ivol),gamma(1,ivol),             &
     &                          gamma(nc+1,ivol),dratedp(im,tid),     &
     &                          phi(im,ivol),phiold(im,ivol),         &
     &                          area(im,ivol),drtinc,im,ivol)
                
                 end if
                end if

              end if

!c  set derivative of rate to zero, if solution supersaturated,
!c  but precipitation does not occur 

              if (.not.far_from_equil(im)) then
                if (dlog10(satm(im,tid)).lt.supsatm(im) .and.         &
     &              ratemdp(im,ivol).gt.r0) then

                  dratedp(im,tid) = r0

                end if
              end if

            end do

!c  derivatives of total source/sink terms due to dissolution/
!c  precipitation reactions
 
            call totmin(dratedp(:,tid),dtotdp(:,tid))

!c  compress  derivatives of source/sink term towards total aqueous
!c  component concentrations due to mineral dissolution-precipitation
!c  reactions in case of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotdp(:,tid)) 
            end if

!c  scale derivative of total source-sink term due to 
!c  dissolution/precipitation reactions

            do ic=1,n
              dtotdp(ic,tid) = cvol(ivol)*dtotdp(ic,tid)
            end do

          end if                  !(nm.gt.0)

!c  construct current column of jacobian matrix

          icon = 0                     !zero counter (connections)

          do ic=1,n
            dtotcflux(ic) = r0         !zero derivative of total
          end do                       !influx (aqueous phase)

          if (ng.gt.0) then
            do ic=1,n
              dtotgflux(ic) = r0       !zero derivative of total
            end do                     !influx (gaseous phase)
          end if
          
!c  compute numerical derivatives for each gas wrt primary unknown incremented
          if (ng.gt.0 .and. (gas_advection .or. dgm .or. maxwell)) then
            
              do ig = 1,ng
                dg(ig) = (ginc(ig,tid) - gnew(ig,ivol)) / drtinc
              end do
              
              dgpivol  = gasp(ng,dg,ivol)          
              dmdens_i = gasm(ng,dg)
              ddens_i  = gasd_m(dmdens_i,gmfrac(:,ivol)) 
              
!c  for dgm module calculations:
!c  calculate gas molar densities and mole fractions
              mdens_g_inc = gasm(ng,ginc(:,tid))                    !gas molar density		      
		      do ig=1,ng
                dgmfrac(ig) = (ginc(ig,tid)/mdens_g_inc-gmfrac(ig,ivol)) / &
                               drtinc
              enddo
!c  end dgm
              
          end if    

          if (b_prtfile) then
              if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(3) = prt_react_jac_part(3) + rtimespan
                rtimespan = cputime()
              end if
          end if
          
          do i1 = istart,iend          !off-diagonal connections

            icon = icon+1              !pointer - connection
            jvol = javs(i1)            !pointer - column
            isym = isymvs(i1)          !symmetry pointer - 1d - scalar
            lsym = lart(isym)          !symmetry pointer - global block
            
            if (ng.gt.0 .and. (gas_advection.or.dgm.or.maxwell)) then 

!c        calculate gas properties at interface according to weighting scheme
               call wgpropd(totgnew(1,ivol),totgnew(1,jvol),totgij   , &
     &                      relpermg(ivol) ,relpermg(jvol) ,relpgij  , &
     &                      gdens(ivol)    ,gdens(jvol)    ,densgij  , &
     &                      gvisc(ivol)    ,gvisc(jvol)    ,viscgij  , &
     &                      gpivol(ivol)   ,gpivol(jvol)   ,gpij     , &
     &                      zg(ivol)       ,zg(jvol)       ,           &
     &                      spt_weight     ,iupsg(i1)      ,wfac     , &
     &                      nc             ,ng             ,gacc     )
               
!c ----- DGM module -------------------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
		      if (dgm) then
			  
                call dgm_dfluxdg (gnew(1,ivol)  ,gnew(1,jvol)  ,       &
     &                            dg            ,dgmfrac       ,       &
     &                            zg(ivol)      ,zg(jvol)      ,       &
     &                            densgij       ,gpij          ,       &
     &                            tkel(ivol)    ,relpgij       ,       &
     &                            tauij(i1)     ,gporij(i1)    ,       &
     &                            deltaij(i1)   ,rverysmall    ,       &
     &                            wfac          ,ipvt(1,icon)  ,       &
     &                            ludecomp(1,1,icon)           ,       &
     &                            fmat(1,icon)  ,dgm_dgflux    )
	        
		      endif

!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
		      if (maxwell) then
              
	            do i=1,ng-1
	              do j=1,ng-1
	                lumat2(i,j)=ludecomp(i,j,icon)
	              enddo
                enddo
			    
	            call ms_dfluxdg  (gnew(1,ivol)    ,gnew(1,jvol)    ,   &
     &                            dg              ,dgmfrac         ,   &
     &                            zg(ivol)        ,zg(jvol)        ,   &
     &                            densgij         ,gpij            ,   &
     &                            tkel(ivol)      ,tauij(i1)       ,   &
     &                            gporij(i1)      ,deltaij(i1)     ,   &
     &                            rverysmall      ,wfac            ,   &
     &                            ipvt(1,icon)    ,equimolar       ,   &
     &                            lumat2          ,fmat(1,icon)    ,   &
     &                            ms_gflux        ,ms_dgflux   )
              
	          endif

            end if 
            

!c  compute derivatives of fluxes between current control volume 
!c  and adjacent control volumes and derivatives of total fluxes into 
!c  current control volume

! prc -------------------------------------------------------
! prc calculating derivatives dynamic visusity for 
! prc multicomponent diffusion flux 
! prc -------------------------------------------------------
        
        if (multi_diff) then

           call dtotdyvisc(cnew(:,ivol),cx(:,ivol),         &       
     &           mdiff_ic_cvol(:,i1),mdiff_ix_cvol(:,i1), drtinc)

           call elecmigration(cnew(:,ivol),cx(:,ivol),cnew(:,jvol),   &
     &                         cx(:,jvol),mdiff_ic_cvol(:,i1),        &
     &                         mdiff_ix_cvol(:,i1),                   &
     &                         electromignew(:,ivol),                 &
     &                         vel_lin(i1),ivol)
     
            call elecmigration(cinc(:,tid),cxinc(:,tid),cnew(:,jvol), &
     &                         cx(:,jvol),mdiff_ic_cvol(:,i1),        &
     &                         mdiff_ix_cvol(:,i1),                   &
     &                         electromignew_inc(:,ivol),             &
     &                         vel_lin(i1),ivol)                      
                                                                      
            call delcmigfunc(electromignew(:,ivol),                   &           !output: delecmigrationnew
     &                       electromignew_inc(:,ivol),drtinc)     
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
#ifdef PETSC
               write(idbg, '(2(a,1x,i10,1x))')                        &
                 "--> multi_diff delecmigrationnew: global ivol",     &
                 node_idx_lg2g(ivol),"global jvol",node_idx_lg2g(jvol)
#else
               write(idbg, '(2(a,1x,i10,1x))')                        &
                 "--> multi_diff delecmigrationnew: ivol",ivol,       &
                 "jvol",jvol
#endif
               
               do ibl=1,nc-1
                   write(idbg,'(a,1x,i10,1x,9(a,1x,e20.12,1x))')       &
                   "ibl",ibl,                                          &
                   "cnew(ibl,ivol)",cnew(ibl,ivol),                    &
                   "cx(ibl,ivol)",cx(ibl,ivol),                        &
                   "cnew(ibl,jvol)",cnew(ibl,jvol),                    &
                   "cx(ibl,jvol)",cx(ibl,jvol),                        &
                   "mdiff_ic_cvol(ibl,i1)",mdiff_ic_cvol(ibl,i1),      &
                   "cinc(ibl,tid)",cinc(ibl,tid),                      &
                   "cxinc(ibl,tid)",cxinc(ibl,tid),                    &
                   "mdiff_ix_cvol(:,i1)",mdiff_ix_cvol(ibl,i1),        &
                   "vel_lin(i1)",vel_lin(i1)
               end do
              
               do ibl=1,nc-1
                   write(idbg,'(4(a,1x,e13.6,1x))')                    &
                      "electromignew",electromignew(ibl,ivol),         &
                      "electromignew_inc",electromignew_inc(ibl,ivol), &
                      "drtinc",drtinc,                                 & 
                      "delecmigrationnew",delecmigrationnew(ibl,tid)
               end do
               
              end if 
            end if
#endif
        end if

            do ibl=1,n                !loop over rows (block matrix)
                
              if(sparse_blocks .and. kblsorb(ibl,jbl) == 1) then
                  cycle
              end if

              if (kaobl(ibl,jbl).ne.0) then          !skip zero entries
              
!cprovi----------------------------------------------------------------
!cprovi Bubbles use component dependent influence coefficient if specified
!cprovi----------------------------------------------------------------
                if (diff_coff) then
                 cinfrt_da(i1) = cinfrt_da_ic(i1,ibl)
                end if
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!c  compute derivative of flux and derivative of total influx 
!c  (aqueous phase)

        if (multi_diff) then 

 !!cmx  adding modification factor for effective porosity calculation
 !           if (epor_diff .and. pornew(ivol) .lt. 0.3 .and.  porold(ivol) .lt. 0.3) then
 !               ecinfrt_mcd = 0.0d0
 !               ecinfrt_mcd = cinfrt_mcd(i1)*f_epor(ic)
 !               
 !               dcflux = fluxv_vl(dtotc(ibl,tid),r0,                  & !advective term
 !    &                            ivol,jvol,                          &
 !    &                            cinfrt_va(i1),ibl)                  &
 !    &                 - fluxd(dtotviscnew(ibl,tid),r0,                  & !diffusive term
 !    &                         ecinfrt_mcd)                           &
 !    &                 - fluxd(delecmigrationnew(ibl,tid),r0,         & !electromigration term
 !    &                         ecinfrt_mcd)           
!
!            else
                
                dcflux = fluxv_vl(dtotc(ibl,tid),r0,                  & !advective term
     &                            ivol,jvol,                          &
     &                            cinfrt_va(i1),ibl)                  &
     &                 - fluxd(dtotviscnew(ibl,tid),r0,               & !diffusive term
     &                         cinfrt_mcd(i1))                        &
     &                 - fluxd(delecmigrationnew(ibl,tid),r0,         & !electromigration term
     &                         cinfrt_mcd(i1))           
!            end if
#ifdef DEBUG
                if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, '(4(a,1x,i10,1x),6(a,1x,e13.6,1x))')   &
                    "--> multi_diff dcflux: ivol",ivol,"jvol",jvol,    &
                    "ibl",ibl,"i1",i1,"dtotc(ibl,tid)",dtotc(ibl,tid), &
                    "cinfrt_va(i1)",cinfrt_va(i1),                     &
                    "dtotviscnew(ibl,tid)",dtotviscnew(ibl,tid),       &
                    "cinfrt_mcd(i1)",cinfrt_mcd(i1),                   &
                    "delecmigrationnew(ibl,tid)",                      &
                    delecmigrationnew(ibl,tid),"dcflux",dcflux
                  end if
                end if
#endif             
        else

                dcflux = fluxv_vl(dtotc(ibl,tid),r0,                     &    !advective term
     &                            ivol,jvol,                          &
     &                            cinfrt_va(i1),ibl)                  &
     &                 - fluxd(dtotc(ibl,tid),r0,                     & !dispersive term
     &                         cinfrt_da(i1))
     
#ifdef DEBUG
                if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, '(4(a,1x,i10,1x),4(a,1x,e13.6,1x))')     &
                    "--> no multi_diff dcflux: ivol",ivol,"jvol",jvol, &
                    "ibl",ibl,"i1",i1,"dtotc(ibl,tid)",dtotc(ibl,tid), &
                    "cinfrt_va(i1)",cinfrt_va(i1),"cinfrt_da(i1)",     &
                    cinfrt_da(i1),"dcflux",dcflux
                  end if
                end if
#endif
        end if
    
!c  derivative of total influx

                dtotcflux(ibl) = dtotcflux(ibl) + dcflux

!c  compute derivative of flux and derivative of total influx 
!c  (gaseous phase)
            
                if (ng.gt.0) then
                    
                  dgflux = r0  
                    
                  if (gas_advection) then

                    if (gsatij(i1).gt.gsatmin) then
      
                      dgflux = dfluxvg(totgij(ibl)  ,dtotg(ibl)   ,   &
     &                                 gpivol(ivol) ,gpivol(ivol) ,   &
     &                                 dgpivol      ,                 &
     &                                 zg(ivol)     ,zg(jvol)     ,   &
     &                                 densgij      ,ddens_i      ,   &
     &                                 viscgij      ,relpgij      ,   &
     &                                 cinfvs_g(i1)   ,wfac       ,   &
     &                                 gas_gravity, gacc          )
#ifdef DEBUG
                      if(info_debug > 10) then
                        if(ivol_gbl == ivol_track .or.                &
                            ivol_track == 0) then  
                          write(idbg, *)                              &
                                "--> compute derivative dgflux 1:, ", &
                                "ivol, dgflux", ivol, dgflux
                        end if
                      end if
#endif
                    endif

                  endif ! gas advection
                  
                  
!c--------ficks law, business as usual------------------------------------   

                  if ((.not.dgm).and.(.not.maxwell)) then

                    if (blanc_diff_g) then
!c                   diffusion coefficient calc'd with LeBlanc's law
                      cinfrt = cinfrt_dg(i1) * gasdiff2(               &
     &                                gmfrac(1,ivol) , gmfrac(1,jvol), &
     &                                gpivol(ivol)   ,gpivol(jvol),    &
     &                                zg(ivol)       ,zg(jvol)    ,    &
     &                                gdens(ivol)    ,gdens(jvol) ,    &
     &                                ic             ,                 &
     &                                iupsg(i1)      ,spt_weight  )
                      
			        else 
!c                     single constant diffusion
	                  cinfrt = cinfrt_dg(i1)
			        endif 

!c diffusive as function of concentration gradients 
     
                    dgflux = dgflux                                    &
     &                       - fluxd(dtotg(ibl),r0,                    & !diffusive flux
     &                               cinfrt)
     

!c ----- DGM module -------------------------------------------------------------
                
			      else if (dgm) then

!c                   check if there is gas phase
                    if (gporij(i1).lt.rverysmall                       &
     &                  .or.relpgij.lt.rverysmall) then
!c                   no gas phase 

                    else

                      dgflux = dgflux                                  &
     &                       + cinfrt_dg(i1)                           &
     &                       * deltaij(i1)                             &
     &                       * dgm_dgflux(ibl)                         &
     &                       / tauij(i1)                               &
     &                       / gporij(i1)

	                endif
!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------
                
			      else if (maxwell) then

!c                   check if there is gas phase
                    if (gporij(i1).lt.rverysmall) then
!c                   no gas phase 
                    else
                      dgflux = dgflux                                  & 
     &                       + cinfrt_dg(i1)                           &
     &                       * deltaij(i1)                             &
     &                       * ms_dgflux(ibl)                          &
     &                       / tauij(i1)                               &
     &                       / gporij(i1)
                    endif

!c ------------------------------------------------------------------------------
                  end if
                    
                  dtotgflux(ibl) = dtotgflux(ibl) + dgflux
#ifdef DEBUG
                  if(info_debug > 10) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                      write(idbg, *)                                   &
                        "--> compute derivative dgflux 2:, ivol, ",    &
                        "i1, ibl, dtotg, cinfrt_dg, dgflux, dtotgflux",&
                        ivol, i1, ibl, dtotg(ibl),cinfrt_dg(i1),       &
                        dgflux, dtotgflux(ibl)
                    end if
                  end if
#endif
                end if

!c  get pointer for assembly in global scalar jacobian matrix

                i2 = kart(lsym+kaobl(ibl,jbl)-1)

!c  allocate entries of column of off-diagonal block 
!c  in global scalar jacobian matrix

                if (component_type(ibl).eq.'aqueous') then
                    
                  art(i2) = art(i2) - cnew(jbl,ivol) * dcflux  !aqueous phase
#ifdef DEBUG
                  if(info_debug > 20) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                      write(idbg, *)                                   &
                        "--> aqueous i2, jbl, ivol, dcflux, cnew, art",&
                        i2, jbl, ivol, dcflux, cnew(jbl, ivol), art(i2)
                    end if
                  end if
#endif
                end if

                if (ng.gt.0) then
                  art(i2) = art(i2) - cnew(jbl,ivol) * dgflux  !gaseous phase
#ifdef DEBUG
                  if(info_debug > 20) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                      write(idbg, *)                                   &
                        "--> gas i2, jbl, ivol, dgflux, cnew, art",    & 
                        i2, jbl, ivol, dgflux, cnew(jbl, ivol), art(i2)
                    end if
                  end if
#endif
                end if
                
              end if              !skip zero entries
            end do                !loop over rows of block matrix
          end do                  !off-diagonal connections
          
          if (b_prtfile) then
              if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(4) = prt_react_jac_part(4) + rtimespan
                rtimespan = cputime()
              end if  
          end if

!c  entries in diagonal block of global scalar jacobian matrix

          ldiag = lart(idiag)     !diagonal pointer - global block matrix
          do ibl = 1,n            !loop over rows of block matrix

            if (kadbl(ibl,jbl).ne.0) then          !skip zero entries
!c  compute derivatives of storage terms for aqueous phase

!c      Porosity correction factors has to be used to modify the effective porosity
!c      of each species for the hybrid multicomponent diffusion model, which is
!c      included in dtotcf as calculated in dtotconc.
                if (hmulti_diff) then
              dcstor = cvol(ivol)/delt                                &
     &                          * bulkconc(dtotcf(ibl,tid),           &
     &                          sanew(ivol),                          &
     &                          pornew(ivol))
                else                    
     
                    dcstor = cvol(ivol)/delt                          &
     &               * bulkconc(dtotc(ibl,tid),                       &
     &                          sanew(ivol),                          &
     &                          pornew(ivol))
                end if
    
!cprovi------------------------------------------------------------------------
!cprovi------------------------------------------------------------------------
!cprovi------------------------------------------------------------------------

!c  compute derivatives of storage terms for gaseous phase

              if (ng.gt.0) then

                dgstor = cvol(ivol)/delt                              &
     &                 * bulkconc(dtotg(ibl),                         &
     &                            sgnew(ivol),                        &
     &                            pornew(ivol))

              end if

!c  get pointer for assembly in global scalar jacobian matrix

              i2 = kart(ldiag+kadbl(ibl,jbl)-1)

!c  allocate entries of column of diagonal block 
!c  in global scalar jacobian matrix

!c  aqueous phase
!c  --------------------------------------------------------------------

!c  - storage and flux terms

              if (component_type(ibl).eq.'aqueous') then              
                art(i2) = art(i2) + cnew(jbl,ivol) * dcstor           &
     &                            + cnew(jbl,ivol) * dtotcflux(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &        
                      "--> aqueous2 i2, ibl, jbl, ivol, dcstor, ",     &
                      "dtotcflux, cnew, art",                          &
                      i2, ibl, jbl, ivol, dcstor,                      &
                      dtotcflux(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              else
                art(i2) = art(i2) + cnew(jbl,ivol) * dcstor
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> not aqueous i2, jbl, ivol, dcstor, cnew, art",&
                    i2, jbl, ivol, dcstor, cnew(jbl,ivol), art(i2)
                  end if
                end if  
#endif
              end if

!c  - kinetically-controlled redox reactions

              if (.not.redox_equil.and.nr.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotor(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> kinetic i2, ibl, jbl, ivol, dtotor, cnew, art",&
                  i2, ibl, jbl, ivol, dtotor(ibl),                    &
                  cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              end if

!c  - intra-aqueous kinetic reactions

              if (naq.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotaq(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, '(a, 4(1x, i8),3(1x, e16.8))')          &
                  "--> intra i2, ibl, jbl, ivol, dtotaq, cnew, art",  &
                  i2, ibl, jbl, ivol, dtotaq(ibl,tid),                &
                  cnew(jbl,ivol), art(i2)
                  end if
                end if
#endif
              end if

!c  - degassing

              if (gas_removal) then
                art(i2) = art(i2) + cnew(jbl,ivol) * totrateg(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> gas removal i2, ibl, jbl, ivol, ",             &
                  "totrateg, cnew, art",                              &
                  i2, ibl, jbl, ivol,                                 &
                  totrateg(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if
#endif
              end if

!c  gaseous phase
!c  --------------------------------------------------------------------

              if (ng.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dgstor           &
     &                            + cnew(jbl,ivol) * dtotgflux(ibl) 
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> gas2 i2, ibl, jbl, ivol, dgstor, ",            &
                  "dtotgflux, cnew, art",                             &
                  i2, ibl, jbl, ivol, dgstor,                         &
                  dtotgflux(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              end if


!c  sorbed phase (non-competitive sorption)
!c  --------------------------------------------------------------------

              if (noncompetitive_sorption) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtota(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> noncompe sorp i2, ibl, jbl, ivol, ",          &
                    "dtota, cnew, art",                                &
                    i2, ibl, jbl, ivol,                                &
                    dtota(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if
#endif
              end if

!c  sorbed phase
!c  --------------------------------------------------------------------

              if (nsb_ion.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotsb_ion(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> nsb_ion i2, ibl, jbl, ivol, dtotsb_ion, ",    &
                    "cnew, art",                                       &
                    i2, ibl, jbl, ivol, dtotsb_ion(ibl,tid),           &
                    cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              end if
              
              if (nsb_surf.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) *                  &
                          dtotsb_surf(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> nsb_surf i2, ibl, jbl, ivol, ",               &
                    "dtotsb_surf, cnew, art",                          &
                    i2, ibl, jbl, ivol,                                &
                    dtotsb_surf(ibl,tid), cnew(jbl,ivol), art(i2)
                  end if
                end if  
#endif
              end if

!c  mineral phase
!c  --------------------------------------------------------------------

              if (nm.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotdp(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "-->mineral i2, ibl, jbl, ivol, dtotdp, cnew, art",&
                    i2, ibl, jbl, ivol, dtotdp(ibl,tid),               &
                    cnew(jbl,ivol), art(i2)
                  end if
                end if  
#endif
              end if
              
            end if                !skip zero entries
            
          end do                  !loop over rows of block matrix

          cinc(jbl,tid) = cnew(jbl,ivol)  !"unshift" free species concentration
          
          if (b_prtfile) then
              if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(5) = prt_react_jac_part(5) + rtimespan
              end if
          end if

        end do                    !loop over columns of block matrix
        
      end do                      !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef DEBUG
      if(info_debug > 10) then
          write(idbg, *) "--> totgflux", totgflux
      end if
#endif

#ifdef DEBUG
      if (info_debug > 10 .and. ivol_track > 0) then
         write(idbg,*) "-->jacrt->gnew(:,ivol_track) C", gnew(:,ivol_track)
      end if
#endif

      if (b_prtfile) then
          prt_react_jac_part(6) = cputime() - prt_react_jac_part(6)
      end if

      continue
!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then
        irow = 0
        do ivol=1,nngl 
          do ic=1,n
            irow = irow+1
            write(idbg,'(a,2x,a,i5,i5,a,1pd12.5)')                    &
     &            namec(ic),'b(',ivol,ic,') = ',brt(irow)/cvol(ivol)
          end do
        end do
        do ivol=1,nngl
          do ic = 1,n
            irow=(ivol-1)*n+ic
            istart = iart(irow)
            iend   = iart(irow+1)-1
            write(idbg,*) iart(irow)
            i2 = 0
            do i1 = istart,iend
              i2 = i2+1
              if (i2.gt.n) then
                i2 = i2-n
              end if
              icol = jart(i1)
              write(idbg,'(a,2x,a,2x,a,i5,i5,a,1pd12.5)')             &
     &              namec(ic),namec(i2),'a(',irow,icol,') = ',        &
     &                           art(i1)/cvol(ivol)
            end do
          end do
        end do
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
      
#endif
!cdbg

      return
      end
