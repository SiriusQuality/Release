!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/infcrtdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine infcrtdd
!c -------------------
!c
!c compute influence coefficients for advective and dispersive flux 
!c terms for rectangular, cartesian finite volume discretization 
!c (reactive transport) for aqueous phase using density dependent 
!c flow equation
!c
!c from Uli Mayer template
!c
!c written by:      Tom Henderson - October 22, 2002
!c
!c last modified:   Tom Henderson - July 11, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c     input:
!c
!c passed:   real*8:
!c           -------
!c           d(3, ibk)          = dimension of cells in x,y,z         + -
!c                                direction
!c           density(nn)        = fluid density                       + - 
!c           dvolcoef           = volume flux coefficient including   * +       
!c                                viscosity and relative permeability
!c           diffu              = phase molecular diffusion (m2/day)
!c           disx(nzn)          = dispersion, x direction (m)
!c           disy(nzn)          =    "      , y    "      (m)
!c           disz(nzn)          =    "      , z    "      (m)
!c           cinfrt_va()        = influence coefficients 
!c                                J^w_ij/A_ij
!c                                (advective flux terms)
!c           cinfrt_da()        = influence coefficients
!c                                D_ij * A_ij / d_ij  
!c                                (dispersvie flux terms)
!c           viscosity(nn)      = fluid viscosity                     - -     
!c
!c           integer*4:
!c           ----------
!c           ibk                = block i
!c           id                 = connected block j
!c           idbg               = output for debugging information
!c           ilog               = unit number, logbook
!c           nmax               = max cells for dim purposes
!c           nphas              = max number of phases
!c           njamxc             = max dim ja array (ncomp.com)
!c           nvx                = number of control volumes 
!c                                in x direction
!c           nvy                = number of control volumes 
!c                                in y direction
!c           nvz                = number of control volumes 
!c                                in z direction
!c           pornew(ibk)        = porosity
!c           sanew(nmax)        = aqueous phase saturation
!c                                - new time level
!c           uvsnew(nmax)       = pressure
!c           relperm(nmax)      = rel permeability
!c           cinfvs(nmax)       = influence coefficient 
!c                                (variably saturated flow) 
!c           ia(), ja()         = ysmp pointers
!c           isymm(ii)          = symmetry pointer for cell ibk
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions
!c           variably_saturated = .true.  -> .not.fully_saturated,
!c                                        -> variably saturated
!c                                           conditions
!c           half_cells         = .true.  -> half cells on boundary
!c           tortuosity_corr    = .true.  -> Millington-Quirk 
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c
!c
!c local:
!c
!c external: diffcoff  = compute effective diffusion coefficient
!c           fluxdd    = flux function for fully saturated flow 
!c           fluxvs    = flux function for variably saturated flow
!c --------------------------------------------------------------------------

      subroutine infcrtdd (nvxgls, nvxgle, nvxgbl,                    &
                         nvygls, nvygle, nvygbl,                      &
                         nvzgls, nvzgle, nvzgbl,                      &
                         nvx, nvy, nvz, ia, ja, isymm,                &
                         cinfvs, cinfrt_va, cinfrt_da, d,             &
                         mprop, nzn, diffu, disx, disy, disz,         &
                         pornew, sanew, uvsnew,                       &
                         density, zg, viscosity,relperm,              &
                         idbg, ilog, fully_saturated,                 &
                         variably_saturated, njamxc, nmax,            &
                         tortuosity_corr,half_cells,time,tfinal,      &
                         cinfrt_da_ic, diff_coff, nc, diff_ic,        &
                         assigned_tau,tau,type_tortuosity,marchies,   &
                         harmonic_porosity,delx,dely,delz,av_dens_z,  &
                         ups_heat,gacc,cinfrad,radial_coord, tau_fac, &
                         sonew)
#ifdef OPENMP
      use omp_lib 
      use gen, only : rank, b_enable_output,                          &
                      numofthreads_global,                            &
                      numofloops_thred_global,                        &
                      numofloops_thred_infcrtdd_1,                    &
                      numofloops_thred_infcrtdd_2,                    &
                      numofloops_thred_infcrtdd_3
#else
      use gen, only : rank, b_enable_output 
#endif  
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none

      external diffcoff, fluxdd

      integer nvxgls, nvxgle, nvxgbl, nvygls, nvygle, nvygbl,         &
             nvzgls, nvzgle, nvzgbl, ivxgbl, ivygbl, ivzgbl,          &
             ivxpgbl, ivypgbl, ivzpgbl, ivxngbl, ivyngbl, ivzngbl,    &
             nvx, nvy, nvz, ia(nmax+1), ja(njamxc),                   &
             isymm(njamxc), idbg, ilog, nzn, mprop(*), nc

      logical half_cells, fully_saturated, variably_saturated,        &
             tortuosity_corr,diff_coff,assigned_tau,                  &
             harmonic_porosity,av_dens_z,radial_coord

      real*8  diffu, disx(nzn), disy(nzn), disz(nzn),                 &
             pornew(nmax), uvsnew(nmax),                              &
             density(nmax), zg(nmax), viscosity(nmax),                &
             relperm(nmax),sanew(nmax), d(3,nmax),                    &
             cinfvs(njamxc), cinfrt_va(njamxc),                       &
             cinfrt_da(njamxc),cinfrt_da_ic(njamxc,nc),               &
             diff_ic(nc),tau(nmax),cinfrad(njamxc), tau_fac(nmax),    &
             marchies(nmax),sonew(nmax)
     
      real*8  delx(nvx),dely(nvy),delz(nvz),ups_heat,rpel_av,         &
             visco_av,gacc     
     
      character(len=*) type_tortuosity

      real*8 diffcoff,fluxfs,fluxvs,fluxdd,value_tau
      
      
!c     local variables
      
      integer :: info_debug, ic, njamxc, nmax

      real*8, parameter :: eps = 1.0d-300, r0 = 0.0d0,                &
                rhalf = 0.5d0, r1 = 1.0d0, r2 = 2.0d0

      real*8 aread(3,12),areax(3,12),vel(3),dist(3,12),               &
            porav, satav, vx2, vy2, vz2, vmag,                        &
            tend(3), areai,                                           &
            diffav, diff_eff,disx_avg, disy_avg,                      &
            disz_avg, dflux, delp_dd, delz_dd,                        &
            rho_av, dvolcoef, time, tfinal,tauav, marchieav
     
!c      added for dgm model
      real*8 :: so_av           
      
!cprovi    changed: Nov. 09, added for harmonic averaging
      real*8 diff_i,diff_j,diff_ij,areaf,                             &
           por_i,por_j,delx_i,dely_i,delz_i,delx_j,dely_j,delz_j,     &
           tau_i, tau_j
     
      integer ibk, ivz, ivy, ivx, ibkz, ibky,                         &
             ii, id, ixx, iyy, izz, iisav,                            &
             idim, npair(3), iface(3,12), ndim,                       &
             fvpair(3,12,2), ipair, idim2, idim3, irk_ibk, irk_id
    
!cprovi    changed: Nov. 09, added for harmonic averaging
      integer ivxp,ivxn,ivyp,ivyn,ivzp,ivzn,jtemp,nedge,              &
             ivol,jvol,izn,jzn
#ifdef OPENMP      
      integer :: nvols
#endif

      character*1 iups

!c  compute influence coefficients for advective flux terms
!c  (influence coefficients are equal Darcy flux = J_ij/A_ij)

    delx_i = r0
    dely_i = r0
    delz_i = r0
    delx_j = r0
    dely_j = r0
    delz_j = r0

!c  loop over control volumes

      info_debug = 0 
      ivol=0
      tau_i = r1
      tau_j = r1
#ifdef OPENMP      
      nvols = nvx * nvy * nvz
#endif
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrtdd_1)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ibky, ibkz, id, idim, idim2, idim3,           &
    !$omp ii, iisav, ivx, ivy, ivz, ixx, iyy, izz,                    &
    !$omp delp_dd, delz_dd, dvolcoef, rho_av, rpel_av, visco_av)                  
    !$omp do schedule(static)
#endif
      do ivz = 1,nvz                !increments in z-direction         
        ibkz = (ivz-1)*nvx*nvy

        do ivy = 1,nvy              !increments in y-direction
          ibky = (ivy-1)*nvx
          
          do ivx = 1,nvx            !increments in x-direction 
            ibk = ibkz+ibky+ivx

!c  loop over three -ve faces

            do idim = 1,3           !loop over dimensions
              ixx = ivx
              iyy = ivy
              izz = ivz

!c  compute in -tive face direction only

              if (idim.eq.1) then           !in x-direction
                ixx = ixx-1
                id = ibk-1
                idim2 = 2
                idim3 = 3
              elseif (idim.eq.2) then       !in y-direction
                iyy = iyy-1
                id = ibk-nvx
                idim2 = 3
                idim3 = 1
              elseif (idim.eq.3) then       !in z-direction
                izz = izz-1
                id = ibk-nvx*nvy
                idim2 = 1
                idim3 = 2
              endif

!c  skip if edge

              if (ixx.le.0 .or. iyy.le.0 .or. izz.le.0) cycle

!c  find -ve face in row of connected cells to ibk

              do ii = ia(ibk),ia(ibk+1)-1
                if (ja(ii).eq.id) then
                  iisav = ii
                  go to 211
                endif
              end do
              if (rank == 0) then
                write(ilog,*) ' error-cannot find id in list-infcrtdd 1'
                write(ilog,*) ' ibk, id ', ibk, id
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
211           continue


!c  find darcy volume (not mass) flux between node pair

              delp_dd = uvsnew(id) - uvsnew(ibk)
              delz_dd = zg(id) - zg(ibk)

              if (delz_dd .ne. r0) then
                rho_av = rhalf * (density(ibk) + density(id))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
 
                delz_dd = delz_dd * rho_av * gacc
                delp_dd = delp_dd + delz_dd
           
              end if
                
!c  assign coefficients for upstream weighting
!c calculate water volume (not mass!!) fluxes
 
              
                if (delp_dd .gt. r0) then
                rpel_av=ups_heat*relperm(id)+           &
                        (r1-ups_heat)*relperm(ibk)
                visco_av=ups_heat*viscosity(id)+        &
                        (r1-ups_heat)*viscosity(ibk)       
                else          
                 rpel_av=ups_heat*relperm(ibk)+           &
                        (r1-ups_heat)*relperm(id)
                 visco_av=ups_heat*viscosity(ibk)+        &
                        (r1-ups_heat)*viscosity(id)               
                end if
                
                dvolcoef=rpel_av/visco_av

#ifdef OPENMP
    !$omp critical
#endif 
                cinfrt_va(iisav) = - fluxdd(delp_dd,cinfvs(ii), &
                                    dvolcoef)

!c  matrix is symmetric n a symbolic sense, since cinfrt_va between 
!c  cell ibk and id is equal to - cinfrt_va between cells id and ibk

                cinfrt_va(isymm(iisav)) = - cinfrt_va(iisav)
#ifdef OPENMP
    !$omp end critical
#endif 
            end do            
          end do         
        end do
      end do      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif       

!c  compute the influence coefficients for dispersive flux terms
!c  loop over the number of "pseudo dispersion elements"

!c  zero the influence coefficient for dispersive flux term
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrtdd_2)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ii)                  
    !$omp do schedule(static)
#endif
      do ibk = 1, nmax
        do ii = ia(ibk),ia(ibk+1)-1
          cinfrt_da(ii) = r0
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  loop over control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrtdd_3)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, id, idim, idim2, idim3, iface, ii, iisav,     &
    !$omp ipair, irk_id, irk_ibk, ivx, ivy, ivz, ivol, ivxp, ivxn,    &
    !$omp ivyp, ivyn, ivzp, ivzn, jtemp, jvol, jzn, ndim,             &
    !$omp ivxgbl, ivygbl, ivzgbl, ivxpgbl, ivypgbl, ivzpgbl,          &
    !$omp ivxngbl, ivyngbl, ivzngbl,                                  &
    !$omp areax, aread, areai, areaf, delp_dd, delz_dd, dflux,        &
    !$omp delx_i, delx_j, dely_i, dely_j, delz_i, delz_j, dist,       &
    !$omp diffav, diff_eff, diff_i, diff_ij, diff_j,                  &
    !$omp disx_avg, disy_avg, disz_avg, dvolcoef, fvpair,             &
    !$omp marchieav, npair, porav, por_i, por_j, rho_av, satav,       &
    !$omp tauav, tau_i, tau_j, tend, vel, vmag, vx2, vy2, vz2,        &
    !$omp so_av)                                                      
    !$omp do schedule(static)
#endif
      do ivz = 1, nvz        !increments in z-direction
        ivzgbl = ivz+nvzgls-1  
        do ivy = 1, nvy      !increments in y-direction
          ivygbl = ivy+nvygls-1  
          do ivx = 1, nvx    !increments in x-direction
            ivxgbl = ivx+nvxgls-1
!c  find node pairs for elemental velocities as well
!c  as influence coefficient for node pairs within dipersion element

!            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,
!     &                     fvpair, npair, aread, d, half_cells,
!    &                     nmax,idbg)
            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,              &
                          fvpair, npair,aread,areax,dist,d,           & 
                          half_cells, ia, ja, njamxc,                 &
                          nmax, idbg, cinfrad, radial_coord)

!c  check if fully connected "pseudo dispersion element"
!c  was found for dimensionality of problem

            if ((nvx .gt. 1 .and. npair(1) .eq. 0) .or.               &
               (nvy .gt. 1 .and. npair(2) .eq. 0) .or.                &
               (nvz .gt. 1 .and. npair(3) .eq. 0)) cycle

!c loop over the dimensions x,y,z

            do idim = 1, 3

              idim2 = idim + 1
              idim3 = idim + 2
              if (idim2 .gt. 3) idim2 = idim2 - 3
              if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero advective velocity

              vel(idim) = r0

!c  loop over the number of node pairs in the dimension

              do ipair = 1, npair(idim)

                ibk = fvpair(idim, ipair, 1)
                id = fvpair(idim, ipair, 2)

!c  calculate average interfacial area between nodes
!cprovi------------------------------------------------
!cprovi Assign the interfacial area
!cprovi------------------------------------------------                
                areai = areax(idim, ipair)

                do ii = ia(ibk), ia(ibk+1)-1
                  if (ja(ii) .eq. id) then
                    iisav = ii
                    go to 431
                  endif
                end do
                if (rank == 0) then
                  write(ilog,*) ' error-cannot find id in list-infcrtdd 2'
                  write(ilog,*) ' ibk, id ', ibk, id
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
431             continue
                iface(idim, ipair) = iisav

!c  find darcy volume (not mass) flux between node pair

                delp_dd = uvsnew(id) - uvsnew(ibk)
                delz_dd = zg(id) - zg(ibk)

              if (delz_dd .ne. r0) then
                  rho_av = rhalf * (density(ibk) + density(id))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
                  if (av_dens_z) then  
                   delp_dd=rho_av*(uvsnew(id)/density(id)-    &
                                  uvsnew(ibk)/density(ibk))
                  end if
                  delz_dd = delz_dd * rho_av * gacc
                  delp_dd = delp_dd + delz_dd
           
                end if
                
!c  assign coefficients for upstream weighting
!c calculate water volume (not mass!!) fluxes
 
                  if (delp_dd .gt. r0) then
                  dvolcoef = relperm(id)/viscosity(id)       
                  else          
                  dvolcoef = relperm(ibk)/viscosity(ibk)          
                  end if
                   
              dflux = - fluxdd(delp_dd,cinfvs(iisav),   &
                                  dvolcoef)

!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two nodes

                vel(idim) = vel(idim) + dflux / areai

              end do !ipair = 1, npair(idim)
               
!c  find the average elemental velocity in the
!c  x,y,z directions

              vel(idim) = vel(idim)/(float( npair(idim) ) + eps)
            end do !idim = 1, 3

!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi Not harmonic average in porosity 
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
      
      if (.not.harmonic_porosity) then  


!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
            porav = r0
            do idim = 1, 3
               do ipair = 1, npair(idim)
                  ibk = fvpair(idim, ipair, 1)
                  id = fvpair(idim, ipair, 2)
                  porav = porav                       &
                       + dmin1( r1, pornew(ibk) )     &
                       + dmin1( r1, pornew(id) )
               end do
            end do 

            ndim = 0
            if (nvx .gt. 1) ndim = ndim + 1
            if (nvy .gt. 1) ndim = ndim + 1
            if (nvz .gt. 1) ndim = ndim + 1
            porav = porav / float(ndim) / r2**ndim
            
!c  average tortuosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
          if (assigned_tau) then
            tauav = r0
            do idim = 1, 3
               do ipair = 1, npair(idim)
                  ibk = fvpair(idim, ipair, 1)
                  id = fvpair(idim, ipair, 2)
 !c                 tauav = tauav                                 &
 !c                     + dmin1( r1, tau(ibk) * tau_fac(ibk) )    &
 !c                     + dmin1( r1, tau(id) * tau_fac(id) )
                  tauav = tauav                                   &
                        + tau(ibk) * tau_fac(ibk)                 &
                        + tau(id) * tau_fac(id)
               end do
            end do 

            ndim = 0
            if (nvx .gt. 1) ndim = ndim + 1
            if (nvy .gt. 1) ndim = ndim + 1
            if (nvz .gt. 1) ndim = ndim + 1
            tauav = tauav / float(ndim) / r2**ndim
          end if

!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

            diffav = r0
            disx_avg = r0
            disy_avg = r0
            disz_avg = r0

            do idim = 1, 3                      !loop over dimensions
              do ipair = 1, npair(idim)        !node pairs

                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                     irk_ibk = mprop(ibk)
                     irk_id = mprop(id)

                     diffav = diffav          &
                           + diffu            &
                           + diffu

                     disx_avg = disx_avg      &
                             + disx(irk_ibk)  &
                             + disx(irk_id)

                     disy_avg = disy_avg      &
                             + disy(irk_ibk)  &
                             + disy(irk_id)

                     disz_avg = disz_avg      &
                             + disz(irk_ibk)  &
                             + disz(irk_id)

                  end do                           !node pairs
               end do                              !dimensions 

               diffav = diffav / float(ndim) / r2**ndim
               disx_avg = disx_avg / float(ndim) / r2**ndim
               disy_avg = disy_avg / float(ndim) / r2**ndim
               disz_avg = disz_avg / float(ndim) / r2**ndim

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element

               satav = r0
               so_av = r0
               do idim = 1, 3
                  do ipair = 1, npair(idim)
                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)
                     satav = satav                    &
                          + dmin1( r1, sanew(ibk) )   &
                          + dmin1( r1, sanew(id) )
		             so_av = so_av                    &
                           + dmin1( r1, sonew(ibk) )  &
                           + dmin1( r1, sonew(id) ) 
                  end do
               end do
               satav = satav / float(ndim) / r2**ndim
               so_av = so_av / float(ndim) / r2**ndim

               vx2 = vel(1)**2
               vy2 = vel(2)**2
               vz2 = vel(3)**2
               vmag = dsqrt(vx2 + vy2 + vz2)
               vx2 = vx2 / (vmag + eps)
               vy2 = vy2 / (vmag + eps)
               vz2 = vz2 / (vmag + eps)
               
!c  calculate the average marchie factor

               marchieav = r0
               do idim = 1, 3
                  do ipair = 1, npair(idim)
                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)
                     marchieav = marchieav + marchies(ibk) + marchies(id)
                  end do
               end do
               marchieav = marchieav / float(ndim) / r2**ndim 

!c  calculate effective diffusion coefficient
               if (.not.diff_coff) then
                diff_eff = diffcoff(diffav,satav,porav,       &
                                    tortuosity_corr,          &
                                    assigned_tau,tauav,       &
                                    type_tortuosity,          &
                                    marchieav,so_av)

                tend(1) = disx_avg * vx2                      &
                      + disy_avg * vy2                        &
                      + disz_avg * vz2                        &
                      + diff_eff

                tend(2) = disy_avg * vx2                      &
                      + disx_avg * vy2                        &
                      + disz_avg * vz2                        &
                      + diff_eff

                tend(3) = disz_avg * vx2                      &
                      + disz_avg * vy2                        &
                      + disx_avg * vz2                        &
                      + diff_eff

!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif 
               do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization


                    do ipair = 1, npair(idim)             !node pairs
  
                       iisav = iface(idim, ipair)

                       cinfrt_da(iisav) = cinfrt_da(iisav)        &
                                       + tend(idim)               &
                                       * aread(idim, ipair)

                       cinfrt_da(isymm(iisav)) =                  &
                                  cinfrt_da(isymm(iisav))         &
                                  + tend(idim) * aread(idim, ipair)

                    end do                                !node pairs
                    
               end do                           !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif 
            else 
              do ic = 1,nc

                diff_eff = diffcoff(diff_ic(ic),satav,porav,           &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av)
                tend(1) = disx_avg * vx2 + disy_avg * vy2              &
                        + disz_avg * vz2 + diff_eff
                
                tend(2) = disy_avg * vx2 + disx_avg * vy2              &
                        + disz_avg * vz2 + diff_eff
                
                tend(3) = disz_avg * vx2 + disz_avg * vy2              & 
                        + disx_avg * vz2 + diff_eff
#ifdef OPENMP
    !$omp critical
#endif 
                do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization


                      do ipair = 1, npair(idim)             !node pairs
  
                         iisav = iface(idim, ipair)

                         cinfrt_da_ic(iisav,ic) =                     &
                                      cinfrt_da_ic(iisav,ic)          &
                                       + tend(idim)                   &
                                       * aread(idim, ipair)

                         cinfrt_da_ic(isymm(iisav),ic) =              &
                                        cinfrt_da_ic(isymm(iisav),ic)    &
                                        + tend(idim)                  &
                                        * aread(idim, ipair)

                      end do                                !node pairs
                end do                             !loop over dimensions 
#ifdef OPENMP
    !$omp end critical
#endif 
             end do
               
               
               
           end if  
           
!cprovi-----------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------           
           
           else ! Harmonic porosity
           
           
!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
!c    changed Nov.09
              ndim = 0
              if (nvx .gt. 1) ndim = ndim + 1
              if (nvy .gt. 1) ndim = ndim + 1
              if (nvz .gt. 1) ndim = ndim + 1
!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

              diffav = r0
              disx_avg = r0
              disy_avg = r0
              disz_avg = r0

              do idim = 1, 3                      !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                    irk_ibk = mprop(ibk)
                    irk_id = mprop(id)

                    disx_avg = disx_avg       &
                             + disx(irk_ibk)  &
                             + disx(irk_id)

                    disy_avg = disy_avg       &
                             + disy(irk_ibk)  &
                             + disy(irk_id)

                    disz_avg = disz_avg       &
                             + disz(irk_ibk)  &
                             + disz(irk_id)

                  end do                          !node pairs
              end do                              !dimensions


              disx_avg = disx_avg / float(ndim) / r2**ndim
              disy_avg = disy_avg / float(ndim) / r2**ndim
              disz_avg = disz_avg / float(ndim) / r2**ndim

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element
!c    changed: Nov. 09
              vx2 = vel(1)**2
              vy2 = vel(2)**2
              vz2 = vel(3)**2
              vmag = dsqrt(vx2 + vy2 + vz2)
              vx2 = vx2 / (vmag + eps)
              vy2 = vy2 / (vmag + eps)
              vz2 = vz2 / (vmag + eps)

!c  calculate effective diffusion coefficient
!c    changed: Nov. 09
!c    changed: Nov. 09

             

              tend(1) = disx_avg * vx2    &
                      + disy_avg * vy2    &
                      + disz_avg * vz2


              tend(2) = disy_avg * vx2    &
                      + disx_avg * vy2    &
                      + disz_avg * vz2


              tend(3) = disz_avg * vx2    &
                      + disz_avg * vy2    &
                      + disx_avg * vz2


!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif 
              do idim = 1, 3                  !loop over dimensions

!c  adjust for 1d-, 2d, 3d - discretization


                    do ipair = 1, npair(idim)            !node pairs
 
                      iisav = iface(idim, ipair)

                      cinfrt_da(iisav) = cinfrt_da(iisav)     &
                                       + tend(idim)           &
                                       * aread(idim, ipair)

                      cinfrt_da(isymm(iisav)) =               &
                                      cinfrt_da(isymm(iisav)) &
                                      + tend(idim)            &
                                      * aread(idim, ipair)

                    end do                                !node pairs
              end do                          !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif 
!c    changed: Nov.09. add diffusion

!c  pointer to current control volume
#ifdef OPENMP
            ivol = ((ivz-1)*nvy + ivy-1) * nvx + ivx
#else
            ivol = ivol+1
#endif    
            jtemp = ia(ivol)

!c  assign conductivities for current control volume
!c    changed: Nov. 09, not used for the time being

           
            por_i = pornew(ivol) !assign porosity
            if (assigned_tau) then
             tau_i = tau(ivol)*tau_fac(ivol)    !
            end if 
            diffav=diffu
            satav=dmin1(r1, sanew(ivol))
            so_av=dmin1(r1, sonew(ivol))
            marchieav = marchies(ivol)

            diff_i = diffcoff(diffav,satav,por_i,tortuosity_corr, & 
                             assigned_tau,tau_i,type_tortuosity,  &
                             marchieav,so_av)           



            jtemp = jtemp+1          ! skip diagonal

!c  pointers to previous colums in x,y and z

            ivxp = ivx-1
            ivxn = ivx+1
            ivyp = ivy-1
            ivyn = ivy+1
            ivzp = ivz-1
            ivzn = ivz+1
            
            ivxpgbl = ivxgbl-1
            ivxngbl = ivxgbl+1
            ivypgbl = ivygbl-1
            ivyngbl = ivygbl+1
            ivzpgbl = ivzgbl-1
            ivzngbl = ivzgbl+1

!c  assign interfacial distances of current control volume

            if (half_cells) then            !half_cells on boundary

              if (nvx.gt.1) then                        !in x-direction
                if (ivxgbl.eq.1.or.ivxgbl.eq.nvxgbl) then        !boundary
                  delx_i = delx(ivxgbl)
                elseif (ivxgbl.gt.0.and.ivxgbl.lt.nvxgbl) then  !interior
                  delx_i = rhalf*delx(ivxgbl) 
                end if
              end if

              if (nvy.gt.1) then                        !in y-direction
                if (ivygbl.eq.1.or.ivygbl.eq.nvygbl) then        !boundary
                  dely_i = dely(ivygbl)
                elseif (ivygbl.gt.0.and.ivygbl.lt.nvygbl) then  !interior
                  dely_i = rhalf*dely(ivygbl) 
                end if
              end if

              if (nvz.gt.1) then                        !in z-direction
                if (ivzgbl.eq.1.or.ivzgbl.eq.nvzgbl) then        !boundary
                  delz_i = delz(ivzgbl)
                elseif (ivzgbl.gt.0.and.ivzgbl.lt.nvzgbl) then  !interior
                  delz_i = rhalf*delz(ivzgbl) 
                end if
              end if

            else                            !full cells on boundary

              if (nvx.gt.1) then                        !in x-direction
                delx_i = rhalf*delx(ivxgbl) 
              end if

              if (nvy.gt.1) then                        !in y-direction
                dely_i = rhalf*dely(ivygbl) 
              end if

              if (nvz.gt.1) then                        !in z-direction
                delz_i = rhalf*delz(ivzgbl) 
              end if

            end if                          !(half_cells)

!c  calculate influence coefficients in x-direction

            if (nvx.gt.1) then              !connections in x-direction

              if (ivxp.gt.0) then          !left connection  (2)
                areaf = dely(ivygbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivxpgbl.eq.1) then
                    delx_j = delx(ivxpgbl)
                  elseif (ivxpgbl.gt.1) then
                    delx_j = rhalf*delx(ivxpgbl)       
                  end if
                else                        !full cells on boundary
                  delx_j = rhalf*delx(ivxpgbl)       
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if 

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)
               
                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, &
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c  permeability update due to porosity changes

                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*delx_j+ diff_j*delx_i)
                endif

                jtemp = jtemp+1
              end if

              if (ivxn.le.nvx) then        !right connection  (3)
                areaf = dely(ivygbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivxngbl.eq.nvxgbl) then
                    delx_j = delx(ivxngbl)
                  elseif (ivxngbl.lt.nvxgbl) then
                    delx_j = rhalf*delx(ivxngbl)       
                  end if
                else                        !full cells on boundary
                  delx_j = rhalf*delx(ivxngbl)
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, &
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c  permeability update due to porosity changes


                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*delx_j+diff_j*delx_i)
                endif

                jtemp = jtemp+1
              end if

            end if                          !connections in x-direction

!c  calculate influence coefficients in y-direction

            if (nvy.gt.1) then              !connections in y-direction

              if (ivyp.gt.0) then          !front connection (4)
                areaf = delx(ivxgbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivypgbl.eq.1) then
                    dely_j = dely(ivypgbl)
                  elseif (ivypgbl.gt.1) then
                    dely_j = rhalf*dely(ivypgbl)       
                  end if
                else                        !full cells on boundary
                  dely_j = rhalf*dely(ivypgbl)       
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
               
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c  permeability update due to porosity changes

                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                endif
                jtemp = jtemp+1
              end if

              if (ivyn.le.nvy) then        !back connection (5)
                areaf = delx(ivxgbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivyngbl.eq.nvygbl) then
                    dely_j = dely(ivyngbl)
                  elseif (ivyngbl.lt.nvygbl) then
                    dely_j = rhalf*dely(ivyngbl)
                  end if
                else                        !full cells on boundary
                  dely_j = rhalf*dely(ivyngbl)
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c  permeability update due to porosity changes

 

                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                endif

                jtemp = jtemp+1
              end if

            endif                          !connections in y-direction

!c  calculate influence coefficients in z-direction

            if (nvz.gt.1) then              !connections in z-direction

              if (ivzp.gt.0) then          !bottom connection (6)
                areaf = delx(ivxgbl)*dely(ivygbl)
                if (half_cells) then        !half cells on boundary
                  if (ivzpgbl.eq.1) then
                    delz_j = delz(ivzpgbl)
                  elseif (ivzpgbl.gt.1) then
                    delz_j = rhalf*delz(ivzpgbl)       
                  end if
                else                        !full cells on boundary
                  delz_j = rhalf*delz(ivzpgbl)       
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)
                

!c  permeability update due to porosity changes

 
                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                endif

                jtemp = jtemp+1
              end if

              if (ivzn.le.nvz) then        !top connection (7)
                areaf = delx(ivxgbl)*dely(ivygbl)
                if (half_cells) then        !half cells on boundary
                  if (ivzngbl.eq.nvzgbl) then
                    delz_j = delz(ivzngbl)
                  elseif (ivzngbl.lt.nvzgbl) then
                    delz_j = rhalf*delz(ivzngbl)
                  end if
                else                        !full cells on boundary
                  delz_j = rhalf*delz(ivzngbl)
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))        !satav=dmin1(r1, sanew(ivol)), bug? DSU 2013-2-28
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c  permeability update due to porosity changes

 
                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                endif

                jtemp = jtemp+1
              end if

            end if                          !connections in z-direction
           
           end if 
                
          end do
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!cdbg
      if (time .gt.(tfinal-1.0d-10)) then
#ifdef DEBUG
        if (info_debug.gt.0) then
!c      do ibk = 1,nmax
!c        do ii = ia(ibk),ia(ibk+1)-1
!c          write(idbg,*) 'cinfrt_va(',ii,') = ',cinfrt_va(ii)
!c        end do
!c        end do
        write(idbg,*) time

        do ibk = 1,nmax
          do ii = ia(ibk),ia(ibk+1)-1
            write(idbg,'(a,i4,a,es20.10)') 'cinfrt_va(',ii,') = ',    &
                                      cinfrt_va(ii)
            write(idbg,'(a,i4,a,es20.10)') 'cinfrt_da(',ii,') = ',    &
                                      cinfrt_da(ii)
          end do
        end do
        end if
#endif
        if (info_debug.gt.1) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if  
!cdbg
      return
      end

