!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initopgs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initopgs
!c -------------------
!c
!c output control parameters  (global system)
!c
!c written by:      Uli Mayer - May 12, 96 
!c
!c last modified:   Uli Mayer - November 25, 96
!c                  Tom Henderson - March 11, 04
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           ------- 
!c           elevmax            = max. elevation in solution domain   + -
!c           gs_tout(ngs)       = specified output times for          * +
!c                                contour data
!c           smass(nmb)         = total mass of selected species in   * +
!c                                aqueous phase [moles]
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           tfinal             = final solution time                 + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           itmp               = unit number, temporary storage      + -
!c           ngb                = number of output locations for      * +
!c                                transient data
!c           ngb_step           = number of time steps between        * +
!c                                output of transient data
!c           ngb_vol(ngb)       = number of control volumes for       * +
!c                                output of transient data
!c           ngs                = number of output times for          * +
!c                                contour data
!c           nmb                = number of selected species          * +
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c
!c           logical:
!c           --------
!c           depth_output       = .true.  -> output in terms of       + -
!c                                           depth instead of
!c                                           elevation
!c           extended_output    = .true.  -> extended output of       * +
!c                                           contour data for
!c                                           reaction-transport
!c                                           simulation
!c                                .false. -> basic output of
!c                                           contour data for
!c                                           for reaction-transport
!c                                           simulation
!c           gb_output          = .true.  -> output of transient data * +
!c           gs_output          = .true.  -> output of contour data   * +
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           tec_header         = .true.  -> write header for tecplot * +
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c
!c           character:
!c           ----------
!c           namemb(nmb)        = names of selected species           * +
!c           section_header     = section header                      * +
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c
!c chem.f:   real*8:
!c           -------
!c           phimin_out(nm)     = cutoff mineral volume fractions     * +
!c                                for output
!c
!c           integer*4:
!c           ----------
!c           nc                 = number of components                + -
!c           nm                 = number of minerals                  + -
!c           nx                 = number of aqueous complexes         + -
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           namem(nm)          = mineral names                       + -
!c           namex(nx)          = names of aqueous complexes          + -
!c
!c local:    real*8:
!c           -------
!c           small              = small increment
!c           tiny               = tiny increment
!c           zout               = output for z-coordinate in terms
!c                                depth or elevation
!c
!c           integer*4:
!c           ----------
!c           nread              = pointer
!c           i                  = counter
!c           ic                 = counter (components)
!c           ierr               = 0 -> memory allocation successful
!c           igb                = counter (number of spatial
!c                                output locations)
!c           igs                = counter (number of output times 
!c                                for contour data)
!c           im                 = counter (minerals)
!c           istart             = pointer
!c           istop              = pointer
!c           imb                = counter (selected species)
!c           ix                 = counter (aqueous complexes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found              = .true.  -> exit search loop
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           findstrg  = find text string in file
!c           readbloc  = read section of input file and write to 
!c                       temporary file
!c           rsort     = sort real*8 array entries in increasing 
!c                       order
!c           zoutput   = assign depth coordinate in terms of depth
!c                       or elevation
!c ----------------------------------------------------------------------
 
      subroutine initopgs
 
      use parm
      use gen
      use chem
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: i, info_debug, l_string, ierr, im, istart, istop,     &
                 igb, igs, ivx, ivy, ivz, ivol, idum, itemp_vol,       &
                 imb, ic, icur, ix, i1, icount, ii, iiso, inic
      real*8 :: rmax_x, rmax_y, rmax_z, xcoord, ycoord, zcoord,        &
                dist_x, dist_y, dist_z, zout, zoutput
      
      real*8 :: isodeltat(10)

      external checkerr, findstrg, readbloc, rsort, zoutput

      logical found, found_section, found_subsection, use_coord
      character*72 subsection
      
      integer, parameter :: nread = 4
      real*8, parameter :: small = 1.0d-10,tiny = 1.0d-300,            &
                           r0=0.0d0, rhalf = 0.5d0, r1 = 1.0d0

      info_debug = 0
 
!c  read output control parameters and write to temporary file   
   
      section_header = 'output control'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for output control parameters 

      b_output_binary = .false.
      b_output_mpiio_single = .true.
      if (nprcs > 1) then
        b_output_multizone = .false.
      else
        b_output_multizone = .true.  
      end if
      
      depth_output = .false.
      gs_output = .true.
      extended_output = .true.
      use_coord = .false.
      ngs = 1
      allocate (gs_tout(ngs), stat = ierr)
      gs_tout=0.0d0
      call checkerr(ierr,'gs_tout',ilog)
      gs_tout(1) = tfinal/time_factor
      gb_output = .false.
      tec_header = .true.
      nmb = 0
      do im = 1,nm
        phimin_out(im) = tiny
      end do

!c  read output control parameters 

      if (found_section) then
          
        subsection = 'use binary format'  
        call findstrg(subsection,itmp,found_subsection)
#ifdef MPI
        if (found_subsection) then
          b_output_binary = .true.
          tec_header = .true.
        else
#endif
          if (found_subsection) then
            if (rank == 0) then
              write(ilog,*) 'Binary output is only available when built with MPI'
            end if
          end if
          b_output_binary = .false.
          b_output_mpiio_single = .false.
#ifdef MPI
        end if
#endif
        
        if (.not.varsat_flow .and. .not.reactive_transport) then
          return  
        end if
       
#ifdef MPI
        subsection = 'use separated file for spatial subdomain output' 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_output_mpiio_single = .false.
        end if
#else
        b_output_mpiio_single = .true.
#endif

#ifdef MPI
        subsection = 'use multizone data format for spatial output'  
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_output_multizone = .true.
        end if 
#else
        b_output_multizone = .true.
#endif

#ifdef WINDOWS
        !!!bug report, by DSU, 20160324: for the Windows version, binary output using  
        !!!MPI_TYPE_CREATE_SUBARRAY is not supported, in this case, use multizone format
        !!!to avoid using this function
        if (b_output_binary .and. .not.b_output_multizone) then
          b_output_multizone = .true.
          if (rank == 0 .and. b_enable_output) then
            write(*,'(a)') "Warning: MPI I/O output to single zone under Windows is not supported." 
            write(*,'(a)') "         Change the output to multiple zones" 
            write(ilog,'(a)') "Warning: MPI I/O output to single zone under Windows is not supported." 
            write(ilog,'(a)') "         Change the output to multiple zones" 
          end if
        end if
#endif

        subsection = 'output in terms of depth'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          depth_output = .true.
        end if

!c  optional use of coordinates for transient output of data

        subsection = 'coordinate output'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          use_coord = .true.
        end if

        subsection = 'define output locations as coordinates'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          use_coord = .true.
        end if

!c  spatial data
!c ---------------------------------------------------------------------- 

        if (reactive_transport.or.transient_flow) then

          subsection = 'output of spatial data'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

!c  number of output times

            read(itmp,*,err=999,end=999) ngs
            
            deallocate(gs_tout, stat = ierr)
            call checkerr(ierr,'gs_tout',ilog)
            allocate (gs_tout(ngs+1), stat = ierr)  !THH patch
            gs_tout=0.0d0 
            call checkerr(ierr,'gs_tout',ilog)

!c  output times

            do i = 1,ngs,nread

              istart = i
              istop = i+nread-1
              if (istop.gt.ngs) then
                istop = ngs
              end if
              read(itmp,*,err=999,end=999) (gs_tout(igs),     &
     &                                      igs=istart,istop)
            end do

!c  exit program, if specified output time > final solution time

            do igs = 1,ngs
              if (gs_tout(igs).gt.tfinal/time_factor+small) then
                if (rank == 0) then  
                  write(ilog,*) 'ABNORMAL EXIT from initopgs'
                  write(ilog,*) 'specified output time ',           &
     &                          'greater than final solution time' 
                  write(ilog,*) 'check section "output control" ',  &
     &                          'in input file'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end do

!c  sort output times in increasing order

            call rsort(gs_tout,ngs)

!c  add output time, if last output time < final solution time
!c  this block crashed August 20, 02

            if (gs_tout(ngs).lt.tfinal/time_factor-small) then
               ngs = ngs+1
               gs_tout(ngs) = tfinal/time_factor !THH - different from original
            end if

          end if              !(found_section)

        end if                !(reactive_transport.or.transient_flow)

!c  extended ouput for spatial data
!c ---------------------------------------------------------------------- 

        if (reactive_transport) then

          subsection = 'limited output of spatial data'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            extended_output = .false.
          end if

        end if

!c  cutoff for mineral volume fractions
!c ---------------------------------------------------------------------- 

        subsection = 'cutoff mineral volume fractions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

!c  read in user specified value

          do im = 1,nm
            read(itmp,*,err=999,end=999) phimin_out(im)
          end do

        end if

!c  transient data
!c ---------------------------------------------------------------------- 

        if (reactive_transport.or.transient_flow) then

          subsection = 'output of transient data'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            gb_output = .true.

            read(itmp,*,err=999,end=999) ngb    !number of control volumes

            allocate (ngb_vol(ngb), stat = ierr)
            ngb_vol=0 
            call checkerr(ierr,'ngb_vol',ilog)
            
!c  allocate file units for binary output using mpi
                
            !allocate binary output control parameters for breakthrough data
            allocate (igbp_mpi(ngb), stat = ierr)
            igbp_mpi = -1
            call checkerr(ierr,'igbp_mpi',ilog)

            allocate (offset_igbp(ngb), stat = ierr)
            offset_igbp = 0
            call checkerr(ierr,'offset_igbp',ilog)

            allocate (offset_igbp_ijk(ngb), stat = ierr)
            offset_igbp_ijk = 0
            call checkerr(ierr,'offset_igbp_ijk',ilog)
            
            allocate (igbt_mpi(ngb), stat = ierr)
            igbt_mpi = -1
            call checkerr(ierr,'igbt_mpi',ilog)     
            
            allocate (offset_igbt(ngb), stat = ierr)
            offset_igbt = 0
            call checkerr(ierr,'offset_igbt',ilog)              
            allocate (offset_igbt_ijk(ngb), stat = ierr)
            offset_igbt_ijk = 0
            call checkerr(ierr,'offset_igbt_ijk',ilog)
            
            allocate (igbc_mpi(ngb), stat = ierr)
            igbc_mpi = -1
            call checkerr(ierr,'igbc_mpi',ilog)              
            allocate (offset_igbc(ngb), stat = ierr)
            offset_igbc = 0
            call checkerr(ierr,'offset_igbc',ilog)              
            allocate (offset_igbc_ijk(ngb), stat = ierr)
            offset_igbc_ijk = 0
            call checkerr(ierr,'offset_igbc_ijk',ilog)
            
            allocate (igbm_mpi(ngb), stat = ierr)
            igbm_mpi = -1
            call checkerr(ierr,'igbm_mpi',ilog)              
            allocate (offset_igbm(ngb), stat = ierr)
            offset_igbm = 0
            call checkerr(ierr,'offset_igbm',ilog)              
            allocate (offset_igbm_ijk(ngb), stat = ierr)
            offset_igbm_ijk = 0
            call checkerr(ierr,'offset_igbm_ijk',ilog)
            
            allocate (igbg_mpi(ngb), stat = ierr)
            igbg_mpi = -1
            call checkerr(ierr,'igbg_mpi',ilog)              
            allocate (offset_igbg(ngb), stat = ierr)
            offset_igbg = 0
            call checkerr(ierr,'offset_igbg',ilog)              
            allocate (offset_igbg_ijk(ngb), stat = ierr)
            offset_igbg_ijk = 0
            call checkerr(ierr,'offset_igbg_ijk',ilog)
            
            allocate (igbgr_mpi(ngb), stat = ierr)
            igbgr_mpi = -1
            call checkerr(ierr,'igbgr_mpi',ilog)              
            allocate (offset_igbgr(ngb), stat = ierr)
            offset_igbgr = 0
            call checkerr(ierr,'offset_igbgr',ilog)              
            allocate (offset_igbgr_ijk(ngb), stat = ierr)
            offset_igbgr_ijk = 0
            call checkerr(ierr,'offset_igbgr_ijk',ilog)
            
            allocate (igbi_mpi(ngb), stat = ierr)
            igbi_mpi = -1
            call checkerr(ierr,'igbi_mpi',ilog)              
            allocate (offset_igbi(ngb), stat = ierr)
            offset_igbi = 0
            call checkerr(ierr,'offset_igbi',ilog)              
            allocate (offset_igbi_ijk(ngb), stat = ierr)
            offset_igbi_ijk = 0
            call checkerr(ierr,'offset_igbi_ijk',ilog)
            
            allocate (igbb_mpi(ngb), stat = ierr)
            igbb_mpi = -1
            call checkerr(ierr,'igbb_mpi',ilog)              
            allocate (offset_igbb(ngb), stat = ierr)
            offset_igbb = 0
            call checkerr(ierr,'offset_igbb',ilog)              
            allocate (offset_igbb_ijk(ngb), stat = ierr)
            offset_igbb_ijk = 0
            call checkerr(ierr,'offset_igbb_ijk',ilog)
            
            allocate (igbs_mpi(ngb), stat = ierr)
            igbs_mpi = -1
            call checkerr(ierr,'igbs_mpi',ilog)              
            allocate (offset_igbs(ngb), stat = ierr)
            offset_igbs = 0
            call checkerr(ierr,'offset_igbs',ilog)              
            allocate (offset_igbs_ijk(ngb), stat = ierr)
            offset_igbs_ijk = 0
            call checkerr(ierr,'offset_igbs_ijk',ilog)
            
            allocate (igbv_mpi(ngb), stat = ierr)
            igbv_mpi = -1
            call checkerr(ierr,'igbv_mpi',ilog)              
            allocate (offset_igbv(ngb), stat = ierr)
            offset_igbv = 0
            call checkerr(ierr,'offset_igbv',ilog)              
            allocate (offset_igbv_ijk(ngb), stat = ierr)
            offset_igbv_ijk = 0
            call checkerr(ierr,'offset_igbv_ijk',ilog)
            
            allocate (igbd_mpi(ngb), stat = ierr)
            igbd_mpi = -1
            call checkerr(ierr,'igbd_mpi',ilog)              
            allocate (offset_igbd(ngb), stat = ierr)
            offset_igbd = 0
            call checkerr(ierr,'offset_igbd',ilog)              
            allocate (offset_igbd_ijk(ngb), stat = ierr)
            offset_igbd_ijk = 0
            call checkerr(ierr,'offset_igbd_ijk',ilog)
            
            allocate (igbx_mpi(ngb), stat = ierr)
            igbx_mpi = -1
            call checkerr(ierr,'igbx_mpi',ilog)  
            
            allocate (igbis_mpi(ngb), stat = ierr)
            igbis_mpi = -1
            call checkerr(ierr,'igbis_mpi',ilog) 
            
            allocate (offset_igbx(ngb), stat = ierr)
            offset_igbx = 0
            call checkerr(ierr,'offset_igbx',ilog)   
            
            allocate (offset_igbx_ijk(ngb), stat = ierr)
            offset_igbx_ijk = 0
            call checkerr(ierr,'offset_igbx_ijk',ilog)
            
            allocate (offset_igbis(ngb), stat = ierr)
            offset_igbis = 0
            call checkerr(ierr,'offset_igbis',ilog)   
            
            allocate (offset_igbis_ijk(ngb), stat = ierr)
            offset_igbis_ijk = 0
            call checkerr(ierr,'offset_igbis_ijk',ilog)            


!c  number of time steps between output 

            read(itmp,*,err=999,end=999) ngb_step

!c  assign control volume using user specified xyz coordinates
!c  assumes level model domain

            if (use_coord) then

!c  extent of model domain

            rmax_x = xg(nngl)
            rmax_y = yg(nngl)
            rmax_z = zg(nngl)

            do igb = 1,ngb

              read(itmp,*,err=999,end=999) xcoord,ycoord,zcoord

              dist_x = xg(1)

!c full cells on domain boundaries

              if (.not.half_cells) then
                dist_x = dist_x - rhalf * delx(nvxls)
                rmax_x = rmax_x + rhalf * delx(nvxle)
              end if

#ifdef DEBUG
              if (info_debug > 0) then
                write(idbg,'(3(a,1x,e13.6,1x))') "dist_x",dist_x,      &
                      "rmax_x",rmax_x,"xcoord",xcoord
              end if
#endif
                            
!c check that xcoord falls within model domain
!c If domain-decomposition is used, it only falls
!c in one sub-domain.
              if ((xcoord.lt.dist_x).or.    &
     &              (xcoord.gt.rmax_x)) then
                  !goto 998
                  ivx = -1
              else
                do ivx = nvxls,nvxle
                  dist_x = dist_x + delx(ivx)
                
!c warn user that coordinate falls on control volume boundary

                  if (xcoord .eq. dist_x) then                    
                    write(*,'(//2a,i3,/2a//)') 'transient output ',    &
     &                     'location ',igb,'located on cell',            &
     &                     ' boundary in x-direction'
                      !pause
                    exit                  
                  end if
                                      
                  if (xcoord .lt. dist_x) then
                    exit
                  end if
                  
                  if (ivx == nvxle) then
                    exit
                  end if
                  
                end do
              end if
               
              dist_y = yg(1)

!c full cells on domain boundaries

              if (.not.half_cells) then
                dist_y = dist_y - rhalf * dely(nvyls)
                rmax_y = rmax_y + rhalf * dely(nvyle)
              end if
              
#ifdef DEBUG
              if (info_debug > 0) then
                write(idbg,'(3(a,1x,e13.6,1x))') "dist_y",dist_y,      &
                      "rmax_y",rmax_y,"ycoord",ycoord
              end if
#endif

!c check that ycoord falls within model domain

              if((ycoord.lt.dist_y).or.     &
     &              (ycoord.gt.rmax_y)) then
                  !goto 998
                  ivy = -1
              else    
                do ivy = nvyls,nvyle
                  dist_y = dist_y + dely(ivy)

!c warn user that coordinate falls on control volume boundary

                  if (ycoord .eq. dist_y) then
                    write(*,'(//2a,i3,/2a//)') 'transient output ',   &
     &                     'location ',igb,'located on cell',           &
     &                     ' boundary in y-direction'
                      !pause
                    exit                  
                  end if
                  
                  if (ycoord .lt. dist_y) then
                    exit
                  end if
                  
                  if (ivy == nvyle) then
                    exit
                  end if
                  
                end do
              end if

              dist_z = zg(1)

!c full cells on domain boundaries

              if (.not.half_cells) then
                dist_z = dist_z - rhalf * delz(nvzls)
                rmax_z = rmax_z + rhalf * delz(nvzle)
              end if
              
#ifdef DEBUG
              if (info_debug > 0) then
                write(idbg,'(3(a,1x,e13.6,1x))') "dist_z",dist_z,      &
                      "rmax_z",rmax_z,"zcoord",zcoord
              end if
#endif

!c check that zcoord falls within model domain

              if ((zcoord.lt.dist_z).or.                            &
     &              (zcoord.gt.rmax_z)) then
                  !goto 998
                  ivz = -1
              else    
                do ivz = nvzls,nvzle
                  dist_z = dist_z + delz(ivz)
                  
!c warn user that coordinate falls on control volume boundary

                  if (zcoord .eq. dist_z) then
                    write(*,'(//2a,i3,/2a//)') 'transient output ',    &
     &                     'location ',igb,'located on cell',          &
     &                     ' boundary in z-direction'
                      !pause
                    exit                  
                  end if
                  
                  if (zcoord .lt. dist_z) then
                    exit
                  end if
                  
                  if (ivz == nvzle) then
                    exit
                  end if
                  
                end do
              end if   
              

              if(ivx > 0 .and. ivy > 0 .and. ivz > 0) then
                !ngb_vol is converted to local node number
                !global node number can be obtained by node_idx_lg2g(ivol) 
                !ngb_vol does include the ghost nodes in this step, later,
                !the ghost nodes will be removed from ngb_vol list
                
                !3D domain
                if (nvxgbl > 1 .and. nvygbl > 1 .and. nvzgbl > 1) then 
                  ngb_vol(igb) = nvxgl*nvygl*(ivz-nvzgls) +            &     
                                 nvxgl*(ivy-nvygls) + ivx-nvxgls+1
                !2D xy domain                                                  
                else if (nvxgbl > 1 .and. nvygbl > 1) then
                  ngb_vol(igb) = nvxgl*(ivy-nvygls) + ivx-nvxgls+1
                !2D yz domain                                                  
                else if (nvygbl > 1 .and. nvzgbl > 1) then
                  ngb_vol(igb) = nvygl*(ivz-nvzgls) + ivy-nvygls+1
                !2D xz domain                                                  
                else if (nvzgbl > 1 .and. nvxgbl > 1) then
                  ngb_vol(igb) = nvxgl*(ivz-nvzgls) + ivx-nvxgls+1
                !1D x domain                                                   
                else if (nvxgbl > 1) then
                  ngb_vol(igb) = ivx-nvxgls+1
                !1D y domain                                                   
                else if (nvygbl > 1) then
                  ngb_vol(igb) = ivy-nvygls+1
                !1D z domain                                                   
                else if (nvzgbl > 1) then
                  ngb_vol(igb) = ivz-nvzgls+1
                end if
                
!cdbg
#ifdef DEBUG
                if (info_debug .gt. 0) then
                  idum = ngb_vol(igb)
#ifdef PETSC                  
                  write(idbg,'(a/,2(a,1x,i6,1x))')                     &  
                     "coordinate to control volume mapping",           &
                     "local volume number",ngb_vol(igb),               &
                     "global volume number", node_idx_lg2g(ngb_vol(igb))
#endif  
                  
                  write(idbg,'(4i6,6es15.7)') idum,ivx-nvxgls+1,       &
     &                                      ivy-nvygls+1,ivz-nvzgls+1, &
     &                                      xcoord,ycoord,zcoord,      &
     &                                      xg(idum),yg(idum),zg(idum)
                end if
#endif
                if ((info_debug .gt. 1).and.(igb .eq. ngb)) then
                 write(*,'(a/)') '*** user dbg stop from initopgs.f ***'
                 !pause
#ifdef PETSC
                 call petsc_mpi_finalize
#endif
                 stop
                end if
              else
                ngb_vol(igb) = -1
              end if
             
!cdbg
            end do !igb = 1,ngb

            else !read control volume numbers directly

              do i = 1,ngb,nread

                istart = i
                istop = i+nread-1
                if (istop.gt.ngb) then
                  istop = ngb
                end if
                read(itmp,*,err=999,end=999) (ngb_vol(igb),           &
     &                                      igb=istart,istop)

              end do
              
!c  convert global node number to local node number
#ifdef PETSC
              info_debug = 0
#ifdef DEBUG
              if(info_debug > 0) then
                  write(idbg,'(a)') "output of transient data mapping"
              end if
#endif
                  
              do igb = 1,ngb
                itemp_vol = ngb_vol(igb)
                ngb_vol(igb) = -1
                do ivol = 1, nngl
                    if(node_idx_lg2l(ivol) > 0 .and.                   &
                       node_idx_lg2g(ivol) == itemp_vol) then
                         ngb_vol(igb) = ivol
                         exit
                    end if
                end do                

#ifdef DEBUG
                if (info_debug > 0) then
                  if(ngb_vol(igb) > 0) then  
                    write(idbg,'(2(a,1x,i6,1x))')                      &  
                      "local volume number",ngb_vol(igb),              &
                      "global volume number", node_idx_lg2g(ngb_vol(igb))
                  end if
                end if
#endif
              end do
#endif     
            end if !(use_coord)
            
!c  check array dimensions

            do igb = 1,ngb
              if (ngb_vol(igb).gt.nngl) then
                if (rank == 0) then  
                  write(ilog,*) 'ABNORMAL EXIT from initopgs'
                  write(ilog,*) 'ngb_vol > nn'
                  write(ilog,*) 'check section "output control" ',     &
     &                          'in input file'
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end do

          end if              !(found_subsection)

        end if                !(reactive_transport or transient_flow)

!c  output for postprocessing with xmgr

        subsection = 'postprocessing with x/lmgr'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          tec_header = .false.
        end if
        
        if (b_output_binary) then
           tec_header = .true. 
        end if
        
!c_isotope
!c  read parameters for output of isotope data

        iso_output = .false.

        subsection = 'isotope output'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

!c_read number of isotope pairs
          iso_output = .true.

          !read number of isotopes component sets
          read(itmp,*,err=999,end=999) nip    

          allocate (isodelta(nip*10), stat = ierr)
          call checkerr(ierr,'isodelta',ilog)
          isodelta = r1

          allocate (iamdisoo(nip*10), stat = ierr)
          call checkerr(ierr,'iamdisoo',ilog)

          allocate (jamdisoo(nip*10), stat = ierr)
          call checkerr(ierr,'jamdisoo',ilog)

          iamdisoo(1) = 1

          do i=1,nip
            read(itmp,*,err=999,end=999) inic, (namet(ii),ii = 1,inic)
            read(itmp,*,err=999,end=999) (isodeltat(ii), ii=1,inic-1)    
            iamdisoo(i+1) = iamdisoo(i) + inic
            icount = 0
            do iiso = 1,inic
              ic = 0
              found = .false.
              do while ((ic.lt.nc).and.(.not.found))                    
                ic = ic+1
                if (namet(iiso).eq.namec(ic)) then
                  found = .true.
                  icount = icount+1
                  icur = iamdisoo(i)+iiso-1
                  jamdisoo(icur) = ic
                  if (iiso.gt.1) then
                    isodelta(icur) = isodeltat(iiso-1)
                  end if
                end if
              end do
            end do

            if (rank == 0 .and. b_enable_output) then
              if (icount.ne.(inic)) then
                write(ilog,'(72a)') ('-',i1=1,72)
                write(ilog,'(2a,a12,a)') 'c component ',               &
                      'listed for isotope output is missing'
                write(ilog,'(72a)') ('-',i1=1,72)
                stop
              end if
            end if
          end do
          
        end if          !(found_subsection)

!c  select species for mass balance output

        subsection = 'select species for mass balance output'

        call findstrg(subsection,itmp,found_subsection)

!c  this option is no longer used and has been passivated

        found_subsection = .false.

        if (found_subsection) then

          read(itmp,*,err=999,end=999) nmb

          allocate (namemb(nmb), stat = ierr)
          namemb=''
          call checkerr(ierr,'namemb',ilog)
          
          allocate (iamb(nmb), stat = ierr)
          iamb=0 
          call checkerr(ierr,'iamb',ilog)
          
          allocate (smass(nmb), stat = ierr)
          smass=0.0d0
          call checkerr(ierr,'smass',ilog)
          
          allocate (smass_gbl(nmb), stat = ierr)
          smass_gbl=0.0d0
          call checkerr(ierr,'smass_gbl',ilog)

          do imb = 1,nmb
            read(itmp,*,err=999,end=999) namemb(imb)
          end do

        end if           !(found_subsection)

      end if             !(found_section)
      
      if (.not.varsat_flow .and. .not.reactive_transport) then
        return  
      end if

!c  return to calling routine if appropriate

      if (.not.reactive_transport.and..not.transient_flow) then
        return
      end if

!c  write output control parameters to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  spatial data
!c ---------------------------------------------------------------------- 

      if (gs_output) then
        if (b_enable_output .and. b_enable_output_gen) then
          if (reactive_transport) then
            if (extended_output) then
              write(igen,'(a/)') 'extended output of spatial data'
            else
              write(igen,'(a/)') 'limited output of spatial data'
            end if
          end if
          write(igen,'(a,i10)')                                     &
     &    'number of output times for spatial data         = ',ngs
          write(igen,'(a/)')                                        &
     &    'specified output times for spatial data:          '
          do igs = 1,ngs
            write(igen,'(a,1pe10.3,1x,a)') 'T = ',gs_tout(igs),time_unit
          end do
          write(igen,*) 
        end if
!c  conversion of time units for computation in days

        do igs = 1,ngs
          gs_tout(igs) = time_factor*gs_tout(igs)
        end do

      end if                 !(gs_output)

!c  transient data
!c ---------------------------------------------------------------------- 

      if (gb_output .and. b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a/)') 'output of transient data:'
        write(igen,'(a,i10/a)')                                       &
     &  'number of time steps between output of          = ',ngb_step,&
     &  'transient data'
        write(igen,'(a,i10/a)')                                       &
     &  'number of spatial locations for output of       = ',ngb,     &
     &  'transient data'
        write(igen,'(a/)')                                            &
     &  'control volume numbers and spatial locations:'
        do igb = 1,ngb
          ivol = ngb_vol(igb)

!c  assign depth coordinate in terms of depth or elevation
          if(ivol > 0) then
            zout = zoutput(depth_output,zg(ivol),elevmax)
#ifdef PETSC
            write(igen,'(2(a,i10,1x),3(a,1pe10.3,a))')                &
     &                          'local ivol = ',ivol,                 &
     &                          'global ivol = ', node_idx_lg2g(ivol), &
     &                          ', x = ',xg(ivol),' m',               &
     &                          ', y = ',yg(ivol),' m',               &
     &                          ', z = ',zout,' m'
#else
          write(igen,'(a,i6,3(a,1pe10.3,a))') 'ivol = ',ivol,         &
     &                                        ', x = ',xg(ivol),' m', &
     &                                        ', y = ',yg(ivol),' m', &
     &                                        ', z = ',zout,' m'
#endif
          end if
        end do
      end if

!c  output in terms of depth or elevation

      if (nvzgl.gt.1 .and. b_enable_output .and.       &
          b_enable_output_gen) then
        if (depth_output) then
          write(igen,'(/a)') 'output in terms of depth'
        else
          write(igen,'(/a)') 'output in terms of elevation'
        end if
      end if
      
!c_isotope
!c  isotope data
!c ---------------------------------------------------------------------- 

      if (rank == 0 .and. b_enable_output .and. iso_output) then
        write(igen,'(a/)') 'output of isotope data:'
        write(igen,'(a,i10/a)')                                        &
        'number of isotope component sets = ', nip                      
                                                                        
        do i = 1, nip                                                   
            istart = iamdisoo(i)                                        
            istop = iamdisoo(i+1)-1                                     
              write(igen,'(a22,i2,a2)') 'isotope component set '       &
                       ,i, ': '                                         
              write(igen,'(a8)')                                       &
                         namec(jamdisoo(istart))                        
            do i1 = istart+1,istop                                      
                  write(igen,'(a8,f6.3)') namec(jamdisoo(i1)),         &
                         isodelta(i1)
              end do
        end do
      end if

!c  read number of selcted species for mass balance output
!c  and specify species

      if (mass_balance_rt.and.nmb.gt.0) then

!c  assign pointer array for selected species to free species
!c  and aqueous complex concentration arrays

        do imb = 1,nmb

          ic = 0
          ix = 0
          found = .false.

!c  free species

          do while (.not.found.and.ic.lt.nc-1)
            ic = ic+1
            if (namemb(imb).eq.namec(ic)) then
              found = .true.
              iamb(imb) = ic
            end if
          end do

!c  aqueous complexes 

          do while (.not.found.and.ix.lt.nx)
            ix = ix+1
            if (namemb(imb).eq.namex(ix)) then
              found = .true.
              iamb(imb) = ix+nc
            end if
          end do

!c  exit, if search was not successful

          if (.not.found) then
            if (rank == 0) then  
              write(ilog,'(72a)') ('-',i=1,72)
              write(ilog,'(a,a,a/a/a)')'species ',trim(namemb(imb)),      &
     &        ' was selected for mass balance output',                    &
     &        'this species is not part of the chemical system specified',&
     &        'stop in routine initopgs'
              write(ilog,'(72a)') ('-',i=1,72)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

        end do

      end if                  !(mass_balance_rt)
 
      goto 1000

!998   continue

      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'transient output coordinates    &                 
     &                 outside of model domain'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
