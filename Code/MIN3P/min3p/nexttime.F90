!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/nexttime.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine nexttime
!c -------------------
!c
!c prepare for next time step
!c
!c written by:      Uli Mayer - November 26, 96
!c
!c last modified:   Tom Henderson - February 9, 2004
!c                  - corrected update of porosity when using 
!c                    'combine mineralogical parameters' option
!c                  - added TDS update for density dependent flow
!c                  - drop NAPL phases from porosity update 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c
!c bbls.f:      logical
!c           --------
!c             gas_bubbles         =.true. -> gas phase saturation       + -
!c                                        is calculated
!c                                         below the water table
!c
!c gen.f:    real*8:
!c           -------
!c           uvsold(nn)         = solution vector (old time level)    * +
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            * +
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            * +
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            * +
!c                                - old time level
!c           c(nc,nn)           = concentrations of free species      * +
!c                                - old time level [moles/l water]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species [-]
!c           phi(nm,nn)         = mineral volume fractions            + -
!c           phiold(nm,nn)      = mineral volume fractions            + -
!c                                - old time level
!c           sionold(nn)        = ionic strength of solution          * +
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgold(nc,nn)      = total gaseous component            * +
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totgnew(nc,nn)      = total gaseous component            + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           cmold(nm,nn)       = mineral concentrations              * +
!c                                - old time level [moles/l bulk]]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           gold(ng,nn)        = gas concentrations                  * +
!c                                - old time level [moles / l air]    
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           perm_fac(nn)       = scaling factor for permeability     + +
!c                                as a function of porosity changes
!c           pornew(nn)         = porosity                            + +
!c           por_thresh_max     = maximum porosity threshold          * +
!c                                avoid division by 0 in 
!c                                Kozeny-Carman equation
!c           por_thresh_min     = minimum porosity threshold          * +
!c           permfac_thresh_max = maximum permeability factor threshold  * +
!c           permfac_thresh_min = minimum permeability factor threshold  * +
!c           tau_fac(nn)        = updated tortuosity as the function
!c                                of changed porosity
!c                                tau = tau_0 * por^alpha / por_0^alpha
!c                                tauupdate_fac = por^alpha / por_0^alpha
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number - debugging information + -
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c                                           simulation
!c
!c chem.f:   real*8:
!c           -------
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c
!c           integer*4:
!c           ----------
!c           iamp(nm+1)         = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jamp(nm)           = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           nc                 = number of components                + -
!c                                (including h2o)
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c
!c dens.f:   integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         * -
!c           inpl               = counter for napl components         * +
!c           nnpl               = total number of napl components     * -
!c
!c local:    real*8:
!c           -------
!c           por_diff           = porosity difference between time 
!c                                steps
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           im2                = counter (minerals)
!c           isb                = counter (sorbed species)
!c           ivol               = counter (control volumes)
!c
!c external: infcvs    = compute influence coefficients (variably
!c                       saturated flow)
!c           sorbspc   = compute concentrations of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totsorb   = compute total sorbed component 
!c                       concentrations [moles/l bulk]
!c ----------------------------------------------------------------------

      subroutine nexttime
 
      use parm
      use gen
      use chem
      use dens
      use phys
      use bbls
#ifdef OPENMP      
      use omp_lib
#endif

      implicit none
      
      integer :: tid
      
      real*8 :: pornew_old   !pornew before adjust
      real*8 :: actw, dummy1, dummy2, dummy3

      external infcvs, sorbspc, totconc, totconcg, totsorb

      real*8 :: r0, r1, dummy, por_diff, pormin, sum
      real*8 :: acoff
      integer :: i1, iaq, ic, im, im2, ivol, ix, izn, ig, isb
      parameter (r0 = 0.0d0, r1 = 1.0d0)      
      external :: acoff
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel  
        end subroutine tcorr
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      im = 0
      por_diff = 0.0d0
                    
!c  prepare for next time step

!c  variably saturated flow
!c  note: in parallel environment, section runs in arbitrary order. DSU
      if (varsat_flow.and.transient_flow) then
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          uvsold(1:nngl) = uvsnew(1:nngl)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          saold(1:nngl) = sanew(1:nngl) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          if (zero_storage) then
            sgnew(1:nngl)=r1-sanew(1:nngl)
            sgold(1:nngl) = sgnew(1:nngl)
          else
            sgold(1:nngl) = sgnew(1:nngl)
            sgnew(1:nngl)=r1-sanew(1:nngl)
          end if
          sa_min_old(1:nngl) = sa_min(1:nngl)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (density_dependence) then
            tds_old2(1:nngl) = tds_old(1:nngl)
          end if
!cprovi--------------------------------------------------------------
!cprovi If density is computer based on pitzer equations, then
!cprovi store the previous values
!cprovi--------------------------------------------------------------
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (heat_transport .and. ispitzerdens) then
            densold2(1:nngl) = densold_pitzer(1:nngl)
          else if (density_dependence) then              
            densold2(1:nngl) = densold(1:nngl)
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (density_dependence) then
            densold1(1:nngl) = density(1:nngl)     
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif    
          if (heat_transport) then
            tempold(1:nngl) = tempnew(1:nngl)
          end if  
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif             
          if (heat_transport .and. update_viscosity_temp) then  
            viscoold(1:nngl) = viscosity(1:nngl)
          end if      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif           
          if (heat_transport .and. variably_saturated.and.evaporation) then
            densvold(1:nngl) = densvnew(1:nngl)
          end if  
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif           
          if (heat_transport .and. variably_saturated.and.evaporation) then
             latvapold(1:nngl) = latvapnew(1:nngl)             
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 
          
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif          
          if (napl_permeability) then 
            sgnew(1:nngl) = r1-sanew(1:nngl)-snnew(1:nngl)
          else
            sgnew(1:nngl) = r1-sanew(1:nngl)
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          if (density_dependence) then
            saold2(1:nngl) = saold(1:nngl)
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          if (density_dependence) then      
            tds_old(1:nngl) = tds_new(1:nngl)
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          if (density_dependence) then
            densold(1:nngl) = density(1:nngl)
          end if
!cprovi--------------------------------------------------------------
!cprovi If density is computer based on pitzer equations, then
!cprovi store the previous values
!cprovi--------------------------------------------------------------
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
          if (heat_transport .and. ispitzerdens) then
            densold_pitzer(1:nngl) = density_pitzer(1:nngl)
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

      end if
      
!c_trap reset variables for bubble entrapment
      do ivol=1,nngl
        izn = mpropvs(ivol)
        if (uvsnew(ivol).lt.aentry(izn)) then
          unsaturated(ivol) = .true.
        else
          unsaturated(ivol) = .false.
        end if
        if (trap_bubbles) then
          sgt_old(ivol) = sgt(ivol)
          big_bub_old(ivol) = big_bubble(ivol)
          end if
      end do
 
!c  reactive transport 

      if (reactive_transport) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_nexttime_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, i1, iaq, ic, ig, im, im2, inpl, isb, ivol, ix, &
    !$omp napl_match)                                                 &
    !$omp firstprivate(por_diff, pornew_old, pormin,sum)
    !$omp do schedule(static)
#endif
        do ivol = 1,nngl
            
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

!c  recompute activity coefficients

          if (update_activity(tid).eq.'time_lagged') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

            if (temp_field.or.heat_transport) then
              call tcorr(tkel(ivol))
            end if
!cprovi----------------------------------------------      
            if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
              call pitzer (phase,gamma(1:nc,ivol),                    &
                           gamma(nc+1:nc+nx,ivol),                    &
                           cnew(1:nc,ivol),cx(1:nx,ivol),             &
                           nc,nx,ilog)                                
            else 
!c  --> for free species

              do ic=1,nc
                gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),       &
                                       sionnew(ivol),chargec(ic),     &
                                       dhac(ic),dhbc(ic),             &
                                       dhad(tid), dhbd(tid),          &
                                       adav,bdav,acth2omin,nc,        &
                                       nx,namec(ic),namec)
              end do

!c  --> for secondary aqueous species

              do ix=1,nx
                gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),    &
                                          sionnew(ivol),chargex(ix),  &
                                          dhax(ix),dhbx(ix),          &
                                          dhad(tid),dhbd(tid),        &     
                                          adav,bdav,acth2omin,nc,     &
                                          nx,namex(ix),namec)
              end do
            end if 
          end if
 
!c  aqueous phase
!c  -------------
!c  reassign ionic strengtih for next time level 

          sionold(ivol) = sionnew(ivol)

!c  reassign free species concentrations for next time level

          do ic = 1,n
            c(ic,ivol) = cnew(ic,ivol)
          end do
          
!c  reassign secondary species concentrations for next time level   !MX May2014
          if (hmulti_diff) then
                do ix = 1,nx
                  cxold(ix,ivol) = cx(ix,ivol)
                end do
          end if
          
!c  redox equilibrium reactions

          if ((redox_equil_rt.and.nr.gt.0) .or. gas_bubbles) then

!c  recompute total aqueous component concentrations

            call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol))

!c Calculate the secondary species concentrations cxold - old time level
            if (hmulti_diff) then
                izn = mpropvs(ivol)
                    
!c  compute total concentrations of aqueous primary and secondary
!c  species times the correction factors
                
                call totconcfac(cnew(1,ivol),cx(1,ivol),totcnewf(1,ivol),izn)
                call totconcfac(c(1,ivol),cxold(1,ivol),totcoldf(1,ivol),izn)
            
            end if

!c  recompute total sorbed component concentrations (non-competitive
!c  sorption)
            
            if (noncompetitive_sorption) then
              call totcona(totanew(1,ivol),totcnew(1,ivol),           &
                            distcoff_rt(1,ivol),sanew(ivol),pornew(ivol))
            end if
            
          end if
          
          if (redox_equil_rt.and.nr.gt.0) then

!c  compress total aqueous and sorbed (noncompetitive sorption)
!c  component concentration vector

            call comptotc(totcnew(1,ivol))
            if (noncompetitive_sorption) then
              call comptotc(totanew(1,ivol))
            end if

          end if

!c  reassign total aqueous and sorbed (non-competitive sorpton)
!c  component concentrations for next time level

          do ic = 1,n
            totcold(ic,ivol) = totcnew(ic,ivol)
            
            if (hmulti_diff) then
                totcoldf(ic,ivol) = totcnewf(ic,ivol)
            end if
            
            if (noncompetitive_sorption) then
              totaold(ic,ivol) = totanew(ic,ivol)
            end if
          end do

!c  gaseous phase
!c  -------------
!c  redox equilibrium reactions

          if (ng.gt.0) then

            if ((redox_equil_rt.and.nr.gt.0) .or. gas_bubbles) then

!c  recompute total gaseous component concentrations

              call totconcg(gnew(1,ivol),totgnew(1,ivol))
              
            end if
            
            if (redox_equil_rt.and.nr.gt.0) then

!c  compress total gaseous component concentrations

              call comptotc(totgnew(1,ivol))

            end if

!c  reassign total gaseous component concentrations for next time level

            do ic = 1,n
              totgold(ic,ivol) = totgnew(ic,ivol)
            end do

!c  reassign gas concentrations for next time level

            do ig = 1,ng
              gold(ig,ivol) = gnew(ig,ivol)
            end do

          end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
 
            if (redox_equil_rt.and.nr.gt.0) then

!c  recompute sorbed species concentrations

              do isb = 1,nsb_ion
                call sorbspc(csb_ion(isb,tid),dummy,cec_g(ivol),      &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,isb,0,                &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
              end do
              
              do isb = 1,nsb_surf
                call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),     &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,0,isb,                &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
              end do

!c  recompute total sorbed component concentrations

              call totsorb(csb_ion(:,tid),csb_surf(:,tid),            &
                   chargesb_ion,rhobulk_g(ivol),                      &
                   totsnew_ion(1,ivol),totsnew_surf(1,ivol),          &
                   xnusb_ion,xnusb_surf,                              &
                   iasb_ion,iasb_surf,jasb_ion,jasb_surf,nc,          &
                   nsb_ion,nsb_surf,namec)
                                                                      
!c  compress total sorbed component concentration vector
              if(nsb_ion.gt.0) then
                call comptotc(totsnew_ion(1,ivol))
              end if
              
              if(nsb_surf.gt.0) then
                call comptotc(totsnew_surf(1,ivol))
              end if

            end if

!c  reassign total sorbed component concentrations for next time level

            if(nsb_ion.gt.0) then
                do ic = 1,n
                  totsold_ion(ic,ivol) = totsnew_ion(ic,ivol)
                end do
            end if
            
            if(nsb_surf.gt.0) then
                do ic = 1,n
                  totsold_surf(ic,ivol) = totsnew_surf(ic,ivol)
                end do
            end if

          end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

          if (nm.gt.0) then

            if (update_porosity) then
              por_diff = r0
            end if

!c update mineral porosity, screening out the napl phases

            do im=1,nm
              cmold(im,ivol) = cmnew(im,ivol)
              napl_match = .false.
              if (update_porosity) then
                i1 = iamp(im)
!c sung-wook's (Dec. 17/2004)
                if (i1.lt.iamp(im+1)) then
                !if (i1.le.nm) then                
                  im2 = jamp(i1)
                  if (napl_permeability) then
                    do inpl = 1,nnpl
                      if (im .eq. ianpl(inpl)) then
                        napl_match = .true.
                        end if
                      end do
                  end if !napl_permeability
                  if (napl_match) then
                    por_diff = r0
                  else
                    por_diff = por_diff -     &
                              (phi(im2,ivol)-phiold(im2,ivol))
                  end if
                end if
              end if
              phiold(im,ivol) = phi(im,ivol)
            end do

            if (update_porosity) then 
              porold(ivol) = pornew(ivol)
              pornew(ivol) = pornew(ivol)+por_diff
              pormin=por_init(ivol)*facpormin              
              if (pornew(ivol)<pormin) then
                pornew(ivol) = pormin 
              elseif (pornew(ivol).gt.r1) then
                pornew(ivol) = r1-1.0d-20
              end if
              
              if (pornew(ivol) > por_thresh_max) then
                  pornew(ivol) = por_thresh_max
              else if (pornew(ivol) < por_thresh_min) then
                  pornew(ivol) = por_thresh_min
              end if
              
              por_diff = pornew(ivol) - porold(ivol)
              
              
            end if

!c  update permeability based on linear relationship, if required
!c  can include here more appropiate relationships when available

            if (update_permeability) then

!c  linear correction term

!cfff          perm_fac(ivol) = perm_fac(ivol)
!cfff &                       * pornew(ivol)/(pornew(ivol)-por_diff)

!c  correction after Kozeny-Carman (normalized to initial permeability
!c  multiplied over time steps)

                if (pornew(ivol) <= por_thresh_max .and. pornew(ivol) >= por_thresh_min) then
         
                perm_fac(ivol) = perm_fac(ivol)                       &
                             * pornew(ivol)**3.0d0                    &
                             / (r1-pornew(ivol))**2.0d0               &
                             * (r1-(pornew(ivol)-por_diff))**2.0d0    &
                             / (pornew(ivol)-por_diff)**3.0d0
                
                if (perm_fac(ivol) > permfac_thresh_max) then
                    perm_fac(ivol) = permfac_thresh_max
                else if (perm_fac(ivol) < permfac_thresh_min) then
                    perm_fac(ivol) = permfac_thresh_min
                end if                    
     
                end if

            end if
            
!c  tortuosity update factor: tau = tau_0 * por^alpha / pro_0^alpha
!c                            tau_fac = por^alpha / pro_0^alpha
!c  used in the benchmark decalcification-of-concrete
!c  DSU, 2013-2-25
            if (assigned_tau .and. update_tortuosity) then
                if (pornew(ivol) >= por_thresh_min) then
                    tau_fac(ivol) = (pornew(ivol)/(pornew(ivol)-por_diff))**marchies(ivol)
                end if                
            end if

          end if
          
!c Copy the new porosities in the old vector 
!c this is after update for dissolution/precipitation 
          if (update_porosity.or.update_porosity_flow) then
             porold(ivol) = pornew(ivol)
          end if 
          
          if (heat_transport.and.entalphy_change) then
              
              
              !sum=r0        
              !do ix=1,nx
              !  sum=sum+dhcx(ix)*cx(ix,ivol)
              !end do
            
              !entalchg(ivol)=sum
            
              sum=r0
              do iaq=1,naq
                sum=sum+dhaq(im)*rateaqtot(iaq)
              end do
              entalchg(ivol)=entalchg(ivol)+sum
              
              sum=r0
              do im=1,nm
                sum=sum+dhcm(im)*ratemdp(im,ivol)
              end do
              entalchg(ivol)=entalchg(ivol)+sum
              
           !   sum=r0           !   do isb=1,nsb
           !     sum=sum+dhsb(isb)*csb(isb)
           !   end do
           !   entalchg(ivol)=entalchg(ivol)+sum
              
              
              
          end if          

        end do           !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
         !This calling is used to generated the same result as sequential codes,
         !because tcorr is last updated by volume nn in sequential running. DSU
         !if (update_activity(tid).eq.'time_lagged') then
         !    if (temp_field.or.heat_transport) then
         !        call tcorr(tkel(nngl))
         !    end if
         !end if
#endif
        
      !cprovi------------------------------------------------------------
      !cprovi Compute the drhov/dT and drhov/dPl as a function of
      !cprovi state variables, for the next time
      !cprovi They are used for influence coefficients of vapor 
      !cprovi diffussion
      !cprovi Only if vapor density derivatives must be updated in 
      !cprovi each time increment
      !cprovi------------------------------------------------------------ 
      if (heat_transport.and.evaporation.and.update_ddensv) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_nexttime_2)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, actw, dummy1, dummy2, dummy3)                  
    !$omp do schedule(static)
#endif
       do ivol=1,nngl  
         if (reactive_transport) then
          actw=gamma(nc,ivol)
         else    
          actw=r1
         end if
         izn = mpropvs(ivol)
         call vapor_prop (dummy1,dummy2,ddensvdpa(ivol),            &
                          ddensvdt(ivol),dummy3,                    &
                          tempnew(ivol),aentry(izn),                &
                          uvsnew(ivol),actw,                        &
                          density(ivol),ivol)
         call surf_tens_prop (dummy1,dsurftensdt(ivol),             &
                                tempnew(ivol))  
    
       end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif        
    end if

!c  recalculate influence coefficients for variably-saturated flow,
!c  if permeability is updated
!c  Parallelized, OpenMP, DSU

        if (update_permeability.or.update_permeability_flow) then
          call infcvs
        end if

      end if             !reactive_transport

      return
      end
