!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/restart_r.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine restart_r
!c -------------------
!c
!c read in variable for restart option
!c
!c written by:      Rich Amos - November 27, 2005
!c
!c last modified:   Sergi Molins - Jan 30, 2007
!c                  bubbles are out
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c
!c
!c gen.f:    real*8:
!c           -------
!c           uvsold(nn)         = solution vector (old time level)    * +
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            * +
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            * +
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            * +
!c                                - old time level
!c           c(nc,nn)           = concentrations of free species      * +
!c                                - old time level [moles/l water]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species [-]
!c           phi(nm,nn)         = mineral volume fractions            + -
!c           phiold(nm,nn)      = mineral volume fractions            + -
!c                                - old time level
!c           sionold(nn)        = ionic strength of solution          * +
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgold(nc,nn)      = total gaseous component            * +
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totgnew(nc,nn)      = total gaseous component            + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           cmold(nm,nn)       = mineral concentrations              * +
!c                                - old time level [moles/l bulk]]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           gold(ng,nn)        = gas concentrations                  * +
!c                                - old time level [moles / l air]    
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           perm_fac(nn)       = scaling factor for permeability     + +
!c                                as a function of porosity changes
!c           pornew(nn)         = porosity                            + +
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number - debugging information + -
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c                                           simulation
!c
!c chem.f:   real*8:
!c           -------
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           csb_ion(nsb_ion,nthreads)
!c                              = concentrations of sorbed species    * *
!c                                - new time level (ion-exchange)
!c           csb_surf(nsb_surf,nthreads) 
!c                              = concentrations of sorbed species    * *
!c                                - new time level (surface-complex)
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c
!c           integer*4:
!c           ----------
!c           iamp(nm+1)         = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jamp(nm)           = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           nc                 = number of components                + -
!c                                (including h2o)
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c
!c local:    real*8:
!c           -------
!c           por_diff           = porosity difference between time 
!c                                steps
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           im2                = counter (minerals)
!c           isb                = counter (sorbed species)
!c           ivol               = counter (control volumes)
!c
!c external: infcvs    = compute influence coefficients (variably
!c                       saturated flow)
!c           sorbspc   = compute concentrations of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totsorb   = compute total sorbed component 
!c                       concentrations [moles/l bulk]
!c ----------------------------------------------------------------------

      subroutine restart_r
 
      use parm
      use gen
      use chem
      use phys
      use dens
      use bbls
      use file_unit, only : lun_get, lun_free
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only :  binary_file_open,               &
                                       restart_binary_read_header,     &
                                       binary_read_data,               &
                                       binary_file_close
      
      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif
      
      integer :: i, ic, ig, im, isb, ivol, ix, izn, bcvs_cnt,itsrc_idx
      
      real*8 :: rdummy, rtemp, strion, acoff, actw, time_temp, time_rs, &
                time_tsrc
      
      integer :: tid
      
      integer :: iskip, nskip, jvol, nprcs_temp
      
      real*8 dummy
      
      character*1024 :: str_file
      
      character*1024 :: strbuffer
      
      real*8, allocatable :: realbuffer_irsrt(:)

      integer :: nvars_irsrt
      
      logical :: bexist
#ifdef MPI
      integer(kind=MPI_OFFSET_KIND) :: offset_irsrt, offset_irsrt_temp

#else
      integer*8 :: offset_irsrt, offset_irsrt_temp

#endif

      external infcvs, sorbspc, totconc, totconcg, totsorb, restart_w

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, tiny_time = 1.0d-10,&
                           tiny_conc = 1.0d-20

      integer, parameter :: rfloatbit = 8
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
      
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel   
        end subroutine tcorr
      
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

!c  open restart file
      
      !irsrt=555
      
      if (b_binary_restart_read) then
        offset_irsrt = 0  
        if(b_distributed_restart_read) then
          str_file = 'restart'//trim(str_rank)//'.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
            
          irsrt = lun_get()
          call binary_file_open(Petsc_Comm_Self,irsrt,                 &
                      trim(str_file),.false.)          
          call restart_binary_read_header(Petsc_Comm_Self,irsrt,       &
                       offset_irsrt,.false.,time_rs,delt_rt,delt_vs,   &
                       time_bcvs,igstime,nprcs_temp)          
          if(nprcs_temp /= nprcs) then
              goto 996
          end if        
        else
            
          str_file = 'restart.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
            
          call binary_file_open(Petsc_Comm_World,irsrt,                &
                       'restart.dat',.true.)  
          call restart_binary_read_header(Petsc_Comm_World,irsrt,      &
                       offset_irsrt,.true.,time_rs,delt_rt,delt_vs,    &
                       time_bcvs,igstime,nprcs_temp) 
        end if
      else
         
        irsrt = lun_get()
        
        if(b_distributed_restart_read) then 
          str_file = 'restart'//trim(str_rank)//'.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
        
          open(irsrt,file='restart'//trim(str_rank)//'.dat',           &
              status='old',form='formatted',access='sequential',err=997)  
          read(irsrt,'(4e22.14,I5.2,I8)',ADVANCE='no',err=998,end=999) &
               time_rs,delt_rt,delt_vs,time_bcvs,igstime,nprcs_temp        
          if(nprcs_temp /= nprcs) then
              goto 996
          end if        
        else
          str_file = 'restart.dat'
          inquire(file = trim(str_file), exist = bexist)          
          if(.not. bexist) then
            if(rank == 0) then
              write(*,'(3(1x,a))') "Error: restart file",trim(str_file),"not found"  
            end if
            goto 997
          end if
            
          open(irsrt,file='restart.dat',status='old',                  &
               form='formatted',access='sequential',err=997) 
          read(irsrt,'(4e22.14,I5.2)',ADVANCE='no',err=998,end=999)    &
              time_rs,delt_rt,delt_vs,time_bcvs,igstime  
        end if
      end if
      
      
      if (.not.ignore_restart_time) then
        time_io = time_rs
      end if

      if(rank == 0 .and. b_enable_output) then      
        write(*,'(a,2x,e16.8,2x,a)')'restarting simulation at',      &
     &     time_io,time_unit
        write(ilog,'(a,1x,e16.8,1x,a)')'restarting simulation at'    &
     &    ,time_io,time_unit                                           
        write(*,'(4e10.3,1x,i3)')time_io,delt_rt,delt_vs,              &
     &                          time_bcvs,igstime
      end if
      
      
      !cdsu revert the restart time index, otherwise, some of the output will be
      !cdsu lost if the output time is changed or restart time is changed.
      if(gs_output) then
        if (ngs == 1) then
          igstime = 1
        else
          time_temp = time_io*time_factor
          do i = 1, ngs            
            if (time_temp <= gs_tout(i)) then 
              igstime = i
              exit
            end if  
          end do
        end if
      end if
    
!c  variably saturated flow

      if (b_binary_restart_read) then
        !calculate the number variables to write  
        nvars_irsrt = 0
        if (varsat_flow.and.transient_flow) then
          nvars_irsrt = nvars_irsrt + 3
        end if
        
        if (heat_transport) then
          nvars_irsrt = nvars_irsrt + 1
        end if
        
        if (density_dependence) then
          nvars_irsrt = nvars_irsrt + 2
        end if
        
        if (update_viscosity.or.update_viscosity_temp) then
          nvars_irsrt = nvars_irsrt + 1
        end if
        
        if (gas_bubbles .and. trap_bubbles) then
          nvars_irsrt = nvars_irsrt + 2  
        end if
        
        if (reactive_transport) then
          nvars_irsrt = nvars_irsrt + 2*n + 1
          if (noncompetitive_sorption) then
            nvars_irsrt = nvars_irsrt + n
          end if
          if (ng.gt.0) then
            nvars_irsrt = nvars_irsrt + n + ng
          end if
          if (nsb_ion.gt.0) then
            nvars_irsrt = nvars_irsrt + n
          end if
          if (nsb_surf.gt.0) then
            nvars_irsrt = nvars_irsrt + n
          end if
          if (nm>0.or.update_porosity_flow) then
            nvars_irsrt = nvars_irsrt + 2*nm + 2
          end if
        end if 
        
        allocate(realbuffer_irsrt(nvars_irsrt)) 
        realbuffer_irsrt = 0.0d0
        
      end if

      nskip = 0
      jvol = 0

      do ivol=1,nngl
        
#ifdef PETSC
      if(.not.(b_binary_restart_read .or.                             &
               b_distributed_restart_read)) then
        do iskip = 1, node_idx_lg2g(ivol) - nskip -1 
          jvol = jvol + 1  
          read(irsrt,'(/,1e22.14)',ADVANCE='no',end=999,err=998)      &
               rdummy
        end do
        nskip = node_idx_lg2g(ivol)
      end if
#endif
        
       
      if (.not. b_binary_restart_read) then
        read(irsrt,'(/,1e22.14)',err=998,end=999) dummy      
        backspace(irsrt)   
      end if
      
      
      if (b_binary_restart_read) then
        if (b_distributed_restart_read) then
          offset_irsrt_temp = offset_irsrt +                           &
                              (ivol-1)*nvars_irsrt*rfloatbit  
        else
          offset_irsrt_temp = offset_irsrt + (node_idx_lg2g(ivol)-1)*  &
                                              nvars_irsrt*rfloatbit 
        end if
      end if
      
      if (varsat_flow.and.transient_flow) then                       
        if(b_binary_restart_read) then
          call binary_read_data(irsrt,3,realbuffer_irsrt(1:3),         &
                      offset_irsrt_temp,.not.b_distributed_restart_read)
          offset_irsrt_temp = offset_irsrt_temp + 3*rfloatbit
          uvsold(ivol) = realbuffer_irsrt(1)
          saold(ivol) = realbuffer_irsrt(2)
          sgold(ivol) = realbuffer_irsrt(3)
        else
          read(irsrt,'(3e22.14)',ADVANCE='no',err=998,end=999)         &
               uvsold(ivol),saold(ivol),sgold(ivol)
        end if                                                               
      end if                                                         
                                                                       
      if (heat_transport) then
        if(b_binary_restart_read) then
          call binary_read_data(irsrt,1,realbuffer_irsrt(1:1),         &
                      offset_irsrt_temp,.not.b_distributed_restart_read)
          offset_irsrt_temp = offset_irsrt_temp + rfloatbit
          tempold(ivol) = realbuffer_irsrt(1)
        else
          read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)         &
               tempold(ivol)
        end if
      end if   
!cprovi------------------------------------------------------------
!cprovi If driven-density dependence is solved 
!cprovi------------------------------------------------------------          
      if (density_dependence) then 
        if(b_binary_restart_read) then
          call binary_read_data(irsrt,2,realbuffer_irsrt(1:2),         &
                      offset_irsrt_temp,.not.b_distributed_restart_read)
          offset_irsrt_temp = offset_irsrt_temp + 2*rfloatbit
          densold(ivol) = realbuffer_irsrt(1)
          tds_old(ivol) = realbuffer_irsrt(2)
        else
          read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)         &
               densold(ivol),tds_old(ivol)
        end if
      end if
!cprovi------------------------------------------------------------
!cprovi If viscosity is updated 
!cprovi------------------------------------------------------------
      if (update_viscosity.or.update_viscosity_temp) then
        if(b_binary_restart_read) then
          call binary_read_data(irsrt,1,realbuffer_irsrt(1:1),         &
                      offset_irsrt_temp,.not.b_distributed_restart_read)
          offset_irsrt_temp = offset_irsrt_temp + rfloatbit
          viscosity(ivol) = realbuffer_irsrt(1)
        else
          read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)         &
               viscosity(ivol)
        end if
      end if 
      
!cprovi------------------------------------------------------------
!cprovi If gas bubbles and trap bubbles
!cprovi------------------------------------------------------------ 
      if (gas_bubbles .and. trap_bubbles) then
          
        if(b_binary_restart_read) then
          call binary_read_data(irsrt,2,realbuffer_irsrt(1:2),         &
                      offset_irsrt_temp,.not.b_distributed_restart_read)
          offset_irsrt_temp = offset_irsrt_temp + 2*rfloatbit          
          sgt_old(ivol) = realbuffer_irsrt(1)
          if (realbuffer_irsrt(2) > 0) then
            big_bub_old(ivol) = .true.
          else 
            big_bub_old(ivol) = .false.  
          end if
        else
          read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)         &
               sgt_old(ivol),rtemp
          
          if(rtemp > 0) then
            big_bub_old(ivol) = .true.
          else
            big_bub_old(ivol) = .false.  
          end if
        end if
        
      end if
      
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------    
!c  reactive transport 

      if (reactive_transport) then

!c  aqueous phase
!c  -------------
        if(b_binary_restart_read) then
          call binary_read_data(irsrt,2*n+1,realbuffer_irsrt(1:2*n+1), &
                      offset_irsrt_temp,.not.b_distributed_restart_read)
          offset_irsrt_temp = offset_irsrt_temp + (2*n+1)*rfloatbit
          sionold(ivol) = realbuffer_irsrt(1)
          do ic = 1,n
            c(ic,ivol) = realbuffer_irsrt(2*ic)
            totcold(ic,ivol) = realbuffer_irsrt(2*ic+1)
          end do
        else    
!c  reassign ionic strengtih for next time level        
          read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)         &
              sionold(ivol)

!c  reassign free species concentrations for next time level
          do ic = 1,n
          read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)         &
               c(ic,ivol),totcold(ic,ivol)
          end do
        end if
         
!c  reassign total aqueous and sorbed (non-competitive sorpton)
!c  component concentrations for next time level
         
        if (noncompetitive_sorption) then
          if(b_binary_restart_read) then
            call binary_read_data(irsrt,n,realbuffer_irsrt(1:n),       &
                        offset_irsrt_temp,.not.b_distributed_restart_read)
            offset_irsrt_temp = offset_irsrt_temp + n*rfloatbit
            do ic = 1,n
              totaold(ic,ivol) = realbuffer_irsrt(ic)
            end do 
          else
            do ic = 1,n
              read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)     &
                 totaold(ic,ivol)
            end do
          end if
        end if
        
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!c  gaseous phase
!c  -------------
!c  redox equilibrium reactions

          if (ng.gt.0) then

!c  reassign total gaseous component concentrations for next time level
            if(b_binary_restart_read) then
              call binary_read_data(irsrt,n,realbuffer_irsrt(1:n),     &
                          offset_irsrt_temp,.not.b_distributed_restart_read)
              offset_irsrt_temp = offset_irsrt_temp + n*rfloatbit
              do ic = 1,n
                totgold(ic,ivol) = realbuffer_irsrt(ic)
              end do 
            else
              do ic = 1,n
              read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)     &
                   totgold(ic,ivol)
              end do
            end if

!c  reassign gas concentrations for next time level
            if(b_binary_restart_read) then
              call binary_read_data(irsrt,ng,realbuffer_irsrt(1:ng),   &
                          offset_irsrt_temp,.not.b_distributed_restart_read)
              offset_irsrt_temp = offset_irsrt_temp + ng*rfloatbit
              do ig = 1,ng
                gold(ig,ivol) = realbuffer_irsrt(ig)
              end do 
            else
              do ig = 1,ng
              read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)     &
                   gold(ig,ivol)
              end do
            end if

          end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
            if(nsb_ion.gt.0) then
              if(b_binary_restart_read) then
                call binary_read_data(irsrt,n,realbuffer_irsrt(1:n),   &
                           offset_irsrt_temp,.not.b_distributed_restart_read)
                offset_irsrt_temp = offset_irsrt_temp + n*rfloatbit
                do ic = 1,n
                  totsold_ion(ic,ivol) = realbuffer_irsrt(ic)
                end do
              else    
                do ic = 1,n
                   read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999)&
                        totsold_ion(ic,ivol)
                end do
              end if
            end if
            
            if(nsb_surf.gt.0) then 
              if(b_binary_restart_read) then
                call binary_read_data(irsrt,n,realbuffer_irsrt(1:n),   &
                           offset_irsrt_temp,.not.b_distributed_restart_read)
                offset_irsrt_temp = offset_irsrt_temp + n*rfloatbit
                do ic = 1,n
                  totsold_surf(ic,ivol) = realbuffer_irsrt(ic)
                end do
              else    
                do ic = 1,n
                  read(irsrt,'(1e22.14)',ADVANCE='no',err=998,end=999) &
                       totsold_surf(ic,ivol)
                end do
              end if
            end if

!c  reassign total sorbed component concentrations for next time level

          end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

          if (nm>0.or.update_porosity_flow) then
            if(b_binary_restart_read) then
              call binary_read_data(irsrt,2*nm+2,                      &
                          realbuffer_irsrt(1:2*nm+2),offset_irsrt_temp,&
                          .not.b_distributed_restart_read)
              offset_irsrt_temp = offset_irsrt_temp + 2*(nm+2)*rfloatbit
              do im=1,nm
                cmold(im,ivol) = realbuffer_irsrt(2*im-1)
                phiold(im,ivol) = realbuffer_irsrt(2*im)  
              end do
              porold(ivol) = realbuffer_irsrt(2*nm+1)  
              perm_fac(ivol) = realbuffer_irsrt(2*nm+2)  
            else    
              do im=1,nm
                read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)   &
                     cmold(im,ivol),phiold(im,ivol)
              end do
              read(irsrt,'(2e22.14)',ADVANCE='no',err=998,end=999)     &
                   porold(ivol),perm_fac(ivol)
            end if
            pornew(ivol) = porold(ivol)
          end if      

        end if             !reactive_transport

    end do          !loop over control volumes
      
    if (b_binary_restart_read) then
      deallocate(realbuffer_irsrt)  
    end if

    if(b_binary_restart_read) then
      call binary_file_close(irsrt,.not.b_distributed_restart_read) 
      if(b_distributed_restart_read) then
        call lun_free(irsrt)
      end if
    else
      close(irsrt)
      call lun_free(irsrt)
    end if 

    !cdsu Check mineral concentration, update the minimum mineral 
    !cdsu concentration to the checked value if that value is very
    !cdsu close to the minimum mineral concentration as this may be
    !cdsu caused by decimal error 
    do im = 1, nm
      do ivol = 1, nngl
        if (dabs(cmold(im,ivol)-cmcmin(im,tid)) <= tiny_conc) then
          cmold(im,ivol) = cmcmin(im,tid)
        end if
      end do
    end do
    
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_restart_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol, izn, ix)                                 &
    !$omp firstprivate(dummy, strion)                  
    !$omp do schedule(static)
#endif
    do ivol=1,nngl
        
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif 
                                           
      izn = mpropvs(ivol)
      if (varsat_flow.and.transient_flow) then                        
          uvsnew(ivol) = uvsold(ivol)                                  
          sanew(ivol) = saold(ivol)
          sgnew(ivol)=r1-sanew(ivol)                                                                       
      end if                                                         
                                                                       
      if (heat_transport) then                                       
          tempnew(ivol)=tempold(ivol)
      end if   

      if (heat_transport .and. ispitzerdens) then
        densold_pitzer(ivol) = densold(ivol)
      end if
!cprovi------------------------------------------------------------
!cprovi If driven-density dependence is solved 
!cprovi------------------------------------------------------------          
      if (density_dependence) then
             tds_old2(ivol) = tds_old(ivol)
             tds_new(ivol) = tds_old(ivol)  
             density(ivol) = densold(ivol) 
             densold1(ivol) = densold(ivol) 
             densold2(ivol) = densold(ivol)
       end if
!cprovi------------------------------------------------------------
!cprovi If viscosity is updated 
!cprovi------------------------------------------------------------ 
      if (update_viscosity_temp) then
         viscoold(ivol) = viscosity(ivol) 
      end if
      
!cprovi------------------------------------------------------------
!cprovi If gas bubbles and trap bubbles
!cprovi------------------------------------------------------------ 
      if (gas_bubbles .and. trap_bubbles) then
	    sgt(ivol) = sgt_old(ivol)
	    big_bubble(ivol) = big_bub_old(ivol)
      end if
      
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------    
!c  reactive transport 

      if (reactive_transport) then

          if (temp_field.or.heat_transport) then
           call tcorr(tkel(ivol))
          end if

!c  aqueous phase
!c  -------------
!c  reassign ionic strengtih for next time level 

          sionnew(ivol) = sionold(ivol)

!c  reassign free species concentrations for next time level

          do ic = 1,n
            cnew(ic,ivol) = c(ic,ivol)
            totcnew(ic,ivol) = totcold(ic,ivol)
          end do

!c Calculate the secondary species concentrations totcnewf and totcoldf
        if (hmulti_diff) then
            izn = mpropvs(ivol)
                
!c  compute total concentrations of aqueous primary and secondary
!c  species times the correction factors

            call updtsvap(c(1,ivol),cxold(1,ivol),gammaold(1,ivol),   &
     &                    gammaold(nc+1,ivol),sionold(ivol)) 
            call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),        &
     &                  gamma(nc+1,ivol),sionnew(ivol))
                
            call totconcfac(cnew(1,ivol),cx(1,ivol),totcnewf(1,ivol),izn)
            call totconcfac(c(1,ivol),cxold(1,ivol),totcoldf(1,ivol),izn)

        end if
         
!c  reassign total aqueous and sorbed (non-competitive sorpton)
!c  component concentrations for next time level
         
        if (noncompetitive_sorption) then
          do ic = 1,n
             totanew(ic,ivol) = totaold(ic,ivol)
          end do
        end if
                  
        if (redox_equil_rt.and.nr.gt.0) then

!c  compress total aqueous and sorbed (noncompetitive sorption)
!c  component concentration vector

            call comptotc(totcnew(1,ivol))
          if (noncompetitive_sorption) then
            call comptotc(totanew(1,ivol))
          end if

        end if

!c  recompute activity coefficients

!c  compute concentrations of aqueous complexes
 
        do ix = 1,nx
          call secspec(c(1,ivol),cx(ix,ivol),eqx(ix,tid),gamma(1,ivol),&
     &              gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)

        end do
 
!c  update ionic strength
 
        call ionstr(c,cx,strion,chargec,chargex,nc-1,nx,namec)
 
!c  make sure new ionic strength is not larger than maximum
!c  allowed ionic strength to avoid convergence problems
 
        strion = dmin1(strion,sionmax)

        if (update_activity(tid).eq.'time_lagged') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

            if (temp_field.or.heat_transport) then    
              call tcorr(tkel(ivol))
            end if

!cprovi----------------------------------------------      
!cprovi It was added by Sergio Andres Bea Jofre 
!cprovi----------------------------------------------      
           if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andrï¿½s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi---------------------------------------------- 
              call pitzer (phase,gamma(1:nc,ivol),                    &
     &                     gamma(nc+1:nc+nx,ivol),                    &
     &                     cnew(1:nc,ivol),cx(1:nx,ivol),             &
     &                     nc,nx,ilog)
         else
!cprovi----------------------------------------------    
!cprovi for free species
!cprovi----------------------------------------------

               do ic=1,nc
                   gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),    &
     &                              sionnew(ivol),chargec(ic),        &
     &                              dhac(ic),dhbc(ic),                &
     &                              dhad(tid),dhbd(tid),              &
     &                              adav,bdav,acth2omin,nc,           &
     &                              nx,namec(ic),namec)
               end do

!c  --> for secondary aqueous species

               do ix=1,nx
                   gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol), &
     &                                 sionnew(ivol),chargex(ix),     &
     &                                 dhax(ix),dhbx(ix),             &
     &                                 dhad(tid),dhbd(tid),           &
     &                                 adav,bdav,acth2omin,nc,        &
     &                                 nx,namex(ix),namec)
               end do
               
           end if 
       end if
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!cprovi----------------------------------------------      
!c  gaseous phase
!c  -------------
!c  redox equilibrium reactions

          if (ng.gt.0) then

!c  reassign total gaseous component concentrations for next time level

            do ic = 1,n
               totgnew(ic,ivol) = totgold(ic,ivol)
            end do

!c  reassign gas concentrations for next time level

            do ig = 1,ng
               gnew(ig,ivol) = gold(ig,ivol)
            end do
          
            if (redox_equil_rt.and.nr.gt.0) then

!c  recompute total gaseous component concentrations

              call totconcg(gnew(1,ivol),totgnew(1,ivol))

            end if

!c  compress total gaseous component concentrations

            if (redox_equil_rt.and.nr.gt.0) then

              call comptotc(totgnew(1,ivol))

            end if

          end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
            if(nsb_ion.gt.0) then  
                do ic = 1,n
                   totsnew_ion(ic,ivol) = totsold_ion(ic,ivol)
                end do
            end if
            
            if(nsb_surf.gt.0) then  
                do ic = 1,n
                   totsnew_surf(ic,ivol) = totsold_surf(ic,ivol)
                end do
            end if
 
            if (redox_equil_rt.and.nr.gt.0) then

!c  recompute sorbed species concentrations

              do isb = 1,nsb_ion
                call sorbspc(csb_ion(isb,tid),dummy,cec_g(ivol),      &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,isb,0,                &
                     sorption_type_ion,                               &
                     sorption_type_surf,sorption_group,isactcexch)
              end do
              
              do isb = 1,nsb_surf
                call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),     &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,0,isb,                &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
              end do

!c  recompute total sorbed component concentrations

              call totsorb(csb_ion(:,tid),csb_surf(:,tid),            &
                   chargesb_ion,rhobulk_g(ivol),                      &
                   totsnew_ion(1,ivol),totsnew_surf(1,ivol),          &
                   xnusb_ion,xnusb_surf,                              &
                   iasb_ion,iasb_surf,jasb_ion,jasb_surf,nc,          &
                   nsb_ion,nsb_surf,namec)

!c  compress total sorbed component concentration vector
              if(nsb_ion.gt.0) then
                call comptotc(totsnew_ion(1,ivol))
              end if
              
              if(nsb_surf.gt.0) then
                call comptotc(totsnew_surf(1,ivol))
              end if
              
            end if

!c  reassign total sorbed component concentrations for next time level

          end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

          if (nm>0.or.update_porosity_flow) then

            do im=1,nm                   
              cmnew(im,ivol) = cmold(im,ivol)                          
              phi(im,ivol) = phiold(im,ivol)                           
            end do
            
            porold(ivol)=pornew(ivol)
            
          end if      
        


!!c  recalculate influence coefficients for variably-saturated flow,
!!c  if permeability is updated
!!c  Bug fixed, call infcvs one time, DSU
!
!         if (update_permeability) then
!            call infcvs
!          end if

        end if             !reactive_transport
        
        
        if (heat_transport.and.evaporation) then
           if (reactive_transport) then
             actw=gamma(nc,ivol)
           else
             actw=r1
           end if
           izn = mpropvs(ivol)     
           call vapor_prop (densvnew(ivol),dummy,ddensvdpa(ivol),     &
     &                      ddensvdt(ivol),latvapnew(ivol),           &
     &                      tempnew(ivol),aentry(izn),                &
     &                      uvsnew(ivol),actw,                        &
     &                      density(ivol),ivol)                        
           densvold(ivol)=densvnew(ivol)                               
           latvapold(ivol)=latvapnew(ivol)                             
           call surf_tens_prop (dummy,dsurftensdt(ivol),              &
     &                          tempnew(ivol))
        end if

    end do          !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c  recalculate influence coefficients for variably-saturated flow,
!c  if permeability is updated
!c  Bug fixed, call infcvs one time, DSU
      if (reactive_transport .and. update_permeability) then
         call infcvs
      end if
    
    !cprovi-----------------------------------------------
      !cprovi Compute new densities and other parameters
      !cprovi related with 
      !cprovi-----------------------------------------------
      if (density_dependence) then  
        if (heat_transport) then
          call ddtds_energybal(.false.)
          if (ispitzerdens) then
            densold_pitzer=density_pitzer
            densold2=densold_pitzer
          end if
        else
          call ddtds
        end if 
      end if
      

    if (update_bcvs) then
      bcvs_cnt=0
      time_temp=1.0d-10

      if (rank == 0 .and. b_enable_output) then
        write(*,*) "restart - update boundary condition"
        write(ilog,*) "restart - update boundary condition"
      end if

      rewind(ibcvs)
      do while (time_io.gt.time_temp-1.0d-10)
!c  assign new boundary conditions for variably-saturated flow
        read(ibcvs,*,err=998,end=990) time_temp
        bcvs_cnt=bcvs_cnt+1
      end do

990   continue

      if (time_io.gt.time_temp - 1.0d-10) then
        !cdsu set the time to the final time later
        time_bcvs = 1.1d0*tfinal/time_factor
        !cdsu backspace of this file, need for updtbcvs and updtbcdd
        backspace(ibcvs)
      else
        time_bcvs = time_temp
      end if
        
      if (density_dependence) then
        call updtbcdd
      else 
        call updtbcvs
      end if

      b_restart_update_bcvs = .false.
      
    end if
      

      if (transient_source) then

        time_tsrc = time_io*time_factor

        do itsrc_idx = 1, ntsrc
          if (time_tsrc > tsrc(itsrc_idx) .and. time_tsrc <= tsrc(itsrc_idx+1)) then
            itsrc = itsrc_idx + 1
            exit
          end if
        end do
      end if

      return
      
996   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'number of restart file does not match'
        write(*,*) 'SIMULATION TERMINATED'
        write(*,*) 'number of restart file does not match'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop     

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error when opening restart file'
        write(*,*) 'SIMULATION TERMINATED'
        write(*,*) 'error when opening restart file'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop      

998   continue     
      backspace(irsrt)
      read(irsrt,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in restart file: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in restart file: ',trim(strbuffer)
        close(ilog)
      end if
      
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'end in reading restart file'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

      end
