!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 493 $
!> $Author: fgerard $
!> $Date: 2017-07-18 20:29:24 +0200 (mar., 18 juil. 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/mbaldd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine mbaldd
!c -----------------
!c
!c mass balance (variably saturated flow)
!c sign convention: inflow  -> positive
!c                  outflow -> negative
!c
!c modified from Uli Mayer template
!c includes point source in calculations
!c
!c written by:      Tom Henderson - August 23, 2002
!c
!c last modified:   Sergio Andres Bea Jofre - November 2009
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           relperm(nn)        = relative permeability               + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           time_io            = current solution time (I/O units)   + -
!c           totvsmass          = total system mass                   + +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c
!c           integer*4:
!c           ----------
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           imvs               = unit number, mass balance -         + *
!c                                             variably saturated
!c                                             flow
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           mtime              = current time step                   + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> calculate root water     + -
!c                                           uptake
!c           steady_flow        = .true.  -> steady state flow        + -
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + - 
!c           dcoef(ncon-1)      = coefficient including density,      + -
!c                                viscosity, and relative 
!c                                permeability
!c           psi_i              = total pressure potential in control + -
!c                                volume i currently considered
!c           psi_j              = total pressure potential in control + -
!c                                volume j currently considered
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c local:    real*8:
!c           -------
!c           qroot              = root water uptake for current 
!c                                control volume
!c           qroot_tot_act      = total actual root water uptake
!c           r0                 = constant
!c           r100               = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c           totinflux          = total flux into domain
!c           totoutflux         = total flux out of domain
!c           totvsflux          = total flux into control volume
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control 
!c                                         volumes)
!c           icon               = pointer (connections - local)
!c           iend               = pointer (end of row)
!c           istart             = pointer (start of row)
!c           jvol               = row-column pointer
!c           ivol               = counter (control volumes)
!c
!c external: fluxdd   = flux function for density dependent 
!c                      flow 
!c           fluxfs   = flux function for fully saturated flow 
!c           msysdd   = compute total system mass
!c                      (density dependent flow)
!c           rootwat  = function for computing root water uptake 
!c           stordd   = storage function for variably saturated  
!c                      density dependent flow
!c           storddfs = storage function for fully saturated  
!c                      density dependent flow
!c ----------------------------------------------------------------------

      subroutine mbaldd

      use parm
      use gen
      use phys
      use dens
      use writeversion
#ifdef OPENMP
      use omp_lib 
#endif

      use module_binary_mpiio, only : binary_write_data

      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif
      
      integer :: i1, icon, ibvs, ivol, istart, iend, jvol
      real*8 :: absbalance, culrelbalvs, fluxdd, area_ivol, relbalance,&
                totvsstor, totinflux, totoutflux, totvsflux, rpor,     &
                rootwat, porosity_flow, vsstor, storddfs, storevap,    &
                qroot_tot_act, rdummy1, rdummy2 ! CBF removed qroot

#ifdef PETSC
      real*8 :: totvsstor_gbl, totinflux_gbl, totoutflux_gbl,          &
                qroot_tot_act_gbl
      PetscErrorCode :: ierrcode
#endif
      
      real(type_r8) :: rho_av_loc

      external fluxdd, msysdd, rootwat, stordd, storevap, storddfs, porosity_flow

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r100 = 100.0d0
      real*8, parameter :: rhalf = 0.5d0, rsmall = 1.0d-100
      
      integer :: nvarsimvs
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      !interface
      !  !>interface of jacbevap
      !  subroutine jacbevap(ivol,typeequation)
      !    integer, intent(in)           :: ivol 
      !    character(len=*), intent(in)  :: typeequation     
      !  end subroutine jacbevap
      !end interface

!c  compute total system mass
!c  Parallelized, OpenMP, DSU

      call msysdd

!c  for transient conditions -> compute changes in storage 

      if (transient_flow) then
        totvsstor = r0
        if (variably_saturated) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbaldd_1)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, rpor, vsstor)                                 &
    !$omp reduction(+:totvsstor)
    !$omp do schedule(static)
#endif 
          do ivol = 1,nngl  
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
            if (modify_por(ivol)) then
             rpor=porosity_flow(porold(ivol),                         &
                  uvsnew(ivol),uvsold(ivol),stor(ivol),               &
                  por_stress(ivol),por_init(ivol),facpormin)   
            else
             rpor=pornew(ivol)
            end if   
            vsstor = cvol(ivol)*storddfs(delt,delt,                   &
                                rpor,porold(ivol),sanew(ivol),        &
                                saold(ivol),density(ivol),            &
                                densold(ivol),density(ivol),          &
                                densold(ivol),r0,r0,r1,r0,            &
                                r0,r0,.true.,.false.,                 &
                                r0,r0,r0,r0) 
      
      
            if (evaporation) then
                     vsstor = vsstor + cvol(ivol)*storevap(delt,r1,   &
                                       r1,sgnew(ivol),sgold(ivol),    &
                                       densvnew(ivol),densvold(ivol), &
                                       rpor,porold(ivol),r1)
            end if   

            totvsstor = totvsstor + vsstor
         
          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
          
        else if (fully_saturated) then
            
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbaldd_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, rpor, vsstor)                                 &
    !$omp reduction(+:totvsstor)
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl 
#ifdef PETSC 
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
            if (modify_por(ivol)) then
             rpor=porosity_flow(porold(ivol),                         &
                  uvsnew(ivol),uvsold(ivol),stor(ivol),               &
                  por_stress(ivol),por_init(ivol),facpormin)   
            else
             rpor=pornew(ivol)
            end if 
            
            vsstor = cvol(ivol)   *storddfs(delt,delt,                &
                                   rpor,porold(ivol),sanew(ivol),     &
                                   saold(ivol),density(ivol),         &
                                   densold(ivol),density(ivol),       &
                                   densold(ivol),r0,r0,r1,r0,         &
                                   r0,r0,.true.,.false.,              &
                                   r0,r0,r0,r0) 
            

            totvsstor = totvsstor + vsstor
         
          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
          
#ifdef PETSC     
        call MPI_Allreduce(totvsstor, totvsstor_gbl,1,MPI_REAL8,MPI_SUM, &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totvsstor = totvsstor_gbl
#endif

        end if !variably_saturated
      end if !transient_flow

!c  compute fluxes across boundary

      totinflux = r0               !initialize total in- and outflux
      totoutflux = r0
      qroot_tot_act = r0 
 
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbvs > numofloops_thred_mbaldd_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(i1, ibvs, icon, iend, istart, ivol, jvol,           &
    !$omp area_ivol, dcoef, del_p, del_z, rho_av_loc,                 &
    !$omp totvsflux, vsflux)                                          &
    !$omp reduction(+:totinflux, totoutflux)
    !$omp do schedule(static)
#endif
      do ibvs = 1,nbvs             !loop over boundary control volumes

        ivol = iabvs(ibvs)         !pointer to control volume
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif
        totvsflux = r0             !initialize total flux

!c  fluxes at first type control volumes or zero pressure seepage 
!c  control volumes

        if ((btypevs(ibvs).eq.'first').or.        & !first type (Dirichlet) 
            ((btypevs(ibvs).eq.'seepage').and.    & !first type (seepage)
             (bcondvs(ibvs).lt.r0))) then

          istart = iavs(ivol)       !pointer - start of row
          iend = iavs(ivol+1)-1     !pointer - end of row
          icon = 0                  !counter (connections)

          do i1=istart,iend         !loop over connected control volumes

            jvol = javs(i1)         !column pointer

            if (jvol.ne.ivol) then

              icon = icon+1          !counter (row entries)


              del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
              del_z(icon) = zg(jvol) - zg(ivol)

              if (del_z(icon) .ne. r0) then
                rho_av_loc = rhalf * (density(ivol) + density(jvol))

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
 
                del_z(icon) = del_z(icon) * rho_av_loc * gacc
                del_p(icon) = del_p(icon) + del_z(icon) 
              end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
 
              if (del_p(icon) .gt. r0) then
              dcoef(icon) = relperm(jvol) *         &
                    density(jvol)/viscosity(jvol)
           
              else
              dcoef(icon) = relperm(ivol) *         &
                    density(ivol)/viscosity(ivol)  
           
              end if

!c  compute fluxes between current control volume and adjacent 
!c  control volumes
       
              vsflux(icon) = - fluxdd(del_p(icon),    &
                               cinfvs_a(i1), dcoef(icon)) 
             
              totvsflux = totvsflux + vsflux(icon)

            end if                  !(ivol.eq.jvol)
          end do                    !loop over connected control volumes

!c  mass fluxes at second type control volumes

        elseif ((btypevs(ibvs).eq.'second').or.       &
            (btypevs(ibvs).eq.'point')) then

          if (flow_verification) then
            totvsflux = bcondvs(ibvs) * ref_dens
          else
            totvsflux = bcondvs(ibvs) * ssdens(ivol)
          end if
          
        elseif (btypevs(ibvs)=='atmospheric'.and.     &
                evaporation) then
     
           area_ivol = bcondvs(ibvs)
        !  call jacbevap(ivol,' ') 
           totvsflux = totwflux_atm*area_ivol
           
        end if                      !boundary type

!c  sum up total inflow and outflow

        if (totvsflux>r0) then   
          totinflux = totinflux + totvsflux
        else
          totoutflux = totoutflux - totvsflux
        end if

      end do                        !loop over boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC     
        call MPI_Allreduce(totinflux,totinflux_gbl,1,MPI_REAL8,        &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totinflux = totinflux_gbl
        
        call MPI_Allreduce(totoutflux,totoutflux_gbl,1,MPI_REAL8,      &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totoutflux = totoutflux_gbl
#endif


!c  compute contributions from root water uptake

      if (root_uptake) then
       
       qroot_tot_act = r0
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbaldd_4)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, qroot)                                        &
    !$omp reduction(+:qroot_tot_act)
    !$omp do schedule(static)
#endif
       do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif



          ! CBF removed because qroot is in gen : qroot = cvol(ivol)*rootwat(sanew(ivol),     &
          ! CBF                           mpropvs(ivol))

          qroot_tot_act = qroot_tot_act + qroot(ivol)

       end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC     
        call MPI_Allreduce(qroot_tot_act,qroot_tot_act_gbl,1,MPI_REAL8,&
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        qroot_tot_act = qroot_tot_act_gbl
#endif

      end if
 
!c  write total contributions to file   

      imvs = imvs+1
    
      if(rank == 0 .and. b_enable_output .and.                         &
         .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        if (b_output_binary) then
          nvarsimvs = 5
          realbuffer_gb(1:nvarsimvs) = (/time_io,totinflux,totoutflux, &
                                   totvsstor,qroot_tot_act/)
          call binary_write_data(imvs_mpi(imvs), 1,            &
                       (/mtime/),offset_imvs_ijk(imvs),.true.)       
          call binary_write_data(imvs_mpi(imvs), nvarsimvs,    &
                       realbuffer_gb,offset_imvs(imvs),.true.) 

          offset_imvs(imvs) = offset_imvs(imvs) + nvarsimvs*nfloatbit

        else  
          write(imvs,'(5(1pe12.4))') time_io,totinflux,totoutflux,     &
                                   totvsstor,qroot_tot_act
        end if
      end if
!c  compute absolute and relative mass balance error 

!c      write(idbg,*) 'new totinflux', totinflux
!c      write(idbg,*) 'new totouflux', totoutflux
!c      write(idbg,*) 'new totvsstor', totvsstor
      rdummy1 = (totinflux-totoutflux-totvsstor-qroot_tot_act)
      rdummy2 = abs(totinflux) + abs(totoutflux)
      if (rdummy2 < rsmall) then
        if(rdummy1 < rsmall) then
          relbalance_vs = 0.0d0
        else
          relbalance_vs = 1.0d100
        end if
      else
        relbalance_vs = rdummy1/rdummy2
      end if

      absbalance = rdummy1*delt
      relbalance = absbalance/totvsmass*r100

      absbalance_vs = absbalance
 
!c  compute accumulative absolute and relative mass balance error 

      culabsbalvs = culabsbalvs + absbalance
      culrelbalvs = culabsbalvs/totvsmass*r100

      imvs = imvs+1
    
      if(rank == 0 .and. b_enable_output .and.                         &
         .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        if (b_output_binary) then
          nvarsimvs = 5
          realbuffer_gb(1:nvarsimvs) = (/time_io,absbalance,relbalance,&
                                     culabsbalvs,culrelbalvs/)
          call binary_write_data(imvs_mpi(imvs), 1,            &
                       (/mtime/),offset_imvs_ijk(imvs),.true.)       
          call binary_write_data(imvs_mpi(imvs), nvarsimvs,    &
                       realbuffer_gb,offset_imvs(imvs),.true.) 

          offset_imvs(imvs) = offset_imvs(imvs) + nvarsimvs*nfloatbit

        else
          write(imvs,'(5(1pe12.4))') time_io,absbalance,relbalance,    &
                                     culabsbalvs,culrelbalvs
        end if
      end if
      
      return
      end 
