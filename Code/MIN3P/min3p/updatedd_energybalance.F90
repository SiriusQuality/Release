!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/updatedd_energybalance.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updatedd_energybalance
!c -------------------
!c
!c update fluid pressure and check for convergence
!c (density dependent variably saturated flow)
!c compute underrelaxation factor for variably saturated flow
!c update solution vector and secondary variables - check for convergence
!c if relaxation factor is less than one, updates are scaled and the
!c convergence check is based on the scaled updates
!c
!c modified from Sergio Andres Bea Jofre
!c
!c written by:     Sergio Andres Bea Jofre 
!c
!c last modified:   Sergio Andres Bea Jofre 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   - 
!c
!c common:   
!c gen.f:    real*8:
!c           ------- 
!c           relfacold          = underrelaxation factor              + +
!c                                (old time level)
!c           srelfac_vs         = user specified underrelaxation      + -
!c                                factor
!c           uvs(nn)            = update towards solution-vector      + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           uvslim             = user specified upper limit for      + -
!c                                magnitude of solution update        + -
!c           uvsmaxold          = maximum solution update             + +
!c                                (old time level)
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           ilog               = unit number, log file               + -
!c           nn                 = total number of control volumes     + -
!c           iter_vs            = iteration counter                   + -
!c                                (variably saturated flow)
!c           itsolv             = actual number of solver iterations
!c           idetail_vs         = solver information level            + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   + -
!c                                           factor
!c           not_converged      = .true.  -> continue Newton          + +
!c                                           iteration
!c           under_relax        = .true.  -> underrelaxation          + -
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + -  
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c           r3                 = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c           relfac             = underrelaxation factor
!c           sfac               = intermediate value for 
!c                                computation of relaxation factor
!c           ufac               = intermediate dampening factor
!c           uvsmax             = maximum solution update
!c           uvsabs             = absolute value of solution update
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           maxvol             = control volume with maximum 
!c                                solution update
!c           nexvol             = number of control volumes 
!c                                exceeding update tolerance
!c
!c external: -
!c ----------------------------------------------------------------------

subroutine updatedd_energybalance 

use parm
use gen
use dens
use phys
use chem
#ifdef OPENMP
use omp_lib 
#endif

      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif      

#ifdef PETSC
      real*8 :: uvsmax_gbl,utempmax_gbl
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer :: mpireduce_irank
      PetscErrorCode :: ierrcode
#endif
      
      real*8, parameter :: rhalf = 0.5d0, &
                           r0 = 0.0d0, &
                           r1 = 1.0d0, &
                           r3 = 3.0d0, &
                           r10=10.0d0, &
                           enat = 2.71828182845904509d0, &
                           rkelvin = 273.15d0
      integer, parameter :: iscreen=6
      
      integer :: ivol, izn, tid, i1, ibvs, ibheat, ioutunit
      real*8 :: actw, dummy1, dummy2, dummy3, uabs
      integer :: nexvolpa, nexvoltemp, maxvolpa, maxvoltemp
      real*8 :: uvsmax, utempmax, ugloblim_ln, relfac, sfac, ufac,     &
                relfactemp, sfactemp, ufactemp,                        &
                rhonew, visconew, porosity_flow, ugloblim_ln_temp
      logical :: bflag_goto

      external :: rhonew, visconew, porosity_flow
      
      !!For the shared-memory parallel version, the variables defined in the module
      !!are shared variables by different threads. So as to avoid race condition, 
      !!these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      !interface
      !  !>interface of jacbevap
      !  subroutine jacbevap(ivol,typeequation)
      !    integer, intent(in)           :: ivol 
      !    character(len=*), intent(in)  :: typeequation     
      !  end subroutine jacbevap
      !end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      relfac = r0
      relfactemp = r0
      
      if (islogunk_energybal) then
        ugloblim_ln = ugloblim_log * dlog(r10)             
      else
        ugloblim_ln = enat**(ugloblim_log * dlog(r10))
      end if
      
#ifdef STANDARD_FORTRAN
      !By definition, NAN is not equal to anything, even itself.
      if (rnorm /= rnorm .or. over_flow_vs) then
#else
      !isnan is not fortran standard, this is gnu extension.
      if (isnan(rnorm) .or. over_flow_vs) then
#endif
         if(rank == 0 .and. b_enable_output)  then 
           write(ilog,*) 'NAN or over_flow obtained in updatedd_energybalance'
           write(*,*) 'NAN or over_flow obtained in updatedd_energybalance'
         end if
         reduce_timestep=.true.
         return
      end if
      
      uvsmax  = r0
      utempmax = r0 
      if (under_relax) then          !underrelaxation

        if (comp_relax) then         !compute underelaxation factor

!c  find maximum update to calculate relaxation factor
!c  according to Cooley's method (1983)

#ifdef OPENMP
         maxval_omp = uvsmax
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_updatedd_ener_1)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, tid)                                              
    !$omp do schedule(static)
#endif   

#ifdef OPENMP   
          do ivol = 1,nngl 
!#ifdef PETSC
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif
        
            tid = omp_get_thread_num()+1  
            if (dabs(uglob(ivol)).gt.dabs(maxval_omp(tid))) then
                maxval_omp(tid) = uglob(ivol)
            end if
          end do
#else
          do ivol = 1,nngl 
!#ifdef PETSC 
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif 
            if (dabs(uglob(ivol)).gt.dabs(uvsmax)) then
                uvsmax = uglob(ivol)
            end if
          end do
#endif

#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
          i1 = maxloc(abs(maxval_omp), 1)
          uvsmax = maxval_omp(i1)    
#endif

#ifdef PETSC
          call MPI_Allreduce(uvsmax,uvsmax_gbl,1,MPI_REAL8,MPI_MAX,    &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          uvsmax = uvsmax_gbl
#endif


!c  compute underrelaxation factor

          if (iterglob==1) then                 !first iteration

            relfac = r1

          else                                   !following iterations

            sfac = uvsmax/(uvsmaxold*relfacold)            !step 1

            if (sfac<-r1) then                          !step 2
              relfac = rhalf/dabs(sfac)
            else
              relfac = (r3 + sfac)/(r3 + dabs(sfac))
            endif

          end if

!c  limit to maximum allowed update

          ufac = relfac*dabs(uvsmax)/uvslim                !step 3
          if (ufac>r1) then
            relfac = relfac/ufac
          end if

!c  assign old max. update and relaxation factor for next time step

          uvsmaxold = uvsmax
          relfacold = relfac

        else                      !user specified underelaxtion factor

          relfac = srelfac_vs

        end if       !comp_relax
      end if         !under_relax
      
      
      if (under_relax_temp) then          !underrelaxation

        if (comp_relax_temp) then         !compute underelaxation factor

!c  find maximum update to calculate relaxation factor
!c  according to Cooley's method (1983)

#ifdef OPENMP
         maxval_omp2 = utempmax
#endif

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_updatedd_ener_1)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, tid)                                              
    !$omp do schedule(static)
#endif   

#ifdef OPENMP   
          do ivol = 1,nngl 
!#ifdef PETSC
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif
        
            tid = omp_get_thread_num()+1  
            if (dabs(uglob(ivol+nngl)).gt.dabs(maxval_omp2(tid))) then
                maxval_omp2(tid) = uglob(ivol+nngl)
            end if
          end do
#else
          do ivol = 1,nngl 
!#ifdef PETSC 
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif 
            if (dabs(uglob(ivol+nngl)).gt.dabs(utempmax)) then
                utempmax = uglob(ivol+nngl)
            end if
          end do
#endif

#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
          i1 = maxloc(abs(maxval_omp2), 1)
          utempmax = maxval_omp2(i1)         
#endif

#ifdef PETSC          
          call MPI_Allreduce(utempmax,utempmax_gbl,1,MPI_REAL8,MPI_MAX,&
                             Petsc_Comm_World,ierrcode) 
          CHKERRQ(ierrcode)
          utempmax = utempmax_gbl
#endif


!c  compute underrelaxation factor

          if (iterglob==1) then                 !first iteration

            relfactemp = r1

          else                                   !following iterations

            sfactemp = utempmax/(utempmaxold*relfactempold)            !step 1

            if (sfactemp<-r1) then                          !step 2
              relfactemp = rhalf/dabs(sfactemp)
            else
              relfactemp = (r3 + sfactemp)/(r3 + dabs(sfactemp))
            endif

          end if

!c  limit to maximum allowed update
          
          ufactemp = relfactemp*dabs(utempmax)/utemplim                !step 3
          if (ufactemp>r1) then
            relfactemp = relfactemp/ufactemp
          end if

!c  assign old max. update and relaxation factor for next time step
          
          utempmaxold = utempmax
          relfactempold = relfactemp

        else                      !user specified underelaxtion factor

            relfactemp = srelfac_temp

        end if       !comp_relax
        
      end if         !under_relax

      
!dsu start of maximum log cycles control
1000  continue  

!c  check size of updates (relaxed/un-relaxed) to determine convergence

    
      nexvolpa=0
      nexvoltemp=0
      uvsmax=r0
      utempmax=r0
      maxvolpa=1
      maxvoltemp=1
#ifdef OPENMP
      bflag_omp1 = .false.
      bflag_omp2 = .false.
      bflag_omp3 = .false.  
      maxval_omp = uvsmax
      maxval_omp2 = utempmax
      maxvol_omp = maxvolpa
      maxvol_omp2 = maxvoltemp
#endif 

      bflag_goto = .false.  

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_updatedd_ener_2)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, izn, tid, actw, dummy1, dummy2, dummy3,      &
    !$omp uabs, ugloblim_ln_temp)                                     &
    !$omp reduction(+:nexvolpa, nexvoltemp)
    !$omp do schedule(static)
#endif 
      do ivol = 1,nngl  
!#ifdef PETSC
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#endif
          
#ifdef OPENMP    
        tid = omp_get_thread_num()+1
#else
        tid = 1
#endif         

#ifdef OPENMP
        if (bflag_omp1(tid).or.bflag_omp2(tid).or.bflag_omp3(tid)) then
          cycle
        end if
#endif
        
        if (under_relax) then                    !underrelaxation
          uglob(ivol) = relfac*uglob(ivol)
        end if
        
        if (under_relax_temp) then                    !underrelaxation
          uglob(ivol+nngl) = relfactemp*uglob(ivol+nngl)
        end if

        ! Stablish the thershold for maximum update
        
        if (uglob(ivol)>ugloblim_ln) then
          uglob(ivol) = ugloblim_ln
        elseif (uglob(ivol)<-ugloblim_ln) then
          uglob(ivol) = -ugloblim_ln
        end if
        
        ! Update the solution for Pa
        
        if (islogunk_energybal) then          
          uvsnew(ivol) = dlog(uvsnew(ivol)) + uglob(ivol) 
          uvsnew(ivol) = enat**uvsnew(ivol)             
          uabs  = dabs(uglob(ivol)/dlog(r10))            
        else 
          uvsnew(ivol) = uvsnew(ivol) + uglob(ivol) 
          uabs  = dabs(uglob(ivol))        
        end if
        
#ifdef OPENMP
        if (uabs>maxval_omp(tid)) then
          maxval_omp(tid) = uabs                    !max solution update
          maxvol_omp(tid) = ivol                    !location of max update
        endif   
#else
        if (uabs>uvsmax) then
          uvsmax = uabs                             !max solution update
          maxvolpa = ivol                           !location of max update
        endif
#endif
        
        if (uabs>tol_vs) then                      !number of volumes
          nexvolpa = nexvolpa + 1                  !exceeding convergence
        end if                                     !tolerance
        
        if (uglob(ivol+nngl)>ugloblim_ln) then
           uglob(ivol+nngl) = ugloblim_ln
        elseif (uglob(ivol+nngl)<-ugloblim_ln) then
           uglob(ivol+nngl) = -ugloblim_ln
        end if
        
        if (islogunk_energybal) then      
            tempnew(ivol) = dlog(tempnew(ivol)) + uglob(ivol+nngl)
            tempnew(ivol) = enat**tempnew(ivol)
            uabs  = dabs(uglob(ivol+nngl)/dlog(r10))              
        else  
            tempnew(ivol) = tempnew(ivol) + uglob(ivol+nngl) 
            uabs  = dabs(uglob(ivol+nngl))        
        end if

        if (tempnew(ivol) < tempcorr_min .or. tempnew(ivol) > tempcorr_max) then

          if (islogunk_energybal) then
            ugloblim_ln_temp = ugloblim_ln*0.5 
          else  
            ugloblim_ln_temp = sqrt(ugloblim_ln)
          end if
          
          if(ugloblim_ln_temp < 1.0d-8) then
#ifdef OPENMP
            bflag_omp1(tid) = .true.
#else
            not_converged = .true.
#endif              
            if (tempnew(ivol) < tempcorr_min) then  
              write(*,*) "reduce timestep: temperature is below correction range, ivol", ivol  
              write(ilog,*) "reduce timestep: temperature is below correction range, ivol", ivol
            else
              write(*,*) "reduce timestep: temperature is below correction range, ivol", ivol  
              write(ilog,*) "reduce timestep: temperature is below correction range, ivol", ivol    
            end if
            
            if(iterglob >= maxiterglob) then
#ifdef OPENMP
             bflag_omp2(tid) = .true.
#else
             reduce_timestep=.true. 
#ifndef MPI
             return
#endif
#endif
            end if
           
          else
#ifdef OPENMP
            bflag_omp3(tid) = .true.
#else
            bflag_goto = .true.
#endif
          end if
        end if
       
#ifdef OPENMP
        if (uabs>maxval_omp2(tid)) then
          maxval_omp2(tid) = uabs                 !max solution update
          maxvol_omp2(tid) = ivol                 !location of max update
        endif
#else        
        if (uabs>utempmax) then
          utempmax = uabs                         !max solution update
          maxvoltemp = ivol                       !location of max update
        endif
#endif     
        if (uabs>tolglob) then               !number of volumes
          nexvoltemp = nexvoltemp + 1                    !exceeding convergence
        end if
!cprovi----------------------------------------------------------------------------------
!cprovi Update the density according to linear expression or based on Pitzer equations
!cprovi----------------------------------------------------------------------------------        
       if (ispitzerdens) then 
         density(ivol) = rhonew(ref_dens,density_pitzer(ivol),ref_dens,  &
                                tempnew(ivol),tempref_dens,r1,drho_dt,nonlindens_heat, &
                                cdens1,cdens2,cdens3,cdens4)
       else
         density(ivol) = rhonew(ref_dens,tds_new(ivol),ref_tds, &
                                tempnew(ivol),tempref_dens,drho_dc,drho_dt,nonlindens_heat, &
                                cdens1,cdens2,cdens3,cdens4)
       end if
       
       if (update_viscosity_temp.or.update_viscosity) then
            viscosity(ivol) = visconew(density(ivol),tds_new(ivol),tempnew(ivol),update_viscosity, &
                              update_viscosity_temp,cvisco1,cvisco2,cvisco3,cvisco4,cvisco5, &
                              tempref_dens,iviscomodel,ref_visco,ref_tds,ref_dens) 
       end if   
!cprovi----------------------------------------------------------------------------------
!cprovi Update the porosity as a function of Pa
!cprovi----------------------------------------------------------------------------------        
       if (modify_por(ivol)) then
            pornew(ivol)=porosity_flow(porold(ivol),uvsnew(ivol),uvsold(ivol),stor(ivol), &
                         por_stress(ivol),por_init(ivol),facpormin)   
       end if
       
!cprovi----------------------------------------------------------------------------------
!cprovi Update the soil properties as a function of water pressure
!cprovi Only of variable saturated medium 
!cprovi----------------------------------------------------------------------------------        
      if (variably_saturated) then       
        izn = mpropvs(ivol)
        call soilprdd(uvsnew(ivol),sanew(ivol),sgnew(ivol),relperm(ivol),relpermg(ivol), &
                      snnew(ivol),swr(izn),aentry(izn),spalpha(izn), & 
                      spbeta(izn),expn(izn),spgamma(izn), &
                      napl_permeability,napl_kfunction,sgr, &
                      isovendrying(izn),beta_ovendry(izn),hm_ovendry(izn), &
                      w0_ovendry(izn),cp0_ovendry(izn),ref_dens,gacc)
        !cprovi--------------------------------------------------------------------------
        !cprovi Compute the saturated vapour density 
        !cprovi (see Saito et al. (2006) and RETRASO manual
        !cprovi--------------------------------------------------------------------------
        if (evaporation) then             
           if (reactive_transport) then   
              actw = gamma(nc,ivol) 
           else
              actw = r1
           end if
           call vapor_prop (densvnew(ivol),dummy1,dummy2,dummy3,latvapnew(ivol), &
                            tempnew(ivol),aentry(izn),uvsnew(ivol), &
                            actw,density(ivol),ivol) 
                            
        end if 
      end if                       
      
      end do        !loop over control volumes     
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
      if (any(bflag_omp1,1) .eqv. .true.) then
        not_converged = .true.
        if (any(bflag_omp2,1) .eqv. .true.) then
          reduce_timestep = .true.  
        end if
      end if
#endif

#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(not_converged, b_mpi_process_flag,1,          &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      not_converged = b_mpi_process_flag
      
      b_mpi_process_flag = .false.
      call MPI_Allreduce(reduce_timestep, b_mpi_process_flag,1,        &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      reduce_timestep = b_mpi_process_flag
#endif

      if (reduce_timestep) then
        return
      end if

#ifdef OPENMP 
      if (any(bflag_omp3,1) .eqv. .true.) then
        bflag_goto = .true.
      end if
#endif


#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(bflag_goto, b_mpi_process_flag,1,             &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      bflag_goto = b_mpi_process_flag    
#endif

      if (bflag_goto) then        
        if (islogunk_energybal) then
          ugloblim_ln = ugloblim_ln*0.5 
        else  
          ugloblim_ln = sqrt(ugloblim_ln)
        end if      
        goto 1000
      end if

!dsu end of maximum log cycles control

#ifdef OPENMP
    i1 = maxloc(maxval_omp, 1)
    uvsmax = maxval_omp(i1)
    maxvolpa = maxvol_omp(i1)
    
    i1 = maxloc(maxval_omp2, 1)
    utempmax = maxval_omp2(i1)
    maxvoltemp = maxvol_omp2(i1)    
#endif

#ifdef PETSC
      mpireduce_in(1) = uvsmax      !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      uvsmax = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvolpa, 1, MPI_INTEGER4, mpireduce_irank,       &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
      
      
      mpireduce_in(1) = utempmax    !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      utempmax = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvoltemp, 1, MPI_INTEGER4, mpireduce_irank,     &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
#endif
      
      
!cprovi----------------------------------------------------------------------------------
!cprovi If evaporation is solved, update the atmospheric parameters for flow and 
!cprovi energy transport equations 
!cprovi---------------------------------------------------------------------------------- 
      if (evaporation) then 
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbvs > numofloops_thred_updatedd_ener_3)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ibheat, ibvs, ivol)
#endif

#ifdef OPENMP
    !$omp do schedule(dynamic)
#endif
         do ibvs = 1,nbvs
           if (btypevs(ibvs).eq.'atmospheric') then
              ivol = iabvs(ibvs)

              call jacbevap(ivol,' ')  

           end if                     
         end do 
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp do schedule(dynamic)
#endif
         do ibheat = 1,nbheat          
            if (btypeheat(ibheat)=='atmospheric') then
              ivol = iabheat(ibheat)

              call jacbevap(ivol,' ')

            end if 
         end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif
         
       end if         
!cprovi----------------------------------------------------------------------------------
!cprovi Write convergence history to screen or log file
!cprovi----------------------------------------------------------------------------------
      
      if (idetailglob>0) then
       
        if(rank == 0 .and. b_enable_output .and. .not.                 &
           ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
            
          ioutunit = iscreen
            
2000      continue  
       
          if (iterglob==1.or.idetailglob==2) then
            write(ioutunit,*)'------------------------------------------------'
            write(ioutunit,'(a)') ' Newton Iteration Convergence Summary:'
            write(ioutunit,*)'------------------------------------------------'
            write(ioutunit,'(a30)') 'Coordenates maximum update Pa'
            write(ioutunit,'(a2,e11.4,2x,a2,e11.4,2x,a2,e11.4)')              &
                  'x=',xg(maxvolpa),'y=',yg(maxvolpa),'z=',zg(maxvolpa)
            write(ioutunit,*)'------------------------------------------------'
            write(ioutunit,'(a32)') 'Coordenates maximum update Temp'
            write(ioutunit,'(a2,e11.4,2x,a2,e11.4,2x,a2,e11.4)')              &
                  'x=',xg(maxvoltemp),'y=',yg(maxvoltemp),'z=',zg(maxvoltemp)
            write(ioutunit,*)                                                 &
                  '------------------------------------------------'  
            write(ioutunit,'(2a)')                                            &
                  ' Newton       maximum      maximum    ',' solver'
            write(ioutunit,'(2a)')                                            &
                  ' iteration    updatePa  updateTemp    residual   ',        &
                  ' iterations  maxvolpa   maxvoltemp   nexvolpa   nexvoltemp'
             
          end if
          
          write(ioutunit,'(i6,6x,2e11.4,2x,1e11.4,2i9,5x,i9,3x,i9,3x,i9)')    &
                iterglob,uvsmax,utempmax,rnorm,itsolvtotglob,maxvolpa,        &
                maxvoltemp,nexvolpa,nexvoltemp
          
          if(ioutunit == iscreen .and. ioutunit /= ilog) then
            ioutunit = ilog
            goto 2000
          end if
      
        end if
        
      end if
!cprovi-----------------------------------------------------------------------------------
!cprovi Final convergence check
!cprovi-----------------------------------------------------------------------------------
      if (uvsmax<tol_vs.and.utempmax<tolglob) then
        if (abs(relbalance_vs) .le. rtol_relbalance_vs .or.            &
            abs(absbalance_vs) .le. rtol_absbalance_vs) then

          not_converged = .false.

        end if
      end if

      return
      end
