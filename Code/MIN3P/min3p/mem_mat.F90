!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 488 $
!> $Author: cblitz $
!> $Date: 2017-07-17 18:22:05 +0200 (Mon, 17 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/mem_mat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mem_mat
!c ------------------
!c
!c allocate memory for physical parameters in material 
!c property zones
!c
!c written by:      Uli Mayer - Januray 6, 2000
!c
!c last modified:   Celine Blitz Frayret (CBF) and Frédéric Gérard (FG) - from May 9, 2017 - According to the MIN3P-ArchiSimple
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    integer*4:
!c           ----------
!c           ilog               = unit number, logbook file           + -
!c           nn                 = number of control volumes           + -
!c
!c phys.f:   real*8:
!c           ------- 
!c           aentry(nzn)        = air entry pressure                  * +
!c           condxx(nzn)        = saturated hydraulic conductivity    * +
!c                                in x-direction
!c           condyy(nzn)        = saturated hydraulic conductivity    * +
!c                                in y-direction
!c           condzz(nzn)        = saturated hydraulic conductivity    * +
!c                                in z-direction
!c           permx(nn)          = saturated permeability in           * +
!c                                x-direction
!c           permy(nn)          = saturated permeability in           * +
!c                                y-direction
!c           permz(nn)          = saturated permeability in           * +
!c                                z-direction
!c           expn(nzn)          = soil hydraulic function parameter   * +
!c           spalpha(nzn)       = soil hydraulic function parameter   * +
!c           spbeta(nzn)        = soil hydraulic function parameter   * +
!c           spgamma(nzn)       = soil hydraulic function parameter   * +
!c           spstor(nzn)        = specific storage coefficient        * +
!c           swr(nzn)           = residual saturation                 * +
!c           disx(nzn)          = longitudinal dispersivity           * +
!c           disy(nzn)          = transverse horizontal dispersivity  * +
!c           disz(nzn)          = transverse vertical dispersivity    * +
!c           satwlim(nzn)       = water saturation at wilting point   * +
!c           satwfield(nzn)     = water saturation at field capacity  * +
!c           satwopt(nzn)     = water saturation optimal (FEDDES)     * +
!c           satwdry(nzn)       = water saturation air-dry            * +
!c           h1lim(nzn)         = wilting point aqueous pressure	  * +
!c           h1field(nzn)       = field capacity aqueous pressure	  * +
!c           h1opt(nzn)         = optimal aqueous pressure (FEDDES)   * +
!c           h1dry(nzn)         = air-dry aqueous pressure	! CBF
!c           pvol(nzn)          = volume of property zone (used for evaporation)   ! CBF
!c           rate_root_max(nzn) = maximum root water uptake rate      * +
!c
!c           character:
!c           ----------
!c           mprop_name(nzn)    = name of material property zone
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c
!c external: checkerr  = check for error during memory allocation
!c---------------------------------------------------------------------- 
!c WARNING
!c---------------------------------------------------------------------- 
!c All allocated variables are initialized to some value. This depends  
!c of its type:
!c 
!c real*8      => 0.0d0
!c integer     => 0 
!c character   => ' '    
!c logical     => .false. 
!c 
!c Sergio Andres Bea Jofre (2009)
!c
!c ----------------------------------------------------------------------
  
      subroutine mem_mat
 
      use parm
      use gen
      use phys
      use bbls
      use biol!FG dec 2020
#ifdef OPENMP
      use omp_lib 
#endif

      implicit none
      
      integer :: ierr
 
      external checkerr
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

!c  allocate memory for physical material property zones
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (mprop_name(nzn), stat = ierr)
      mprop_name=' '
      call checkerr(ierr,'mprop_name',ilog)

!	allocate (rew0(nzn), stat = ierr) FG dec 2020
!	rew0=0.0d0
!      call checkerr(ierr,'rew0',ilog)
 
      allocate (condxx(nzn), stat = ierr)
      condxx=0.0d0
      call checkerr(ierr,'condxx',ilog)

      allocate (condyy(nzn), stat = ierr)
      condyy=0.0d0
      call checkerr(ierr,'condyy',ilog)

      allocate (condzz(nzn), stat = ierr)
      condzz=0.0d0
      call checkerr(ierr,'condzz',ilog)
      
      allocate (spstor(nzn), stat = ierr)
      spstor=0.0d0
      call checkerr(ierr,'spstor',ilog)
!cprovi----------------------------------------------------------
!cprovi Allocate vector for oven dry model
!cprovi----------------------------------------------------------
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (beta_ovendry(nzn), stat = ierr)
      beta_ovendry=0.0d0
      call checkerr(ierr,'beta_ovendry',ilog)
      
      allocate (cp0_ovendry(nzn), stat = ierr)
      cp0_ovendry=0.0d0
      call checkerr(ierr,'cp0_ovendry',ilog)
      
      allocate (hm_ovendry(nzn), stat = ierr)
      hm_ovendry=0.0d0
      call checkerr(ierr,'hm_ovendry',ilog)
      
      allocate (w0_ovendry(nzn), stat = ierr)
      w0_ovendry=0.0d0
      call checkerr(ierr,'w0_ovendry',ilog)
      
      allocate (isovendrying(nzn), stat = ierr)
      isovendrying=.false.
      call checkerr(ierr,'isovendrying',ilog)
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (swr(nzn), stat = ierr)
      swr=0.0d0
      call checkerr(ierr,'swr',ilog)

      allocate (spalpha(nzn), stat = ierr)
      spalpha=0.0d0
      call checkerr(ierr,'spalpha',ilog)

      allocate (spbeta(nzn), stat = ierr)
      spbeta=0.0d0
      call checkerr(ierr,'spbeta',ilog)

      allocate (spgamma(nzn), stat = ierr)
      spgamma=0.0d0
      call checkerr(ierr,'spgamma',ilog)

      allocate (expn(nzn), stat = ierr)
      expn=0.0d0
      call checkerr(ierr,'expn',ilog)
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (aentry(nzn), stat = ierr)
      aentry=0.0d0
      call checkerr(ierr,'aentry',ilog)

      allocate (disx(nzn), stat = ierr)
      disx=0.0d0
      call checkerr(ierr,'disx',ilog)

      allocate (disy(nzn), stat = ierr)
      disy=0.0d0
      call checkerr(ierr,'disy',ilog)

      allocate (disz(nzn), stat = ierr)
      disz=0.0d0
      call checkerr(ierr,'disz',ilog)

      allocate (h1lim(nzn), stat = ierr) !FG dec 2020
      h1lim=0.0d0
      call checkerr(ierr,'h1lim',ilog)
      
      allocate (satwlim(nzn), stat = ierr)
      satwlim=0.0d0
      call checkerr(ierr,'satwlim',ilog)

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (h1field(nzn), stat = ierr) !FG dec 2020
      h1field=0.0d0
      call checkerr(ierr,'h1field',ilog)
      
      allocate (h1opt(nzn), stat = ierr) !FG dec 2020
      h1opt=0.0d0
      call checkerr(ierr,'h1opt',ilog)
      
      allocate (satwfield(nzn), stat = ierr)
      satwfield=0.0d0
      call checkerr(ierr,'satwfield',ilog)
      
      allocate (satwopt(nzn), stat = ierr)
      satwopt=0.0d0
      call checkerr(ierr,'satwopt',ilog)

!      allocate (p1(nzn), stat = ierr) FG dec 2020
!      p1=0.0d0
!      call checkerr(ierr,'p1',ilog)

      allocate (rate_root_max(nzn), stat = ierr)
      rate_root_max=0.0d0
      call checkerr(ierr,'rate_root_max',ilog)

      allocate (satwdry(nzn), stat = ierr)
      satwdry=0.0d0
      call checkerr(ierr,'satwdry',ilog)

      allocate (h1dry(nzn), stat = ierr)	! CBF
      call checkerr(ierr,'h1dry',ilog)     ! CBF
      call zero_r8(h1dry,nzn,1,1) ! clean array ! CBF

      allocate (pvol(nzn), stat = ierr)! CBF
      call checkerr(ierr,'pvol',ilog)! CBF
      call zero_r8(pvol,nzn,1,1) ! clean array! CBF
      
!c_trap allocate memory for variables used for bubble entrapment
      if (trap_bubbles) then
        allocate (sgr_imbi(nzn), stat = ierr)
        sgr_imbi=0.0d0
        call checkerr(ierr,'sgr_imbi',ilog)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (root_length_dens(nzn), stat = ierr)
      root_length_dens=0.0d0
      call checkerr(ierr,'root_length_dens',ilog)

      allocate (tree_trans_factor(nzn), stat = ierr)
      tree_trans_factor=0.0d0
      call checkerr(ierr,'tree_trans_factor',ilog)

      ! CBF allocate (canopy_evap_factor(nzn), stat = ierr)
      ! CBF canopy_evap_factor=0.0d0
      ! CBF call checkerr(ierr,'canopy_evap_factor',ilog)

!c allocate memory for material parameters read from file
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (permx(nngl), stat = ierr)
      permx=0.0d0
      call checkerr(ierr,'permx',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (permy(nngl), stat = ierr)
      permy=0.0d0
      call checkerr(ierr,'permy',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (permz(nngl), stat = ierr)
      permz=0.0d0
      call checkerr(ierr,'permz',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      if (compute_permafrost) then
        allocate (permx0(nngl), stat = ierr)
        permx0=0.0d0
        call checkerr(ierr,'permx0',ilog)
      end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      if (compute_permafrost) then
        allocate (permy0(nngl), stat = ierr)
        permy0=0.0d0
        call checkerr(ierr,'permy0',ilog)
      end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      if (compute_permafrost) then
        allocate (permz0(nngl), stat = ierr)
        permz0=0.0d0
        call checkerr(ierr,'permz0',ilog)
      end if       
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

      return
      end
