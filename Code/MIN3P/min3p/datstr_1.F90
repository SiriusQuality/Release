!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/datstr_1.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine datstr_1
!c -------------------
!c
!c set up data structure, generate ordering vectors 
!c and perform symbolic factorization for 1d-scalar matrix
!c
!c written by:      Uli Mayer - August 6, 96
!c
!c last modified:   Uli Mayer - November 19, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.f:   - 
!c
!c gen.f:    integer*4:
!c           ----------
!c           ilog               = unit number, log file               + -
!c           mnjavs             = max. number of global connections   * +
!c           mnjafvs            = max. number of factored connections * +
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        * +
!c           njafvs             = number of factored connections      * +
!c           iavs(nn+1)         = row pointer array for avs           * + 
!c           javs(njavs)        = connectivity list                   * +
!c           iafvs(nn+1)        = row pointer array for afvs          * +
!c           iafdvs(nn)         = diagonal pointer array for afvs     * +
!c           isymvs(njavs)      = symmetry pointer array              * +
!c           jafvs(njafvs)      = column pointer array for afvs       * +
!c           lordervs(nn)       = array containing ordering           * +
!c           invordvs(nn)       = array containing inverse ordering   * +
!c           iwork(*)           = integer work array                  * +
!c           idbg               = unit number, debugging file         + -
!c           level_vs           = incomplete factoriztaion level      + -
!c
!c           logical:
!c           --------
!c           lwork(*)           = logical work array                  * +
!c           rcm_ordering_vs    = .true.  -> rcm ordering             + -
!c                                .false. -> natural ordering
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c
!c dual.f:   logical:
!c           --------
!c           dual_porosity      = .true.  -> dual porosity            + - 
!c                                 simulation
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c           ilist              = pointer for work array list
!c           irow               = pointer for work array irow
!c           ilevptr            = pointer for work array levptr
!c
!c external: checkerr  = check for error during memory allocation
!c           iajavs    = set up ia-ja data-structure for
!c                       1d-scalar matrix
!c           iajavs_dp = set up ia-ja data-structure for
!c                       1d-scalar matrix - secondary porosity
!c           mem_njavs = allocate memory for one-dimensional arrays
!c                       of size njavs
!c           naturalordering = assigns ordering vectors for natural 
!c                             ordering
!c           rcmordering =  assigns ordering vectors for reverse 
!c                          Cuthill-McKee ordering
!c           symbolicfactorization = incomplete symbolic lower/
!c                                   upper factorization 
!c                                   - brute force factor
!c ----------------------------------------------------------------------
 
      subroutine datstr_1
 
      use parm
      use gen
      use dual
      use matrix_utility, only : remap_matrix_ja
#ifdef PARDISO
      use solver_pardiso, only : ptvs, ptglob 
#endif
      implicit none
      
      integer :: i1, ierr, ilist, ilevptr, irow
      
      real*8, parameter :: r0 = 0.0d0

      external checkerr, iajavs, iajavs_dp, mem_njavs, rcmordering, &
              naturalordering, symbolicfactorization

!c  final memory allocation for row pointer array iavs,
!c  preliminary memory allocation for pointer arrays javs and isymvs

      if (.not.dual_porosity) then
        mnjavs = 3*nngl*ncon
      else
        mnjavs = 6*nngl*ncon        
      end if
      
      if (heat_transport) then          
        mnjaglob = 4*mnjavs            
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
     if (dual_porosity) then
        deallocate (iavs, stat = ierr)
        call checkerr(ierr,'iavs',ilog)        
        allocate(iavs(2*nngl+1), stat = ierr)
        iavs=0 
        call checkerr(ierr,'iavs',ilog)
#ifdef PETSC        
        deallocate (row_idx_l2pg_vs, stat = ierr)
        call checkerr(ierr,'row_idx_l2pg_vs',ilog)        
        allocate(row_idx_l2pg_vs(2*nngl+1), stat = ierr)
        row_idx_l2pg_vs=0 
        call checkerr(ierr,'row_idx_l2pg_vs',ilog)
#endif
        
      end if                     !(dual_porosity)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate(javs(mnjavs), stat = ierr)
      javs=0 
      call checkerr(ierr,'javs',ilog)
#ifdef PETSC
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate(col_idx_l2pg_vs(mnjavs), stat = ierr)
      col_idx_l2pg_vs=0 
      call checkerr(ierr,'col_idx_l2pg_vs',ilog)
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif    
      allocate(isymvs(mnjavs), stat = ierr)
      isymvs=0 
      call checkerr(ierr,'isymvs',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

!c  set up data-structure for 1D-scalar matrix
!c  Parallelized, OpenMP, DSU
      call iajavs

!c  set up data-structure for secondary porosity for 1D-scalar matrix
!c  Parallelized, OpenMP, DSU
      if (dual_porosity) then
        call iajavs_dp
      end if                     
    
!c  set up data-structure for flow and energy balance equations 
!c  Parallelized, OpenMP, DSU
      if (heat_transport) then
       call iajavs_energybal 
      end if                     

!c  final memory allocation for one-dimensional arrays of size njavs
!c  Parallelized, OpenMP, DSU
      call mem_njavs
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------

    ! use ws209 solver
    if (i_solver_type_flow == 0) then
               
      if (heat_transport) then
          
        mnjafglob  = 3*(levelglob+1)*njaglob

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif
   
!c  allocate memory for temporary work-arrays
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
        allocate(lwork(2*nngl), stat = ierr)
        lwork=.false.
        call checkerr(ierr,'lwork',ilog)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
        allocate (iwork(4*nngl+mnjafglob), stat = ierr)
        iwork=0 
        call checkerr(ierr,'iwork',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
        allocate (jafglob(mnjafglob), stat = ierr)
        jafglob=0 
        call checkerr(ierr,'jafglob',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

        if (varsat_flow) then          !variably saturated flow

    !c  ordering vectors
            if (rcm_ordering_vs) then    !rcm ordering    

              call rcmordering (2*nngl,njaglob,iaglob,jaglob,          &
                               lorderglob,invordglob,lwork,iwork)

            else                         !natural ordering

              call naturalordering (2*nngl,lorderglob,invordglob)

            endif

    !c  write memory-requirements to log file

            if(rank == 0 .and. b_enable_output)  then
                
            write(ilog,'(/a/)')   &
           'memory requirements for variably-saturated flow simulation:'
            write(ilog,'(2(a,i10/),a,i10)')                           &
           'estimated number of connections:          ',mnjaglob,     & 
           'actual number of connections:             ',njaglob,      &
           'estimated number of factored connections: ',mnjafglob
    
            end if
            !!
            !!Note201211231457:
            !!No definition or reference is found for the above variable mnjaglob.
            !!Output a large number when the program is compiled in CYGWIN. 
            !!Danyang, 2012-11-23
            !!
       
    !c  symbolic factorization
            njafglob = 0
            ilist = 1                  !pointer for work array list
            irow = 2*nngl+1            !pointer for work array irow
            ilevptr = 4*nngl+1         !pointer for work array levptr
        

            call symbolicfactorization (ilog,2*nngl,njaglob,njafglob,      &
                                       mnjafglob,                          &
                                       level_vs,iwork(ilist),iaglob,jaglob,&
                                       iwork(irow),iwork(ilevptr),iafglob, &
                                       iafdglob,jafglob,lorderglob,        &
                                       invordglob,b_enable_output)

    !c  write actual number of factored connections to log file
            if(rank == 0 .and. b_enable_output)  then
    
            write(ilog,'(a,i10/)') &
           'actual number of factored connections:    ',njafglob
     
            end if
    !c  deallocate memory for temporary arrays

            deallocate (iwork, stat = ierr)
            call checkerr(ierr,'iwork',ilog)
      

    !c  minimize memory requirements for array jafglob

            allocate (iwork(njafglob), stat = ierr)
            iwork=0 
            call checkerr(ierr,'iwork',ilog)

            do i1 = 1,njafglob
              iwork(i1) = jafglob(i1)
            end do

            deallocate (jafglob, stat = ierr)
            call checkerr(ierr,'jafglob',ilog)

            allocate (jafglob(njafglob), stat = ierr)
            call checkerr(ierr,'jafglob',ilog)

            do i1 = 1,njafglob
              jafglob(i1) = iwork(i1)
            end do
            
        end if
        
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)      
        deallocate(lwork, stat = ierr)
        call checkerr(ierr,'lwork',ilog)
        
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
      end if     !  energy balance
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
      mnjafvs  = 3*(level_vs+1)*njavs
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif
!c  allocate memory for temporary work-arrays
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate(lwork(nngl), stat = ierr)
      lwork=.false.
      call checkerr(ierr,'lwork',ilog)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (iwork(2*nngl+mnjafvs), stat = ierr)
      iwork=0 
      call checkerr(ierr,'iwork',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (jafvs(mnjafvs), stat = ierr)
      jafvs=0 
      call checkerr(ierr,'jafvs',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif

      if (varsat_flow) then          !variably saturated flow

    !c  ordering vectors

            if (rcm_ordering_vs) then    !rcm ordering    

              call rcmordering (nngl,njavs,iavs,javs,lordervs,invordvs,&
                               lwork,iwork)

            else                         !natural ordering

              call naturalordering (nngl,lordervs,invordvs)

            endif

    !c  write memory-requirements to log file
           if(rank == 0 .and. b_enable_output)  then

            write(ilog,'(/a/)') &
           'memory requirements for variably-saturated flow simulation:'
            write(ilog,'(2(a,i10/),a,i10)')                       &
           'estimated number of connections:          ',mnjavs,   &
           'actual number of connections:             ',njavs,    &
           'estimated number of factored connections: ',mnjafvs

           end if
       
    !c  symbolic factorization
            njafvs = 0
            ilist = 1                  !pointer for work array list
            irow = nngl+1              !pointer for work array irow
            ilevptr = 2*nngl+1         !pointer for work array levptr

            call symbolicfactorization (ilog,nngl,njavs,njafvs,mnjafvs,   &
                                       level_vs,iwork(ilist),iavs,javs,   &
                                       iwork(irow),iwork(ilevptr),iafvs,  &
                                       iafdvs,jafvs,lordervs,invordvs,    &
                                       b_enable_output)

    !c  write actual number of factored connections to log file
            if(rank == 0 .and. b_enable_output)  then
                
            write(ilog,'(a,i10/)')  &
           'actual number of factored connections:    ',njafvs 
            
            end if

      end if                       !variably saturated flow      
            
!c  deallocate memory for temporary arrays

        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)      

!c  minimize memory requirements for array jafvs

        allocate (iwork(njafvs), stat = ierr)
        iwork=0 
        call checkerr(ierr,'iwork',ilog)

        do i1 = 1,njafvs
        iwork(i1) = jafvs(i1)
        end do

        deallocate (jafvs, stat = ierr)
        call checkerr(ierr,'jafvs',ilog)

        allocate (jafvs(njafvs), stat = ierr)
        call checkerr(ierr,'jafvs',ilog)

        do i1 = 1,njafvs
        jafvs(i1) = iwork(i1)
        end do
   
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)      
        deallocate(lwork, stat = ierr)
        call checkerr(ierr,'lwork',ilog)
    end if
    
    ! use pardiso solver
#ifdef PARDISO
    if (i_solver_type_flow == 1 .or. (i_solver_type_flow == 0 .and. b_solver_test_pardiso .eqv. .true.)) then
        
      if (heat_transport) then

          if (varsat_flow) then          !variably saturated flow
              
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
            if (allocated(jaglob_std)) then
                deallocate(jaglob_std, stat = ierr)
                call checkerr(ierr,'jaglob_std',ilog) 
            end if
            allocate(jaglob_std(njaglob), stat = ierr)
            jaglob_std = 0
            call checkerr(ierr,'jaglob_std',ilog)
               
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
            if (allocated(imapglob_std)) then
                deallocate(imapglob_std, stat = ierr)
                call checkerr(ierr,'imapglob_std',ilog) 
            end if
            allocate(imapglob_std(njaglob), stat = ierr)
            imapglob_std = 0
            call checkerr(ierr,'imapglob_std',ilog)
            
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
            if (allocated(aglob_std)) then
                deallocate(aglob_std, stat = ierr)
                call checkerr(ierr,'aglob_std',ilog) 
            end if
            allocate(aglob_std(njaglob), stat = ierr)
            aglob_std = 0
            call checkerr(ierr,'aglob_std',ilog)
            
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
            if (b_solver_test_pardiso) then
                if (allocated(uglob_std)) then
                    deallocate(uglob_std, stat = ierr)
                    call checkerr(ierr,'uglob_std',ilog) 
                end if
                allocate(uglob_std(2*nngl), stat = ierr)
                uglob_std = 0
                call checkerr(ierr,'uglob_std',ilog)
            end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

            !map ja array to standard sparse matrix structure, increasing column number for each row
            jaglob_std = jaglob
            do i1 = 1, njaglob
                imapglob_std (i1) = i1
            end do
            call remap_matrix_ja(2*nngl, iaglob, njaglob, jaglob_std, imapglob_std)
            
          end if

      else  

          if (varsat_flow) then          !variably saturated flow
              
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
            if (allocated(javs_std)) then
                deallocate(javs_std, stat = ierr)
                call checkerr(ierr,'javs_std',ilog) 
            end if
            allocate(javs_std(njavs), stat = ierr)
            javs_std = 0
            call checkerr(ierr,'javs_std',ilog)
            
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
            if (allocated(imapvs_std)) then
                deallocate(imapvs_std, stat = ierr)
                call checkerr(ierr,'imapvs_std',ilog) 
            end if
            allocate(imapvs_std(njavs), stat = ierr)
            imapvs_std = 0
            call checkerr(ierr,'imapvs_std',ilog)
            
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
            if (allocated(avs_std)) then
                deallocate(avs_std, stat = ierr)
                call checkerr(ierr,'avs_std',ilog) 
            end if
            allocate(avs_std(njavs), stat = ierr)
            avs_std = 0.0d0
            call checkerr(ierr,'avs_std',ilog)
            
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
            if (b_solver_test_pardiso) then
                if (allocated(uvs_std)) then
                    deallocate(uvs_std, stat = ierr)
                    call checkerr(ierr,'uvs_std',ilog) 
                end if
                allocate(uvs_std(nngl), stat = ierr)
                uvs_std = 0.0d0
                call checkerr(ierr,'uvs_std',ilog)
            end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 
                         
            !map ja array to standard sparse matrix structure, increasing column number for each row
            javs_std = javs
            do i1 = 1, njavs
                imapvs_std (i1) = i1
            end do
            !write(idbg, *) "remap javs"
            call remap_matrix_ja(nngl, iavs, njavs, javs_std, imapvs_std)

          end if                       !variably saturated flow      
            
      end if     !  energy balance
      
    end if 
#endif
    
    ! use PETSC solver
#ifdef PETSC
    if (i_solver_type_flow == 0 .and. b_solver_test_petsc .eqv. .true.) then
        
      if (heat_transport) then

          if (varsat_flow) then          !variably saturated flow
              
            if (allocated(uglob_std)) then
                deallocate(uglob_std, stat = ierr)
                call checkerr(ierr,'uglob_std',ilog) 
            end if
            allocate(uglob_std(2*nngl), stat = ierr)
            uglob_std = 0.0d0
            call checkerr(ierr,'uglob_std',ilog)
            
          end if

      else  

          if (varsat_flow) then          !variably saturated flow
            
            if (allocated(uvs_std)) then
                deallocate(uvs_std, stat = ierr)
                call checkerr(ierr,'uvs_std',ilog) 
            end if
            allocate(uvs_std(nngl), stat = ierr)
            uvs_std = 0.0d0
            call checkerr(ierr,'uvs_std',ilog)

          end if                       !variably saturated flow      
            
      end if     !  energy balance
      
    end if
#endif
        
        
      
!cdbg
!c
!c  ia-ja pointers
!c
!c     do irow=1,nngl+1
!c       write(idbg,*) 'ia(',irow,') = ',iavs(irow)
!c     end do
!c     do irow=1,nngl
!c       istart = iavs(irow)
!c       iend = iavs(irow+1)-1
!c       write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart,iend)
!c     end do
!c
!c  ordering vectors
!c
!c     do ivol=1,nngl
!c       write(idbg,'(a,1x,i6,1x,a,1x,i6)')
!c    &        'lordervs(',ivol,') = ',lordervs(ivol)
!c     end do
!c     write(idbg,*)
!c     do ivol=1,nngl
!c       write(idbg,'(a,1x,i6,1x,a,1x,i6)')
!c    &        'invordvs(',ivol,') = ',invordvs(ivol)
!c     end do
!c
!c  iaf-jaf pointers
!c
!c     do irow=1,nngl+1
!c       write(idbg,*) 'iaf(',irow,') = ',iafvs(irow)
!c     end do
!c     do irow=1,nngl
!c       write(idbg,*) 'iafd(',irow,') = ',iafdvs(irow)
!c     end do
!c     do irow=1,nngl
!c       istart = iafvs(irow)
!c       iend = iafvs(irow+1)-1
!c       write(idbg,*) ('jaf(',i1,') = ',jafvs(i1),i1=istart,iend)
!c     end do
!c     stop
!cdbg

!    if (b_solver_test_pardiso) then
!!c  ia-ja pointers
!
!     do irow=1,nngl+1
!       write(idbg,*) 'ia(',irow,') = ',iavs(irow)
!     end do
!     do irow=1,nngl
!       istart = iavs(irow)
!       iend = iavs(irow+1)-1
!       write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart,iend)
!     end do
!
!!c  ordering vectors
!
!     do ivol=1,nngl
!       write(idbg,'(a,1x,i6,1x,a,1x,i6)') 'lordervs(',ivol,') = ',lordervs(ivol)
!     end do
!     write(idbg,*)
!     do ivol=1,nngl
!       write(idbg,'(a,1x,i6,1x,a,1x,i6)') 'invordvs(',ivol,') = ',invordvs(ivol)
!     end do
!
!!c  iaf-jaf pointers
!
!     do irow=1,nngl+1
!       write(idbg,*) 'iaf(',irow,') = ',iafvs(irow)
!     end do
!     do irow=1,nngl
!       write(idbg,*) 'iafd(',irow,') = ',iafdvs(irow)
!     end do
!     do irow=1,nngl
!       istart = iafvs(irow)
!       iend = iafvs(irow+1)-1
!       write(idbg,*) ('jaf(',i1,') = ',jafvs(i1),i1=istart,iend)
!     end do  
!     
!    end if

      return
      end
