!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/iajabl.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine iajabl
!c -----------------
!c
!c set up ia-ja data-structure for diagonal and off-diagonal block 
!c matrices for reactive transport problem
!c      
!c written by:      Uli Mayer - August 6, 96 
!c
!c last modified:   Uli Mayer - November 19, 96
!c
!c                  Danyang Su - March 31, 2014
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.inc: -
!c
!c gen.f:    integer*4:
!c           ----------
!c           n                  = number of primary unknowns          + -
!c           kbl(n,n)           = connectivity list for block         * *
!c                                matrices (full format)
!c           iadbl(n+1)         = row pointer array (diagonal block   * +
!c                                matrices)
!c           jadbl(n*n)         = column pointer array (diagonal      * +
!c                                block matrices)
!c           kadbl(n,n)         = pointer array for conversion to     * +
!c                                sparse format (diagonal block
!c                                matrices)
!c           iaobl(n+1)         = row pointer array                   * +
!c                                (off-diagonal block matrices)
!c           jaobl(n*n)         = column pointer array                * +
!c                                (diagonal block matrices)
!c           kaobl(n,n)         = pointer array for conversion        * +
!c                                to sparse format
!c                                (off-diagonal block matrices)
!c           njadbl             = actual number of entries in         * +
!c                                diagonal block matrices
!c           njaobl             = actual number of entries in         * +
!c                                off-diagonal block matrices
!c
!c chem.f:   integer*4:
!c           ----------
!c           iaga(ng+1)         = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           iam(nm+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           iarc(nr+1)         = row pointer array to                + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iax(nx+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in
!c                                secondary aqueous species
!c           jaga(ng*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           jam(nm*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           jarc(nr*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           jax(nx*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in secondary aqueous
!c                                species
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nx                 = number of secondary aqueous species + -
!c
!c
!c           logical:
!c           --------
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c           sparse_blocks      = .true.  -> make use of sparsity of  + -
!c                                           block matrices
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c
!c local:    integer*4:
!c           ----------
!c           ibl                = row pointer (block matrix)
!c           jbl                = column pointer (block matrix)
!c           ic                 = pointer (components)
!c           ic2                = pointer (components)
!c           ig                 = counter (gaseous species)
!c           im                 = counter (minerals)
!c           ir                 = counter (redox couples)
!c           ix                 = counter (secondary aqueous species)
!c           jtemp              = pointer (global storage)
!c           istart             = pointer
!c           iend               = pointer
!c           i1                 = counter
!c           i2                 = counter
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c           logical:
!c           --------
!c           found              = .true.  -> exit loop
!c
!c external: zero_i4   = clear integer*4 array
!c ----------------------------------------------------------------------
 
      subroutine iajabl
 
      use parm
      use gen
      use chem
      use multidiff, only : multi_diff
#ifdef OPENMP
      use omp_lib
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: i, i1, i2, i3, iaq, iaqt, iaqc, iaqx, iaqht, iaqhc,   &
                 iaqhm, iaqit, iaqic, iaqim, ibl2, ic2, ig, im, isb,   &
                 ir, istart2, istart3, iend2, iend3, ix, j, jbl2,      &
                 iiso, iiso2, iaqhst

      external zero_i4

      logical found
      
      !Index of components in all of the sorbed species
      integer, allocatable :: icur_sorbs(:)
      !Number of components in all of the sorbed species
      integer :: ncur_sorbs
      !Index of components in all of the gases
      integer, allocatable :: icur_gas_comps(:)
      !Number of components in all of the gases
      integer :: ncur_gas_comps
      
      integer :: info_debug, jtemp, istart, iend, ic, ibl, jbl, nbl, irs
                 
      ncur_sorbs = 0
      ncur_gas_comps = 0
      info_debug = 0
      
      if (redox_equil.and.nr.gt.0) then
        nbl = n + nr
      else
        nbl = n
      end if
      
!c  clear connectivity list for block matrices (full) and 
!c  pointer arrays for mapping to sparse format
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_i4(kbl,n,n,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_i4(kblsorb,n,n,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_i4(kblredox,n,n,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_i4(kadbl,n,n,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_i4(kaobl,n,n,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif

      if((b_output_matrix.or.itimestep_output_matrix >= 0) .and. &
          b_enable_output .and. rank == 0) then
          write(ilog,'(a)') "component name in block matrix"
          write(ilog,'(100(a12,1x))') namec(1:n)
      end if

      if(sparse_blocks .and. .not. multi_diff) then
          if(nsb_ion > 0 .or. nsb_surf > 0) then
              allocate(icur_sorbs(n))
              icur_sorbs = 0
              ncur_sorbs = 0
          end if
      end if

!c  initialize connectivity list for block matrix (full format)
!c  diagonal entries in block matrix
      if (sparse_blocks .and. .not. multi_diff) then
          
        do ibl = 1,n
          kbl(ibl,ibl) = 1
        end do
        
!c  additional connectivity for gas components
        if (ng .gt.0) then
            
          allocate(icur_gas_comps(n))
          icur_gas_comps = 0
          ncur_gas_comps = 0
          
          do ig = 1, ng
              istart = iaga(ig)
              iend = iaga(ig+1)-1
              do i1 = istart, iend
                  ic = jaga(i1)
                  if((.not. any(icur_gas_comps .eq. ic)) .and.          &
                      ic .le. n) then
                      ncur_gas_comps = ncur_gas_comps + 1
                      icur_gas_comps(ncur_gas_comps) = ic
                  end if
              end do
          end do
          
          do i1 = 1, ncur_gas_comps-1
              do i2 = i1 + 1, ncur_gas_comps
                  ibl = icur_gas_comps(i1)
                  jbl = icur_gas_comps(i2)
                  kbl(ibl, jbl) = 1
                  kbl(jbl, ibl) = 1
              end do
          end do
            
        end if        
      
!c  allocate offdiagonal entries due to mobile secondary species

        if (redox_equil.and.nr.gt.0) then
!c  equilibrium controlled redox reactions
!c  dependent redox species
          do ir = 1,nr               !loop over redox couples    
            
            !c get the component index for the redox secondary component
            do ibl = n, nbl
              if (namec(ibl) == namers(ir)) then
                irs = ibl  
              end if
            end do              
              
            istart = iarc(ir)        !beginning of row
            iend = iarc(ir+1)-1      !end of row             

            do i1 = istart,iend      !loop over components in species
              ibl = jarc(i1)         !get component index 
!c  allocate symbolic entries, if species contains current component

              do i2 = istart,iend
                jbl = jarc(i2)     !get column pointer                
                
                if (namec(ibl).ne.'h2o' .and. namec(jbl).ne.'h2o') then
                  kbl(ibl,jbl) = 1
                  kblredox(ibl,jbl) = 1
                  
                  kbl(irs,jbl) = 1
                  kbl(ibl,irs) = 1
                end if
              end do
            end do            
           
          end do
         
        end if  
        
!c  allocate offdiagonal entries due to mobile secondary species

        do ibl = 1,n                !loop over rows of block matrix  
!c  aqueous complexes

          do ix = 1,nx              !loop over secondary aqueous species

            istart = iax(ix)        !beginning of row
            iend = iax(ix+1)-1      !end of row
  
            do i1 = istart,iend     !loop over components in species

              ic = jax(i1)          !get component index
              
              if (ic.eq.ibl) then
  
!c  allocate symbolic entries, if species contains current component

                do i2 = istart,iend 

                  jbl = jax(i2)     !get column pointer
 
                  if (namec(jbl).ne.'h2o') then
                    kbl(ibl,jbl) = 1
                    
                    if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                      do ibl2 = 1, nbl
                        !set the connection to the redox primary component if column pointer points to the redox secondary component  
                        if (kbl(ibl2,jbl) == 1) then
                          kbl(ibl,ibl2) = 1
                          kbl(ibl2,ibl) = 1
                        end if
                      end do    

                    end if
                  end if

                end do
              end if
            end do
          end do

!c  gaseous species

          do ig = 1,ng                  !loop over gaseous species

            istart = iaga(ig)           !beginning of row
            iend = iaga(ig+1)-1         !end of row

            do i1 = istart,iend         !components in species

              ic = jaga(i1)             !get component index
              if (ic.eq.ibl) then
  
!c  allocate symbolic entries, if species contains current component

                do i2 = istart,iend     !components in species
                  jbl = jaga(i2)        !column pointer

                  if (namec(jbl).ne.'h2o') then
                    kbl(ibl,jbl) = 1 
                  end if
 
                end do
 
              end if
            end do
          end do
          
!c  sorbed species
!c  This part is missing in the previous versions (before v158)
!c  Added by DSU, 2014-02-10
          if(nsb_ion > 0) then              
            do isb = 1, nsb_ion
              istart = iasb_ion(isb)           !beginning of row
              iend = iasb_ion(isb+1)-1         !end of row
            
              do i1 = istart,iend              !components in species                  
            
                ic = jasb_ion(i1)              !get component index
                if (ic.eq.ibl) then    
                    if(all(icur_sorbs(1:n) /= ic,1)) then                    
                        ncur_sorbs = ncur_sorbs + 1
                        icur_sorbs(ncur_sorbs) = ic
                    end if
                end if
              end do
                
            end do          
          end if
          
          if(nsb_surf > 0) then
            do isb = 1, nsb_surf
              istart = iasb_surf(isb)           !beginning of row
              iend = iasb_surf(isb+1)-1         !end of row
            
              do i1 = istart,iend               !components in species
            
                ic = jasb_surf(i1)              !get component index
                if (ic.eq.ibl) then
                    if(all(icur_sorbs(1:n) /= ic,1)) then                    
                        ncur_sorbs = ncur_sorbs + 1
                        icur_sorbs(ncur_sorbs) = ic
                    end if
                end if
              end do              
            end do
          end if

        end do

!c  allocate symbolic entries, if species are included in sorbed component
        if(ncur_sorbs > 0) then
            do i1 = 1, ncur_sorbs
                do i2 = 1, ncur_sorbs
                    ibl = icur_sorbs(i1)
                    jbl = icur_sorbs(i2)
                    if(kbl(ibl,jbl)==0) then
                        kbl(ibl,jbl) = 1
                        kblsorb(ibl,jbl) = 1
                    end if
                end do
            end do
        end if

#ifdef DEBUG
        if (info_debug.gt.0) then
          do ibl=1,n
            write(idbg,'(20(i2))') (kbl(ibl,jbl),jbl = 1,n)
          end do
          write(idbg,*)
        end if
#endif

!c  use full block matrices: fill connectivity list for block matrices 

      else
        kbl = 1
      end if               !sparse_blocks

!c  construct row and column pointer arrays as well as mapping array
!c  for off-diagonal block matrices

      iaobl(1) = 1
      jtemp = 0

      do ibl=1,n                       !loop over rows
        do jbl=1,n                     !loop over columns
          if (kbl(ibl,jbl).ne.0) then
            if(sparse_blocks .and. kblsorb(ibl,jbl) == 1) then
              cycle
            end if
            jtemp = jtemp+1
            jaobl(jtemp) = jbl         !column pointer
            kaobl(ibl,jbl) = jtemp     !conversion full-sparse
          end if
        end do
        iaobl(ibl+1) = jtemp+1         !next row pointer
      end do
      njaobl = jtemp                   !actual number of entries

!c  allocate lumped terms into connectivity list kbl, i.e. entries due
!c  to kinetically controlled redox reactions and mineral dissolution 
!c  precipitation reactions

      if (sparse_blocks .and. .not. multi_diff) then
          
          
!c  kinetically controlled redox reactions 

        if (.not.redox_equil.and.nr.gt.0) then
              
          do ir = 1,nr               !loop over redox couples    
            
            !c get the component index for the redox secondary component
            do ibl = n, nbl
              if (namec(ibl) == namers(ir)) then
                irs = ibl  
              end if
            end do              
              
            istart = iarc(ir)        !beginning of row
            iend = iarc(ir+1)-1      !end of row             

            do i1 = istart,iend      !loop over components in species
              ibl = jarc(i1)         !get component index 
!c  allocate symbolic entries, if species contains current component

              do i2 = istart,iend
                jbl = jarc(i2)     !get column pointer                
                
                if (namec(ibl).ne.'h2o' .and. namec(jbl).ne.'h2o') then
                  kbl(ibl,jbl) = 1
                  kblredox(ibl,jbl) = 1
                  
                  kbl(irs,jbl) = 1
                  kbl(ibl,irs) = 1
                  
                  if (ncur_sorbs > 0) then
                    kblsorb(ibl,jbl) = 0
                    kblsorb(jbl,ibl) = 0
                  end if
                end if
              end do
            end do            
           
          end do
              
        end if                          !(nr.gt.0)
          
          

        do ibl = 1,n                    !loop over rows of block matrix         

!c  dissolution-precipitation reactions

          if (nm.gt.0) then

            do im = 1,nm                  !loop over minerals

              istart = iam(im)            !beginning of row
              iend = iam(im+1)-1          !end of row

              do i1 = istart,iend         !components in species

                ic = jam(i1)              !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend     !components in species

                    jbl = jam(i2)         !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do
                  
                  if(size(iamd,1) .gt. im) then   
                      istart2 = iamd(im)
                      iend2 = iamd(im+1)-1
                      do i2 = istart2, iend2
                        if(size(iamdt, 1) .gt. i2) then    !loop over fractional order terms - total concentrations
                            istart3 = iamdt(i2)
                            iend3 = iamdt(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdt(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdt(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdt(i3)) = 0
                                end if
                            end do
                        end if
                        if(size(iamdc, 1) .gt. i2) then    !loop over product of reacting components as species in solution
                            istart3 = iamdc(i2)
                            iend3 = iamdc(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdc(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdc(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdc(i3)) = 0
                                end if
                            end do
                        end if   
                        
                        if(size(iamdcx, 1) .gt. i2) then    !loop over product of reacting complexed species
                            istart3 = iamdcx(i2)
                            iend3 = iamdcx(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdcx(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdcx(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdcx(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdphm, 1) .gt. i2) then    !loop over product of reacting minerals
                            istart3 = iamdphm(i2)
                            iend3 = iamdphm(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdphm(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdphm(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdphm(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdscx, 1) .gt. i2) then    !loop over product of summed reacting complexed species
                            istart3 = iamdscx(i2)
                            iend3 = iamdscx(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdscx(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdscx(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdscx(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdm, 1) .gt. i2) then    !loop over product of summed reacting complexed species
                            istart3 = iamdm(i2)
                            iend3 = iamdm(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdm(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdm(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdm(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdiso, 1) .gt. i2) then    !loop over isotope sets
                            istart3 = iamdiso(i2)
                            iend3 = iamdiso(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdiso(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdiso(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdiso(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdi, 1) .gt. i2) then      !loop over inhibition terms - T^a
                            istart3 = iamdi(i2)
                            iend3 = iamdi(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdi(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdi(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdi(i3)) = 0
                                end if
                            end do
                        end if   
                        
                        if(size(iamhc, 1) .gt. i2) then      !loop over hyperbolic terms - C^c
                            istart3 = iamhc(i2)
                            iend3 = iamhc(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamhc(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamhc(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamhc(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamic, 1) .gt. i2) then       !loop over inhibition terms - C^c
                            istart3 = iamic(i2)
                            iend3 = iamic(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamic(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamic(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamic(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdpm, 1) .gt. i2) then       !loop over hyperbolic terms - phi^m 
                            istart3 = iamdpm(i2)
                            iend3 = iamdpm(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdpm(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdpm(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdpm(i3)) = 0
                                end if
                            end do
                        end if
                        
                        if(size(iamdpi, 1) .gt. i2) then       !loop over inhibition terms - phi^m
                            istart3 = iamdpi(i2)
                            iend3 = iamdpi(i2+1)-1
                            do i3 = istart3, iend3
                                if(jamdpi(i3) > n) then
                                    cycle
                                end if
                                kbl(ibl, jamdpi(i3)) = 1
                                if (ncur_sorbs > 0) then
                                    kblsorb(ibl, jamdpi(i3)) = 0
                                end if
                            end do
                        end if
                        
                      end do                      
                  end if
                  
                end if
              end do                     
            end do                         !loop over minerals
          end if                           !(nm.gt.0)
          
!c remove this part will cause access error in cygwin           
#ifdef CYGWIN
          if(b_enable_output)  then
            if(naq .gt. 0) then
                write(*,'((a,1x,i6,1x,a))') "rank",rank,               &
                      "adjust block matrix structure for intra-aqueous"
            else
                write(*,'((a,1x,i6,1x,a))') "rank",rank,               &
                      "no intra-aqueous for block matrix"
            end if
          end if
#endif

!c  intra-aqueous kinetic reactions
          if (naq .gt. 0) then

            do iaq = 1,naq                  !loop over intra-aqueous kinetic reactions

              istart = iaaq(iaq)            !beginning of row
              iend = iaaq(iaq+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaq(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaq(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if
                  end do

                end if

              end do 
              
            end do                         !loop over intra-aqueous kinetic reactions
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqt,1) .gt. 1) then

            do iaqt = 1,naq                  !loop over intra-aqueous kinetic reactions

              istart = iaaqt(iaqt)            !beginning of row
              iend = iaaqt(iaqt+1)-1          !end of row

              do i1 = istart,iend           !components in species


                ic = jaaqt(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqt(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqt.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqc,1) .gt. 1) then

            do iaqc = 1,naq                  !loop over intra-aqueous kinetic reactions

              istart = iaaqc(iaqc)            !beginning of row
              iend = iaaqc(iaqc+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqc(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqc(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqc.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqx,1) .gt. 1) then

            do iaqx = 1,naq                  !loop over intra-aqueous kinetic reactions

              istart = iaaqx(iaqx)            !beginning of row
              iend = iaaqx(iaqx+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqx(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqx(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqx.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqht,1) .gt. 1) then

            do iaqht = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqht(iaqht)            !beginning of row
              iend = iaaqht(iaqht+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqht(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqht(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqht.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqhc,1) .gt. 1) then

            do iaqhc = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqhc(iaqhc)            !beginning of row
              iend = iaaqhc(iaqhc+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqhc(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqhc(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqhc.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqhm,1) .gt. 1) then

            do iaqhm = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqhm(iaqhm)            !beginning of row
              iend = iaaqhm(iaqhm+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqhm(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqhm(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqhm.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqit,1) .gt. 1) then

            do iaqit = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqit(iaqit)            !beginning of row
              iend = iaaqit(iaqit+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqit(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqit(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqit.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqic,1) .gt. 1) then

            do iaqic = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqic(iaqic)            !beginning of row
              iend = iaaqic(iaqic+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqic(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqic(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqic.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqim,1) .gt. 1) then

            do iaqim = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqim(iaqim)            !beginning of row
              iend = iaaqim(iaqim+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqim(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqim(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqim.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iaaqhst,1) .gt. 1) then

            do iaqhst = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iaaqhst(iaqhst)            !beginning of row
              iend = iaaqhst(iaqhst+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jaaqhst(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jaaqhst(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naqhst.gt.0)
          
!c  intra-aqueous kinetic reactions
          if (maxval(iamdisoa,1) .gt. 1) then

            do iaq = 1,naq                    !loop over intra-aqueous kinetic reactions

              istart = iamdisoa(iaq)            !beginning of row
              iend = iamdisoa(iaq+1)-1          !end of row

              do i1 = istart,iend           !components in species

                ic = jamdisoa(i1)               !get component index
                if (ic.eq.ibl) then

                  do i2 = istart,iend       !components in species

                    jbl = jamdisoa(i2)          !column pointer

!c  allocate symbolic entries, if species contains current component

                    if (namec(jbl).ne.'h2o') then
                      kbl(ibl,jbl) = 1   
                      if (ncur_sorbs > 0) then
                          kblsorb(ibl,jbl) = 0
                      end if
                      if (nr .gt. 0 .and. jbl > n) then   !check if the namec is the second species in a redox couples 
                        do ibl2 = 1, nbl
                          !set the connection to the redox primary component if column pointer points to the redox secondary component  
                          if (kbl(ibl2,jbl) == 1) then
                            kbl(ibl,ibl2) = 1
                            kbl(ibl2,ibl) = 1
                          end if
                        end do    
                      end if
                    end if

                  end do

                end if

              end do                     
            end do                         !loop over intra-aqueous kinetic reactions
          end if                           !(naq.gt.0)
          
          
          end if                             !(naq.gt.0)
          
        end do
        
!c  additional connectivity for isotope components
!c  for minerals reactions
        if (nm.gt.0 .and. size(iamdiso,1) > 1) then
          do im = 1,nm                  !loop over minerals
            do iiso = iamdiso(im), iamdiso(im+1)-1
              ibl = jamdiso(iiso)
              do iiso2 = iamdiso(im)+1, iamdiso(im+1)-1
                jbl = jamdiso(iiso2)
                if (ibl /= jbl) then
                  !isotope pair connectivity  
                  kbl(ibl,jbl) = 1
                  kbl(jbl,ibl) = 1 
                  do ibl2 = 1, n  
                    !connectivy through direct isotope pair  
                    if (kbl(ibl2,ibl) == 1) then
                      kbl(ibl2,jbl) = 1
                      kbl(jbl,ibl2) = 1
                    end if
                    if (kbl(ibl2,jbl) == 1) then
                      kbl(ibl2,ibl) = 1
                      kbl(ibl,ibl2) = 1
                    end if
                    !connectivy through indirect isotope connectivity 
                    if (kbl(ibl2,ibl) == 1 .or. kbl(ibl2,jbl) == 1) then
                      do jbl2 = 1, n
                        if (kbl(ibl, jbl2) == 1) then
                          kbl(ibl2, jbl2) = 1
                          kbl(jbl2, ibl2) = 1
                        end if
                      end do
                    end if
                  end do
                end if
              end do 
            end do  
          end do
        end if
       
!c  additional connectivity for isotope components     
!c  for intra-aqueous kinetic reactions
        if (naq.gt.0 .and. size(iamdisoa,1) > 1) then
          do iaq = 1,naq                  !loop over minerals
            do iiso = iamdisoa(iaq), iamdisoa(iaq+1)-1
              ibl = jamdisoa(iiso)
              do iiso2 = iamdisoa(iaq)+1, iamdisoa(iaq+1)-1
                jbl = jamdisoa(iiso2)
                if (ibl /= jbl) then
                  !isotope pair connectivity  
                  kbl(ibl,jbl) = 1
                  kbl(jbl,ibl) = 1 
                  do ibl2 = 1, n  
                    !connectivy through direct isotope pair  
                    if (kbl(ibl2,ibl) == 1) then
                      kbl(ibl2,jbl) = 1
                      kbl(jbl,ibl2) = 1
                    end if
                    if (kbl(ibl2,jbl) == 1) then
                      kbl(ibl2,ibl) = 1
                      kbl(ibl,ibl2) = 1
                    end if
                    !connectivy through indirect isotope connectivity 
                    if (kbl(ibl2,ibl) == 1 .or. kbl(ibl2,jbl) == 1) then
                      do jbl2 = 1, n
                        if (kbl(ibl, jbl2) == 1) then
                          kbl(ibl2, jbl2) = 1
                          kbl(jbl2, ibl2) = 1
                        end if
                      end do
                    end if
                  end do
                end if
              end do 
            end do  
          end do
        end if 
        
!c  additional connectivity for isotope components     
!c  for intra-aqueous kinetic reactions
        if (naq.gt.0 .and. size(iaaqht,1) > 1) then
          do iaq = 1,naq                  !loop over minerals
            do iiso = iaaqht(iaq), iaaqht(iaq+1)-1
              ibl = jaaqht(iiso)
              do iiso2 = iaaqht(iaq)+1, iaaqht(iaq+1)-1
                jbl = jaaqht(iiso2)
                if (ibl /= jbl) then
                  !isotope pair connectivity  
                  kbl(ibl,jbl) = 1
                  kbl(jbl,ibl) = 1 
                  do ibl2 = 1, n  
                    !connectivy through direct isotope pair  
                    if (kbl(ibl2,ibl) == 1) then
                      kbl(ibl2,jbl) = 1
                      kbl(jbl,ibl2) = 1
                    end if
                    if (kbl(ibl2,jbl) == 1) then
                      kbl(ibl2,ibl) = 1
                      kbl(ibl,ibl2) = 1
                    end if
                    !connectivy through indirect isotope connectivity 
                    if (kbl(ibl2,ibl) == 1 .or. kbl(ibl2,jbl) == 1) then
                      do jbl2 = 1, n
                        if (kbl(ibl, jbl2) == 1) then
                          kbl(ibl2, jbl2) = 1
                          kbl(jbl2, ibl2) = 1
                        end if
                      end do
                    end if
                  end do
                end if
              end do 
            end do  
          end do
        end if 

        if (info_debug.gt.0) then
          do ibl=1,nbl
            write(idbg,'(20(i2))') (kbl(ibl,jbl),jbl = 1,nbl)
          end do
          write(idbg,*)
          
          !do ibl = 1, n
          !    write(idbg,'(20(i2))') (kblsorb(ibl,jbl),jbl = 1,n)
          !end do
        end if

      end if

!c  construct row and column pointer array as well as mapping array
!c  for off-diagonal block matrices, the diagonal entry is always 
!c  allocated in column 1

      iadbl(1) = 1
      jtemp = 0

      do ibl = 1,n
       
        jbl = 0
        found = .false.
        do while(.not.found.and.jbl.lt.n)
          jbl = jbl+1
          if (ibl.eq.jbl) then      !put diagonal in column 1
            jtemp = jtemp+1
            jadbl(jtemp) = jbl      !column pointer
            kadbl(ibl,jbl) = jtemp  !conversion full-> sparse
            found = .true.
          end if
        end do

!c  non-zero off-diagonal entries

        do jbl = 1,n
          if (ibl.ne.jbl.and.kbl(ibl,jbl).ne.0) then  
            jtemp = jtemp+1
            jadbl(jtemp) = jbl      !column pointer
            kadbl(ibl,jbl) = jtemp  !conversion full-> sparse
          end if
        end do
        
        iadbl(ibl+1) = jtemp+1    !next row pointer
      end do
      njadbl = jtemp              !actual number of entries
      
      if(sparse_blocks .and. .not. multi_diff) then
          if(nsb_ion > 0 .or. nsb_surf > 0) then
              deallocate(icur_sorbs)
          end if
      end if

!cdbg
#ifdef DEBUG
      if (info_debug.gt.0) then
        write(idbg,*) 'njadbl = ',njadbl
        do i=1,n+1
          write(idbg,*) 'iadbl(',i,') = ',iadbl(i)
        end do
        do i=1,n
          istart = iadbl(i)
          iend = iadbl(i+1)-1
          write(idbg,*) ('jadbl(',i1,') = ',jadbl(i1),i1=istart,iend)
        end do
        do i = 1,n
          write(idbg,*) ('kadbl(',i,j,')=',kadbl(i,j),j=1,n) 
        end do
        write(idbg,*) 'njaobl = ',njaobl
        do i=1,n+1
          write(idbg,*) 'iaobl(',i,') = ',iaobl(i)
        end do
        do i=1,n
          istart = iaobl(i)
          iend = iaobl(i+1)-1
          write(idbg,*) ('jaobl(',i1,') = ',jaobl(i1),i1=istart,iend)
        end do
        do i = 1,n
          write(idbg,*) ('kaobl(',i,j,')=',kaobl(i,j),j=1,n) 
        end do
      end if
      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
#endif
!cdbg
    
      return
      end
