!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 492 $
!> $Author: fgerard $
!> $Date: 2017-07-18 13:24:36 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initcpgs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpgs
!c -------------------
!c
!c control parameters for global system
!c modified for optional density dependent flow simulation
!c
!c written by:      Uli Mayer - May 9, 96
!c
!c last modified:   Tom Henderson - August 21, 2002
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           l_time_unit        = length of time_unit for output      * +
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     * +
!c           geo_chemistry      = .true.  -> local or background and  * +
!c                                           source chemistry
!c           reactive_transport = .true.  -> perform reactive         * +
!c                                           transport simulation
!c           steady_flow        = .true.  -> steady state flow        * +
!c           transient_flow     = .true.  -> .not.steady_flow,        * +
!c                                        -> transient flow
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c           varsat_flow        = .true.  -> perform flow simulation  * +
!c
!c           character:
!c           ----------
!c           problem_title      = problem title                       * +
!c           section_header     = section header                      * +
!c           drive              = drive of program installation       * +
!c           time_unit          = time unit for output -> 'years'     * +
!c                                                        'days'
!c                                                        'hours'
!c                                                'seconds'
!c dens.f:   logical:
!c           --------
!c           density_dependence = .true.  -> density-dependant flow 
!c
!c local:    integer*4:
!c           ----------
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c
!c external: readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpgs
 
      use parm
      use gen
      use dens
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: i, l_string

      external readbloc
 
      logical found_section, found_subsection,iserror
      character*72 subsection

!c     set defaults

      drive = 'u'
      density_dependence = .false.

!c  read numerical data and write to temporary file   
   
      section_header = 'global control parameters'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to current output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  read global control parameters 
  
      read(itmp,*,err=999,end=999) problem_title
      read(itmp,*,err=999,end=999) varsat_flow
      read(itmp,*,err=999,end=999) steady_flow
      read(itmp,*,err=999,end=999) fully_saturated
      read(itmp,*,err=999,end=999) reactive_transport
!      read(itmp,*,err=999,end=999) root_uptake !CBF 
      read(itmp,*,err=998,end=999) root_uptake!FG 07-2017 - fast trick to enable reading of trunk benchmarks 
998   continue!FG 07-2017 - fast trick to enable reading of trunk benchmarks
!c  chemical water
      subsection = 'chemical water'
      
	  call findstrg(subsection,itmp,found_subsection)

      chemical_water = .false.
	 
	  if (found_subsection) then
        chemical_water = .true.
        if (steady_flow) then
          if (rank == 0) then  
	        write(ilog,*) 'chemical water and steady flow: not compatible'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop       
        endif
        
      end if
      
!c  number of time steps to skip for writing log file (and on screen)
      skip_time = 0   !initially none
      subsection = 'skipped time steps in log file'
         
	  call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        read(itmp,*,err=999,end=999) skip_time
      
        if (rank == 0 .and. b_enable_output) then
          write(*,*) 'skipped time steps in log file: ', skip_time
          write(ilog,*) 'skipped time steps in log file: ', skip_time
        end if

      end if                 !(found_section)

!c  type of redox reactions

      subsection = 'specify drive of program installation'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        read(itmp,*,err=999,end=999) drive
      end if
      
!c  write version information to tecplot data file or not

      subsection = 'write version to tecplot data file'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
          b_writeversion_tecplot = .true.
      else
          b_writeversion_tecplot = .false.
      end if
      
!cprovi---------------------------------------------------
!cprovi Restart process
!cprovi Based on Richard Amos implementation 
!cprovi and Sergi Molins implementation 
!cprovi---------------------------------------------------
      restart_sim = .false.

      subsection = 'restart'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        restart_sim = .true.
        b_check_restart_time = .true.
        b_restart_update_bcvs = .true.
      else
        b_check_restart_time = .false.
        b_restart_update_bcvs = .false.
      end if
      
      b_max_restart_timestep = .false.
      if (restart_sim) then
        subsection = 'restart at maximum timestep'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_max_restart_timestep = .true.
        end if
      end if
      
#ifdef MPI
      subsection = 'use distributed restart files to read'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        b_distributed_restart_read = .true.
      else
        b_distributed_restart_read = .false.
      end if
#else
      b_distributed_restart_read = .false.
#endif
      
#ifdef MPI
      subsection = 'use distributed restart files to write'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        b_distributed_restart_write = .true.
      else
        b_distributed_restart_write = .false.
      end if
#else
      b_distributed_restart_write = .false.
#endif
      
      subsection = 'use binary restart file to read'
      call findstrg(subsection,itmp,found_subsection)
#ifdef MPI
      if (found_subsection) then
        b_binary_restart_read = .true.
      else
#endif
        if (found_subsection) then
          if (rank == 0) then
            write(ilog,'(a)') 'Binary restart file reading is only available when built with MPI'
          end if
        end if
        b_binary_restart_read = .false.
#ifdef MPI
      end if
#endif
      
      subsection = 'use binary restart file to write'
      call findstrg(subsection,itmp,found_subsection)
#ifdef MPI
      if (found_subsection) then
        b_binary_restart_write = .true.
      else
#endif
        if (found_subsection) then
          if (rank == 0) then
            write(ilog,'(a)') 'Binary restart file writing is only available when built with MPI'
          end if
        end if
        b_binary_restart_write = .false.
#ifdef MPI
      end if
#endif

      subsection = 'ignore restart time'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        ignore_restart_time = .true.
      else
        ignore_restart_time = .false.
      end if

      subsection = 'backup frequency'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        read(itmp,*,err=999,end=999) backup_frequency
      else
        backup_frequency = 100
      end if

 
!c  assign related global control parameters
 
      if ((varsat_flow).and.(reactive_transport)) then
        geo_chemistry = .true.
      elseif ((varsat_flow).and.(.not.reactive_transport)) then
        geo_chemistry = .false.
      elseif ((.not.varsat_flow).and.(reactive_transport)) then
        geo_chemistry = .true.
      elseif ((.not.varsat_flow).and.(.not.reactive_transport)) then
        geo_chemistry = .true.
      end if

      transient_flow = .not.steady_flow
      variably_saturated = .not.fully_saturated

      if (steady_flow.and.(.not.reactive_transport)) then
      time_unit = '-'
      l_time_unit = 1
      end if

! prc --------------------------------------------------------
! prc --------------------------------------------------------
! prc Multicomponenet Diffusion: finding the keyword in the 
! prc subsection and intializing the logical variable
! prc --------------------------------------------------------
! prc --------------------------------------------------------
      multi_diff = .false.
      hmulti_diff = .false.
      

      subsection = 'multicomponent diffusion'
      
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        multi_diff = .true.        
      else
        subsection = 'hybrid multicomponent diffusion'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          multi_diff = .true.
          hmulti_diff = .true.
        end if
      end if

!c  density dependant flow

      subsection = 'density dependent flow'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        density_dependence = .true.
      end if
    
    
!cprovi--------------------------------------------------------
!cprovi  Energy balance block 
!cprovi--------------------------------------------------------
      subsection = 'energy balance'
      heat_transport=.false. 
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        heat_transport = .true.
      end if
    
    
    
!cprovi---------------------------------------------------
!cprovi---------------------------------------------------
!cprovi---------------------------------------------------    
!cprovi---------------------------------------------------
!cprovi Compute Ice Sheet loading  
!cprovi---------------------------------------------------
      compute_ice_sheet_loading = .false.
      compute_permafrost=.false. 
      subsection = 'compute ice sheet loading/unloading'

      call findstrg(subsection,itmp,found_section)

      if (found_section) then

        icestage = -1
        nicestages = -1

        compute_ice_sheet_loading = .true.
        allocate (ice_sheet)
        call create_ (ice_sheet)
        call read_ice_sheet_block_ (ice_sheet,idat,heat_transport,    &
     &                              icetimeline, iserror)
        if (iserror) then
           if (rank == 0) then 
             write(*,*) 'Error when call service read_ice_sheet_block_'
             write(ilog,*) 'Error when call service read_ice_sheet_block_'
             close(ilog)
           end if
#ifdef PETSC
           call petsc_mpi_finalize
#endif
           stop 
        end if
        
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,*) 'Ice Sheet loading/unloading is computed'
        end if
        
        subsection = 'compute permafrost'
        call findstrg(subsection,idat,found_subsection)
        if (found_subsection) then
          if (b_enable_output .and. b_enable_output_gen) then  
            write(igen,*) 'Permafrost is considered'
          end if
          compute_permafrost=.true.          
        end if 
        if (b_enable_output .and. b_enable_output_gen) then
          call write_ (ice_sheet,igen,iserror)
        end if
        if (iserror) then
          if (rank == 0) then  
           write(*,*) 'Error when call service write_'
           write(ilog,*) 'Error when call service write_'
           close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
        end if
    end if
!cdsu--------------------------------------------------------  
!cdsu   Parallel solver configuration file
!cdsu--------------------------------------------------------
        if (.not. b_solver_cfg_arg) then
          subsection = 'parallel solver configuration file'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) str_solvercfg
          else
            str_solvercfg = ""
          end if
        end if
        
!cdsu--------------------------------------------------------  
!cdsu   Output or not
!cdsu   If true, all the output will be disabled. 
!cdsu   Only the final output "normal exit" is kept.
!cdsu   This section has been moved to opngfls subroutine
!cdsu--------------------------------------------------------         
        !b_enable_output = .true.
        !subsection = 'disable output'        
        !call findstrg(subsection,itmp,found_subsection)
        !
        !if (found_subsection) then
        !  b_enable_output  = .false. 
        !end if 

    
!cdsu--------------------------------------------------------  
!cdsu   Output runtime statistics
!cdsu   This is only for test
!cdsu-------------------------------------------------------- 
        if (.not. b_prtfile) then
          subsection = 'output runtime statistics analysis'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            b_prtfile  = .true.
          end if
        end if
        
!cdsu--------------------------------------------------------  
!cdsu   Output sparse matrix data and right hand side
!cdsu   This is only for test
!cdsu-------------------------------------------------------- 
        if (.not. (b_output_matrix .or. b_output_matrix_petsc) .and.   &
            itimestep_output_matrix<0) then
          subsection = 'output sparse matrix data set and rhs'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            b_output_matrix = .true.
            itype_matrix_format = 1
          end if

          subsection = 'output sparse matrix data set and rhs using petsc'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            b_output_matrix_petsc = .true.
            itype_matrix_format = 1
          end if

          subsection = 'output sparse matrix data set and rhs at timestep'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) itimestep_output_matrix
            itype_matrix_format = 1
          else
            itimestep_output_matrix = -1
          end if


        end if
        
!cdsu--------------------------------------------------------  
!cdsu   Output condition number
!cdsu   This is only for test
!cdsu--------------------------------------------------------
        if (.not. b_output_condition_number) then
          subsection = 'output condition number'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            if(b_enable_output)  then
              b_output_condition_number  = .true.
            else
              b_output_condition_number  = .false.
            end if
          end if
        end if
!cprovi--------------------------------------------------------
!cprovi--------------------------------------------------------
!cprovi--------------------------------------------------------    

!c  write run specific information to generic output file
!c  type of simulation

!c  disable the following output if b_enable_output is .false.
      if (b_enable_output .and. b_enable_output_gen) then

!c  New block for density dependent flow

      write(igen,'(a/)') problem_title

      if (.not.density_dependence) then             

        if ((varsat_flow).and.(reactive_transport)) then

          if (steady_flow) then

            if (fully_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'steady state saturated flow ',            &
     &             'and reactive transport'
            elseif (variably_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'steady state variably saturated flow ',   &
     &             'and reactive transport'
            end if                !(fully_saturated/variably_saturated)

          elseif (transient_flow) then

            if (fully_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'transient saturated flow ',               &
     &             'and reactive transport'       
            elseif (variably_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'transient variably saturated flow ',      &
     &             'and reactive transport'
            end if                !(fully_saturated/variably_saturated)

          end if                  !(steady_flow/transient_flow)

        elseif ((varsat_flow).and.(.not.reactive_transport)) then

          if (steady_flow) then

            if (fully_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'steady state saturated flow '     
            elseif (variably_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'steady state variably saturated flow '
            end if                !(fully_saturated/variably_saturated)

          elseif (transient_flow) then

            if (fully_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'transient saturated flow '
            elseif (variably_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'transient variably saturated flow '
            end if                !(fully_saturated/variably_saturated)

          end if                  !(steady_flow/transient_flow)

        elseif ((.not.varsat_flow).and.(reactive_transport)) then

          write(igen,'(a/a)')                                 &
     &          'simulation of:',                             &
     &          'reactive transport with constant velocity field '

        elseif ((.not.varsat_flow).and.(.not.reactive_transport)) then

          write(igen,'(a/a)')                                 &
     &          'simulation of:',                             &
     &          'batch test with kinetically controlled dissolution-',&
     &          'precipitation reactions'

        end if
      end if !.not density-dependence

!c  density dependent flow

      if (density_dependence) then             

        if ((varsat_flow).and.(reactive_transport)) then

          if (steady_flow) then

            if (fully_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'density dependent steady state ',         &
     &             'saturated flow and reactive transport'
            elseif (variably_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'density dependent steady state',          &
     &             'variably saturated flow and reactive transport'
            end if                !(fully_saturated/variably_saturated)

          elseif (transient_flow) then

            if (fully_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'density dependent transient ',            &
     &             'saturated flow and reactive transport'
            elseif (variably_saturated) then
              write(igen,'(2(a/),a)')                         &
     &             'simulation of:',                          &
     &             'density dependent transient',             &
     &             'variably saturated flow and reactive transport'
            end if                !(fully_saturated/variably_saturated)

          end if                  !(steady_flow/transient_flow)

        elseif ((varsat_flow).and.(.not.reactive_transport)) then

          if (steady_flow) then

            if (fully_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'density dependent steady state saturated flow '
            elseif (variably_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'density dependent steady state',          &
     &             'variably saturated flow '
            end if                !(fully_saturated/variably_saturated)

          elseif (transient_flow) then

            if (fully_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'density dependent transient saturated flow '
            elseif (variably_saturated) then
              write(igen,'(a/a)')                             &
     &             'simulation of:',                          &
     &             'density dependent transient',             &
     &             'variably saturated flow '
            end if                !(fully_saturated/variably_saturated)

          end if                  !(steady_flow/transient_flow)

        elseif ((.not.varsat_flow).and.(reactive_transport)) then

          write(igen,'(a/a)')                                 &
     &          'simulation of:',                             &
     &          'reactive transport with constant velocity field '

        elseif ((.not.varsat_flow).and.(.not.reactive_transport)) then

          write(igen,'(a/a)')                                 &
     &          'simulation of:',                             &
     &          'batch test with kinetically controlled dissolution-',&
     &          'precipitation reactions'

        end if
      end if ! density-dependence


!C     Multicomponent diffusion function warning

      if (multi_diff) then
            write(igen,'(2(a/),a)')            &
     &           '',                    &
     &           '!!!!!!!!!! WARNING !!!!!!!!!!',    &
     &           'Multicomponent diffusion is ON',    &
     &           'Make sure initial solution is charge balanced.'
      end if ! (multi_diff)
      
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
