!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 488 $
!> $Author: cblitz $
!> $Date: 2017-07-17 18:22:05 +0200 (lun. 17 juil. 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/cblitz_1/src/min3p/rootwat.F90 $
!---------------------------------------------------------------------
!********************************************************************!
!c -----------------------------------------------------------------------
!c subroutine initplant
!c -------------------
!c
!c plant transpiration and passive/rejective uptake for variably saturated flow
!c  
!c		    Celine Blitz Frayret (CBF) and Frédéric Gérard (FG) - from May 9, 2017 - According to the MIN3P-ArchiSimple
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common: 
!c gen.f:    real*8:
!c           ------- 
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c           sec_per_days       = conversion factor from SI input     + -
!c                                units for physico-chemical
!c                                parameters to internal time units
!c           canopy_int         = canopy interception                 + -
!c           scale_tree_growth  = scale factor to account for the influence
!c                                of the tree growth on transpiration
!c           pet                = potential evapotranspiration        + -
!c           pe_soil            = potential soil evaporation          + -
!c           time_soi           = next read time for etp specific     + -
!c                                parameters
!c
!c
!c           integer*4:
!c           ----------
!c           icnv               = unit number, type conversion and    + -
!c                                temporary storage
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging file         + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           ihyc               = unit number, initial hydraulic      + -
!c                                             conductivity
!c                                             distribution
!c           isoi               = unit number, soil specific          * +
!c                                parameters
!c           itmp               = unit number, temporary storage      + -
!c           itec               = i-index for tecplot                 + -
!c           jtec               = j-index for tecplot                 + -
!c           ktec               = k-index for tecplot                 + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c           logical:
!c           --------
!c           root_uptake        = .true. -> compute root water       * +
!c                                          and passive/rejective
!c                                          solute uptakes
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       * +
!c           section_header     = section header                      * +
!c           zone_name          = name of zone                        * +
!c
!c phys.f:   real*8:
!c           -------
!c           swr(nzn)           = residual saturation                 * +
!c           satwdry(nzn)       = air-dry water saturation            * +
!c           h1dry(nzn)         = air-dry aqueous pressure
!c           satwcrit(nzn)      =  sat value for onset of increased hydr conductivity
!c           canopy_evap_factor = efficiency factor for canopy   * +
!c                                     evaporation
!c
!c           integer*4:
!c           ----------
!c           mprop_name(nzn)    = name of material property zone      + -
!c           nzn                = number of material property zones   + -
!c
!c           logical:
!c           --------
!c           vegetation_growth  = .true. -> account for the effect of vegetation growth
!c                                          on water uptake vs. physical evaporation
!c           rootlengthdens_field = .true.  -> read root length density field
!c                                  .false. -> specify root length density
!c                                             in input file
!c           randomdistrib_root   = .true.  -> randomly distribute root length
!c                                             density read from file
!c
!c biol.f:   integer*4:
!c           ----------
!c           cmws              = computing method for water stress             * +
!c                             if 1 => control volume values of alpha (local REW)
!c                             if 2 => profil scale value of alpha (mean REW used)
!c                             if 3 => no correction
!c           real*8:
!c           -------
!c           canopy_int         = canopy interception                 + -
!c           scale_tree_growth  = scale factor to account for the influence
!c                                of the tree growth on transpiration
!c           pet                = potential evapotranspiration        + -
!c           pe_soil            = potential soil evaporation          + -
!c           time_soi           = next read time for etp specific     + -
!c                                parameters
!c           rootlengthdens(nzn)= root length density (zone)
!c           rld(nn)            = root length density (control vol)
!            h1lim(nzn)         = water pressure at wilting point
!            h1field(nzn)       = water pressure at field capacity
!            h1opt(nzn)         = optimal water pressure (Feddes)
!            satwlim(nzn)       = water saturation at wilting point
!            satwfield(nzn)     = water saturation at field capacity
!            satwopt(nzn)       = optimal water saturation (Feddes correction)
!c           rew0(izn)          = relative extractable water at       * +
!c                                50% of maximum extraction capacity 
!c                                (fitting parameter)
!c           p1(nzn)            = fitting parameter for root water    * +
!c                                uptake function
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c           tiny               = small increment
!c           rdummy             = real*8 dummy variable 
!c           solar_ratio        = ratio between the solar energy at the forest floor
!c                                and this above tree canopy
!c           sumrld             = sum of root length density read in zones (rootlengthdens(izn) !! FG,5, april 08
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           ivol               = counter
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c      
!c           update_root_rld = .true. -> 'update root' for
!c                                        rootgenthdensity          
!c           izn                = counter (zones)
!c           l_string           = length of text string   
!c           inside_rld = .true. -> root length density
!c                                  updated internally
!c           coupled_archi_rld = .true. -> coupling
!c                                         with Archisimple
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c           cdummy             = character dummy variable
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           satfpres  = compute saturation from pressure
!c ----------------------------------------------------------------------
    
 
    
      subroutine initplant

      
      use parm
      use gen
      use phys
      use biol
      use file_unit, only : lun_get !CBF : fct to assign isoi number when opening *.soi file

      implicit real*8 (a-h,o-z)

      external findstrg, readbloc, satfpres

      logical found_section, found_subsection
      character*72 subsection
	character*1 cdummy,temppy*15

	real*8 :: aa, bb, cc

	parameter (r0 = 0.0d0, r1 = 1.0d0,tiny = 1.0d-10)

!c  set defaults

	vegetation_growth = .false.
	rootlengthdens_field = .false.
	randomdistrib_root = .false.

	sumrld= r0 ! FG, 5 (initialisation)
    time_rld=1.0d0 !FG dec 2013 initialization time rld
    
    update_root_rld = .false.
    inside_rld = .false.
    coupled_archi_rld = .false.
    coupled_sirius = .false.
    
!c  call subroutine to store in memory the evapo-transpiration parameters
!c  (from wm version)
     
	call mem_etr

!c  read parameters for variably saturated flow and write 
!c  to temporary file
 
      section_header ='plant transpiration and passive/rejective uptake'

      call readbloc (idat,itmp,section_header,found_section,.true.)
	
	

!c  define length of section header

      l_string = index(section_header,'  ')-1

      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

     if (.not.found_section) then

        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'" missing'
       stop
 
     elseif (found_section) then
!c
!c  Growing vegetation switch
!c
       
        subsection = 'growing vegetation'
        call findstrg(subsection,itmp,found_subsection)
        
       if (found_subsection) then !FG 07-2017
	   	vegetation_growth = .true.
	 	write(igen,*) 'growing vegetation'

	   else

        write(igen,*) 'steady vegetation'

       endif!growing above ground or not

!c
!c  read root length density from file ------------------------------------------------
!c

      subsection = 'read root length density from file'

         call findstrg(subsection,itmp,found_subsection)         

         if (found_subsection) then
      
            write(*,*) 'Initial root density read from file'!FG 28,Dec 2013

            rootlengthdens_field = .true.
            
!FG feb 2016 - open file containing root length density distribution, input directory specified as file read in this case
  	      irld = 81 ! unit number
          open(irld,file=prefix(:l_prfx)//'.rld',status='unknown',&
     &          form='formatted')
!-----------------------------

            read(irld,*,err=998,end=998) cdummy
            
		  do ivol = 1,nn
              
			read(irld,*,err=998,end=998) rdummy, rdummy, rdummy,&
    &                                     rld(ivol)
	      enddo
            
!c  feed-back in output file

            write(igen,'(3a)') 'read as nodal properties from file ',&
    &                          prefix(:l_prfx)//'.rld'
     	    
      	endif !end reading rld from external file
          

       if (.not.steady_flow) then!FG feb 2016 - suite of option that can operate with transient flow only
!          
! Update root length density either internally or coupled with Archisimple model 
!      
        subsection = 'update root'
      
        call findstrg(subsection,itmp,found_subsection)
       
        if(found_subsection) then
         update_root_rld = .true.
         write(*,*) 'root density updated'
         write(igen,*) 'root density updated'
        
!check for the update method
        
         subsection = 'internal'

         call findstrg(subsection,itmp,found_subsection)

         if(found_subsection) then
          inside_rld = .true.
          write(*,*) 'internal root density update'
          write(ilog,*) 'Internal root density update'
          write(igen,*) 'Internal root density update'
          
!          pause
       
         else !FG internal not found, then seek for coupled
        
          subsection = 'coupled'!check for coupled if root update true 
       
          call findstrg(subsection,itmp,found_subsection)
       
           if(found_subsection) then!FG la condition update root n'est plus necessaire ici maintenant
           
            coupled_archi_rld = .true. 
            compt_rld_coupled = 0
            
            write(*,*) 'coupled with ArchiSimple' !FG ajout car toujours utile de preciser cela au moins a l'ecran (comme fait plus haut pour la lecture des rld init dans fichier externe)
            write(ilog,*) 'Coupled with ArchiSimple' !FG jan 2017 -  to write in log file as well
            write(igen,*) 'Coupled with ArchiSimple'    
            
            
        else !TR internal and coupled not found, then seek for coupled with Sirius
        
          subsection = 'sirius'!check for coupled with sirius if root update true 
       
          call findstrg(subsection,itmp,found_subsection)
       
           if(found_subsection) then
           
            coupled_sirius = .true. 
            compt_rld_coupled = 0
            
            write(*,*) 'coupled with Sirius'
            write(ilog,*) 'Coupled with Sirius' !TR jan 2021 -  to write in log file as well
            write(igen,*) 'Coupled with Sirius'
            
          
           else  !FG no method selected for root update , but root update = true => input error
           
            write(*,*) 'Input error: root density update selected but'
            write(*,*) 'update method?'
            write(igen,*)'Input error: root density update selected but'
            write(igen,*)'update method?'
            stop
           
           endif!coupled found
           
           endif !sirius found
           
         endif!method to update root dens
            
        endif!update root or not
            
       endif ! check for no steady flow

!c
!c Read correction method for water stress
!c

          subsection = 'correction method for water stress'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then 

          	read(itmp,*,err=999,end=999) cmws
            	write(igen, '(/a,11x,a,i1/)')          &   !CBF : instead of 'i', I wrote 'i1'
     &        	'correction method for water stress :',' =',cmws
           else

	      	    write(ilog,*) 'SIMULATION TERMINATED'
             	write(ilog,*) 'error reading input file'
            	write(ilog,*) 'correction method for water stress missing'
            	stop

           endif
           
!c
!c Read global parameters for evapotranspiration processes (crop factor only!FG dec 2020)
!c
            subsection = 'transpiration global parameter'

            call findstrg(subsection,itmp,found_subsection)

            if (found_subsection) then

                read(itmp,*,err=999,end=999) canopy_evap_factor

		        write(igen, '(/a/,3(a,18x,a,1pe10.3/))')              &
     &           'canopy evaporation factor:  ',' = ',           &
     &            canopy_evap_factor
      

            elseif (.not.found_subsection) then

                  if (rank == 0) then

                  	l_string = index(subsection,'  ')-1
                  	if (l_string.eq.-1.or.l_string.gt.72) then
                     		l_string=72
                  	end if

                  	write(ilog,*) 'SIMULATION TERMINATED'
                  	write(ilog,*) 'error reading input file'
                  	write(ilog,*) 'subsection "',subsection(:l_string),   &
     &                          '" missing'
                  	close(ilog)
                  end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

            end if !subsection

! FG dec 2020 read Battaglia reduction function parameters if needed
            
           if ((cmws.eq.1).or.(cmws.eq.2)) then
        
             subsection = 'Battaglia function parameters'

             call findstrg(subsection,itmp,found_subsection)

              if (found_subsection) then

            	read(itmp,*,err=999,end=999) rew0 !FG dec 2020 - scalar used as it must
            	read(itmp,*,err=999,end=999) p1   !FG dec 2020 - scalar used as it must

		        write(igen, '(/a/,3(a,18x,a,1pe10.3/))')             &
     &           'Battaglia function parameters',                &
     &	         'fitting parameter rew0:     ',' = ',rew0,         & 
     &           'fitting parameter p1:       ',' = ',p1


               elseif (.not.found_subsection) then

                  if (rank == 0) then

                  	l_string = index(subsection,'  ')-1
                  	if (l_string.eq.-1.or.l_string.gt.72) then
                     		l_string=72
                  	end if

                  	write(ilog,*) 'SIMULATION TERMINATED'
                  	write(ilog,*) 'error reading input file'
                  	write(ilog,*) 'subsection "',subsection(:l_string),   &
     &                          '" missing'
                  	close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop               
          
                endif! subsection
           endif !FG dec2020 cmws = 1 or 2

!c  read material properties for material property zones from input file
	           
        do izn = 1,nzn                !loop over property zones

!c  assign defaults for physical parameters for variably saturated flow

          spstor(izn) = r0

!c  search for entry for material property zone in input file

          zone_name = mprop_name(izn)

!c  define length of name of material property zone

          l_zone_name = index(zone_name,'  ')-1
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
            l_zone_name = 72
          end if

!c  search temporary data file for current material property zone
!c  and write to scratch file

          call readbloc (itmp,icnv,zone_name,found_subsection,.true.)

!c  read material properties

      	if (found_subsection) then

!c  read parameters for root water uptake
            
           subsection = 'root water uptake'

           call findstrg(subsection,icnv,found_subsection)

		   if (found_subsection) then
            
              if (cmws.ne.3) then !FG dec 2020 if reduction factor set read soil parameters
                read(icnv,*,err=999,end=999) h1lim(izn) !FG dec 2020
                read(icnv,*,err=999,end=999) h1opt(izn) !FG dec 2020 ! used only for Feddes and van genuchten corrections
                read(icnv,*,err=999,end=999) h1field(izn) !FG dec 2020          
              endif ! cmws
            
!read input file root length density
               if (.not.rootlengthdens_field) then
                 read(icnv,*,err=999,end=999) rootlengthdens(izn)
               end if	

!c  if a correction function is used (cmws not eq to 3), calculate water saturation at wilting point, field capacity, + optimal pressure
!c                                                       and check if values are consistent
               
               if (cmws.ne.3) then !FG dec 2020
      
                	satwlim(izn)=satfpres(swr(izn),aentry(izn),h1lim(izn),     &
     &               spalpha(izn),spbeta(izn),spgamma(izn))	!wilting point	  
                    

	          	    satwfield(izn)=satfpres(swr(izn),aentry(izn),h1field(izn),    &
     &               spalpha(izn),spbeta(izn),spgamma(izn)) !field capacity
                    
                    
                    if ((cmws.eq.4).or.(cmws.eq.5)) then !FG dec 2020
     	              satwopt(izn)=satfpres(swr(izn),aentry(izn),h1opt(izn),    &
     &                spalpha(izn),spbeta(izn),spgamma(izn))
                    endif
                    
                    if (h1dry(izn).gt.0) then!FG calculate satdry if any
                     satwdry(izn)=satfpres(swr(izn),aentry(izn),h1dry(izn),    & !FG 07-2017 calculate satdry
     &               spalpha(izn),spbeta(izn),spgamma(izn))
                    
                    else!set to dummy (0) value if h1dry set to 0 in this layer, as unused in this case
                     satwdry(izn) = 0.0
                    endif
                    
        write(*,*) 'satwlim(izn)', satwlim(izn)
        write(*,*) 'satwfield(izn)', satwfield(izn)
        write(*,*) 'satwopt(izn)', satwopt(izn)
        write(*,*) 'satwdry(izn)', satwdry(izn)
!c
!c  check allowed values of satw
!c
!c  satfield lesser or equal to 1
                    satwfield(izn) = min(satwfield(izn),1.0)
!c  satwdry always greater than sat residual
                	satwdry(izn) = max(satwdry(izn)+tiny,swr(izn))
!c  satwlim always greater  than sat residual
	                satwlim(izn)= max(satwlim(izn)+tiny,swr(izn))
                    
!c  avoid inconsistent values of sat field (>) sat lim

	          if (satwlim(izn).gt.satwfield(izn)) then
                  	write(ilog,*) 'SIMULATION TERMINATED'
                  	write(ilog,*) 'error reading input file'
                  	write(ilog,*) 'psifield > psilim'
                  	write(ilog,*) 'in property zone number : ',izn
	            	stop
              endif

!FG dec 2020 same but for satwop, which must be > than  satwlim   

                if ((cmws.eq.4).or.(cmws.eq.5)) then                
                 if (satwlim(izn).gt.satwopt(izn)) then                
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error reading input file'
                  write(ilog,*) 'psiopt > psilim'    
                  write(ilog,*) 'in property zone number : ',izn
                  stop  
                  
!FG dec 2020 same but for satwopt, which must be comprised between satwlim and satwfiedl      

                 elseif (satwopt(izn).gt.satwfield(izn)) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error reading input file'
                    write(ilog,*) 'psifield > psiopt'    
                    write(ilog,*) 'in property zone number : ',izn
	                stop
                 endif
                endif !cmws 4 or 5
               endif !FG dec 2020 cmws ne 3
          else ! if not found_subsection 'root water uptake'

!		
                  if (rank == 0) then

                  	l_string = index(subsection,'  ')-1
                  	if (l_string.eq.-1.or.l_string.gt.72) then
                     		l_string=72
                  	end if

                  	write(ilog,*) 'SIMULATION TERMINATED'
                  	write(ilog,*) 'error reading input file'
                  	write(ilog,*) 'subsection "',subsection(:l_string),   &
     &                          '" missing'
                  	close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

            
	       endif !found_subsection 'root water uptake'

!c  read parameters for passive solute uptake

 			subsection = 'passive solute uptake'

              call findstrg(subsection,icnv,found_subsection)

            if (found_subsection) then
			  read(icnv,*,err=999,end=999) uptakefactor(izn)
	        else
 		        write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'passive uptake with transpiration'
                write(ilog,*) 'passive uptake factor must be set'
	        end if

			write(igen,'(/a/,7(a,18x,a,1pe10.3/),a,18x,a,1pe10.3)')    &
     &		'root uptake parameters:',     &
     &		'saturation at wilting point: ',' = ',satwlim(izn),    &
     &        'saturation at field capacity:',' = ',satwfield(izn),    &
     &        'root length density         :',' = ',     &
     &         rootlengthdens(izn)

!c  conversion of time units for computation in days

          elseif (.not.found_subsection) then

		   if (rank == 0) then

                  	l_string = index(subsection,'  ')-1

                 	 if (l_string.eq.-1.or.l_string.gt.72) then
                     		l_string=72
                  	end if

            		write(ilog,*) 'SIMULATION TERMINATED'
            		write(ilog,*) 'error reading section "',	&
     &                     section_header(:l_string),'" ',	&
     &                    'in input file'

            		write(ilog,*) 'entry for material property zone "',	&
     &                     zone_name(:l_zone_name),'" missing'	

	      		    write(ilog,*) 'error may also be caused by missing or ',	&
     &                    'mispelled keyword for nodal property ',	&
     &                    'zone input'
            		stop

            endif ! rank==0


        end if   !(found_subsection)

        end do                            !loop over property zones

!c  open file containing time dependent parameters for root water 
!c  uptake and physical evaporation and read/calculate initial values

        isoi = lun_get()


        open(isoi,file=prefix(:l_prfx)//'.soi',          &
     &            err=997, status='old')

	
 	  read(isoi,*,err=998,end=998) time_soi,pet,canopy_int,         &
     &                               solar_ratio,scale_tree_growth

	  !pe_soil = pet*solar_ratio*sec_per_days
      pe_soil = ep_sirius
	  !pet = pet * sec_per_days
      pet = ep_sirius + tp_sirius
	  canopy_int = canopy_int*sec_per_days

!c
!c assign zone-defined root length density to each control volume
!c
        if (.not.rootlengthdens_field) then
		 do ivol=1,nn
			izn=mpropvs(ivol)
			rld(ivol)=rootlengthdens(izn)
		 enddo
	    endif

!c
!c assign zone-defined uptake factor to each control volume
!c
		do ivol=1,nn
			izn=mpropvs(ivol)
            puf(ivol) = uptakefactor(izn)	
        enddo

!calculate if (initial) rld = 0 (to check if no root, in rootwat function) 
            do ivol = 1,nn
              sumrld = sumrld + rld(ivol)
            enddo
            if (sumrld.eq.0.0) then
              rootdensitynill =.true.
            endif

!FG july 2017 - rewind and close if file has been read
          if (rootlengthdens_field) then
           rewind(irld)
! if rld not already opened for reading, open it here
          else
           irld = 81 ! unit number
           open(irld,file=prefix(:l_prfx)//'.rld',status='unknown',&
     &          form='formatted')
	      endif
!FG july 2017 - (re)write initial root length density in external file (rld suffix)
          write(irld,'(2a)') 'variables = "x", "y", "z", "rld"'
	    
           do ivol=1,nn

		    write(irld,'(6e15.7)') xg(ivol),yg(ivol),zg(ivol),&
     &                            rld(ivol)
            
           enddo
          
		   close (irld) ! close file after writing, as reading (optional) passed  
    
     endif!found datablock 17 correct heading or not
          
	goto 1000

997   write(ilog,*) 'SIMULATION TERMINATED' 
      write(ilog,*) 'file ', prefix(:l_prfx)//'.soi missing'
      stop

998   write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error reading nodal material properties field ','from file'
      write(ilog,*) 'section "',section_header(:l_string),'"'
      stop

999   write(ilog,*) 'SIMULATION TERMINATED'
      write(ilog,*) 'error reading input file'
      write(ilog,*) 'section "',section_header(:l_string),'"'
      stop
      

1000  return
      end
