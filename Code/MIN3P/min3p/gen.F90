!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/gen.F90 $
!---------------------------------------------------------------------
!********************************************************************!

      module gen 

      use parm
      use m_ice_sheet
      use m_heat_transport
      use multidiff
      
      implicit none

! ---------------------------------------------------------------------- 
! common - general variables
!
! ---------------------------------------------------------------------- 
! global control parameters:
! --------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cpuint             = cpu-time (intermediate) [seconds]
!           csec               = cpu-time [seconds]
!           por_thresh_max     = maximum porosity threshold          * +
!                                avoid division by 0 in 
!                                Kozeny-Carman equation
!           por_thresh_min     = minimum porosity threshold          * +
!           permfac_thresh_max = maximum permeability factor threshold  * +
!           permfac_thresh_min = minimum permeability factor threshold  * +
!           marchie            = updated tortuosity as the function
!                                of changed porosity
!                                tau = tau_0 * por^alpha / por_0^alpha
!                                tau_0 = assigned tau or por_0^alpha
!                                marchie = alpha
!
!           logical:
!           --------
!           depth_output       = .true.  -> output in terms of
!                                           depth instead of 
!                                           elevation
!           root_uptake        = .true.  -> calculate root water
!                                           uptake
!           full_path          = .true.  -> path for database
!                                           specified in problem
!                                           specific input file
!           fully_saturated    = .true.  -> saturated conditions 
!           geo_chemistry      = .true.  -> local or background and   
!                                           source chemistry         
!           log_file           = .true.  -> write logbook to file
!           not_converged      = .true.  -> continue Newton 
!                                           iteration
!           reactive_transport = .true.  -> perform reactive          
!                                           transport simulation      
!           show_module        = .true.  -> write current module
!                                           name to screen
!           steady_flow        = .true.  -> steady state flow
!           update_porosity    = .true.  -> update porosity as
!                                           a result of dissolution-
!                                           precipitation reactions
!           update_permeability= .true.  -> update permeability as
!                                           a function of porosity
!           transient_flow     = .true.  -> .not.steady_flow,
!                                        -> transient flow
!           variably_saturated = .true.  -> .not.fully_saturated,
!                                        -> variably saturated 
!                                           conditions
!           varsat_flow        = .true.  -> perform flow simulation   
!           pure_evap          = .true.  -> pure evaporation (when root_uptake = false) CBF
!           update_tortuosity  = .true.  -> update tortuosity as 
!                                           tau = tau_0*por^tor_factor/
!                                                 por_o^tor_factor
!           assign_marchies    = .true.  -> update tortuosity as a function 
!                                           of tau = tau_0 * (por_0/por)^alpha
!
!           character:
!           ----------
!           problem_title      = problem title
!           dbs_dir            = database directory
!           drive              = drive of program installation
!        -->                                                         <--
! ---------------------------------------------------------------------- 

      real (type_r8) :: cpuint 
      real (type_r8) :: csec
      real (type_r8) :: por_thresh_max
      real (type_r8) :: por_thresh_min
      real (type_r8) :: permfac_thresh_max
      real (type_r8) :: permfac_thresh_min      

      logical :: varsat_flow 
      logical :: steady_flow 
      logical :: transient_flow 
      logical :: not_converged
      logical :: full_path
      logical :: fully_saturated
      logical :: variably_saturated
      logical :: geo_chemistry
      logical :: reactive_transport
      logical :: show_module 
      logical :: log_file 
      logical :: depth_output
      logical :: harmonic_porosity
      logical :: update_porosity
      logical :: update_permeability
      logical :: update_porosity_flow
      logical :: update_permeability_flow
      logical :: iterative_solver_flow
      logical :: root_uptake
      logical :: radial_coord
      logical :: update_tortuosity
      logical :: assign_marchies
      logical :: pure_evap

      character*72 :: problem_title
      character*256 :: dbs_dir
      character*1 ::  drive

      

! ---------------------------------------------------------------------- 
! global constants:
! -----------------
!        -->                                                         <--
!           real*8:
!           -------
!           sec_per_days       = conversion factor from SI input
!                                units for physico-chemical 
!                                parameters to internal time units
!           gacc               = gravity acceleration
!        -->                                                         <--
! ---------------------------------------------------------------------- 

      real (type_r8) :: sec_per_days
      real (type_r8) :: gacc
      
! ---------------------------------------------------------------------- 
! spatial discretization:
! -----------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cvol(nn)           = nodal volumes
!           delx(nvx)          = spatial increment in x-direction         
!           dely(nvy)          = spatial increment in y-direction         
!           delz(nvz)          = spatial increment in z-direction         
!           dimcv(3,nn)        = dimension of control volumes
!           elevmax            = max. elevation in solution domain
!           xg(nn)             = spatial coordinates in x-direction
!           yg(nn)             = spatial coordinates in y-direction
!           zg(nn)             = spatial coordinates in z-direction
!           xglat(nvx)         = spatial coordinates in x-direction
!           yglat(nvy)         = spatial coordinates in y-direction
!           zglat(nvz)         = spatial coordinates in z-direction
!           xmax(nxx)          = max. coordinate of discretization 
!                                interval in x-direction
!           xmin(nxx)          = min. coordinate of discretization 
!                                interval in x-direction
!           ymax(nyy)          = max. coordinate of discretization 
!                                interval in y-direction
!           ymin(nyy)          = min. coordinate of discretization
!                                interval in y-direction
!           zmax(nzz)          = max. coordinate of discretization
!                                interval in z-direction
!           zmin(nzz)          = min. coordinate of discretization
!                                interval in z-direction
!	    toparea            = profil area exposed to atmosphere ! CBF ADDED
!
!           integer:
!           --------
!           nxx                = number of intervals in x-direction  
!           nyy                = number of intervals in y-direction 
!           nzz                = number of intervals in z-direction
!           nvix(nxx)          = number of control volumes in 
!                                x-direction (intervals)
!           nviy(nyy)          = number of control volumes in 
!                                y-direction (intervals)
!           nviz(nzz)          = number of control volumes in 
!                                z-direction (intervals)
!           nvx                = number of control volumes in 
!                                x-direction
!           nvy                = number of control volumes in 
!                                y-direction
!           nvz                = number of control volumes in 
!                                z-direction
!           nvxgl              = number of control volumes in 
!                                x-direction with ghost nodes
!           nvygl              = number of control volumes in 
!                                y-direction with ghost nodes
!           nvzgl              = number of control volumes in 
!                                z-direction with ghost nodes
!           nn                 = total number of control volumes without ghost nodes
!
!           nngl               = total number of control volumes with ghost nodes
!
!           nn_interfacial     = total number of interfacial area contained within 
!                                elemental volume 
!
!           nn_offset          = offset of control volumes without ghost nodes
!
!           nngl_offset        = offset of control volumes with ghost nodes
!
!           nn_interfacial_offset
!                              = offset of interfacial area contained within 
!                                elemental volume 
!
!           nn_ranks(nprcs)    = total number of control volumes without ghost nodes 
!                                for each rank
!
!           nngl_ranks(nprcs)  = total number of control volumes with ghost nodes
!                                for each rank
!
!           nn_interfacial_ranks(nprcs)
!                              = total number of interfacial area contained within 
!                                elemental volume for each rank
!
!           nvxgbl             = number of control volumes in 
!                                x-direction for global grid
!           nvygbl             = number of control volumes in 
!                                y-direction for global grid
!           nvzgbl             = number of control volumes in 
!                                z-direction for global grid
!           nngbl              = total number of control volumes
!                                for global grid
!           nvxls              = start number (1-based) of control volumes in
!                                x-direction for local grid
!           nvxle              = end number (1-based) of control volumes in
!                                x-direction for local grid
!           nvyls              = start number (1-based) of control volumes in
!                                y-direction for local grid
!           nvyle              = end number (1-based) of control volumes in
!                                xy-direction for local grid
!           nvzls              = start number (1-based) of control volumes in
!                                z-direction for local grid
!           nvzle              = end number (1-based) of control volumes in
!                                z-direction for local grid
!           nvxgls             = start number (1-based) of control volumes in
!                                x-direction for local grid
!           nvxgle             = end number (1-based) of control volumes in
!                                x-direction for local grid
!           nvygls             = start number (1-based) of control volumes in
!                                y-direction for local grid
!           nvygle             = end number (1-based) of control volumes in
!                                xy-direction for local grid
!           nvzgls             = start number (1-based) of control volumes in
!                                z-direction for local grid
!           nvzgle             = end number (1-based) of control volumes in
!                                z-direction for local grid
!           xlmin              = min coordinate in x direction for local grid, without grid node
!           xlmax              = max coordinate in x direction for local grid, without grid node
!           ylmin              = min coordinate in y direction for local grid, without grid node
!           ylmax              = max coordinate in y direction for local grid, without grid node
!           zlmin              = min coordinate in z direction for local grid, without grid node
!           zlmax              = max coordinate in z direction for local grid, without grid node
!
!           gxlmin             = min coordinate in x direction for local grid, with grid node
!           gxlmax             = max coordinate in x direction for local grid, with grid node
!           gylmin             = min coordinate in y direction for local grid, with grid node
!           gylmax             = max coordinate in y direction for local grid, with grid node
!           gzlmin             = min coordinate in z direction for local grid, with grid node
!           gzlmax             = max coordinate in z direction for local grid, with grid node
!           
!           xlmingbl             = min coordinate in x direction for global grid
!           xlmaxgbl             = max coordinate in x direction for global grid
!           ylmingbl             = min coordinate in y direction for global grid
!           ylmaxgbl             = max coordinate in y direction for global grid
!           zlmingbl             = min coordinate in z direction for global grid
!           zlmaxgbl             = max coordinate in z direction for global grid
!
!           logical:
!           --------
!           half_cells         = .true.  -> half cells on boundary
!        -->                                                         <--
! ---------------------------------------------------------------------- 


      real (type_r8), allocatable :: xg(:)
      real (type_r8), allocatable :: yg(:)
      real (type_r8), allocatable :: zg(:)
      real (type_r8), allocatable :: xglat(:)
      real (type_r8), allocatable :: yglat(:)
      real (type_r8), allocatable :: zglat(:)      
      real (type_r8), allocatable :: dimcv(:,:)
      real (type_r8), allocatable :: cvol(:)
      real (type_r8), allocatable :: delx(:)
      real (type_r8), allocatable :: dely(:)
      real (type_r8), allocatable :: delz(:)
      real (type_r8), allocatable :: xmax(:)
      real (type_r8), allocatable :: xmin(:)
      real (type_r8), allocatable :: ymax(:)
      real (type_r8), allocatable :: ymin(:)
      real (type_r8), allocatable :: zmax(:)
      real (type_r8), allocatable :: zmin(:)

      real (type_r8) :: elevmax
      real (type_r8) :: toparea ! CBF

      integer (type_i4), allocatable :: nvix(:)
      integer (type_i4), allocatable :: nviy(:)
      integer (type_i4), allocatable :: nviz(:)

      integer (type_i4) :: nxx
      integer (type_i4) :: nyy
      integer (type_i4) :: nzz
      integer (type_i4) :: nvx
      integer (type_i4) :: nvy
      integer (type_i4) :: nvz
      integer (type_i4) :: nvxgl
      integer (type_i4) :: nvygl
      integer (type_i4) :: nvzgl      
      integer (type_i4) :: nn
      integer (type_i4) :: nngl
      integer (type_i4) :: nn_interfacial
      integer (type_i4) :: nn_offset
      integer (type_i4) :: nngl_offset
      integer (type_i4) :: nn_interfacial_offset
      integer (type_i4), allocatable :: nn_ranks(:)
      integer (type_i4), allocatable :: nngl_ranks(:)
      integer (type_i4), allocatable :: nn_interfacial_ranks(:)
      integer (type_i4) :: nvxgbl
      integer (type_i4) :: nvygbl
      integer (type_i4) :: nvzgbl
      integer (type_i4) :: nngbl
      integer (type_i4) :: nvxls
      integer (type_i4) :: nvxle
      integer (type_i4) :: nvyls
      integer (type_i4) :: nvyle
      integer (type_i4) :: nvzls
      integer (type_i4) :: nvzle
      integer (type_i4) :: local_node_start
      integer (type_i4) :: local_node_end
      
      integer (type_i4) :: nvxgls
      integer (type_i4) :: nvxgle      
      integer (type_i4) :: nvygls      
      integer (type_i4) :: nvygle      
      integer (type_i4) :: nvzgls      
      integer (type_i4) :: nvzgle  
      
      real (type_r8) :: xlmin
      real (type_r8) :: xlmax
      real (type_r8) :: ylmin
      real (type_r8) :: ylmax
      real (type_r8) :: zlmin
      real (type_r8) :: zlmax 
      
      real (type_r8) :: gxlmin
      real (type_r8) :: gxlmax
      real (type_r8) :: gylmin
      real (type_r8) :: gylmax
      real (type_r8) :: gzlmin
      real (type_r8) :: gzlmax

      real (type_r8) :: xlmingbl
      real (type_r8) :: xlmaxgbl
      real (type_r8) :: ylmingbl
      real (type_r8) :: ylmaxgbl
      real (type_r8) :: zlmingbl
      real (type_r8) :: zlmaxgbl

      logical :: half_cells

! ----------------------------------------------------------------------
! time step control:
! ------------------
!        -->                                                         <--
!           real*8:
!           -------
!           delta_c(n)         = actual update in log cycles
!           delta_c_max(n)     = maximum update in log cycles
!           delt               = time step         
!           delt_io            = time step (I/O units)        
!           delt_vs            = estimated time step 
!                                (variably saturated flow)
!           delt_rt            = estimated time step 
!                                (reactive transport)
!           deltmax            = maximum time step
!           deltmin            = minimum time step
!           time               = current solution time
!           time_io            = current solution time (I/O units)
!           time_factor        = conversion factor from I/O time
!                                units to internal time units
!           tfinal             = final solution time
!           urtant_log         = anticipated update in log cycles
!
!           integer:
!           --------
!           l_time_unit        = length of time unit for output
!           mtime              = current time step
!           mtime_f            = number of failed time steps
!
!           logical:
!           --------
!           reduce_timestep    = .true.  -> restart with reduced
!                                           timestep
!
!           ignore_restart_time= .true.  -> ignore the time stamp in 
!                                           restart file
!           character:
!           ----------
!           time_unit          = time unit for output -> 'years'
!                                                        'days'
!                                                        'hours'
!                                                        'seconds'
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: delta_c(:)
      real (type_r8), allocatable :: delta_c_max(:)

      real (type_r8) :: time
      real (type_r8) :: time_io
      real (type_r8) :: time_factor
      real (type_r8) :: tfinal
      real (type_r8) :: delt
      real (type_r8) :: delt_io
      real (type_r8) :: delt_vs
      real (type_r8) :: delt_rt
      real (type_r8) :: deltmin
      real (type_r8) :: deltmax
      real (type_r8) :: urtant_log

      integer (type_i4) :: l_time_unit
      integer (type_i4) :: mtime
      integer (type_i4) :: mtime_f

      logical :: reduce_timestep
      logical :: ignore_restart_time
      logical :: b_check_restart_time
      logical :: b_restart_update_bcvs

      character*12 :: time_unit

! ----------------------------------------------------------------------
! control parameters for I/O:
! ---------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           gs_tout(ngs)       = specified output times for
!                                contour data 
!
!           integer:
!           --------
!           iamb(nmb)          = pointer array for selected 
!                                species to species concentration
!                                arrays
!           idat               = unit number, run specific input 
!                                             file
!           igen               = unit number, generic output file
!           ifls               = unit number, file information
!           idbg               = unit number, debugging file
!           ilog               = unit number, logbook file
!           idelt              = unit mumber, magnitude of current
!                                             time step
!           itmp               = unit number, temporary storage
!           icnv               = unit number, data conversion
!           ihyc               = unit number, initial hydraulic
!                                             conductivity
!                                             distribution
!           ivel               = unit number, average interfacial 
!                                             velocities
!           icdbs              = unit number, database for
!                                             components
!           igdbs              = unit number, database gases 
!           imdbs              = unit number, database for minerals
!           irdbs              = unit number, database for redox 
!                                             couples
!           isdbs              = unit number, database for sorbed
!                                             species
!           item               = unit number, temperature data
!           ixdbs              = unit number, database for 
!                                             secondary species in 
!                                             water phase
!           igb_start          = starting pointer for unit numbers
!                                for transient data
!           imrt               = unit number, mass balance - 
!                                             reactive transport
!           imrt_first         = pointer - first unit number for
!                                mass balance - reactive transport
!           imrt_last          = pointer - last unit number for
!                                mass balance - reactive transport
!           imcd               = unit number, mass balance - 
!                                        multicomponent diffusion
!           imcd_first         = pointer - first unit number for
!                                mass balance - multicomponent diffusion
!           imcd_last          = pointer - last unit number for
!                                mass balance - multicomponent diffusion
!           imvs_first         = pointer - first unit number for
!                                mass balance - variably saturated
!                                               flow
!           imvs_last          = pointer - last unit number for
!                                mass balance - variably saturated
!                                               flow
!           imvs               = unit number, mass balance - 
!                                             variably saturated 
!                                             flow
!           igsp               = unit number, flow variables 
!           igst               = unit number, total aqueous 
!                                             component 
!                                             concentrations 
!                                             - contour data
!           igsb               = unit number, sorbed species
!                                             concentrations 
!                                             - contour data
!           igsc               = unit number, free species and 
!                                             secondary aqueous
!                                             species concentrations 
!                                             - contour data
!           igsd               = unit number, reaction rates of
!                                             dissolution-
!                                             precipitation
!                                             reactions
!                                             - contour data
!           igsg               = unit number, gas concentrations
!                                             - contour data 
!           igsgr              = unit number, rates of degassing
!                                             - contour data 
!           igsm               = unit number, master variables
!                                             - contour data 
!           igss               = unit number, saturation indices 
!                                             - contour data
!           igsv               = unit number, mineral volume 
!                                             fractions
!                                             - contour data
!           igsx               = unit number, saturation indices 
!                                             excluded minerals
!                                             - contour data
!           igsi               = unit number, rates of intra-aqueous
!                                             kinetic reactions
!                                             - contour data
!           igbt               = unit number, total aqueous 
!                                             component 
!                                             concentrations 
!                                             - transient data 
!                                               global system
!           igbb               = unit number, concentrations of
!                                             sorbed species
!                                             - transient data
!                                               global system
!           igbc               = unit number, free species and 
!                                             secondary aqueous 
!                                             species concentrations 
!                                             - transient data
!                                               global system
!           igbd               = unit number, reaction rates for
!                                             dissolution-
!                                             precipitation
!                                             reactions
!                                             - transient data
!                                               global system
!           igbg               = unit number, gas concentrations
!                                             - transient data
!                                                global system
!           igbgr              = unit number, degassing rates
!                                             - transient data
!                                                global system
!           igbm               = unit number, master variables
!                                             - transient data
!                                               global system
!           igbi               = unit number, rates of intra-aqueous 
!                                             kinetic reactions
!                                             - transient data
!                                               global system
!           igbp               = unit number, flow variables
!                                             - transient data
!                                               global system
!           igbs               = unit number, saturation indices 
!                                             - transient data
!                                               global system
!           igbv               = unit number, mineral volume 
!                                             fractions 
!                                             - transient data 
!                                               global system
!           igbx               = unit number, saturation indices
!                                             excluded minerals
!                                             - transient data
!                                               global system
!           icbt               = unit number, totcnew(nn), 
!                                             charge balance
!                                              - contour data
!           igmf               = unit number, total flux                                
!                                              - contour data
!           igstime            = pointer to next output time for 
!                                contour data
!           ipsp               = unit number, list of possible
!                                             secondary aqueous
!                                             species, gases and 
!                                             minerals
!           itec               = i-index for tecplot
!           jtec               = j-index for tecplot
!           ktec               = k-index for tecplot
!           ntecvel_dif        = difference of spatial data number for velocity
!           ntecvel_dif_gbl    = difference of spatial data number for velocity for global grid
!           itec_gbl           = i-index of global grid for tecplot
!           jtec_gbl           = j-index of global grid for tecplot
!           ktec_gbl           = k-index of global grid for tecplot
!           l_dbs_dir          = length of string for database
!           l_prfx             = length of prefix of I/O files
!           l_zone_name        = length of zone name
!           ngb                = number of output locations for
!                                transient data
!           ngb_step           = number of time steps between 
!                                output of transient data
!           ngb_vol(ngb)       = control volumes numbers for 
!                                output of transient data
!           ngs                = number of output times for
!                                contour data 
!           nmb                = number of mass balance files
!                                for species concentrations
!
!           logical:
!           --------
!           extended_output    = .true.  -> extended output of 
!                                           contour data for 
!                                           reaction-transport 
!                                           simulation
!                                .false. -> basic output of 
!                                           contour data for  
!                                           for reaction-transport 
!                                           simulation
!           gb_output          = .true.  -> output of transient data
!           gs_output          = .true.  -> output of contour data
!           flux_out           = .true.  -> output of flux data (MCD)
!           initial_condition  = .true.  -> output of initial 
!                                           condition for contour 
!                                           data
!                                .false. -> output of contour data
!                                           for steady state or
!                                           transient solutions
!           tec_header         = .true.  -> write header for tecplot
!                                           postprocessing to output
!                                           files
!                                .false. -> skip headers
!        
!           character:
!           ----------
!           prefix             = prefix name for all I/O files
!           section_header     = section header
!           namemb(nmb)        = names of species with mass balance
!                                for species
!           zone_name          = name of zone
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: gs_tout(:)

      integer (type_i4), allocatable :: iamb(:)
      integer (type_i4), allocatable :: ngb_vol(:)

      integer (type_i4) :: ngb,ngs
      integer (type_i4) :: igstime
      integer (type_i4) :: ngb_step
      integer (type_i4) :: nmb
      integer (type_i4) :: l_prfx
      integer (type_i4) :: l_dbs_dir
      integer (type_i4) :: idat
      integer (type_i4) :: igen
      integer (type_i4) :: ifls
      integer (type_i4) :: idbg
      integer (type_i4) :: ilog
      integer (type_i4) :: idelt
      integer (type_i4) :: icnv
      integer (type_i4) :: ihyc
      integer (type_i4) :: ihycx
!cprovi-----------------------------------------------------------
!cprovi unit for to read porosity field
!cprovi Sergio Andres Bea Jofre 
!cprovi-----------------------------------------------------------
      integer (type_i4) :: ipor   ! Unit for porosity field 
      integer (type_i4) :: istor  ! Unit for specific storage coefficient
!cprovi-----------------------------------------------------------
!cprovi unit for to read tortuosity field
!cprovi Sergio Andres Bea Jofre 
!cprovi-----------------------------------------------------------
      integer (type_i4) :: itor   ! Unit for porosity field 
!cprovi-----------------------------------------------------------
      integer (type_i4) :: itmp
      integer (type_i4) :: ivel
      integer (type_i4) :: icdbs
      integer (type_i4) :: ixdbs
      integer (type_i4) :: imdbs
      integer (type_i4) :: isdbs
      integer (type_i4) :: irdbs
      integer (type_i4) :: igdbs
      integer (type_i4) :: imvs
      integer (type_i4) :: imvs_first
      integer (type_i4) :: imvs_last
      integer (type_i4) :: imrt
      integer (type_i4) :: imrt_first
      integer (type_i4) :: imrt_last 
      integer (type_i4) :: imcd
      integer (type_i4) :: imcd_first
      integer (type_i4) :: imcd_last 
      integer (type_i4) :: igsp
      integer (type_i4) :: igsb
      integer (type_i4) :: igsc
      integer (type_i4) :: igsd
      integer (type_i4) :: idmr!FG sept 2021
      integer (type_i4) :: idmm!FG sept 2021
      integer (type_i4) :: igsg
      integer (type_i4) :: igsgr
      integer (type_i4) :: igsm
      integer (type_i4) :: igsi
      integer (type_i4) :: igss
      integer (type_i4) :: igst
      integer (type_i4) :: igsv
      integer (type_i4) :: igsx
      integer (type_i4) :: igb_start
      integer (type_i4) :: igbb
      integer (type_i4) :: igbc
      integer (type_i4) :: igbd
      integer (type_i4) :: igbg
      integer (type_i4) :: igbgr
      integer (type_i4) :: igbm
      integer (type_i4) :: igbp
      integer (type_i4) :: igbi
      integer (type_i4) :: igbs
      integer (type_i4) :: igbt
      integer (type_i4) :: igbv
      integer (type_i4) :: igbx
      integer (type_i4) :: igbis        !c_isotope
      integer (type_i4) :: igsis        !c_isotope
      integer (type_i4) :: ipsp
      integer (type_i4) :: itec
      integer (type_i4) :: itec_vel
      integer (type_i4) :: itec_gbl
      integer (type_i4) :: itec_vel_gbl
      integer (type_i4) :: item
      integer (type_i4) :: jtec
      integer (type_i4) :: jtec_vel
      integer (type_i4) :: jtec_gbl
      integer (type_i4) :: jtec_vel_gbl
      integer (type_i4) :: ktec
      integer (type_i4) :: ktec_vel
      integer (type_i4) :: ktec_gbl
      integer (type_i4) :: ktec_vel_gbl
      integer (type_i4) :: ntecvel_dif
      integer (type_i4) :: ntecvel_dif_gbl
      integer (type_i4) :: l_zone_name
      integer (type_i4) :: igsa       ! advective velocity and fluxes
      integer (type_i4) :: igsa_first ! 
      integer (type_i4) :: igsa_last  !
      integer (type_i4) :: igs2       ! (cumulative) mol fractions
      integer (type_i4) :: igsr       ! gas density
      integer (type_i4) :: igsy       ! gas viscosity
	  integer (type_i4) :: igsf       ! variable diffusion coefficients
	  integer (type_i4) :: igsf_first ! 
      integer (type_i4) :: igsf_last  !
      integer (type_i4) :: igsk       ! gradients
      integer (type_i4) :: igsw       ! rates of chemical water
      integer (type_i4) :: icbt
      integer (type_i4) :: igmf
      
      character*72, allocatable :: namemb(:)

      !character*72 :: prefix
      character*256 :: prefix           !dsu, change the length of prefix to 256 to support long file path
      character*72 :: section_header
      character*72 :: zone_name
 
      logical :: initial_condition
      logical :: extended_output
      logical :: gs_output
      logical :: gb_output
      logical :: tec_header
      logical :: flux_out
 
! ----------------------------------------------------------------------
! control parameters - reactive transport
! ---------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           dinc_rt            = factor to compute increment for
!                                numerical differentiation
!           srelfac_rt         = user specified underrelaxation 
!                                factor (reactive transport)
!           tol_rt             = convergence tolerance
!                                (reactive transport)
!
!           integer:
!           --------
!           iter_rt            = iteration counter
!                                (reactive transport)
!           iter_rt_ant        = anticipated number of iterations
!                                (reactive transport)
!           itsolvtot_rt       = total number of solver 
!                                iterations
!                                (reactive transport)
!           ittot_rt           = total number of iterations 
!                                (reactive transport)
!           maxit_rt           = max. number of iterations
!                                (reactive transport)
!           n                  = number of components excluding h2o 
!                                equals number of unknowns per 
!                                control volume
!
!           logical:
!           --------
!           analyt_deriv_rt    = .true.  -> form derivatives
!                                           analytically
!           mass_balance_rt    = .true.  -> compute mass balance 
!                                           (reactive tramsport)
!           redox_equil_rt     = .true.  -> equilibrium redox
!                                           reactions
!           sparse_blocks      = .true.  -> make use of sparsity
!                                           of block matrices
!           under_relax_rt     = .true.  -> underrelaxation   
!           gas_advection      = .true.  -> enable gas advection
!           cum_molfrac        = .true.--> .gs2 results in terms
!                                           of cummulative molar fractions
!           gas_gravity        = .true.  -> enable gravity when gas advection
!           tortuosity_corr    = .true.  -> Millington-Quirk 
!                                           tortuosity correction
!                                           for diffusion
!                                           coefficients
!           epor_diff           = .true.-> effective porosity factor
!                                           for effective diffusion correction
!
!           character:
!           ----------
!           update_activity_rt = 'no_update' -> unity activity
!                                 coefficients
!                                'time_lagged' -> update activity
!                                 coefficients after each time step
!                                'double_update' -> double update
!                                 of activity coefficients during
!                                 Newton iterations
!                                 (reactive transport)
!           spatial_weighting  = 'upstream' -> upstream weigthing
!                                'centered' -> centered weighting
!                                'vanleer' -> Van Leer flux limiter
!                                              (upstream-downstream)
!                                'vanleer2' -> Van Leer flux limiter
!                                              (upstream-centered)
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: dinc_rt
      real (type_r8) :: tol_rt
      real (type_r8) :: srelfac_rt

      integer (type_i4) :: n
      integer (type_i4) :: iter_rt
      integer (type_i4) :: iter_rt_ant
      integer (type_i4) :: maxit_rt
      integer (type_i4) :: itsolvtot_rt
      integer (type_i4) :: ittot_rt

      logical :: analyt_deriv_rt
      logical :: mass_balance_rt
      logical :: sparse_blocks
      logical :: redox_equil_rt
      logical :: tortuosity_corr
      logical :: under_relax_rt
      
      logical :: gas_advection  ! .true.--> enable gas advection
      logical :: cum_molfrac    ! .true.--> .gs2 results in terms
                                !           of cummulative molar fractions
      logical :: gas_gravity    ! .true.--> enable gravity when gas advection
            
      
!cprovi---------------------------------------------------------------
!cprovi Assigned tau 
!cprovi---------------------------------------------------------------      
      logical                 :: assigned_tau
      real (type_r8), pointer :: tau(:)
!cprovi---------------------------------------------------------------
!cprovi tortuosity type 
!cprovi---------------------------------------------------------------      
      character(len=100)      :: type_tortuosity
      real (type_r8)          :: marchie
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi For diffusion coefficients for each component 
!cprovi---------------------------------------------------------------      
      logical :: diff_coff      
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi For effective diffusion factor of MCD diffusion for each component 
!cprovi---------------------------------------------------------------      
      logical :: epor_diff      
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
      character*12 :: spatial_weighting
      character*72 :: update_activity_rt
	  character*20 :: gas_tortuosity ! gas_tortuosity = 'same as aqueous'
!c                                                      'millington'
!c                                                      'no correction'
!c                                                      'moldrup repacked'
!prc---------------------------------------------------------------
!prc   Diffusion averaging type
!prc---------------------------------------------------------------
      logical :: averaging_diffusion
      logical :: no_average

      character(len=30)      :: type_averaging_De
!prc---------------------------------------------------------------
!prc--------------------------------------------------------------- 
! prc ----------------------------------------------------------------
! ----------------------------------------------------------------------
! main variables (reactive transport):
! ------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           c(nc,nn)           = concentrations of free species
!                                - old time level [moles/l water]
!           cnew(nc,nn)        = concentrations of free species
!                                - new time level [moles/l water]
!           cec_g(nn)          = cation exchange capacity
!                                - global system
!           cec_fraction_g(nsites_ion,nn)                            * +
!                              = cec fractions of multisite ion 
!                                exchange [-] - global system
!           totaold(n,nn)      = total sorbed component 
!                                concentrations
!                                non-competitive sorption 
!                                - old time level [moles/l bulk]
!           totanew(n,nn)      = total aqueous component
!                                concentrations
!                                non-competitive sorption
!                                - new time level [moles/l bulk]
!           totcold(n,nn)      = total aqueous component 
!                                concentrations 
!                                - old time level [moles/l water]
!           totcnew(n,nn)      = total aqueous component
!                                concentrations
!                                - new time level [moles/l water]
!           totgold(nc,nn)      = total gaseous component
!                                concentrations 
!                                - old time level [moles/l air]]
!           totgnew(nc,nn)      = total gaseous component
!                                concentrations
!                                - new time level [moles/l air]
!           totsold(n,nn)      = total sorbed component 
!                                concentrations 
!                                - old time level [moles/l bulk]
!           totsold_ion(n,nn)  = total sorbed component 
!                                concentrations 
!                                - old time level [moles/l bulk]
!                                (ion-exchange)
!           totsold_surf(n,nn) = total sorbed component 
!                                concentrations 
!                                - old time level [moles/l bulk]
!                                (surface-complex)
!           totsnew(n,nn)      = total sorbed component 
!                                concentrations
!                                - new time level [moles/l bulk]
!           totsnew_ion(n,nn)  = total sorbed component 
!                                concentrations
!                                - new time level [moles/l bulk]
!                                (ion-exchange)
!           totsnew_surf(n,nn) = total sorbed component 
!                                concentrations
!                                - new time level [moles/l bulk]
!                                (surface-complex)
!           cmold(nm,nn)       = mineral concentrations 
!                                - old time level [moles/l bulk]
!           cmnew(nm,nn)       = mineral concentrations 
!                                - new time level [moles/l bulk]
!           distcoff_rt(nc,nn) = sorption distribution coefficient
!                                [-], [l bulk/l bulk]
!                                - reactive transport
!           gold(ng,nn)        = gas concentrations 
!                                - old time level [moles/l air]
!           gnew(ng,nn)        = gas concentrations
!                                - new time level [moles/l air]
!           gmfrac(ng,nn)      = molar fraction 
!                                - new time level [moles/l air]
!           totgmfrac(n,nn)    = total molar gas fractions
!           cx(nx,nn)          = concentrations of secondary aqueous 
!                                species [moles/l water]-new time level
!           cxold(nx,nn)       = concentrations of secondary aqueous 
!                                species [moles/l water]-old time level
!           gamma(nc+nx,nn)    = activity coefficients of aqueous
!                                species [-]
!           gammaold(nc+nx,nn) = activity coefficients of aqueous
!                                species [-] -old time level
!           sionnew(nn)        = ionic strength of solution
!                                - new time level
!           sionold(nn)        = ionic strength of solution
!                                - old time level
!           phi(nm,nn)         = volume fractions of minerals
!           phiold(nm,nn)      = volume fractions of minerals
!                                (old time level)
!           phi_init(nm,nn)    = volume fractions of minerals
!                                (initial condition)
!           phinucthrd(nm,nn)  = volume fractions of mineral for
!                                 nucleation threshold
!           area(nm,nn)        = mineral reactivity term
!                                (global system)
!           area_init(nm,nn)   = initial mineral reactivity term
!                                (global system)!
!           areanucthrd(nm,nn) = reference area for the the specified nucleation threshold
!                                (global system)!
!           cinfrt_va(njavs)   = influence coefficients  
!                                (advection - aqueous phase)
!           cinfrt_da(njavs)   = influence coefficients 
!                                (dispersion - aqueous phase)
!           cinfrt_dg(njavs)   = influence coefficients 
!                                (diffusion - gaseous phase)
!           gsatij(njavs)      = gas saturation at interface i-j
!           tkel(nn)           = nodal temperatures in Kelvin
!
!           integer:
!           --------
!           mpropc(nn)         = pointer array for allocation of 
!                                chemical material properties
!        -->                                                         <--
! ----------------------------------------------------------------------
 
      real (type_r8), allocatable :: c(:,:)
      real (type_r8), allocatable :: cnew(:,:)
      real (type_r8), allocatable :: cec_g(:)
      real (type_r8), allocatable :: cec_fraction_g(:,:)
      real (type_r8), allocatable :: rhobulk_g(:)
      real (type_r8), allocatable :: gamma(:,:)
      real (type_r8), allocatable :: gammaold(:,:)
      real (type_r8), allocatable :: totaold(:,:)
      real (type_r8), allocatable :: totanew(:,:)
      real (type_r8), allocatable :: totcold(:,:)
      real (type_r8), allocatable :: totcoldf(:,:)
      real (type_r8), allocatable :: totcnew(:,:)
       real (type_r8), allocatable :: totcnewf(:,:)
      real (type_r8), allocatable :: totgold(:,:)
      real (type_r8), allocatable :: totgnew(:,:)
      !real (type_r8), allocatable :: totsold(:,:)
      real (type_r8), allocatable :: totsold_ion(:,:)
      real (type_r8), allocatable :: totsold_surf(:,:)
      !real (type_r8), allocatable :: totsnew(:,:)
      real (type_r8), allocatable :: totsnew_ion(:,:)
      real (type_r8), allocatable :: totsnew_surf(:,:)
      real (type_r8), allocatable :: cmold(:,:)
      real (type_r8), allocatable :: cmnew(:,:)
      real (type_r8), allocatable :: distcoff_rt(:,:)
      real (type_r8), allocatable :: gold(:,:)
      real (type_r8), allocatable :: gnew(:,:)
      real (type_r8), allocatable :: cx(:,:)
      real (type_r8), allocatable :: cxold(:,:)
      real (type_r8), allocatable :: sionnew(:)
      real (type_r8), allocatable :: sionold(:)
      real (type_r8), allocatable :: phi(:,:)
      real (type_r8), allocatable :: phiold(:,:)
      real (type_r8), allocatable :: phi_init(:,:)
      real (type_r8), allocatable :: phinucthrd(:,:)
      real (type_r8), allocatable :: area(:,:)
      real (type_r8), allocatable :: area_init(:,:)
      real (type_r8), allocatable :: areanucthrd(:,:)
      real (type_r8), allocatable :: cinfrt_va(:)
      real (type_r8), allocatable :: cinfrt_da(:)
      real (type_r8), allocatable :: cinfrt_dg(:)
      real (type_r8), allocatable :: gporij(:)      ! gas filled porosity at i-j
      real (type_r8), allocatable :: gsatij(:)      ! gas saturation at i-j
      real (type_r8), allocatable :: tkel(:)
      real (type_r8), allocatable :: gmfrac(:,:)    ! molar fractions
      real (type_r8), allocatable :: totgmfrac(:,:) ! total molar fractions
      
      logical :: i_first!FG sept 2021
     
!CBF--------------------------------------------------------------------
!main variables (evapotranspiration)
!           real*8:
!           -------
!           qroot(nn)      = root water uptake for current
!                            control volume
!           qrootinc(nn)   = root water uptake for current
!                            control volume (incremented)
!           dqroot(nn)     = derivative of root water uptake
!           BINev(nn)      = binary matrix of track control volume
!                            subjected to evaporation
!           BINT(nn)       = binary matrix of track control volume
!                            subjected to transpiration
	real (type_r8), allocatable :: qroot(:)
    real (type_r8), allocatable :: qrootinc(:)
    real (type_r8), allocatable :: dqroot(:)
    logical, allocatable :: BINev(:)
    logical, allocatable :: BINT(:)
	!CBF real (type_r8) :: rewm


!cdsu---------------------------------------------------------------
!cdsu      Gas advection variables in jacobi matrix assembly
!cdsu---------------------------------------------------------------
!c             dg(ng)
!c             gdens(nn)
!c             gij(ng)
!c             gvisc(nn)
!c             gpivol(nn)
!c             gmfracij(ng)
!c             gmfrac_brt(ng)
!c             gmfrac_ivol(ng)
!c             totgnew_brt(nc)
!c             totgmfrac_brt(nc)
!c             totgmfrac_ivol(nc)
!c             totgij(nc)
      real (type_r8), allocatable :: dg(:)           
      real (type_r8), allocatable :: gdens(:) 
      real (type_r8), allocatable :: gij(:)
      real (type_r8), allocatable :: gvisc(:)        
      real (type_r8), allocatable :: gpivol(:)
      real (type_r8), allocatable :: gmfracij(:)
      real (type_r8), allocatable :: gmfrac_brt(:) 
      real (type_r8), allocatable :: gmfrac_ivol(:)
      real (type_r8), allocatable :: totgnew_brt(:)
      real (type_r8), allocatable :: totgmfrac_brt(:) 
      real (type_r8), allocatable :: totgmfrac_ivol(:)
      real (type_r8), allocatable :: totgij(:) 
      
      
!cprovi--------------------------------------------------------------
!cprovi--------------------------------------------------------------
!cprovi--------------------------------------------------------------
      real (type_r8), allocatable :: cinfrt_da_ic(:,:)
      real (type_r8), allocatable :: vel_lin(:)           !MCD

!cprovi--------------------------------------------------------------      
!cprovi--------------------------------------------------------------      
!cprovi--------------------------------------------------------------
      integer (type_i4), allocatable :: mpropc(:)      
! prc ---------------------------------------------------------------
! defining the vectors for diffusion coefficients for primary and 
! secondary spices
! prc ---------------------------------------------------------------
      real (type_r8), allocatable :: diff_ic(:) 
! prc ---------------------------------------------------------------
! cmx ---------------------------------------------------------------          
! defining the vectors for effective porosity factors for primary and 
! secondary spices
! cmx ---------------------------------------------------------------
      real*8, pointer, dimension (:) :: f_epor
 !     real*8, pointer, dimension (:) :: f_etau(:) 
      real (type_r8), allocatable ::  f_etau(:)
      real (type_r8), allocatable ::  f_epor_ps(:,:)
      real (type_r8), allocatable ::  f_etau_ps(:,:)
      real (type_r8), allocatable ::  f_epor_ss(:,:)
      real (type_r8), allocatable ::  f_etau_ss(:,:)
! cmx ---------------------------------------------------------------           


! ----------------------------------------------------------------------
! boundary and initial conditions (reactive transport):
! -----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           bcondrt_a(nc,nbrt) = concentrations in boundary control 
!                                volumes (aqueous phase)
!                                first type b.c. -> free species 
!                                                   concentrations 
!                                third type b.c. -> total aqueous 
!                                                   component
!                                                   concentrations 
!           bcondrt_g(nc,nbrt) = concentrations in boundary control
!                                volumes (gaseous phase)
!                                third type b.c. -> total gaseous
!                                                   component
!                                                   concentrations
!           bdycrt_d(nbrt)     = boundary influence coefficients for
!                                diffusive mass fluxes across
!                                boundary (excluding diffusion 
!                                coefficient)
!           zgbrt(nbrt)        = elevation of dummy boundary nodes (mixed 
!                                type b.c.) used to calculate gas transport
!           gbrt(ng,nbrt)      = gas concentrations in boundary 
!                                control volumes
!           tsrc(ntsrc)        = target read times - transient
!                                source chemistry
!                                (reactive transport)
!           transient_time_series(ntsrc+1)
!                              = target time for transient boundary update
!           spatial_weight_bd_internbzrt()
!                              = spatial weighting for transient boundary condition 
!                                interpolation. 
!                                Time spatial weighting, [0-1], 0.0d0 is 
!                                prefered and 1.0 is apt to cause occillation. 
!                                By default, 1 is used as spatial weithting
!                                so as to backward compatible
!
!           integer:
!           --------
!           iabrt(nbzrt+1)     = pointer array - boundary conditions
!                                (reactive transport)
!           itsrc              = pointer to target read time for 
!                                transient source chemistry
!           jabrt(nbrt)        = pointer array - boundary conditions
!                                (reactive transport)
!           nbrt               = number of specified boundary 
!                                control volumes
!           nbzrt              = number of boundary zones
!                                (reactive transport)
!           ntsrc              = pointer to target read times for 
!                                transient source chemistry
!
!           logical:
!           --------
!           spec_conc          = .true.  -> source concentrations 
!                                           specified
!                                .false. -> background 
!                                           concentrations as 
!                                           boundary condition
!           transient_source   = .true.  -> transient source 
!                                           chemistry
!                                .false. -> constant source 
!                                           chemistry
!           b_update_zone_func(nbzrt) 
!                              = .true.  -> transient boundary
!                              = .false. -> steady boundary
!           b_update_zone_series(nbzrt,ntsrc) 
!                              = .true.  -> transient boundary
!                              = .false. -> steady boundary
!           b_fluxd_mixed_bcond(nn) 
!                              = .true.  -> with diffusive flux from 
!                                           mixed boundary condition
!                                .false. -> without diffusive flux from 
!                                           mixed boundary condition
!                                default value is .true.
!
!           character:
!           ----------
!           btypert(nn)        = type of boundary control volumes    
!                                'first'  = Dirichlet 
!                                           (specified 
!                                            concentration)
!                                'second' = Neumann
!                                           (free advective mass
!                                            outflux for aqueous 
!                                            phase)
!                                'third'  = Cauchy
!                                           (specified advective 
!                                            mass influx for 
!                                            aqueous phase)
!                                'mixed'  = mixed
!                                           (specified advective
!                                            mass influx and
!                                            free diffusive mass
!                                            influx for aqueous 
!                                            phase and gaseous phase
!           iupsgbrt(nbrt)     = upstream node 'i', 'j', 'a'
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: bcondrt_a(:,:)
      real (type_r8), allocatable :: bcondrt_g(:,:)
      real (type_r8), allocatable :: bdycrt_d(:)
      real (type_r8), allocatable :: zgbrt(:)
      real (type_r8), allocatable :: gbrt(:,:)
      real (type_r8), allocatable :: tsrc(:)
      real (type_r8), allocatable :: transient_time_series(:)
      
      real (type_r8), allocatable :: dijbrt(:)       !gas transport
      real (type_r8), allocatable :: permbrt(:)      !gas transport
      real (type_r8), allocatable :: cinfvs_gbrt(:)  !gas transport

      integer (type_i4), allocatable :: iabrt(:)
      integer (type_i4), allocatable :: jabrt(:)

      integer (type_i4) :: itsrc
      integer (type_i4) :: nbrt
      integer (type_i4) :: nbzrt
      integer (type_i4) :: ntsrc
      real (type_r8), allocatable :: spatial_weight_bd_inter(:)

      logical :: spec_conc 
      logical :: transient_source
      logical :: transient_source_function
      logical, allocatable :: b_update_zone_func(:)      
      logical, allocatable :: b_update_zone_series(:,:)

      character*12, allocatable :: btypert(:)      
      
      logical, allocatable :: b_fluxd_mixed_bcond(:)
      character*1, allocatable ::  iupsgbrt(:)   !gas transport

! ----------------------------------------------------------------------
! newton iteration (reactive transport):
! --------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           astor(n)           = storage term (non-competitive
!                                sorption)
!           cflux(ncon,n)      = interfacial mass fluxes           
!                                (aqueous phase)
!           cstor(n)           = storage term (aqueous phase)
!           gflux(ncon,n)      = interfacial mass fluxes 
!                                (gaseous phase)
!           gstor(n)           = storage term (gaseous phase)
!           dtotcflux(n)       = derivatives of total mass fluxes
!                                (aqueous phase)
!           dtotgflux(n)       = derivatives of total mass fluxes
!                                (gaseous phase)
!           ratemdp(nm,nn)     = absolute dissolution-precipitation 
!                                rates of minerals
!           totcflux(n)        = total mass fluxes (aqueous phase)
!           totcflux_diff(n)   = total mass fluxes (diffused aqueous phase)
!           totcflux_mig(n)    = total mass fluxes (MCD, electrochemical 
!                                migration, aqueous phase)
!           totgflux(n)        = total mass fluxes (gaseous phase)
!           totgaflux(n)       = total mass fluxes (gaseous phase, advective)
!           totmdp(n,nn)       = total source/sink term towards 
!                                total aqueous component 
!                                concentrations due to mineral
!                                dissolution-precipitation reactions
!           integer:
!           --------
!           i2up(nn)           = pointer array to second upstream 
!                                point
!
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: astor(:)
      real (type_r8), allocatable :: cflux(:,:)
      real (type_r8), allocatable :: cstor(:)
      real (type_r8), allocatable :: gflux(:,:)
      real (type_r8), allocatable :: gstor(:)
      real (type_r8), allocatable :: dtotcflux(:)
      real (type_r8), allocatable :: dtotgflux(:)
      real (type_r8), allocatable :: ratemdp(:,:)
      real (type_r8), allocatable :: totcflux(:)
      real (type_r8), allocatable :: totcflux_diff(:)
      real (type_r8), allocatable :: totcflux_mig(:)
      real (type_r8), allocatable :: totgflux(:)
      real (type_r8), allocatable :: totgaflux(:)
      real (type_r8), allocatable :: totmdp(:,:)
 
      integer (type_i4), allocatable :: i2up(:) 

! ----------------------------------------------------------------------
! data structure and solver - reactive transport:
! -----------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           art(njart)         = jacobian matrix
!           afrt(njafrt)       = incomplete factorization
!           brt(nn*n)          = rhs vector
!           deltol_rt          = solver update tolerance
!           resrt(nn*n)        = residual
!           restol_rt          = solver residual tolerance
!           urt(nn*n)          = update towards solution-vector
!           urtlim_log         = maximum tolerated update
!                                in log cycles
!
!           integer:
!           --------
!           iart(nn*n+1)       = row pointer array for n-d scalar 
!                                matrix
!           jart(njart)        = connectivity list for n-d scalar 
!                                matrix
!           lart(njavs+1)      = pointer array
!           kart(njart)        = mapping pointer 
!                                (global block -> n-d scalar)
!           iafrt(nn*n+1)      = row pointer array for afrt
!           jafrt(njafrt)      = column pointer array for afrt
!           iafdrt(nn*n)       = diagonal pointer array for afrt
!           kbl(n,n)           = connectivity list for block
!                                matrices (full format)
!           kblsorb(n,n)       = Additional connectivity list for components in 
!                                sorbed species in block matrices (full format).
!           kblredox(n,n)      = Additional connectivity list for redox couples in 
!                                block matrices (full format).
!           iadbl(n+1)         = row pointer array (diagonal block  
!                                matrices)
!           jadbl(n*n)         = column pointer array (diagonal 
!                                block matrices)
!           kadbl(n,n)         = pointer array for conversion to 
!                                sparse format (diagonal block 
!                                matrices)
!           iaobl(n+1)         = row pointer array 
!                                (off-diagonal block matrices)
!           jaobl(n*n)         = column pointer array 
!                                (diagonal block matrices)
!           kaobl(n,n)         = pointer array for conversion 
!                                to sparse format 
!                                (off-diagonal block matrices)
!           lorderrt(nn*n)     = array containing ordering
!           invordrt(nn*n)     = array containing inverse ordering
!           mnjart             = max. number of global connections
!           mnjafrt            = max. number of factored connections
!           njart              = number of global connections
!           njafrt             = number of factored connections
!           njadbl             = actual number of entries in 
!                                diagonal block matrices
!           njaobl             = actual number of entries in 
!                                off-diagonal block matrices
!           level_rt           = incomplete factorization level
!           msolvit_rt         = max. number of solver iterations
!           nexvol_old_rt      = number of nonconvergent control
!                                volumes from last time step
!           idetail_rt         = information level
!
!           logical:
!           --------
!           rcm_ordering_rt    = .true.  -> rcm ordering for 
!                                           n-d scalar matrix
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: art(:)
      real (type_r8), allocatable :: brt(:)
      real (type_r8), allocatable :: urt(:)
      real (type_r8), allocatable :: resrt(:)
      real (type_r8), allocatable :: afrt(:)

      real (type_r8) :: restol_rt
      real (type_r8) :: deltol_rt
      real (type_r8) :: urtlim_log

      integer (type_i4), allocatable :: iart(:)
      integer (type_i4), allocatable :: jart(:)
      integer (type_i4), allocatable :: lart(:)
      integer (type_i4), allocatable :: kbl(:,:)
      integer (type_i4), allocatable :: kblsorb(:,:)
      integer (type_i4), allocatable :: kblredox(:,:)
      integer (type_i4), allocatable :: kart(:)
      integer (type_i4), allocatable :: iafrt(:)
      integer (type_i4), allocatable :: jafrt(:)
      integer (type_i4), allocatable :: iafdrt(:)
      integer (type_i4), allocatable :: lorderrt(:)
      integer (type_i4), allocatable :: invordrt(:)
      integer (type_i4), allocatable :: iadbl(:)
      integer (type_i4), allocatable :: jadbl(:)
      integer (type_i4), allocatable :: kadbl(:,:)
      integer (type_i4), allocatable :: iaobl(:)
      integer (type_i4), allocatable :: jaobl(:)
      integer (type_i4), allocatable :: kaobl(:,:)      

      real(type_r8), allocatable :: resrt_check(:)
      real(type_r8) :: rnorm_check
      !logical :: b_doublecheck_residual

      integer (type_i4) :: mnjart
      integer (type_i4) :: mnjafrt
      integer (type_i4) :: njart
      integer (type_i4) :: njafrt
      integer (type_i4) :: njadbl
      integer (type_i4) :: njaobl
      integer (type_i4) :: level_rt
      integer (type_i4) :: msolvit_rt
      integer (type_i4) :: nexvol_old_rt
      integer (type_i4) :: idetail_rt

      logical :: rcm_ordering_rt
      
! ----------------------------------------------------------------------
! standard data structure and solver - reactive transport: 
! ----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           art_std(njart)     = jacobian matrix for standard sparse
!                                 matrix
!           integer:
!           --------
!           jart_std(njart)    = connectivity list for 1d-scalar 
!                                matrix
!           imaprt_std(njart) = point of standard sparse matrix to 
!                                 sparse matrix used in ws209
!                                 
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: art_std(:)
      real (type_r8), allocatable :: urt_std(:)         !for test, dsu
      integer (type_i4), allocatable :: jart_std(:)      
      integer (type_i4), allocatable :: imaprt_std(:)     
      logical :: bsymbolicfactor_rt  =  .true.

! ----------------------------------------------------------------------
! mass balance (reactive transport):
! ----------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cfluxin(n)         = mass gain due to inflow in water  
!                                phase in terms of total aqueous 
!                                component concentrations
!           cfluxout(n)        = mass loss due to outflow in water 
!                                phase in terms of total aqueous
!                                component concentrations
!           cfluxin_diff(n)    = mass gain due to diffusion in water  
!                                phase in terms of total aqueous 
!                                component concentrations
!           cfluxout(n)        = mass loss due to diffusion in water 
!                                phase in terms of total aqueous
!                                component concentrations
!           cfluxin_mig(n)     = mass gain due to electrochemical    
!                                migration in water phase in terms  
!                                of total aqueous component 
!                                concentrations
!           cfluxout_mig(n)    = mass loss due to electrochemical    
!                                migration in water phase in terms  
!                                of total aqueous component 
!                                concentrations
!           gfluxtbdy(ng)      = mass flux across top boundary
!                                (gaseous phase)
!           gfluxin(n)         = mass gain due to inflow in air   
!                                phase in terms of total gaseous
!                                component concentrations
!           gfluxout(n)        = mass loss due to outflow in air   
!                                phase in terms of total gaseous
!                                component concentrations
!           cstordiff(n+nm)    = change in storage in terms of total
!                                aqueous component concentrations
!           gdegas(n)          = mass loss from aqueous phse due 
!                                to degassing
!           gstordiff(n)       = change in storage in terms of total
!                                gaseous component concentrations
!           ordiff(n)          = global source-sink term due to
!                                oxidation/reduction reactions
!           dpdiff(n+nm)       = source-sink term due to phase
!                                exchange with solid phase 
!                                (minerals)
!           dpdiffp(ndr*nm)    = individual source-sink terms due
!                                to parallel dissolution-
!                                precipitation reactions
!           gdiff(n+ng)        = source-sink term due to phase
!                                exchange with air phase 
!           amass(n)           = total adsorbed mass -
!                                non-competitive sorption [moles]
!           tmass(n)           = total mass in aqueous and gaseous 
!                                phase in terms of total 
!                                component concentrations [moles]
!           cmass(n)           = total mass in aqueous phase in 
!                                terms of total aqueous component 
!                                concentrations [moles]
!           gmass(ng)          = total mass in gaseous phase in
!                                terms of total gaseous component 
!                                concentrations [moles]
!           cmmass(nm)         = total mineral mass in system       
!                                [moles]
!           csbmass(nsb)       = total sorbed mass in system       
!                                [moles]
!           csbmass_ion(nsb_ion)       = total sorbed mass in system       
!                                        [moles] (ion-exchange)
!           csbmass_surf(nsb_surf)     = total sorbed mass in system       
!                                        [moles] (surface-complex)
!           csbmass_c(nsites)  = total sorbed mass in system
!                                - non-aqueous components [moles]
!           cculabsbal(n)      = accumulative absolute mass balance
!                                error for dissolved species
!                                [moles/elapsed time]
!           cculrelbal(n)      = accumulative relative mass balance
!                                error for dissolved species [%]
!           gculabsbal(ng)     = accumulative absolute mass balance
!                                error for gaseous species
!                                [moles/elapsed time]
!           gculrelbal(ng)     = accumulative relative mass balance
!                                error for gaseous species [%]
!           cmculabsbal(nm)    = accumulative absolute mass balance
!                                error for minerals 
!                                [moles/elapsed time]
!           cmculrelbal(nm)    = accumulative relative mass balance
!                                error for minerals [%]
!           sbdiff(n)          = source-sink term due to phase
!                                exchange with sorbed phase 
!           smass(nmb)         = total mass of selected species in
!                                aqueous phase [moles]
!           rateaqtot(naq)     = total rate of intra-aqueous kinetic
!                                reaction in solution domain
!                                [moles/day]
!           contaqtot(naq)     = contribution of intra-aqueous 
!                                kinetic reactions to mass balance
!                                [moles/elapsed time]
!           contmintot(nm)     = contribution of dissolution-
!                                precipitation reactions to mass
!                                balance [moles/elapsed time]
!           totdpdiffp(ndr*nm) = individual contribution of parallel 
!                                reaction pathways of dissolution-
!                                precipitation reactions to mass
!                                balance [moles/elapsed time]
!           totcfluxin(nc)     = total mass gain due to inflow in
!                                auqueous phase in terms of total 
!                                aqueous component concentrations
!           totcfluxout(nc)    = total mass loss due to inflow in
!                                aqueous phase in terms of total 
!                                aqueous component concentrations

!      real (type_r8), allocatable :: totcfluxin_diff(:)
!      real (type_r8), allocatable :: totcfluxin_mig(:)
!      real (type_r8), allocatable :: totcfluxout_diff(:)
!      real (type_r8), allocatable :: totcfluxout_mig(:)

!           totcstordiff(nc)   = total change in storage in
!                                aqueous phase in terms of total 
!                                aqueous component concentrations
!           totordiff(nc)      = total source/sink to total 
!                                aqueous component concentrations
!                                due to intra-aqueous kinetic 
!                                reactions
!           totdpdiff(nc)      = total source/sink to total 
!                                aqueous component concentrations
!                                due to dissolution-precipitation 
!                                reactions
!           totgdegas(nc)      = total mass loss from aqueous 
!                                phase due to degassing
!           totgdiff(nc)       = total source/sink to total 
!                                aqueous component concentrations
!                                due to gas dissolution-esolution
!                                reactions
!           totgfluxin(nc)     = total mass gain due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!           totgfluxout(nc)    = total mass loss due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!           totgafluxin(nc)    = total mass gain due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!                                advective part
!           totgafluxout(nc)   = total mass loss due to inflow in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!                                advective part
!           totgstordiff(nc)   = total change in storage in
!                                gas phase in terms of total 
!                                gaseous component concentrations
!           totsbdiff(nc)      = total source/sink to total 
!                                aqueous component concentrations
!                                due to sorption or ion-exchange
!                                reactions
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: cfluxin(:)
      real (type_r8), allocatable :: cfluxin_diff(:)
      real (type_r8), allocatable :: cfluxin_mig(:)
      real (type_r8), allocatable :: cfluxout_diff(:)
      real (type_r8), allocatable :: cfluxout_mig(:)
      real (type_r8), allocatable :: cfluxout(:)
      real (type_r8), allocatable :: gfluxtbdy(:)
      real (type_r8), allocatable :: gfluxin(:)
      real (type_r8), allocatable :: gfluxout(:)
      real (type_r8), allocatable :: gafluxin(:)
      real (type_r8), allocatable :: gafluxout(:)
      real (type_r8), allocatable :: cstordiff(:)
      real (type_r8), allocatable :: gdegas(:)
      real (type_r8), allocatable :: gstordiff(:)
      real (type_r8), allocatable :: ordiff(:)
      real (type_r8), allocatable :: dpdiff(:)
      real (type_r8), allocatable :: gdiff(:)
      real (type_r8), allocatable :: amass(:)
      real (type_r8), allocatable :: amass_gbl(:)
      real (type_r8), allocatable :: tmass(:)
      real (type_r8), allocatable :: tmass_gbl(:)
      real (type_r8), allocatable :: cmass(:)
      real (type_r8), allocatable :: cmass_gbl(:)
      real (type_r8), allocatable :: gmass(:)
      real (type_r8), allocatable :: gmass_gbl(:)
      real (type_r8), allocatable :: cmmass(:)
      real (type_r8), allocatable :: cmmass_gbl(:)
      !real (type_r8), allocatable :: csbmass(:)
      real (type_r8), allocatable :: csbmass_ion(:)
      real (type_r8), allocatable :: csbmass_ion_gbl(:)
      real (type_r8), allocatable :: csbmass_surf(:)
      real (type_r8), allocatable :: csbmass_surf_gbl(:)
      real (type_r8), allocatable :: csbmass_c(:)
      real (type_r8), allocatable :: csbmass_c_gbl(:)
      real (type_r8), allocatable :: cculabsbal(:)
      real (type_r8), allocatable :: cculrelbal(:)
      real (type_r8), allocatable :: gculabsbal(:)
      real (type_r8), allocatable :: gculrelbal(:)
      real (type_r8), allocatable :: cmculabsbal(:)
      real (type_r8), allocatable :: cmculrelbal(:)
      real (type_r8), allocatable :: smass(:)
      real (type_r8), allocatable :: smass_gbl(:)
      real (type_r8), allocatable :: sbdiff(:)
      real (type_r8), allocatable :: rateaqtot(:)
      real (type_r8), allocatable :: contaqtot(:)
      real (type_r8), allocatable :: contmintot(:)
      !FG sept 2021
      real (type_r8), allocatable :: sum_ratemin(:)!domain-scale reacted mineral rates (mol/yr)
      real (type_r8), allocatable :: sum_rmm(:)!domain-scale reacted mineral masses (mol)
!      real (type_r8), allocatable :: sum_rmm_cumul(:)!cumulated domain-scale reacted mineral mass (mol) 
      
      real (type_r8) :: alphafeddes !Mujica 2022
      
#ifdef PETSC
      real (type_r8), allocatable :: contmintot_mpi(:)
#endif
      real (type_r8), allocatable :: totcfluxin(:)
      real (type_r8), allocatable :: totcfluxin_diff(:)
      real (type_r8), allocatable :: totcfluxin_mig(:)
      real (type_r8), allocatable :: totcfluxout(:)
      real (type_r8), allocatable :: totcfluxout_diff(:)
      real (type_r8), allocatable :: totcfluxout_mig(:)
      real (type_r8), allocatable :: totcstordiff(:)
      real (type_r8), allocatable :: totordiff(:)
      real (type_r8), allocatable :: totdpdiff(:)
      real (type_r8), allocatable :: totgdegas(:)
      real (type_r8), allocatable :: totgdiff(:)
      real (type_r8), allocatable :: totgfluxin(:)
      real (type_r8), allocatable :: totgfluxout(:)
      real (type_r8), allocatable :: totgafluxin(:)
      real (type_r8), allocatable :: totgafluxout(:)
      real (type_r8), allocatable :: totgstordiff(:)
      real (type_r8), allocatable :: totsbdiff(:) 
      real (type_r8), allocatable :: dpdiffp(:)
      real (type_r8), allocatable :: totdpdiffp(:)
#ifdef PETSC
      real (type_r8), allocatable :: totdpdiffp_mpi(:)
#endif

! ----------------------------------------------------------------------
! control parameters - variably saturated flow
! --------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           sw_star            = anticipated change in saturation 
!                                per time step
!           uvslim             = user specified upper limit for 
!                                magnitude of solution update
!                                (flow)
!           utemplim           = user specified upper limit for 
!                                magnitude of solution update
!                                (energy balance, temperature)
! 
!           integer:
!           --------
!           iter_seep          = iteration counter 
!                                (seepage face iterations)
!           itseep_tot         = total number of seepage face 
!                                iterations
!           itsolvtot_vs       = total number of solver
!                                iterations
!                                (variably saturated flow)
!           nseep_first        = number of seepage face nodes
!
!           logical:
!           --------
!           hydraulic_head     = .true.  -> initial condition in 
!                                           terms of hydraulic head
!           mass_balance_vs    = .true.  -> compute mass balance
!                                           (variably_saturated
!                                            flow)
!           pressure_head      = .true.  -> initial condition in 
!                                           terms of pressure head
!           seepage_face       = .true.  -> seepage face boundary 
!                                           specified
!           seep_iter          = .true.  -> continue seepage face 
!                                           iteration
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: sw_star
      real (type_r8) :: uvslim
      real (type_r8) :: utemplim

      integer (type_i4) :: iter_seep
      integer (type_i4) :: itseep_tot
      integer (type_i4) :: itsolvtot_vs
      integer (type_i4) :: nseep_first

      logical :: pressure_head
      logical :: hydraulic_head
      logical :: seepage_face
      logical :: seep_iter
      logical :: mass_balance_vs

! ----------------------------------------------------------------------
! main variables (variably saturated flow):
! -----------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           cinfvs(njavs)      = influence coefficients
!                                (variably saturated flow)
!           hhead(nn)          = hydraulic head
!           perm_fac(nn)       = scaling factor for permeability
!                                as a function of porosity changes
!           tau_fac(nn)        = updated tortuosity as the function
!                                of changed porosity
!                                tau = tau_0 * por^alpha / por_0^alpha
!                                tau_fac = por^alpha / por_0^alpha
!           marchies(nn)       = tortuosity update factor in archie's equation
!                                tau = por^alpha
!                                alpha = marchies(i)
!           pornew(nn)         = porosity           
!           por_init(nn)       = initial porosity  
!           sgnew(nn)          = gaseous phase saturation 
!                                (new time level)
!           sgold(nn)          = gaseous phase saturation 
!                                (old time level)
!           sainc(nn)          = aqueous phase saturation 
!                                (incremented)
!           sanew(nn)          = aqueous phase saturation 
!                                (new time level)
!           saold(nn)          = aqueous phase saturation 
!                                (time level N)
!           saold2(nn)         = aqueous phase saturation 
!                                (time level N-1)
!           sonew(nn)          = oil saturation
!           snnew(nn)          = napl saturations time level N+1
!           relperm(nn)        = relative permeability
!           relpermg(nn)       = relative permeability for the 
!                                gas phase
!           relpinc(nn)        = relative permeability (incremented)
!           uvsinc(nn)         = solution vector (incremented)
!           uvsnew(nn)         = solution vector (new time level)
!           uvsold(nn)         = solution vector (old time level)
!           cinfvs_a(njavs)    = influence coefficients for the 
!                                aqueous phase
!           cinfvs_g(njavs)    = influence coefficients for the 
!                                gas phase
!           Added by Anna Harrison Jan 24, 2014
!           qh20(nn)           = equation to remove water during
!                                hydrated mineral precipitation
!                                [L]
!           rwaterremovalcoeff(nm)  
!                              = water removal coefficient,
!                                e.g., 2 for nesquehonite Mg(HCO3)(OH)2H2O
!                                      3 for artinite     Mg2(CO3)(OH)23H2O
!                                Note: this coefficient is a little different
!                                from the stoichiometric of mineral reaction 
!                                equation. Danyang SU, 2015-03-27
!
!
!           integer:
!           --------
!           mpropvs(nn)        = pointer array for allocation of 
!                                material properties
!           logical::
!           --------
!           water_removal      = true to use water removal feature
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: uvsnew(:)
      real (type_r8), allocatable :: uvsold(:)
      real (type_r8), allocatable :: uvsinc(:)
      real (type_r8), allocatable :: hhead(:)
      real (type_r8), allocatable :: saold(:)
      real (type_r8), allocatable :: sanew(:)
      real (type_r8), allocatable :: sgold(:)
      real (type_r8), allocatable :: sgnew(:)
      real (type_r8), allocatable :: sainc(:)
      real (type_r8), allocatable :: sonew(:) ! oil sat - May 15, 06
      real (type_r8), allocatable :: relperm(:)
      real (type_r8), allocatable :: relpermg(:)
      real (type_r8), allocatable :: relpinc(:)
      real (type_r8), allocatable :: relpincg(:)
      real (type_r8), allocatable :: pornew(:)
      real (type_r8), allocatable :: porold(:)
      real (type_r8), allocatable :: por_init(:)
      real (type_r8), allocatable :: perm_fac(:)
      real (type_r8), allocatable :: tau_fac(:)
      real (type_r8), allocatable :: marchies(:)
      real (type_r8), allocatable :: cinfvs(:)
      real (type_r8), allocatable :: cinfvs_a(:)
      real (type_r8), allocatable :: cinfvs_g(:)
      real (type_r8), allocatable :: permij(:)
      real (type_r8), allocatable :: cinfrad(:)
      real (type_r8), allocatable :: snnew(:)
      real (type_r8), allocatable :: saold2(:)
      
      logical :: water_removal
      real (type_r8), allocatable :: qh2o(:)
      real (type_r8), allocatable :: rwaterremovalcoeff(:) 
      
      real (type_r8), allocatable :: tauivol(:)

      integer (type_i4), allocatable :: mpropvs(:)
      
      real (type_r8), allocatable :: stor(:)
      
      real (type_r8)              :: facpormin 

! ----------------------------------------------------------------------
! mass balance (variably saturated flow):
! ---------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           culabsbalvs        = accumulative absolute mass balance 
!                                error
!           totvsmass          = total system mass
!           rtol_relbalance_vs = relative mass balance tolerance for
!                                convergence check
!           rtol_absbalance_vs = absolute mass balance tolerance for
!                                convergence check
!           relbalance_vs      = relative mass balance for                            
!                                convergence check                                              
!           absbalance_vs      = absolute mass balance for                            
!                                convergence check 
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: totvsmass
      real (type_r8) :: culabsbalvs 

      real (type_r8) :: rtol_relbalance_vs
      real (type_r8) :: rtol_absbalance_vs
      real (type_r8) :: relbalance_vs
      real (type_r8) :: absbalance_vs

! ----------------------------------------------------------------------
! boundary and initial conditions (variably saturated flow):
! ----------------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           bcondvs(nbvs)      = boundary condition 
!                                (pressure head or flux) or 
!                                identification of seepage face 
!                                boundary type
!           pet                = potential evapotranspiration
!           pe_soil            = potential soil evaporation
!           canopy_int         = canopy interception
!	    scale_tree_growth  =  CBF ADDED
!	    solar_ratio	       =  CBF ADDED
!           time_bcvs          = next read time for flow boundary 
!                                conditions
!           time_soi           = next read time for soil specific
!                                parameters
!      
!           integer:
!           --------
!           iabvs(nbvs)        = pointer to boundary control volumes
!                                for variably saturated flow
!           ivol2bvs(nbvs)     = pointer from control volume number to 
!                                boundary control volume index
!           bvalid_iabvs(nbvs) = flag to indicate if this boundary 
!                                condition is valid. If the boundary
!                                condition is overwritten, it is 
!                                an invalid boundary condition
!                                .true.  => valid
!                                .false. => invalid
!                                
!           ibcvs              = unit number, transient boundary 
!                                             conditions, variably
!                                             saturated flow
!           isoi               = unit number, soil specific 
!                                             parameters
!           nbvs               = number of specified boundary 
!                                control volumes 
!                                (variably saturated flow)
!
!           logical:
!           --------
!           update_bcvs        = .true.  -> transient boundary  
!                                           condition for variably 
!                                           saturated flow
!           character:
!           ----------
!           btypevs(nbvs)      = boundary type array 
!                                (variably saturated flow)
!                                'first'   = Dirichlet 
!                                'second'  = Neumann
!                                'seepage' = seepage face
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8) :: pet
      real (type_r8) :: pe_soil
      real (type_r8) :: canopy_int
      real (type_r8) :: time_bcvs
      real (type_r8) :: time_soi
      real (type_r8) :: scale_tree_growth
      real (type_r8) :: solar_ratio
      real (type_r8), allocatable :: bcondvs(:)
      
      real (type_r8) :: np_sirius !TR azote optimal
      real (type_r8) :: tp_sirius !TR
      real (type_r8) :: ep_sirius !TR
      real (type_r8) :: lost_water !TR
      real (type_r8) :: irrig_sirius !TR
      real (type_r8) :: ferti_sirius !TR
      real, dimension (:), allocatable :: rld_sirius 
      !real,dimension(nn) :: rld_sirius !TR
      logical :: siriusDayDone = .false. !TR
      logical :: sirius_finished = .false. !TR
      logical :: min3pDayFinished = .false. !TR
      

      integer (type_i4), allocatable :: iabvs(:)
      integer (type_i4), allocatable :: ivol2bvs(:)
      !logical, allocatable :: bvalid_iabvs(:)

      integer (type_i4) :: nbvs
      integer (type_i4) :: ibcvs
      integer (type_i4) :: isoi

      logical :: update_bcvs
!cprovi-----------------------------------------------------------------      
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
      logical :: update_ext_type_bcvs
      integer (type_i4) :: ibcvs1
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------      

      character*12, allocatable :: btypevs(:)

! ----------------------------------------------------------------------
! newton iteration - variably saturated flow
! ------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           dinc_vs            = increment for numerical 
!                                differentiation
!           relfacold          = underrelaxation factor 
!                                (old time level)
!           relfactempold      = underrelaxation factor 
!                                (old time level, temperature)
!           srelfac_vs         = user specified underrelaxation 
!                                factor
!           srelfac_temp       = user specified underrelaxation 
!                                factor (temperature)
!           tol_vs             = convergence tolerance 
!                                (variably saturated flow)
!           uvsmaxold          = maximum solution update 
!                                (old time level)
!           utempmaxold        = maximum solution update 
!                                (old time level, temperature)
!           vsflux(ncon-1)     = interfacial fluxes
!
!           integer:
!           --------
!           iter_vs            = iteration counter 
!                                (variably saturated flow)
!           ittot_vs           = total number of iterations 
!                                (variably saturated flow)
!           ittotglob          = total number of iterations
!                                (heat transport)
!           maxit_vs           = max. number of newton iterations
!                                (variably saturated flow)
!
!           logical:
!           --------
!           comp_relax         = .true.  -> compute underelaxation 
!                                           factor
!           comp_relax_temp    = .true.  -> compute underelaxation 
!                                           factor for temperature
!           under_relax        = .true.  -> underrelaxation
!           upstream           = .true.  -> upstream weighting
!           under_relax_temp   = .true.  -> underrelaxation for temperature
!
!           character:
!           ----------
!           iups(ncon-1)       = upstream pointer
!           iupsg(njavs)       = upstream node for gas transport
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: vsflux(:)

      real (type_r8)    :: dinc_vs
      real (type_r8)    :: tol_vs
      real (type_r8)    :: uvsmaxold
      real (type_r8)    :: relfacold
      real (type_r8)    :: srelfac_vs

      integer (type_i4) :: maxit_vs
      integer (type_i4) :: iter_vs
      integer (type_i4) :: ittot_vs
      integer (type_i4) :: ittotglob

      logical           :: upstream
      logical           :: under_relax
      logical           :: comp_relax
      
      real (type_r8)    :: utempmaxold
      real (type_r8)    :: relfactempold
      real (type_r8)    :: srelfac_temp
      
      logical           :: under_relax_temp
      logical           :: comp_relax_temp

      character*1, allocatable :: iups(:)
      character*1, allocatable :: iupsg(:) ! upstream node for gas trans

! ----------------------------------------------------------------------
! data structure and solver - variably saturated flow: 
! ----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           avs(njavs)         = jacobian matrix
!           afvs(njafvs)       = incomplete factorization
!           bvs(nn)            = rhs vector
!           deltol_vs          = solver update tolerance
!           resvs(nn)          = residual
!           restol_vs          = solver residual tolerance
!           uvs(nn)            = update towards solution-vector
!
!           integer:
!           --------
!           iavs(nn+1)         = row pointer array for 1d-scalar 
!                                matrix
!           iafvs(nn+1)        = row pointer array for afvs
!           idetail_vs         = information level
!           javs(njavs)        = connectivity list for 1d-scalar 
!                                matrix
!           jafvs(njafvs)      = column pointer array for afvs
!           iafdvs(nn)         = diagonal pointer array for afvs
!           isymvs(njavs)      = symmetry pointer array 
!           lordervs(nn)       = array containing ordering
!           invordvs(nn)       = array containing inverse ordering
!           level_vs           = incomplete factorization level
!           msolvit_vs         = max. number of solver iterations
!           mnjavs             = max. number of global connections
!           mnjafvs            = max. number of factored connections
!           njavs              = number of global connections
!           njafvs             = number of factored connections
!
!           logical:
!           --------
!           rcm_ordering_vs    = .true.  -> rcm ordering for 
!                                           1-d scalar matrix
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: avs(:)
      real (type_r8), allocatable :: bvs(:)
      real (type_r8), allocatable :: uvs(:)
      real (type_r8), allocatable :: resvs(:)
      real (type_r8), allocatable :: afvs(:)

      real (type_r8) :: restol_vs
      real (type_r8) :: deltol_vs

      integer (type_i4), allocatable :: iavs(:)
      integer (type_i4), allocatable :: javs(:)
      integer (type_i4), allocatable :: iafvs(:)
      integer (type_i4), allocatable :: jafvs(:)
      integer (type_i4), allocatable :: iafdvs(:)
      integer (type_i4), allocatable :: isymvs(:)
      integer (type_i4), allocatable :: lordervs(:)
      integer (type_i4), allocatable :: invordvs(:)

      integer (type_i4) :: mnjavs
      integer (type_i4) :: mnjafvs
      integer (type_i4) :: njavs
      integer (type_i4) :: njafvs
      integer (type_i4) :: level_vs
      integer (type_i4) :: msolvit_vs
      integer (type_i4) :: idetail_vs

      logical           :: rcm_ordering_vs
      
! ----------------------------------------------------------------------
! standard data structure and solver - variably saturated flow: 
! ----------------------------------------------------
!        -->                                                         <--
!           real*8:
!           -------
!           avs_std(njavs)     = jacobian matrix for standard sparse
!                                 matrix
!           integer:
!           --------
!           javs_std(njavs)    = connectivity list for 1d-scalar 
!                                matrix
!           imapvs_std(njavs) = point of standard sparse matrix to 
!                                 sparse matrix used in ws209
!                                 
!        -->                                                         <--
! ----------------------------------------------------------------------

      real (type_r8), allocatable :: avs_std(:)
      real (type_r8), allocatable :: uvs_std(:)         !for test, dsu      
      integer (type_i4), allocatable :: javs_std(:)
      integer (type_i4), allocatable :: imapvs_std(:)  
      logical :: bsymbolicfactor_vs  =  .true.

! ----------------------------------------------------------------------
! solver - general
! ----------------
!        -->                                                         <--
!           real*8:
!           -------
!           rwork(:,:)         = real*8 work array
!           rwork_max(:,:)     = real*8 work array, maximum work array for 
!                                solver in flow and reactive transport equations
!           rnorm              = residual 2-norm 
!           rmupdate           = maximum solution update (solver)
!
!           integer:
!           --------
!           iwork(:)           = integer work array
!           iwork_max(:)       = integer work array, maximum work array for 
!                                solver in flow and reactive transport equations
!           itsolv             = actual number of solver iterations
!           n_rwork_max        = maximum size of rwork for flow and reactive transport
!
!           logical:
!           --------
!           lwork(:)           = logical work array
! ----------------------------------------------------------------------


      real (type_r8), allocatable :: rwork(:,:)
      real (type_r8), allocatable :: rwork_max(:)      
      

      real (type_r8) :: rnorm
      real (type_r8) :: rmupdate
      logical :: over_flow_vs
      logical :: over_flow_rt


      integer (type_i4), allocatable :: iwork(:)
      integer (type_i4), allocatable :: iwork_max(:)

      integer (type_i4) :: itsolv
      
      integer :: n_rwork_max
      integer :: n_iwork_max

      logical, allocatable :: lwork(:)
      
! ----------------------------------------------------------------------
      integer (type_i4) :: skip_time, nskip_time    ! skip writing output in logfile
                                                    ! for long simulations

      logical :: chemical_water

	  real (type_r8), allocatable :: qwater(:)
      
!cprovi--------------------------------------------------------
!cprovi Restart process
!cprovi Based on Richard Amos implementation 
!cprovi integer (type_i4) :: rsrt_cnt           ! restart counter
!cprovi    integer (type_i4) :: irsrt              ! output unit for restart files
!cprovi    integer (type_i4) :: backup_frequency   ! backup frecuency 
!cprovi    logical           :: restart_sim        ! if true, the simulations is restarted according to restart.dat file 
!cptovi 
!cprovi It was added 09/08/2009 
!cprovi Sergio Andres Bea Jofre 
!cprovi--------------------------------------------------------
      integer (type_i4) :: rsrt_cnt           ! restart counter
      integer (type_i4) :: irsrt              ! output unit for restart files
      integer (type_i4) :: backup_frequency   ! backup frecuency 
      logical           :: restart_sim        ! if true, the simulations is restarted according to restart.dat file 
      logical           :: b_max_restart_timestep       ! if true, the simulation is restarted at maximum timestep
      logical           :: b_distributed_restart_read   ! If true, the simulations is restarted according to restart_rank_n.dat file. 
                                                        ! Note: activate this if domain decomposition method is used.
      logical           :: b_distributed_restart_write  ! If true, the simulations is restarted according to restart_rank_n.dat file. 
                                                        ! Note: activate this if domain decomposition method is used.
                                               
      logical           :: b_binary_restart_read   ! if true, use binary fortat tp read restart file
      logical           :: b_binary_restart_write  ! if true, use binary fortat to write restart file
!cprovi--------------------------------------------------------
!cprovi
!cprovi Ice sheet 
!cprovi Sergio Andres Bea Jofre 
!cprovi 
!cprovi--------------------------------------------------------
      type(t_ice_sheet), pointer    :: ice_sheet
      logical                       :: compute_ice_sheet_loading
      logical                       :: compute_permafrost 
      real (type_r8), allocatable   :: skempton(:)
      integer (type_i4)             :: iskempton  ! Unit for skempton's coefficient
      real (type_r8), allocatable   :: bcondvs0(:)
      integer(type_i4), allocatable :: iabvs0(:)
      integer(type_i4), allocatable :: jabrt0(:)
      integer(type_i4)              :: nbvs0
      integer(type_i4)              :: nbrt0
      real (type_r8), allocatable   :: por_stress(:)     ! - stor * skempton * delta stress  
      real (type_r8), allocatable   :: por_stress_old(:)
      
      real(type_r8), allocatable    :: valuebc(:)        
      integer(type_i4), allocatable :: iwork_bc(:)
      real(type_r8), allocatable    :: rwork_bc(:)
      
!cdsu ice loading/unloading timeline variables
!cdsu this variables are used to modify the timestep to make sure the timestep will 
!cdsu not span the ice loading/unloading stages.
!cdsu assume the time is in ascending order and continuous, icetimeline(2,nstages)
!cdsu these 
      integer(type_i4)              :: icestage, nicestages
      real(type_r8), allocatable    :: icetimeline(:,:)

!cprovi--------------------------------------------------------
!cprovi--------------------------------------------------------
!cprovi--------------------------------------------------------

!>Parameter for output control
! dsu
!> b_writeversion_tecplot
!> If ture, write version information to the output tecplot data file or not
      logical                       :: b_writeversion_tecplot = .false.

!>dsu----------------------------------------------------------
!>Parameters for parallel version of min3p, OpenMP
!>dsu----------------------------------------------------------
! path of parallel solver configuration file
     character(2048) :: str_solvercfg
!> b_solver_cfg_arg: if true, the solver configuration file is specified from the input arguments
!> Otherwise, it is specified from the input file
     logical :: b_solver_cfg_arg = .false.

!> isolvercfg
!> file unit of solver configuration
     integer(type_i4) :: isolvercfg
!
!> b_solver_test_pardiso
     logical :: b_solver_test_pardiso   = .false.             !.true.
     
!
!> b_solver_test_petsc
     logical :: b_solver_test_petsc     = .false.             !.true.
     
!
!> b_output_condition_number
     logical :: b_output_condition_number = .false. 

!> b_dynamic_memory 
!> use static memory is more efficient than dynamic memory, especially when memory is large enough
     logical :: b_dynamic_memory        = .false.
     
!> b_enable_output
!> If fasle, the output will be disabled. Only some log information are output.
     logical :: b_enable_output = .true.
     
!> b_enable_output_gen
     logical :: b_enable_output_gen = .true.
     
!> b_min3p_input_param_first
!> If true, it indicates that the input parameters in the MIN3P input
!> file have the priority over the input parameters in the parallel
!> solver configuration file.
!> By default, the parameters in this file will overwrite the same
!> parameters in the MIN3P input file.
!> For example, if there are solver convergence parameters in both 
!> files, you can use the following command if you want to use MIN3P
!> input parameters first.
!> Requirement: Optional
!> 
     logical :: b_min3p_input_param_first = .false.
     
!> b_mpi_process_flag = .true. stop or return all process
     logical :: b_mpi_process_flag = .false.
    
    
!> i_solver_type = 0 use ws209 solver
!>                 1 use pardiso solver
     integer :: i_solver_type           = 0 
!> i_solver_type_flow = 0 use ws209 solver
!>                      1 use pardiso solver
     integer :: i_solver_type_flow      = 0
!> i_solver_type_react = 0 use ws209 solver
!>                       1 use pardiso solver
     integer :: i_solver_type_react     = 0
     
!> i_symfactor_type_flow = 0 symbolic factorization at first run
!>                         1 symbolic factorization every step
     integer :: i_symfactor_type_flow   = 0
!> i_symfactor_type_react = 0 symbolic factorization at first run
!>                          1 symbolic factorization every step
     integer :: i_symfactor_type_react  = 0
     
!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time.
!> When preconditioned CGS is used, this value will be compared to the number of completed iterations,
!> otherwise, this value will be compared to the number of iterative refinement steps performed.
!> When the iteration number is larger than the provided, do symblic factorization again.
!> Maximum pardiso solver iteration in flow
     integer :: n_max_iteration_flow  = 9
!> Maximum pardiso solver iteration in reactive transport   
     integer :: n_max_iteration_react = 9
     
!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time. 
!> When the maximum residual is larger than the provided, do symblic factorization again.
!> Maximum residual in flow
     real (type_r8) :: r_max_residual_flow  = 1.0E-5
!> maximum residual in reactive transport
     real (type_r8) :: r_max_residual_react = 1.0E-5
     
!> b_prtfile write files of parallel runtime (prt) for different modules
     logical :: b_prtfile = .false.
     
!> b_output_matrix output sparse matrix data set and rhs for different modules    
     logical :: b_output_matrix = .false.
     
!> b_output_matrix output sparse matrix data set and rhs for different modules using petsc
     logical :: b_output_matrix_petsc = .false.

!> output sparse matrix data set and rhs at specific timestep
     integer(type_i4) :: itimestep_output_matrix = -1

!> Set the output matrix format  
!> 0: export a (ia, ja), b, x as 1d array into separated files
!> 1: export a (ia, ja) as matrix market exchange format, 
!>    and b and x as 1d array into separated files
!> E.g.
!> OUTPUT MATRIX FORMAT SELECTION
!> 1
     integer(type_i4) :: itype_matrix_format = 1

!> file unit of parallel runtime (prt) for different modules
!> file unit of parallel runtime for flow
     integer(type_i4) :: iprt_flow
!> file unit of parallel runtime for reactive transport
     integer(type_i4) :: iprt_react
!> file unit of parallel runtime for reactive transport
     integer(type_i4) :: iprt_react_jac     
!> file unit of parallel runtime for flow
     integer(type_i4) :: iprt_flow_comp
!> file unit of parallel runtime for reactive transport
     integer(type_i4) :: iprt_react_comp     
!> file unit of parallel runtime for non-linear euqations in every time step
     integer(type_i4) :: iprt_nonlinear
!> file unit of parallel runtime for time steps
     integer(type_i4) :: iprt_timestep    
     
!> parallel runtime for flow module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_flow_tot       = 0
     real (type_r8) :: prt_flow_jac       = 0
     real (type_r8) :: prt_flow_symbfac   = 0
     real (type_r8) :: prt_flow_fac       = 0
     real (type_r8) :: prt_flow_sub       = 0
     real (type_r8) :: prt_flow_solver    = 0   !total time of symbfac, fac and sub
     
!> parallel runtime for reactive transport module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_react_tot      = 0
     real (type_r8) :: prt_react_jac      = 0
     real (type_r8) :: prt_react_symbfac  = 0
     real (type_r8) :: prt_react_fac      = 0
     real (type_r8) :: prt_react_sub      = 0
     real (type_r8) :: prt_react_solver   = 0   !total time of symbfac, fac and sub
     
!> parallel runtime for flow module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_flow_symbfac_comp  = 0
     real (type_r8) :: prt_flow_fac_comp  = 0
     real (type_r8) :: prt_flow_sub_comp  = 0
     
!> parallel runtime for reactive transport module "jacobi matrix construction", 
!> "factorization" and "substitution"
     real (type_r8) :: prt_react_symbfac_comp = 0
     real (type_r8) :: prt_react_fac_comp = 0
     real (type_r8) :: prt_react_sub_comp = 0 

!> parallel runtime for coupling iterations
     real (type_r8) :: prt_nonlinear_tot   = 0
     real (type_r8) :: prt_nonlinear_flow  = 0
     real (type_r8) :: prt_nonlinear_react = 0
     
!> parallel runtime for time steps
     real (type_r8) :: prt_timestep_tot       = 0
     real (type_r8) :: prt_timestep_nonlinear  = 0
     
!> time for different part of matrix assemble in reactive transport  
!> For test only, dsu
     real (type_r8) :: prt_react_jac_part(6)
    
!>
!> Set the number of threads for global use
!> Default value: 1
!> Requirement: Optional
!> This value should maybe reset to the maximum number of threads
!> used for each process.
    integer(type_i4) :: numofthreads_global = 1
    
!>
!> Set the maximum number of threads used.
    integer(type_i4) :: nthreads = 1
    
!>
!> Set the number of parallel loop threshold for general use
!> Default value: 10000
!> Requirement: Optional  
    integer(type_i8) :: numofloops_thred_global = 1
    
!>
!> Set the matrix assembly type for flow problem
!> i_matrix_assembly_type_flow = 0 use sequential mode (default)
!>                               1 use Openmp parallel mode
!>                               2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode    
    integer(type_i4) :: i_matrix_assembly_type_flow = 0
    
!>
!> Set the number of threads in matrix assembly for flow problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: numofthreads_matrix_flow = 1
    
!> Set the schedule type in matrix assembly for flow problem.
!> If not specified, use the static schedule method.
!> i_schedule_type_flow = 0 use static schedule method (default)
!>                        1 use dynamic schedule method 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_schedule_type_flow = 0


!> Set the chunk size factor for matrix assembly for flow problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_flow = 0 use system default size
!>                           1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_chunksize_factor_flow = 0   
    
!>
!> Set the matrix assembly type for reactive transport problem
!> i_matrix_assembly_type_react = 0 use sequential mode (default)
!>                                1 use Openmp parallel mode
!>                                2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_matrix_assembly_type_react = 0
    integer(type_i4) :: i_matrix_assembly_type_jacrt = 0
    integer(type_i4) :: i_matrix_assembly_type_jacbrt = 0
    
!>
!> Set the number of threads in matrix assembly for reactive 
!> transport problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: numofthreads_matrix_react = 1
    
!> Set the schedule type in matrix assembly for reactive 
!> transport problem.
!> If not specified, use the static schedule method.
!> i_schedule_type_react = 0 use static schedule method (default)
!>                         1 use dynamic schedule method 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_schedule_type_react = 0

!> Set the chunk size factor for matrix assembly for reactive 
!> transport problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_react = 0 use system default size
!>                            1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
    integer(type_i4) :: i_chunksize_factor_react = 0
    
!> Set the number of threads for ws209 solver.
!> Only works when the solver type is ws209.
!> Default value: 1
    integer(type_i4) :: numofthreads_ws209 = 1
    
!> Condition number of Jacobi matrix
!> condition_number(1): classical condition number in the infinite-norm
!> condition_number(2): Skeel's condition number
!> In the case of an error return, condition_number is set to zero.
    real(type_r8) :: condition_number(2)
!> Return information of estimating condition number
    integer :: condition_number_info(5)

!> Variables for OpenMP version 
#ifdef OPENMP
    character*72, allocatable :: string_omp(:)
    
    integer(type_i4), allocatable :: maxvol_omp(:)
    real(type_r8),    allocatable :: maxval_omp(:)
    
    integer(type_i4), allocatable :: maxvol_omp2(:)
    real(type_r8),    allocatable :: maxval_omp2(:) 
    
    logical, allocatable :: bflag_omp1(:)
    logical, allocatable :: bflag_omp2(:)
    logical, allocatable :: bflag_omp3(:)
    
#endif

!> Openmp parallel debug variables
#ifdef OPENMP
    integer(type_i8) :: numofloops_thred_mbalrt_1
    integer(type_i8) :: numofloops_thred_mbalrt_2
    integer(type_i8) :: numofloops_thred_mbalrt_3
    integer(type_i8) :: numofloops_thred_mbalrt_4
    integer(type_i8) :: numofloops_thred_mbalrt_5
    integer(type_i8) :: numofloops_thred_mbalrt_6
    integer(type_i8) :: numofloops_thred_mbalrt_7
    integer(type_i8) :: numofloops_thred_mbalrt_8
    integer(type_i8) :: numofloops_thred_mbalrt_9
    integer(type_i8) :: numofloops_thred_mbalrt_10
    integer(type_i8) :: numofloops_thred_mbalrt_11

    integer(type_i8) :: numofloops_thred_msysrt_1
    integer(type_i8) :: numofloops_thred_msysrt_2
    integer(type_i8) :: numofloops_thred_msysrt_3
    integer(type_i8) :: numofloops_thred_msysrt_4
    integer(type_i8) :: numofloops_thred_msysrt_5
    integer(type_i8) :: numofloops_thred_msysrt_6 
    
    integer(type_i8) :: numofloops_thred_mcd_1
    integer(type_i8) :: numofloops_thred_mcd_2
    integer(type_i8) :: numofloops_thred_mcd_3
    
    integer(type_i8) :: numofloops_thred_infcrtdd_1
    integer(type_i8) :: numofloops_thred_infcrtdd_2
    integer(type_i8) :: numofloops_thred_infcrtdd_3
    
    integer(type_i8) :: numofloops_thred_infcrt_a_1
    integer(type_i8) :: numofloops_thred_infcrt_a_2
    integer(type_i8) :: numofloops_thred_infcrt_a_3  
    
    integer(type_i8) :: numofloops_thred_infcrt_g_1
    integer(type_i8) :: numofloops_thred_infcrt_g_2 
    
    integer(type_i8) :: numofloops_thred_infcrt_mcd_1
    integer(type_i8) :: numofloops_thred_infcrt_mcd_2 
    
    integer(type_i8) :: numofloops_thred_diffcoff_mcd_1
    
    integer(type_i8) :: numofloops_thred_i2upfind_heat_1
        
    integer(type_i8) :: numofloops_thred_i2upfind_1
    
    integer(type_i8) :: numofloops_thred_ddtds_1
    
    integer(type_i8) :: numofloops_thred_ddtds_energybal_1
    integer(type_i8) :: numofloops_thred_ddtds_energybal_2
    
    integer(type_i8) :: numofloops_thred_comp_bc_ice_1
    integer(type_i8) :: numofloops_thred_comp_bc_ice_2
    
    integer(type_i8) :: numofloops_thred_timeloop_1
    
    integer(type_i8) :: numofloops_thred_infheat_c_1
    
    integer(type_i8) :: numofloops_thred_infheat_d_1
    
    integer(type_i8) :: numofloops_thred_infevap_1
    
    integer(type_i8) :: numofloops_thred_updatedd_1
    integer(type_i8) :: numofloops_thred_updatedd_2
    
    integer(type_i8) :: numofloops_thred_updatedd_ener_1    
    integer(type_i8) :: numofloops_thred_updatedd_ener_2
    integer(type_i8) :: numofloops_thred_updatedd_ener_3
    
    integer(type_i8) :: numofloops_thred_ddvsflow_1
    
    integer(type_i8) :: numofloops_thred_seepfdd_1
    
    integer(type_i8) :: numofloops_thred_tstepvs_1
    
    integer(type_i8) :: numofloops_thred_updatevs_1
    integer(type_i8) :: numofloops_thred_updatevs_2
    
    integer(type_i8) :: numofloops_thred_seepface_1    
    
    integer(type_i8) :: numofloops_thred_soilparm_1
    
    integer(type_i8) :: numofloops_thred_msysdd_1
    integer(type_i8) :: numofloops_thred_msysdd_2
    integer(type_i8) :: numofloops_thred_msysdd_3
    
    integer(type_i8) :: numofloops_thred_msysvs_1
    
    integer(type_i8) :: numofloops_thred_mbalvs_1
    integer(type_i8) :: numofloops_thred_mbalvs_2
    integer(type_i8) :: numofloops_thred_mbalvs_3
    
    integer(type_i8) :: numofloops_thred_energysys_1
    
    integer(type_i8) :: numofloops_thred_energy_bal_1
    integer(type_i8) :: numofloops_thred_energy_bal_2
    
    integer(type_i8) :: numofloops_thred_velodd_1
    
    integer(type_i8) :: numofloops_thred_nexttime_1
    integer(type_i8) :: numofloops_thred_nexttime_2
    
    integer(type_i8) :: numofloops_thred_infcvs_1
    
    integer(type_i8) :: numofloops_thred_xyzcoord_1
    
    integer(type_i8) :: numofloops_thred_cvolume_1

    integer(type_i8) :: numofloops_thred_iajavs_1
    integer(type_i8) :: numofloops_thred_iajavs_2
    
    integer(type_i8) :: numofloops_thred_iajavs_dp_1
    
    integer(type_i8) :: numofloops_thred_iajavs_ener_1
    integer(type_i8) :: numofloops_thred_iajavs_ener_2
    
    integer(type_i8) :: numofloops_thred_matrix_uti_1
    
    integer(type_i8) :: numofloops_thred_initpppm_1
    
    integer(type_i8) :: numofloops_thred_initppvs_1    
    integer(type_i8) :: numofloops_thred_initppvs_2
    
    integer(type_i8) :: numofloops_thred_initppdd_1
    
    integer(type_i8) :: numofloops_thred_initppeb_1
    integer(type_i8) :: numofloops_thred_initppeb_2
    
    integer(type_i8) :: numofloops_thred_initicvs_1
    
    integer(type_i8) :: numofloops_thred_initsatw_1
    integer(type_i8) :: numofloops_thred_initsatw_2
    integer(type_i8) :: numofloops_thred_initsatw_3
    
    integer(type_i8) :: numofloops_thred_initicener_1
    
    integer(type_i8) :: numofloops_thred_initprob_1
    integer(type_i8) :: numofloops_thred_initprob_2
    
    integer(type_i8) :: numofloops_thred_initicrt_1
    
    integer(type_i8) :: numofloops_thred_initicdd_1
    
    integer(type_i8) :: numofloops_thred_restart_1
    
    integer(type_i8) :: numofloops_thred_batreac_1
    integer(type_i8) :: numofloops_thred_batreac_2
    
    integer(type_i8) :: numofloops_thred_intpolt
    
    integer(type_i8) :: numofloops_thred_mbaldd_1
    integer(type_i8) :: numofloops_thred_mbaldd_2
    integer(type_i8) :: numofloops_thred_mbaldd_3
    integer(type_i8) :: numofloops_thred_mbaldd_4
    
    integer(type_i8) :: numofloops_thred_gasbub_1
    integer(type_i8) :: numofloops_thred_gasbub_2
    integer(type_i8) :: numofloops_thred_gasbub_3
    integer(type_i8) :: numofloops_thred_gasbub_4
    integer(type_i8) :: numofloops_thred_gasbub_5
    
    integer(type_i8) :: numofloops_thred_rateh2o_1
    
#endif

!>dsu----------------------------------------------------------
!>Parameters for parallel version of min3p, OpenMP
!>dsu----------------------------------------------------------

    logical :: b_use_mpi_nprcs_omp_nthreads
    
    integer*4 :: rank 
    integer*4 :: nprcs
    integer*4 :: nthreads_per_proc
    character(14) :: str_rank
    integer*4, allocatable :: dmda_neighbors(:)
#ifndef PETSC
    integer*4 :: Petsc_Comm_World
    integer*4 :: Petsc_Comm_Self
#endif

    !Variables used for mpi reduce operation
    real(type_r8):: mpireduce_gbl
    real(type_r8), allocatable :: mpireduce_n(:)
    real(type_r8), allocatable :: mpireduce_ng(:)
    real(type_r8), allocatable :: mpireduce_nm(:)
    real(type_r8), allocatable :: mpireduce_naq(:)
    
    
    !> Temp value for input data reading
    real(type_r8), allocatable :: rtempvals(:)
    !>       MIN3P                       MIN3P
    !> Local volume number   to   Global volume number
    !> without ghost nodes 
    !>         (a)                        (b)
    !> ------------------         ------------------
    !> | 4  5  6 | 3  4 |         | 21 22 23| 24 25|
    !> | 1  2  3 | 1  2 |         | 16 17 18| 19 20|
    !> ------------------   <-->  ------------------
    !> | 7  8  9 | 5  6 |         | 11 12 13| 14 15|
    !> | 4  5  6 | 3  4 |         | 6  7  8 | 9  10|
    !> | 1  2  3 | 1  2 |         | 1  2  3 | 4  5 |
    !> ------------------         ------------------
    !>        /\                          /\
    !>        \/                          \/
    !>                    
    !>     MIN3P/PETSc                   PETSc
    !> Local volume number   to   Global volume number
    !> with ghost nodes 
    !>         (c)                        (d)
    !> ------------------         ------------------
    !> | X  X  X | X  X |         | 19 20 21| 24 25|
    !> | 13 14 15| 16 X |         | 16 17 18| 22 23|
    !> ------------------   <-->  ------------------
    !> | 9  10 11| 12 X |         | 7  8  9 | 14 15|
    !> | 5  6  7 | 8  X |         | 4  5  6 | 12 13|
    !> | 1  2  3 | 4  X |         | 1  2  3 | 10 11|
    !> ------------------         ------------------  
    
    !>     MIN3P/PETSc     
    !> Local volume number 
    !> with ghost nodes 
    !>         (e)         
    !> ------------------  
    !> |-1  13 14| 15 16|  
    !> |-1  9  10| 11 12|  
    !> ------------------  
    !> |-1  5  6 | 7  8 |  
    !> |-1  1  2 | 3  4 |  
    !> |-1 -1 -1 |-1 -1 |  
    !> ------------------  
    
    !> MIN3P local volume number map with ghost nodes to 
    !> MIN3P local volume number map without ghost nodes, (c)->(a)
    !> If the value is -1, this is a ghost value 
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_lg2l(:)
    
    !> MIN3P local volume number map with ghost nodes to 
    !> min3p global node number map, (c)->(b)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_lg2g(:)
   
    !> MIN3P local volume number map with ghost nodes to 
    !> PETSc global volume number map, (c)->(d)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_lg2pg(:)  
    
    !> MIN3P local volume number map without ghost nodes to 
    !> MIN3P local volume number map with ghost nodes, (a)->(c)
    !> Size nn
    integer(type_i4), allocatable :: node_idx_l2lg(:)
    
    !> MIN3P local volume number map with ghost nodes to 
    !> min3p global node number map for velocity output, 
    !> If the value is -1, this is not a valid velocity node.
    !> (c)->(e)
    !> Size nngl
    integer(type_i4), allocatable :: node_idx_vel_lg2g(:)
    
    !> MIN3P local matrix pointer to global matrix pointer
    !> for flow problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_vs(:)
    integer(type_i4), allocatable :: col_idx_l2pg_vs(:)
    
    !> MIN3P local matrix pointer to global matrix pointer
    !> for density depedent flow problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_glob(:)
    integer(type_i4), allocatable :: col_idx_l2pg_glob(:)
    
    !> MIN3P local matrix pointer to global matrix pointer
    !> for reactive transport problem, (c)->(d)
    integer(type_i4), allocatable :: row_idx_l2pg_rt(:)
    integer(type_i4), allocatable :: col_idx_l2pg_rt(:)
    
!>dsu----------------------------------------------------------
!>Parameters for binary output of tecplot data file
!>dsu----------------------------------------------------------
    !> b_output_binary: if true, use binary output, otherwise, use ascii output
    logical :: b_output_binary
    !> b_output_mpiio_single: if true, use parallel mpi I/O to export the result
    !> as a single file from different ranks, otherwise, use parallel mpi I/O to 
    !> export nrank files from different ranks. Only binary output is supported
    !> for mpi I/O single file export.
    logical :: b_output_mpiio_single
    !> b_output_multizone: if true, the binary output will use multizone data format
    !> for spatial output, otherwise, the results of different zones are merged into
    !> one domain. By default, this is false.
    logical :: b_output_multizone
    
    !> the default binary output is in single precision. If double precision is 
    !> needed, add 'OUTPUT_DOUBLE' to the preprocessor definition.
#ifdef OUTPUT_DOUBLE
    integer, parameter :: nfloatbit = 8 
    real*8, allocatable :: realbuffer(:)
    real*8, allocatable :: realbuffer2(:)
    real*8, allocatable :: realbuffer3(:)
    real*8, allocatable :: realbuffer4(:)
    real*8, allocatable :: realbuffer5(:)
    real*8, allocatable :: realbuffer6(:)
    real*8, allocatable :: realbuffer7(:)
    real*8, allocatable :: realbuffer8(:)
    real*8, allocatable :: realbuffer9(:)
    real*8, allocatable :: realbuffer10(:)
    real*8, allocatable :: realbuffer11(:)
    real*8, allocatable :: realbuffer12(:)
    real*8, allocatable :: realbuffer13(:)
    real*8, allocatable :: realbuffer2d(:,:)
    real*8, allocatable :: realbuffer2d_2(:,:)
    real*8              :: realbuffer_gb(1000)
#else 
    integer, parameter :: nfloatbit = 4 
    real*4, allocatable :: realbuffer(:)
    real*4, allocatable :: realbuffer2(:)
    real*4, allocatable :: realbuffer3(:)
    real*4, allocatable :: realbuffer4(:)
    real*4, allocatable :: realbuffer5(:)
    real*4, allocatable :: realbuffer6(:)
    real*4, allocatable :: realbuffer7(:)
    real*4, allocatable :: realbuffer8(:)
    real*4, allocatable :: realbuffer9(:)
    real*4, allocatable :: realbuffer10(:)
    real*4, allocatable :: realbuffer11(:)
    real*4, allocatable :: realbuffer12(:)
    real*4, allocatable :: realbuffer13(:)
    real*4, allocatable :: realbuffer2d(:,:)
    real*4, allocatable :: realbuffer2d_2(:,:)
    real*4              :: realbuffer_gb(1000)
#endif

!c  file unit for writing transient data (*.gb*)
    integer(type_i4), allocatable :: igbp_mpi(:)
    integer(type_i4), allocatable :: igbt_mpi(:)
    integer(type_i4), allocatable :: igbc_mpi(:)
    integer(type_i4), allocatable :: igbm_mpi(:)
    integer(type_i4), allocatable :: igbgr_mpi(:)
    integer(type_i4), allocatable :: igbg_mpi(:)
    integer(type_i4), allocatable :: igbi_mpi(:)
    integer(type_i4), allocatable :: igbb_mpi(:)
    integer(type_i4), allocatable :: igbs_mpi(:)
    integer(type_i4), allocatable :: igbv_mpi(:)
    integer(type_i4), allocatable :: igbd_mpi(:)
    integer(type_i4), allocatable :: igbx_mpi(:)
    integer(type_i4), allocatable :: igbis_mpi(:)
    
!c  offset for writing transient data (*.gb*) 
    integer*8, allocatable :: offset_igbp(:)
    integer*8, allocatable :: offset_igbt(:)
    integer*8, allocatable :: offset_igbc(:)
    integer*8, allocatable :: offset_igbm(:)
    integer*8, allocatable :: offset_igbgr(:)
    integer*8, allocatable :: offset_igbg(:)
    integer*8, allocatable :: offset_igbi(:)
    integer*8, allocatable :: offset_igbb(:)
    integer*8, allocatable :: offset_igbs(:)
    integer*8, allocatable :: offset_igbv(:)
    integer*8, allocatable :: offset_igbd(:)
    integer*8, allocatable :: offset_igbx(:)
    integer*8, allocatable :: offset_igbis(:)
    
    integer*8, allocatable :: offset_igbp_ijk(:)
    integer*8, allocatable :: offset_igbt_ijk(:)
    integer*8, allocatable :: offset_igbc_ijk(:)
    integer*8, allocatable :: offset_igbm_ijk(:)
    integer*8, allocatable :: offset_igbgr_ijk(:)
    integer*8, allocatable :: offset_igbg_ijk(:)
    integer*8, allocatable :: offset_igbi_ijk(:)
    integer*8, allocatable :: offset_igbb_ijk(:)
    integer*8, allocatable :: offset_igbs_ijk(:)
    integer*8, allocatable :: offset_igbv_ijk(:)
    integer*8, allocatable :: offset_igbd_ijk(:)
    integer*8, allocatable :: offset_igbx_ijk(:)
    integer*8, allocatable :: offset_igbis_ijk(:)
    
!c  file unit for writing transient data e.g., 
!c  .mas, .mss, .mgs, .mss, .mms, .mac, .mae, .msc, .mic, .mgc, .mmc
    integer(type_i4), allocatable :: imrt_mpi(:)
    integer(type_i4), allocatable :: imvs_mpi(:)
    integer(type_i4), allocatable :: imcd_mpi(:)

    
!c  offset for writing transient data e.g., 
!c  .mas, .mss, .mgs, .mss, .mms, .mac, .mae, .msc, .mic, .mgc, .mmc
    integer*8, allocatable :: offset_imrt(:)
    integer*8, allocatable :: offset_imrt_ijk(:)
    integer*8, allocatable :: offset_imvs(:)
    integer*8, allocatable :: offset_imvs_ijk(:)
    integer*8, allocatable :: offset_imcd(:)
    integer*8, allocatable :: offset_imcd_ijk(:)
    
!c  variables for MPI_TYPE_CREATE_SUBARRAY
!c  these variables are used for binary output only.    
    integer*4 :: mpiarray_ndim
    integer*4 :: mpiarray_filetype
    integer*4 :: mpiarray_filetype_vel
    
    integer*4 :: mpiarray_sizes_gbl(3)
    integer*4 :: mpiarray_sizes_sub(3)
    integer*4 :: mpiarray_starts_sub(3)
    
    integer*4 :: mpiarray_sizes_vel_gbl(3)
    integer*4 :: mpiarray_sizes_vel_sub(3)
    integer*4 :: mpiarray_starts_vel_sub(3)

    logical   :: b_mpiarray_igsp_init = .false.
    integer*4 :: mpiarray_filetype_igsp
    integer*4 :: mpiarray_sizes_gbl_igsp(3)
    integer*4 :: mpiarray_sizes_sub_igsp(3)
    integer*4 :: mpiarray_starts_sub_igsp(3)
    
    logical   :: b_mpiarray_ihyc_init = .false.
    integer*4 :: mpiarray_filetype_ihyc
    integer*4 :: mpiarray_sizes_gbl_ihyc(3)
    integer*4 :: mpiarray_sizes_sub_ihyc(3)
    integer*4 :: mpiarray_starts_sub_ihyc(3)
    
    logical   :: b_mpiarray_idens_init = .false.
    integer*4 :: mpiarray_filetype_idens
    integer*4 :: mpiarray_sizes_gbl_idens(3)
    integer*4 :: mpiarray_sizes_sub_idens(3)
    integer*4 :: mpiarray_starts_sub_idens(3)

    logical   :: b_mpiarray_igst_init = .false.
    integer*4 :: mpiarray_filetype_igst
    integer*4 :: mpiarray_sizes_gbl_igst(3)
    integer*4 :: mpiarray_sizes_sub_igst(3)
    integer*4 :: mpiarray_starts_sub_igst(3)

    logical   :: b_mpiarray_icbt_init = .false.
    integer*4 :: mpiarray_filetype_icbt
    integer*4 :: mpiarray_sizes_gbl_icbt(3)
    integer*4 :: mpiarray_sizes_sub_icbt(3)
    integer*4 :: mpiarray_starts_sub_icbt(3)

    logical   :: b_mpiarray_igmf_init = .false.
    integer*4 :: mpiarray_filetype_igmf
    integer*4 :: mpiarray_sizes_gbl_igmf(3)
    integer*4 :: mpiarray_sizes_sub_igmf(3)
    integer*4 :: mpiarray_starts_sub_igmf(3)
    
    logical   :: b_mpiarray_igsc_init = .false.
    integer*4 :: mpiarray_filetype_igsc
    integer*4 :: mpiarray_sizes_gbl_igsc(3)
    integer*4 :: mpiarray_sizes_sub_igsc(3)
    integer*4 :: mpiarray_starts_sub_igsc(3)

    logical   :: b_mpiarray_igsm_init = .false.
    integer*4 :: mpiarray_filetype_igsm
    integer*4 :: mpiarray_sizes_gbl_igsm(3)
    integer*4 :: mpiarray_sizes_sub_igsm(3)
    integer*4 :: mpiarray_starts_sub_igsm(3)
    
    logical   :: b_mpiarray_igsi_init = .false.
    integer*4 :: mpiarray_filetype_igsi
    integer*4 :: mpiarray_sizes_gbl_igsi(3)
    integer*4 :: mpiarray_sizes_sub_igsi(3)
    integer*4 :: mpiarray_starts_sub_igsi(3)

    logical   :: b_mpiarray_igsg_init = .false.
    integer*4 :: mpiarray_filetype_igsg
    integer*4 :: mpiarray_sizes_gbl_igsg(3)
    integer*4 :: mpiarray_sizes_sub_igsg(3)
    integer*4 :: mpiarray_starts_sub_igsg(3)

    logical   :: b_mpiarray_igs2_init = .false.
    integer*4 :: mpiarray_filetype_igs2
    integer*4 :: mpiarray_sizes_gbl_igs2(3)
    integer*4 :: mpiarray_sizes_sub_igs2(3)
    integer*4 :: mpiarray_starts_sub_igs2(3)

    logical   :: b_mpiarray_igsgr_init = .false.
    integer*4 :: mpiarray_filetype_igsgr
    integer*4 :: mpiarray_sizes_gbl_igsgr(3)
    integer*4 :: mpiarray_sizes_sub_igsgr(3)
    integer*4 :: mpiarray_starts_sub_igsgr(3)

    logical   :: b_mpiarray_igsb_init = .false.
    integer*4 :: mpiarray_filetype_igsb
    integer*4 :: mpiarray_sizes_gbl_igsb(3)
    integer*4 :: mpiarray_sizes_sub_igsb(3)
    integer*4 :: mpiarray_starts_sub_igsb(3)

    logical   :: b_mpiarray_igss_init = .false.
    integer*4 :: mpiarray_filetype_igss
    integer*4 :: mpiarray_sizes_gbl_igss(3)
    integer*4 :: mpiarray_sizes_sub_igss(3)
    integer*4 :: mpiarray_starts_sub_igss(3)

    logical   :: b_mpiarray_igsd_init = .false.
    integer*4 :: mpiarray_filetype_igsd
    integer*4 :: mpiarray_sizes_gbl_igsd(3)
    integer*4 :: mpiarray_sizes_sub_igsd(3)
    integer*4 :: mpiarray_starts_sub_igsd(3)

    logical   :: b_mpiarray_igsv_init = .false.
    integer*4 :: mpiarray_filetype_igsv
    integer*4 :: mpiarray_sizes_gbl_igsv(3)
    integer*4 :: mpiarray_sizes_sub_igsv(3)
    integer*4 :: mpiarray_starts_sub_igsv(3)
    
    logical   :: b_mpiarray_igsx_init = .false.
    integer*4 :: mpiarray_filetype_igsx
    integer*4 :: mpiarray_sizes_gbl_igsx(3)
    integer*4 :: mpiarray_sizes_sub_igsx(3)
    integer*4 :: mpiarray_starts_sub_igsx(3)
    
    logical   :: b_mpiarray_igsis_init = .false.
    integer*4 :: mpiarray_filetype_igsis
    integer*4 :: mpiarray_sizes_gbl_igsis(3)
    integer*4 :: mpiarray_sizes_sub_igsis(3)
    integer*4 :: mpiarray_starts_sub_igsis(3)
    
    logical   :: b_mpiarray_igsw_init = .false.
    integer*4 :: mpiarray_filetype_igsw
    integer*4 :: mpiarray_sizes_gbl_igsw(3)
    integer*4 :: mpiarray_sizes_sub_igsw(3)
    integer*4 :: mpiarray_starts_sub_igsw(3)

    logical   :: b_mpiarray_ivel_init = .false.
    integer*4 :: mpiarray_filetype_ivel
    integer*4 :: mpiarray_sizes_gbl_ivel(3)
    integer*4 :: mpiarray_sizes_sub_ivel(3)
    integer*4 :: mpiarray_starts_sub_ivel(3)

    logical   :: b_mpiarray_ivel_dd_init = .false.
    integer*4 :: mpiarray_filetype_ivel_dd
    integer*4 :: mpiarray_sizes_gbl_ivel_dd(3)
    integer*4 :: mpiarray_sizes_sub_ivel_dd(3)
    integer*4 :: mpiarray_starts_sub_ivel_dd(3)
    
    logical   :: b_mpiarray_igsa2_init = .false.
    integer*4 :: mpiarray_filetype_igsa2
    integer*4 :: mpiarray_sizes_gbl_igsa2(3)
    integer*4 :: mpiarray_sizes_sub_igsa2(3)
    integer*4 :: mpiarray_starts_sub_igsa2(3)

    logical   :: b_mpiarray_igsa_g_init = .false.
    integer*4 :: mpiarray_filetype_igsa_g
    integer*4 :: mpiarray_sizes_gbl_igsa_g(3)
    integer*4 :: mpiarray_sizes_sub_igsa_g(3)
    integer*4 :: mpiarray_starts_sub_igsa_g(3)

    logical   :: b_mpiarray_igsa2_g_init = .false.
    integer*4 :: mpiarray_filetype_igsa2_g
    integer*4 :: mpiarray_sizes_gbl_igsa2_g(3)
    integer*4 :: mpiarray_sizes_sub_igsa2_g(3)
    integer*4 :: mpiarray_starts_sub_igsa2_g(3)
    
    logical   :: b_mpiarray_igsf2_g_init = .false.
    integer*4 :: mpiarray_filetype_igsf2_g
    integer*4 :: mpiarray_sizes_gbl_igsf2_g(3)
    integer*4 :: mpiarray_sizes_sub_igsf2_g(3)
    integer*4 :: mpiarray_starts_sub_igsf2_g(3)

    logical   :: b_mpiarray_igsr_g_init = .false.
    integer*4 :: mpiarray_filetype_igsr_g
    integer*4 :: mpiarray_sizes_gbl_igsr_g(3)
    integer*4 :: mpiarray_sizes_sub_igsr_g(3)
    integer*4 :: mpiarray_starts_sub_igsr_g(3)
    
    logical   :: b_mpiarray_igsy_g_init = .false.
    integer*4 :: mpiarray_filetype_igsy_g
    integer*4 :: mpiarray_sizes_gbl_igsy_g(3)
    integer*4 :: mpiarray_sizes_sub_igsy_g(3)
    integer*4 :: mpiarray_starts_sub_igsy_g(3)

    logical   :: b_mpiarray_igsk_g_init = .false.
    integer*4 :: mpiarray_filetype_igsk_g
    integer*4 :: mpiarray_sizes_gbl_igsk_g(3)
    integer*4 :: mpiarray_sizes_sub_igsk_g(3)
    integer*4 :: mpiarray_starts_sub_igsk_g(3)

    logical   :: b_mpiarray_ihycx_g_init = .false.
    integer*4 :: mpiarray_filetype_ihycx_g
    integer*4 :: mpiarray_sizes_gbl_ihycx_g(3)
    integer*4 :: mpiarray_sizes_sub_ihycx_g(3)
    integer*4 :: mpiarray_starts_sub_ihycx_g(3)
    
    logical   :: b_mpiarray_ivelvap_init = .false.
    integer*4 :: mpiarray_filetype_ivelvap
    integer*4 :: mpiarray_sizes_gbl_ivelvap(3)
    integer*4 :: mpiarray_sizes_sub_ivelvap(3)
    integer*4 :: mpiarray_starts_sub_ivelvap(3)

    logical   :: b_mpiarray_irsrt_init = .false.
    integer*4 :: mpiarray_filetype_irsrt
    integer*4 :: mpiarray_sizes_gbl_irsrt(3)
    integer*4 :: mpiarray_sizes_sub_irsrt(3)
    integer*4 :: mpiarray_starts_sub_irsrt(3)
    
    logical   :: b_mpiarray_igsbub_init = .false.
    integer*4 :: mpiarray_filetype_igsbub
    integer*4 :: mpiarray_sizes_gbl_igsbub(3)
    integer*4 :: mpiarray_sizes_sub_igsbub(3)
    integer*4 :: mpiarray_starts_sub_igsbub(3)
    
    end module gen

