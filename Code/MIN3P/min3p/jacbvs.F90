!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacbvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacbvs
!c -----------------
!c
!c incorporate dirichlet and neumann type boundary condition in 
!c jacobian matrix and rhs vector for variably saturated flow 
!c
!c written by:      Uli Mayer - May 6, 96
!c
!c last modified:   Tom Henderson - March 20, 2003
!c                  added point source
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = Jacobian matrix                     + +
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           bvs(nn)            = rhs vector                          + +
!c           
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           njavs              = number of global connections        + -
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c dens.f:   real*8:
!c           -------
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density 
!c                                           dependent flow
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           ibvs               = counter (boundary control volumes)
!c           istart             = pointer (start of row) 
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal entry)
!c           i1                 = counter (row entries)
!c           info_debug         = debugging information level
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine jacbvs
 
      use parm
      use gen
      use dens
#ifdef OPENMP
      use omp_lib 
#endif 
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
 
      implicit none
      
      integer :: i1, ibvs, idiag, istart, iend, ivol, info_debug

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0

    
!c  debug toggle
 
      info_debug = 0

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (i1, ibvs, idiag, iend, istart, ivol) 
#endif      
!c  loop over boundary control volumes
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
      do ibvs = 1,nbvs
          
        ivol = iabvs(ibvs)
 
!c  modify for second type flow boundary condition and
!c  point source boundary
!c  calculate mass flux
 
        if ((btypevs(ibvs).eq.'second') .or.                          &
     &      (btypevs(ibvs).eq.'point')) then
          if(b_water_freezing) then
            if (tempnew(ivol) > water_freezing_temper) then
              if ((density_dependence).and.(.not.flow_verification)) then
                bvs(ivol) = bvs(ivol) + bcondvs(ibvs)*ssdens(ivol)
              else
                bvs(ivol) = bvs(ivol) + bcondvs(ibvs)
              end if
            end if
          else
            if ((density_dependence).and.(.not.flow_verification)) then
              bvs(ivol) = bvs(ivol) + bcondvs(ibvs)*ssdens(ivol)
            else
              bvs(ivol) = bvs(ivol) + bcondvs(ibvs)
            end if
          end if

          continue
!c  modify for first type boundary and zero pressure seepage face
!c  boundary conditions
 
        elseif ((btypevs(ibvs).eq.'first').or.                        &
     &          (btypevs(ibvs).eq.'seepage'.and.                      &
     &           bcondvs(ibvs).lt.r0)) then

          istart = iavs(ivol)          !pointer - start of row
          iend = iavs(ivol+1)-1        !pointer - end of row
          idiag = iavs(ivol)           !pointer - diagonal

          do i1=istart,iend            !modify matrix and rhs
            avs(i1) = r0
          end do
          avs(idiag) = r1
          bvs(ivol) = r0 
 
        end if                        !(btypevs(ibvs).eq......)

      end do                          !loop - boundary control volumes 
      
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif      

      continue 
!cdbg
#ifdef DEBUG
      if (info_debug.gt.0) then
        write(idbg,'(/a/)') 'flow jacobian' 
        do ivol=1,nngl
          istart = iavs(ivol)
          iend = iavs(ivol+1)-1
          write(idbg,'(8es16.8)')(avs(i1),i1=istart,iend),bvs(ivol) 
        end do
      end if
#endif
      if (info_debug.gt.1) then
        if (mtime .eq. 10) then 
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if 
!cdbg

      return
      end
