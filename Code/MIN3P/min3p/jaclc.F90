!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jaclc.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jaclc
!c ----------------
!c
!c construct Jacobian matrix and rhs vector (local chemistry)
!c
!c written by:      Uli Mayer - November 29, 96
!c
!c last modified:   Uli Mayer - January 15, 01
!c                  added contributions from intra-aqueous
!c                  kinetic reactions
!c                  Uli Mayer - November 12, 01
!c                  added new database format
!c                  for dissolution-precipitation reactions
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           cnew(nc)           = concentrations of free species      + -
!c                                [moles/l water]
!c           cx(nx)             = concentrations of secondary         * +
!c                                aqueous species
!c                                [moles/l water]
!c           gammac(nc)         = activity coefficients of free       * +
!c                                species
!c           gammax(nx)         = activity coefficient of             * +
!c                                secondary aqueous species
!c           sw                 = water saturation                    + -
!c           sa                 = air saturation                      + -
!c           por                = porosity                            + -
!c
!c common:   
!c chem.f:   real*8:
!c           -------
!c           areac(nm)          = reactivity term                     + -
!c           alc(nc-1,nc-1,nthreads) 
!c                              = jacobian matrix                * +
!c           blc(nc-1,nthreads)      
!c                              = rhs-vector                     * + 
!c           cec(nthreads)      = cation exchange capacity (meq/100g) + -
!c           cinc(nc,nthreads)  = incremented free species            * +
!c                                concentrations
!c                                [moles/(l water)]
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           csb(nsb)           = concentrations of sorbed species    * +
!c                                - new time level
!c           cxinc(nx,nthreads) = secondary aqueous species           * +
!c                                concentrations dependent on
!c                                incremented free species
!c                                concentrations 
!c                                [moles/(l water)]
!c           dcsb(nsb)          = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species
!c           dratedp(nm,nthreads)        
!c                              = derivatives of absolute             * +
!c                                dissolution-precipitation 
!c                                rates of minerals
!c                                [moles/(l bulk*day)]
!c           totaq(n,nthreads)  = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           dtotc(n,nthreads)  = derivatives of total aqueous        * +
!c                                component concentrations
!c                                [moles/l water]
!c           dtotdp(n,nthreads) = derivative of total source/sink     * +
!c                                term towards total aqueous 
!c                                component concentrations due to
!c                                mineral dissolution-precipitation
!c                                reactions [moles/(l bulk*day)]
!c           dtotsb(n)          = derivatives of total source/sink    * +
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c           dtotsb_ion(n,nthreads)      
!c                              = derivatives of total source/sink    * +
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c                                (ion-exchange)
!c           dtotsb_surf(n,nthreads)     
!c                              = derivatives of total source/sink    * +
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c                                (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           phic(nm,nthreads)  = volume fractions of minerals        + -
!c           phicold(nm,nthreads) 
!c                              = volume fractions of minerals        + -
!c                                - old time level
!c           rateaq(naq,nthreads)        
!c                              = reaction rates of intra-aqueous     * *
!c                                kinetic reaction
!c           ratedp(nm,nthreads)= absolute dissolution-precipitation  * +
!c                                rates of minerals
!c                                [moles/(l bulk*day)]
!c           rhobulk            = dry bulk density of porous medium   + -
!c           sion1(nthreads)    = ionic strength of solution          + +
!c           totaq(n,nthreads)  = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           totcinc(n,nthreads)= total aqueous component             * +
!c                                concentrations - new time level
!c                                incremented [moles/l water]
!c           totcn(n,nthreads)  = total aqueous component             * +
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totco(n,nthreads)  = total aqueous component             + -
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totdp(n,nthreads)  = total source/sink term towards      * +
!c                                aqueous component concentrations
!c                                due to mineral dissolution-
!c                                precipitation reactions
!c                                [moles/(l bulk*day)]
!c           totcsn(n)          = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totcsn_ion(nc-1,nthreads) 
!c                              = total sorbed component              * +
!c                                concentrations
!c                                (ion-exchange)
!c           totcsn_surf(nc-1,nthreads) 
!c                              = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           totcso(n)          = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totcso_ion(n)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totcso_surf(n)     = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c           xnux(nx*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of secondary aqueous
!c                                species from free species
!c           dinc_lc            = factor to compute increment for     + -
!c                                numerical differentiation
!c           delt_lc(nthreads)  = time step for local chemistry       + -
!c                                computations
!c
!c           integer*4:
!c           ----------
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           iax(nx+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in
!c                                secondary aqueous species
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jax(nx*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in secondary aqueous
!c                                species
!c           iter_lc(nthreads)  = iteration counter                   + -
!c                                (local chemistry)
!c           naq                = number of intra-aqueous kinetic     + -
!c                                reactions
!c           nc                 = number of components including h2o  + -
!c           nm                 = number of minerals                  + -
!c           nopu               = number of primary unknowns          + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c           nx                 = number of secondary aqueous species + -
!c           ntstp_lc(nthreads) = time step counter                   + -
!c                                (local chemistry)
!c
!c           logical:
!c           --------
!c           explicit_surface   = .true.  -> include surface sites    + -
!c                                           in equilibrium 
!c                                           calculations
!c           explicit_surface_ion  = .true.  -> include surface sites + -
!c                                           in equilibrium 
!c                                           calculations
!c                                           of ion-exchange
!c           explicit_surface_surf = .true.  -> include surface sites + -
!c                                           in equilibrium 
!c                                           calculations
!c                                           of surface-complex
!c           minequil(nm)       = .true.  -> equilibrate aqueous      + -
!c                                           species with specified
!c                                           mineral
!c           new_database       = .true.  -> use new database format  + -
!c           reactive_minerals  = .true.  -> consider mineral         + -
!c                                           dissolution-
!c                                           precipitation reactions
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c           character:
!c           ----------
!c           ctype(nc-1)        = 'charge' = correct total aqueous    + -
!c                                           component concentration
!c                                           for specified component 
!c                                           to satisfy charge balance
!c                                'fixed'  = compute total aqueous
!c                                           component concentrations
!c                                           based on fixed activities
!c                                           of components as species
!c                                           in solution
!c                                'free'   = compute concentrations
!c                                           of components as species
!c                                           in solution based on 
!c                                           specified total aqueous
!c                                           component concentrations
!c                                'ph'    =  pH specified for 'h+1'
!c           namec(nc)          = component names                     + -
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c                                'surface-complex'
!c                                'constant-capacitance'
!c
!c local:    real*8:
!c           -------
!c           drtinc             = increment for numerical 
!c                                differentiation
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           iaq                = counter (intra-aqueous kinetic 
!c                                         reactions)
!c           ic                 = counter (components)
!c           im                 = counter (minerals)
!c           isb                = counter (sorbed species)
!c           ix                 = counter (secondary aqueous 
!c                                species)
!c           ibl                = counter (rows of Jacobian 
!c                                matrix) 
!c           jbl                = counter (columns of Jacobian 
!c                                matrix)
!c
!c           logical:
!c           --------
!c           analyt_deriv_lc    = .true.  -> compute derivatives
!c                                           analytically
!c
!c external: comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox 
!c                       equilibrium reactions
!c           drateint  = compute derivative of reaction rate
!c                       of intra-aqueous kinetic reaction
!c           drateint_new  = compute derivative of reaction rate
!c                       of intra-aqueous kinetic reaction (new database
!c                       format)
!c           dratemin  = compute derivatives of absolute dissolution-
!c                       precipitation rates of minerals
!c           dratemin_new  = compute derivatives of absolute dissolution-
!c                       precipitation rates of minerals (new database
!c                       format)
!c           dtotconc  = compute numerical derivatives of total aqueous 
!c                       component concentrations
!c           atotconc  = compute analytical derivatives of total aqueous 
!c                       component concentrations
!c           rateint   = compute rate for intra-aqueous kinetic 
!c                       reactions
!c           rateint_new  = compute rate for intra-aqueous kinetic 
!c                       reactions (new database format)
!c           ratemin   = compute absolute dissolution-precipitation 
!c                       rates of minerals
!c           ratemin_new  = compute absolute dissolution-precipitation 
!c                       rates of minerals (new database format)
!c           secspec   = compute concentration of secondary 
!c                       species based on concentrations
!c                       of primary species according to 
!c                       the law of mass action 
!c           sorbspc   = compute concentration of sorbed species
!c           totconc   = compute total aqueous component 
!c                       concentrations based on concentrations of 
!c                       free species and secondary aqueous species
!c           totmin    = compute total source/sink rates due to 
!c                       mineral dissolution-precipitation 
!c                       reactions towards total aqueous component 
!c                       concentrations
!c           totint    = compute total source-sink terms towards
!c                       total aqueous component concentrations
!c                       due to intra-aqueous reactions
!c           totsorb   = compute total sorbed component concentrations
!c                       [moles/l bulk]
!c           updtsvap  = update secondary variables in aqueous phase
!c ----------------------------------------------------------------------
 
      subroutine jaclc(cnew,cx,gammac,gammax,sw,sa,por)
      
      use parm
      use chem
      use gen, only : idbg
#ifdef OPENMP
      use omp_lib 
#endif 
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
      implicit none
      
      real*8 :: cnew, cx, gammac, gammax, sw, sa, por
      
      integer :: tid 
      
      real*8 dummy

      external comptotc, secspec, sorbspc, totconc, totmin,totsorb

      dimension cnew(*),cx(*),gammac(*),gammax(*)

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
      
      !local variable
      integer :: ic, ix, ir, isb, iaq, im, ibl, jbl, info_debug
      real*8 :: dissvol, drtinc
      logical analyt_deriv_lc
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface 
      
        !>interface of atotconc
        subroutine atotconc(c,cx,jbl)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          integer(type_i4) :: jbl     
        end subroutine atotconc
      
        !>interface of drateint
        subroutine drateint(rate,totc,c,gammac,phim,drtinc,iaq,        &
                            scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: phim
          real(type_r8) :: drtinc
          integer(type_i4) :: iaq 
          real(type_r8) :: scalfacaq
        end subroutine drateint
        
        !>interface of drateint_new
        subroutine drateint_new(rate,totc,c,cx,gammac,gammax,phim,    &
                                drtinc,iaq,scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: phim
          real(type_r8) :: drtinc
          integer(type_i4) :: iaq 
          real(type_r8) :: scalfacaq
        end subroutine drateint_new
                            
        !>interface of dratemin
        subroutine dratemin(totc,c,cx,gammac,gammax,ratem,phim,      &
                         phimold,aream,drtinc,im,ivol)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8) :: phim
          real(type_r8) :: phimold
          real(type_r8) :: aream
          real(type_r8) :: drtinc
          integer(type_i4) :: im
          integer(type_i4) :: ivol
        end subroutine dratemin
        
        !>interface of dratemin_new
        subroutine dratemin_new(totc,c,cx,gammac,gammax,ratem,phim,  &
                         phimold,aream,drtinc,im,ivol)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8), dimension(*) :: phim
          real(type_r8) :: phimold
          real(type_r8) :: aream
          real(type_r8) :: drtinc
          integer(type_i4) :: im
          integer(type_i4) :: ivol
        end subroutine dratemin_new
                         
        !>interface dtotconc
        subroutine dtotconc(c,cx,drtinc,jbl, izn_opt)
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8) :: drtinc
          integer(type_i4) :: jbl  
          integer, optional :: izn_opt
        end subroutine dtotconc
                 
                 
        !>interface of rateint
        subroutine rateint(rate,totc,c,gammac,phim,iaq,scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: phim
          integer(type_i4) :: iaq  
          real(type_r8) :: scalfacaq
        end subroutine rateint
        
        !>interface of rateint_new
        subroutine rateint_new(rate,totc,c,cx,gammac,gammax,phim,iaq,  &
                               scalfacaq)
          use parm, only : type_i4, type_r8     
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: phim
          integer(type_i4) :: iaq
          real(type_r8) :: scalfacaq
        end subroutine rateint_new
                               
        !> interface of ratemin
        subroutine ratemin(totc,c,cx,gammac,gammax,ratem,phim,    &
                           phimold,aream,im) 
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
        end subroutine ratemin  
                           
        !> interface of ratemin_new
        subroutine ratemin_new(totc,c,cx,gammac,gammax,ratem,phim,    &
                               phimold,aream,im) 
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8), dimension(*) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
        end subroutine ratemin_new                  
                               
        !>interface of totint
        subroutine totint(totintaq,idbg)
          use parm, only : type_i4, type_r8   
          real(type_r8), dimension(*) :: totintaq
          integer(type_i4) :: idbg
        end subroutine totint
        
        !>interface of updtsvap
        subroutine updtsvap (c,cx,gammac,gammax,strion)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: strion
        end subroutine updtsvap        
        
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      analyt_deriv_lc = .false.

!c  construct rhs vector,
!c  first iteration
!c  -> initialize activity coefficients and concentrations of secondary
!c     aqueous species
      

      if (iter_lc(tid).eq.1.and.ntstp_lc(tid).eq.0) then

        do ic=1,nc
          gammac(ic) = r1
        end do
        do ix=1,nx
          gammax(ix) = r1
        end do

!c  equilibrium redox reactions, compute concentrations of secondary
!c  components of redox couples

        if (redox_equil.and.nr.gt.0) then
          do ir=1,nr
            ic = nopu+ir
            call secspec(cnew,cnew(ic),eqr(ir,tid),gammac,gammac(ic), &
     &                   xnur,iarc,jarc,nc,ir)
          end do
        end if

!c  compute concentrations of aqueous complexes

        do ix=1,nx
          call secspec(cnew,cx(ix),eqx(ix,tid),gammac,gammax(ix),     &
     &                 xnux,iax,jax,nc,ix)
        end do

!c  following iterations

      else

!c  unit activity coefficients
!c  -> update only concentrations of secondary aqueous species
!c     and compute ionic strength as a secondary variable 
        call updtsvap(cnew,cx,gammac,gammax,sion1(tid))

!c  variable activity coefficients
!c  -> double update of secondary variables
!c     - activitiy coefficients
!c     - complex concentrations
!c     - ionic strength

        if (update_activity(tid).ne.'no_update') then
 
          call updtsvap(cnew,cx,gammac,gammax,sion1(tid))

        end if

      end if

!c  compute total aqueous concentrations
 
      call totconc(cnew,cx,totcn(:,tid))

!c  compress total aqueous component concentration vector in case 
!c  of redox equilibrium reactions

      if (redox_equil.and.nr.gt.0) then
        call comptotc(totcn(:,tid))
      end if

!c  compute concentrations of sorbed species, if surface sites 
!c  initially empty or during transient simulations

      if (nsb_ion.gt.0 .and. explicit_surface_ion) then
          
          do isb = 1,nsb_ion 
              call sorbspc(csb_ion(isb,tid),dummy,cec(tid),           &
              eqsb_ion(:,tid),eqsb_surf(:,tid),gammac,cnew,           &
              xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,jasb_ion,       &
              jasb_surf,nsb_ion,nsb_surf,isb,0,sorption_type_ion,     &
              sorption_type_surf,sorption_group,isactcexch)
          end do          

!c  compute total sorbed concentrations

        call totsorb(csb_ion(:,tid),csb_surf(:,tid),                  &
             chargesb_ion,rhobulk,                                    &
             totcsn_ion(:,tid),totcsn_surf(:,tid),                    &
             xnusb_ion,xnusb_surf,iasb_ion,                           &
             iasb_surf,jasb_ion,jasb_surf,nc,nsb_ion,0,               &
             namec)

!c  compress total sorbed component concentration vector in case 
!c  of redox equilibrium reactions

        if (redox_equil.and.nr.gt.0) then
          call comptotc(totcsn_ion(:,tid))
        end if

      end if
      
!c  compute concentrations of sorbed species, if surface sites 
!c  initially empty or during transient simulations

      if (nsb_surf.gt.0 .and. explicit_surface_surf) then

        do isb = 1,nsb_surf 
            call sorbspc(dummy,csb_surf(isb,tid),cec(tid),            &
                 eqsb_ion(:,tid),eqsb_surf(:,tid),gammac,cnew,        &
                 xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,jasb_ion,    &
                 jasb_surf,nsb_ion,nsb_surf,0,isb,sorption_type_ion,  &
                 sorption_type_surf,sorption_group,isactcexch)
        end do

!c  compute total sorbed concentrations

        call totsorb(csb_ion(:,tid),csb_surf(:,tid),                  &
             chargesb_ion,rhobulk,                                    &
             totcsn_ion(:,tid),totcsn_surf(:,tid),                    &
             xnusb_ion,xnusb_surf,iasb_ion,                           &
             iasb_surf,jasb_ion,jasb_surf,nc,0,nsb_surf,              &
             namec)

!c  compress total sorbed component concentration vector in case 
!c  of redox equilibrium reactions
        
        if (redox_equil.and.nr.gt.0) then
          call comptotc(totcsn_surf(:,tid))
        end if

      end if      

!c  compute total source-sink terms towards total concentrations due
!c  to intra-aqueous kinetic reactions

      if (naq.gt.0.and.ntstp_lc(tid).gt.0) then

!c  reaction rates of intra-aqueous kinetic reactions

        do iaq = 1,naq
          if (new_database) then
              call rateint_new(rateaq(iaq,tid),totcn(:,tid),cnew,cx,  &
                               gammac,gammax,phic(:,tid),iaq,         &
                               scalfac_aq(iaq))
          else
              call rateint(rateaq(iaq,tid),totcn(:,tid),cnew,gammac,  &
                           phic(:,tid),iaq,scalfac_aq(iaq))
          end if
        end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions

        call totint(totaq(:,tid),idbg)

      end if

!c  compute absolute dissolution-precipitation rates of minerals
 
      if (nm.gt.0) then

        if (reactive_minerals.and.ntstp_lc(tid).gt.0) then

          do im=1,nm

            if (minequil(im)) then

              if (new_database) then
                call ratemin_new(totcn(:,tid),cnew,cx,gammac,gammax,  &
     &                           ratedp(im,tid),phic(:,tid),          &
     &                           phicold(im,tid),areac(im),im)
#ifdef DEBUG
                write(idbg,'(a,1x,i4,1x,a,1x,e16.8)')                 &
                      "-->jaclc im",im,"ratedp",ratedp(im,tid)
#endif
            else
                call ratemin(totcn(:,tid),cnew,cx,gammac,gammax,      &
     &                       ratedp(im,tid),phic(im,tid),             &
     &                       phicold(im,tid),areac(im),im)
            end if

!c  - check if enough mineral is available for specified rate
!c    if not -> assign rate, which leads to depletion of mineral
!c              down to nucleus 
!c    and assign reaction rate leading to depletion of mineral
!c    dissolution   -ve
!c    precipitation +ve

              dissvol = ratedp(im,tid)*delt_lc(tid)
              if ((cmcnew(im,tid)+dissvol).lt.cmcmin(im,tid)) then
                ratedp(im,tid) = - (cmcnew(im,tid)-cmcmin(im,tid))/   &
                                 delt_lc(tid)
              end if

            else

              ratedp(im,tid) = r0

            end if

          end do
 
!c  compute source/sink term towards total aqueous concentrations
!c  due to mineral dissolution-precipitation reactions
 
          call totmin(ratedp(:,tid),totdp(:,tid))

!c  compress source/sink term towards total aqueous component 
!c  concentrations due to mineral dissolution-precipitation reactions 
!c  in case of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totdp(:,tid))
          end if

        end if

      end if             !(nm.gt.0)
 
!c  put 0 on rhs, if free species concentration is fixed
 
      do ibl = 1,nopu               !loop over rows

        if (ctype(ibl).ne.'fixed') then

!c  contributions from aqueous phase

          blc(ibl,tid) = - sw*por*(totcn(ibl,tid)-totco(ibl,tid))/    &
                         delt_lc(tid)

!c  contributions from sorbed phase

          if (nsb_ion.gt.0.and.explicit_surface_ion) then
            blc(ibl,tid) = blc(ibl,tid) - sw*por*                     &
     &                     (totcsn_ion(ibl,tid)-totcso_ion(ibl))/     &
     &                     delt_lc(tid)
          end if
          
          if (nsb_surf.gt.0.and.explicit_surface_surf) then
            blc(ibl,tid) = blc(ibl,tid)-sw*por*                       &
     &                     (totcsn_surf(ibl,tid)-totcso_surf(ibl))/   &
                           delt_lc(tid)
          end if

!c  contributions from intra-aqueous kinetic reactions

          if (naq.gt.0.and.ntstp_lc(tid).gt.0) then
            blc(ibl,tid) = blc(ibl,tid) - sw*por*totaq(ibl,tid)
          end if

!c  contributions from solid phase

          if (nm.ne.0) then
            if (reactive_minerals.and.ntstp_lc(tid).gt.0) then
              blc(ibl,tid) = blc(ibl,tid) - totdp(ibl,tid)
            end if
          end if

         elseif (ctype(ibl).eq.'fixed') then

           blc(ibl,tid) = r0

         end if                        !ctype

      end do                           !loop over rows

!c  construct jacobian matrix
!c  assign current component species concentrations to work array
 
      do ic = 1,nc
        cinc(ic,tid) = cnew(ic)
      end do
 
      do jbl = 1,nopu                 !loop over columns

!c  compute increment for numerical differentiation

        drtinc = dinc_lc * cnew(jbl)
 
!c  increment free species concentration for current column
  
        cinc(jbl,tid) = cnew(jbl) + drtinc
 
!c  equilibrium redox reactions, compute concentrations of dependent
!c  components of redox couples with incremented free species
!c  concentrations

        if (redox_equil.and.nr.gt.0) then
          do ir=1,nr
            ic = nopu+ir
            call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),gammac, &
                 gammac(ic),xnur,iarc,jarc,nc,ir)
          end do
        end if

!c  compute aqueous complex concentrations based on incremented free
!c  species concentrations 
 
        do ix = 1,nx
          call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),gammac,  &
               gammax(ix),xnux,iax,jax,nc,ix)   
        end do

!c  compute derivatives of total aqueous component concentrations

        if (analyt_deriv_lc) then
          call atotconc(cnew,cx,jbl)
        else
          call dtotconc(cnew,cx,drtinc,jbl)
        end if

!c  compress total aqueous component concentration vector in case 
!c  of redox equilibrium reactions

        if (redox_equil.and.nr.gt.0) then
          call comptotc(dtotc(:,tid))
        end if

!c  compute concentrations of sorbed species based on incremented free
!c  species concentrations 

        if (nsb_ion.gt.0 .and. explicit_surface_ion) then

          do isb = 1,nsb_ion
            call sorbspc(dcsb_ion(isb,tid),dummy,cec(tid),            &
                         eqsb_ion(:,tid),eqsb_surf(:,tid),            &
                         gammac,cinc(:,tid),                          &
                         xnusb_ion,xnusb_surf,                        &
                         iasb_ion, iasb_surf,jasb_ion,                &
                         jasb_surf,nsb_ion,nsb_surf,isb,0,            &
                         sorption_type_ion, sorption_type_surf,       &
                         sorption_group,isactcexch)
            
!c  compute derivatives of concentrations of sorbed species
            dcsb_ion(isb,tid) =                                       &
                (dcsb_ion(isb,tid) - csb_ion(isb,tid))/drtinc
          end do

!c  compute total sorbed concentrations

          call totsorb(dcsb_ion(:,tid),dcsb_surf(:,tid),              &
                       chargesb_ion,rhobulk,                          &
                       dtotsb_ion(:,tid),dtotsb_surf(:,tid),          &
                       xnusb_ion,xnusb_surf,                          &
                       iasb_ion,iasb_surf,jasb_ion,jasb_surf,         &
                       nc,nsb_ion,0,namec)

!c  compress total sorbed component concentration vector in case
!c  of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(dtotsb_ion(:,tid))
          end if

        end if
        
!c  compute concentrations of sorbed species based on incremented free
!c  species concentrations 

        if (nsb_surf.gt.0 .and. explicit_surface_surf) then
          
          do isb = 1,nsb_surf
            call sorbspc(dummy,dcsb_surf(isb,tid),cec(tid),           &
                         eqsb_ion(:,tid),eqsb_surf(:,tid),            &
                         gammac,cinc(:,tid),                          &
                         xnusb_ion,xnusb_surf,                        &
                         iasb_ion,iasb_surf,jasb_ion,                 &
                         jasb_surf,nsb_ion,nsb_surf,0,isb,            &
                         sorption_type_ion, sorption_type_surf,       &
                         sorption_group,isactcexch)
            
!c  compute derivatives of concentrations of sorbed species
            dcsb_surf(isb,tid) = (dcsb_surf(isb,tid) -                &
                                 csb_surf(isb,tid))/drtinc
          end do    

!c  compute total sorbed concentrations

          call totsorb(dcsb_ion(:,tid),dcsb_surf(:,tid),              &
                       chargesb_ion,rhobulk,                          &
                       dtotsb_ion(:,tid),dtotsb_surf(:,tid),          &
                       xnusb_ion,xnusb_surf,                          &
                       iasb_ion,iasb_surf,jasb_ion,jasb_surf,nc,0,    &
                       nsb_surf,namec)

!c  compress total sorbed component concentration vector in case
!c  of redox equilibrium reactions
          
          if (redox_equil.and.nr.gt.0.and.nsb_surf.gt.0) then
            call comptotc(dtotsb_surf(:,tid))
          end if

        end if

!c  compute derivatives of intra-aqueous kinetic reactions

        if (naq.gt.0.and.ntstp_lc(tid).gt.0) then

          call totconc(cinc(:,tid),cxinc(:,tid),totcinc(:,tid))

          do iaq = 1,naq
          if (new_database) then
              call drateint_new(rateaq(iaq,tid),totcn(:,tid),cnew,cx, &
                                gammac,gammax,phic(:,tid),drtinc,iaq, &
                                scalfac_aq(iaq))
          else
              call drateint(rateaq(iaq,tid),totcn(:,tid),cnew,gammac, &
                            phic(:,tid),drtinc,iaq,scalfac_aq(iaq))
          end if
        end do

!c  derivative of total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions

          call totint(dtotaq(:,tid),idbg)
        end if

!c  contributions from mineral dissolution-precipitation

        if (reactive_minerals.and.ntstp_lc(tid).gt.0) then

!c  - derivatives of overall dissolution-precipitation rates

          do im = 1,nm

!c  - total aqueous component concentrations (incremented) for
!c    the computing reaction rates

            call totconc(cinc(:,tid),cxinc(:,tid),totcinc(:,tid))

            if (minequil(im)) then

!c  - check if sufficient mineral mass is available

              dissvol = ratedp(im,tid)*delt_lc(tid)

!c  - mineral mass insufficient -> rate is known, set derivative to zero

              if ((cmcnew(im,tid)+dissvol).lt.cmcmin(im,tid)) then
                dratedp(im,tid) = r0

!c  - mineral mass sufficient -> compute derivative of rate

              else
                if (new_database) then
                call dratemin_new(totcn(:,tid),cnew,cx,gammac,gammax, &
     &                            dratedp(im,tid),                    &
     &                            phic(:,tid),phicold(im,tid),        &
     &                            areac(im),drtinc,im,0)
#ifdef DEBUG
                write(idbg,'(a,1x,i4,1x,a,1x,e16.8)')                 &
                      "-->jaclc im",im,"dratedp",dratedp(im,tid)
#endif
              else
                  call dratemin(totcn(:,tid),cnew,cx,gammac,gammax,   &
     &                          dratedp(im,tid),                      &
     &                          phic(im,tid),phicold(im,tid),         &
     &                          areac(im),drtinc,im,0)
              end if
              end if

            else

              dratedp(im,tid) = r0

            end if

          end do

!c  - compute derivatives of total source/sink term toward total aqueous
!c    component concentrations due to mineral-dissolution precipitation
!c    reactions
 
          call totmin(dratedp(:,tid),dtotdp(:,tid))

!c  compress  derivatives of source/sink term towards total aqueous 
!c  component concentrations due to mineral dissolution-precipitation 
!c  reactions in case of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(dtotdp(:,tid))
          end if

        end if
 
!c  contruct current column of jacobian matrix
 
        do ibl = 1,nopu             !loop over rows

!c  allocate entry in jacobian matrix
 
          if (ctype(ibl).ne.'fixed'.and.ctype(jbl).ne.'fixed') then

!c  contribution from aqueous phase

            alc(ibl,jbl,tid) = sw*por*dtotc(ibl,tid)/delt_lc(tid)
 
!c  contribution from sorbed phase

            if (nsb_ion.gt.0.and.explicit_surface_ion) then

              alc(ibl,jbl,tid) = alc(ibl,jbl,tid) + sw*por*           &
                                 dtotsb_ion(ibl,tid)/delt_lc(tid)

            end if
            
            if (nsb_surf.gt.0.and.explicit_surface_surf) then

              alc(ibl,jbl,tid) = alc(ibl,jbl,tid) + sw*por*           &
                                 dtotsb_surf(ibl,tid)/delt_lc(tid)

            end if
            
!c  contributions from intra-aqueous kinetic reactions

            if (naq.gt.0.and.ntstp_lc(tid).gt.0) then
             alc(ibl,jbl,tid) = alc(ibl,jbl,tid) + sw*por*            &
                                dtotaq(ibl,tid)
          end if

!c  contribution from solid phase
 
            if (reactive_minerals.and.ntstp_lc(tid).gt.0) then
              alc(ibl,jbl,tid) = alc(ibl,jbl,tid) + dtotdp(ibl,tid)
            end if 

!c  modify derivative with respect to C_j to
!c         derivative with respect to ln C_j

            alc(ibl,jbl,tid) = cnew(jbl) * alc(ibl,jbl,tid)  

!c  put 1 on diagonal for component type 'fixed' 

          elseif (ctype(ibl).eq.'fixed'.and.                          &
     &            ctype(jbl).eq.'fixed'.and.                          &
     &            ibl.eq.jbl) then
   
            alc(ibl,jbl,tid) = r1
   

!c  put 0 on off-diagonal in rows and columns for component type 
!c  'fixed'

          elseif (ctype(ibl).ne.'fixed'.and.                          &
     &            ctype(jbl).eq.'fixed'.or.                           &
     &            ctype(ibl).eq.'fixed'.and.                          &
     &            ctype(jbl).ne.'fixed') then
   
            alc(ibl,jbl,tid) = r0
   
          end if                          !end - ctype

        end do                            !end - loop over rows
 
!c  assign unshifted concentration to work array
 
        cinc(jbl,tid) = cnew(jbl)

      end do                              !end - loop over columns
      
!cdbg  activate this section for debugging
!c     info_debug = 1 -> write to screen
!c     info_debug = 2 -> write to screen and pause
!c     info_debug = 3 -> write to screen and stop

      info_debug = 0
      if (info_debug.gt.0) then
        write(*,*)
        do ibl=1,nopu
          write(*,'(a,1x,15(1pe12.3))') trim(namec(ibl)),             &
     &                               (alc(ibl,jbl,tid),jbl=1,nc-1),   &
     &                                blc(ibl,tid)
        end do
        write(*,*)
      end if
      if (info_debug.eq.2) then
        !pause
      elseif (info_debug.eq.3) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
!cdbg
 
      return
      end
