!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/seepface.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine seepface
!c -------------------
!c
!c seepage face iteration control
!c
!c written by:      Uli Mayer - July 10, 96
!c
!c last modified:   Uli Mayer - November 25, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + +
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           hhead(nn)          = hydraulic head                      + +
!c           relperm(nn)        = relative permeability               + -
!c           uvsold(nn)         = solution vector (old time level)    + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           vsflux(ncon-1)     = interfacial fluxes                  * +
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ---------- 
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           javs(njavs)        = connectivity list                   + - 
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary
!c                                control volumes
!c                                (variably saturated flow)
!c           nseep_first        = number of seepage face nodes        + -
!c
!c           logical:
!c           --------
!c           seep_iter          = .true.  -> continue seepage face    + +
!c                                           iteration 
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c           iups(ncon-1)       = upstream pointer array              * +
!c
!c local:    real*8:
!c           -------
!c           totvsflux          = total flux 
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control volumes)
!c           icon               = pointer (connections - local)
!c           iend               = pointer (end of row)
!c           istart             = pointer (start of row)
!c           ivol               = counter (control volumes)
!c           jvol               = pointer
!c           not_matched        = number of nonconforming seepage 
!c                                face nodes
!c
!c external: fluxvs   = flux function for variably saturated flow       
!c ----------------------------------------------------------------------

      subroutine seepface

      use parm
      use gen
#ifdef OPENMP
      use omp_lib 
#endif

      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif

      integer :: not_matched, ibvs, ivol, istart, iend, icon, i1, jvol
      real*8 :: totvsflux, fluxvs

#ifdef PETSC 
      integer :: not_matched_gbl, nseep_first_gbl
      PetscErrorCode :: ierrcode
#endif      

      external fluxvs

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0

!c  reassign seepage face boundary condition
 
      not_matched = 0
      nseep_first = 0
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbvs > numofloops_thred_seepface_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, ibvs, icon, iend, istart, ivol, jvol,          &
    !$omp iups, totvsflux,  vsflux)                                   &
    !$omp reduction(+:not_matched, nseep_first)
    !$omp do schedule(dynamic)
#endif 
      do ibvs = 1,nbvs             !loop over boundary control volumes

!c  check only on seepage face boundary

        if (btypevs(ibvs).eq.'seepage') then  
          ivol = iabvs(ibvs)  
!#ifdef PETSC
!          if(node_idx_lg2l(ivol) < 0) then
!              cycle
!          end if
!#endif

!c  check, if seepage face too low and reassign if p>0

          if ((bcondvs(ibvs).gt.r0).and.(uvsnew(ivol).gt.r0)) then  
            bcondvs(ibvs) = -r1
            uvsnew(ivol) = r0
            uvsold(ivol) = r0
            hhead(ivol) = r0 + zg(ivol)
            not_matched = not_matched+1
            nseep_first = nseep_first+1    !sum up seepage face nodes
            
!#ifdef DEBUG
!            if(ivol == 14) then
!                write(idbg,*) "-->seepface hhead(ivol)", hhead(ivol)
!            end if
!#endif

!c  check, if seepage face too high and reassign if necessary,
!c  this is done by doing a mass balance on all seepage face 
!c  control volume with p=0, the zero pressure boundary condition
!c  is correct, if the change in mass is negative, i.e. outflow
!c  occurs over the boundary, if the change in mass is positive
!c  a zero flux boundary has to be assigned 
 
          elseif (bcondvs(ibvs).lt.r0) then

!c  calculate total flux

            istart = iavs(ivol)       !pointer - start of row 
            iend = iavs(ivol+1)-1     !pointer - end of row
            icon = 0                  !counter (connections)
            totvsflux = r0            !initialize total influx

            do i1=istart,iend         !loop over connections

              jvol = javs(i1)         !column pointer
        
              if (jvol.ne.ivol) then
                icon = icon+1         !counter (connections)

!c  consistent with upstream weighting 

                if (upstream) then
                  iups(icon) = 'i'                         !h_i >= h_j
                  if (hhead(jvol).gt.hhead(ivol)) then     !h_j > h_i
                    iups(icon) = 'j'
                  end if
                end if

!c  flux calculations

                vsflux(icon) = - fluxvs(upstream,hhead(ivol),         &
     &                                  hhead(jvol),relperm(ivol),    &
     &                                  relperm(jvol),iups(icon),     &
     &                                  cinfvs_a(i1))
                totvsflux = totvsflux + vsflux(icon)

              end if                  !(ivol.eq.jvol)
            end do                    !loop over connections

            if (totvsflux.gt.r0) then
              bcondvs(ibvs) = r1             !set to zero flux
              not_matched = not_matched+1
            else    
              nseep_first = nseep_first + 1  !sum up seepage face nodes
            end if

          end if                   !(p>0/p=0)
        end if                     !(seepage)
      end do                       !loop over boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif     

#ifdef PETSC
          call MPI_Allreduce(not_matched, not_matched_gbl,1,           &
                    MPI_INTEGER4,MPI_SUM, Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          not_matched = not_matched_gbl
          
          call MPI_Allreduce(nseep_first, nseep_first_gbl,1,           &
                    MPI_INTEGER4,MPI_SUM, Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          nseep_first = nseep_first_gbl
          
#endif

!c  check for convergence of seepage face iteration

      if (not_matched.eq.0) then
        seep_iter = .false.
      end if
 
      return
      end 
