!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/mbalrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mbalrt
!c -----------------
!c mass balance (reactive transport)
!c
!c modified for density dependent flow
!c
!c written by:      Uli Mayer - September 5, 96
!c
!c last modified:   Uli Mayer - July 26, 01
!c                  Uli Mayer - November 12, 01
!c                  added new database format
!c                  for dissolution-precipitation reactions
!c
!c                  Tom Henderson - October 24, 2002
!c                  Sergi Molins - May 2, 2006
!c                  added gas advection and multi-component diffusion
!c                  still to add multi-comp diff for individual gas species
!c                  Sergi Molins - May 24,2006
!c                  press+temp dependence of diff coeff
!c                  Sergi Molins - June 12, 2006
!c                  fixed bug: rverysmall
!c
!c                  Danyang Su - March 27, 2014
!c                  Add gas advection, modified from Sergi Molins's codes
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   - 
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third and mixed 
!c                                type b.c.       -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (gaseous phase)
!c                                third and mixed 
!c                                type b.c.       -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for + -
!c                                diffusive mass fluxes across
!c                                boundary (excluding diffusion 
!c                                coefficient)
!c           cinfrt_da(njavs)   = influence coefficients              + -
!c                                (dispersion - aqueous phase)
!c           cinfrt_va(njavs)   = influence coefficients              + -
!c                                (advection - aqueous phase)
!c           hhead(nn)          = hydraulic head                      + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species
!c           gbrt(ng,nbrt)      = gas concentrations in boundary      + -
!c                                control volumes
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           gold(ng,nn)        = gas concentrations                  + -
!c                                - old time level [moles / l air]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           cmold(nm,nn)       = mineral concentrations              + -
!c                                - old time level [moles/l bulk]]
!c           cculabsbal(n)      = accumulative absolute mass balance  + +
!c                                error for dissolved species 
!c                                [moles/elapsed time]
!c           cmculabsbal(n)     = accumulative absolute mass balance  + +
!c                                error for minerals 
!c                                [moles/elapsed time]
!c           cculrelbal(n)      = accumulative relative mass balance  + +
!c                                error for dissolved species [%]
!c           cmculrelbal(n)     = accumulative relative mass balance  + +
!c                                for minerals [%]
!c           gculabsbal(ng)     = accumulative absolute mass balance  + +
!c                                error for gaseous species
!c                                [moles/elapsed time]
!c           gculrelbal(ng)     = accumulative relative mass balance  + +
!c                                error for gaseous species [%]
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = current time step                   + -
!c           dpdiff(nc+nm-1)    = source-sink term due to phase       * * 
!c                                exchange with minerals 
!c           dpdiffp(ndr*nm)    = individual source-sink terms due    * *
!c                                to parallel dissolution-
!c                                precipitation reactions
!c           cfluxin(n)         = mass gain due to inflow in water    * *
!c                                phase in terms of total aqueous
!c                                component concentrations
!c           cfluxout(n)        = mass loss due to outflow in water   * *
!c                                phase in terms of total aqueous
!c                                component concentrations
!c           contaqtot(naq)     = contribution of intra-aqueous       + +
!c                                kinetic reactions to mass balance
!c                                [moles/elapsed time]
!c           contmintot(nm)     = contribution of dissolution-        + +
!c                                precipitation reactions to mass
!c                                balance [moles/elapsed time]
!c           gfluxtbdy(ng)      = mass flux across top boundary       * *
!c                                (gaseous phase)
!c           gfluxin(n)         = mass gain due to inflow in air      * *
!c                                phase in terms of total gaseous
!c                                component concentrations
!c           gfluxout(n)        = mass loss due to outflow in air     * *
!c                                phase in terms of total gaseous
!c                                component concentrations
!c           ordiff(n)          = global source-sink term due to      * *
!c                                oxidation-reduction reactions
!c           pornew(nn)         = porosity                            + -
!c           ratemdp(nm,nn)     = absolute dissolution-precipitation  + -
!c                                rates of minerals
!c           cstordiff(nc+nm-1) = change in storage in terms of total * *
!c                                aqueous component concentrations
!c           gdegas(n)          = mass loss from aqueous phase due to * *
!c                                degassing 
!c           gstordiff(n)       = change in storage in terms of total * *
!c                                gaseous component concentrations
!c           phi(nm,nn)         = volume fractions of minerals        + -
!c           phiold(nm,nn)      = volume fractions of minerals        + -
!c                                (old time level)
!c           rateaqtot(naq)     = total rate of intra-aqueous kinetic * * 
!c                                reaction in solution domain
!c                                [moles/day]
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           sbdiff(n)          = source-sink term due to phase       * *
!c                                exchange with sorbed phase
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            + -
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             + +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c
!c           totcnew(nc-1,nn)   = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totcold(nc-1,nn)   = total aqueous component             + -
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgnew(nc-1,nn)   = total gaseous component             + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totgold(nc,nn)      = total gaseous component            + -
!c                                concentrations
!c                                - old time level [moles/l air]
!c           tmass(n)           = total mass in aqueous and gaseous   + -
!c                                phase in terms of total component
!c                                concentrations [moles] 
!c           time_io            = current solution time (I/O units)   + -
!c           totmdp(nc-1,nn)    = total source/sink term towards      + -
!c                                total aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c           totcflux(n)        = total mass fluxes (aqueous phase)   * *
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * *
!c           totsold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              + -
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              + -
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           totcfluxin(nc)     = total mass gain due to inflow in    + +
!c                                auqueous phase in terms of total
!c                                aqueous component concentrations
!c           totcfluxout(nc)    = total mass loss due to inflow in    + +
!c                                aqueous phase in terms of total
!c                                aqueous component concentrations
!c           totcstordiff(nc)   = total change in storage in          + +
!c                                aqueous phase in terms of total
!c                                aqueous component concentrations
!c           totordiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to intra-aqueous kinetic 
!c                                reactions
!c           totdpdiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to dissolution-precipitation 
!c                                reactions
!c           totdpdiffp(ndr*nm) = individual contribution of parallel + +
!c                                reaction pathways of dissolution-
!c                                precipitation reactions to mass
!c                                balance [moles/elapsed time]
!c           totgdegas(nc)      = total mass loss from aquoeus phase  + +
!c                                due to degassing
!c           totgdiff(nc)       = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to gas dissolution-esolution
!c                                reactions
!c           totgfluxin(nc)     = total mass gain due to inflow in    + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totgfluxout(nc)    = total mass loss due to inflow in    + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totgstordiff(nc)   = total change in storage in          + +
!c                                gas phase in terms of total
!c                                gaseous component concentrations
!c           totsbdiff(nc)      = total source/sink to total          + +
!c                                aqueous component concentrations
!c                                due to sorption or ion-exchange
!c                                reactions
!c
!c           added for gas advection and multi-component diffusion
!c
!c           deltaij(njavs)     = distance between i-j                + -
!c           gmfrac(1,ivol)     = gas molar fractions at c.v. i       * +
!c           gporij(njavs)      = gas filled porosity                 + -
!c           relpermg(ivol)     = relative permeability (gas phase)   * +
!c           tauij(njavs)       = tortuosity (gas phase)              + -
!c
!c           character:
!c           ----------
!c           iupsg(i1)          = upstream node for weighting         + -
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        + -
!c
!c           integer*4:
!c           ----------
!c           i2up(nn)           = pointer array to second upstream    + -
!c                                point
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           idbg               = unit number - debugging file        + -
!c           imrt               = unit number, mass balance -         + -
!c                                             reactive transport
!c           jabrt(nbrt)        = pointer array - boundary conditions + -
!c                                (reactive transport)
!c           l_time_unit        = length of time unit for output      + -
!c           m_time             = current time step                   + -
!c           nbrt               = number of specified boundary        + -
!c                                control volumes
!c           nn                 = total number of control volumes     + -
!c
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (free advective mass
!c                                            outflux for aqueous
!c                                            phase)
!c                                'third'  = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c
!c chem.f:   real*8:
!c           -------
!c           acth2omin          = min. activity for h2o               + -
!c           adav               = coefficient for Davies equation     + -
!c           bdav               = coefficient for Davies equation     + -
!c           dhac(nc)           = debye-huckel a for free species     + -
!c           dhad(nthreads)     = Debye Huckel constant a_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhax(nx)           = debye-huckel a for secondary        + -
!c                                aqueous species
!c           dhbc(nc)           = debye-huckel b for free species     + -
!c           dhbd(nthreads)     = Debye Huckel constant b_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhbx(nx)           = debye-huckel b for secondary        + -
!c                                aqueous species
!c           rateaq(naq,nthreads)
!c                              = reaction rates of intra-aqueous     * *
!c                                kinetic reaction
!c           rateg(ng,nthreads) = degassing rates                     * *
!c           rateor(nr,nthreads)= oxidation-reduction rate for        * *
!c                                redox couple [moles/(l h2o*day)
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           totaq(nc-1,nthreads)
!c                              = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           totor(nc-1)        = total source/sink term towards      * *
!c                                aqueous component concentrations
!c                                due to oxidation-reduction
!c                                reactions [moles/(l bulk*day)]
!c           totrateg(nc-1)     = total rate for removal of aqueous   * *
!c                                components due to degassing
!c                                [mol L^-1 s^-1]
!c
!c           logical:
!c           --------
!c           gas_removal        = .true.  -> degassing of dissolved   + -
!c                                           gases, if confining
!c                                           pressure exceeded
!c           new_database       = .true.  -> use new database format  + -
!c           noncompetitive_sorption = logical array for activation   + -  
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           integer*4:
!c           ----------
!c           l_namec(nc)        = length of component names           + -
!c           naq                = number of intra-aqueous kinetic     + -
!c                                reactions
!c           nc                 = number of components                + -
!c           nx                 = number of secondary species         + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           nameaq(naq)        = names of intra-aqueous kinetic      + -
!c                                reactions
!c           namec(nc)          = component names                     + -
!c           namem(nm)          = mineral names                       + -
!c           sorption_group     = 'ion-exchange'
!c                                'surface-complexation'
!c                                'undefined'
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c dens.f:   logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c           absbalance         = absolute mass balance in 
!c                                [moles/timestep]
!c           bdyinfrt_da        = boundary influence coefficient 
!c                                for diffusive mass flux (aqueous
!c                                phase)
!c           bdyinfrt_dg        = boundary influence coefficient 
!c                                for diffusive mass flux (gaseous
!c                                phase)
!c           conv3              = conversion factor [l/m^3]
!c           diff_eff           = effective diffusion coefficient
!c           r0                 = constant
!c           r100               = constant
!c           relbalance         = relative mass balance in %
!c           totvsflux          = total water flux across boundary
!c
!c           added for gas transport:
!c
!c           densgij            = gas density at interface i-j
!c           dgm_gflux(nc)      = diffusive gas flux of total         * +
!c                                components (as computed w/ DGM) 
!c           dgm_gflux_s(ng)    = diffusive gas flux of gas species   * +
!c                                (as computed w/ DGM) 
!c           fmat(ng,ncon)      = right hand side DGM system          * +
!c           gacc               = gravity                             + -
!c           gafluxin(nc)       = advective in-flux                   * +
!c           gafluxout(nc)      = advective out-flux                  * +
!c           gdens(nn)          = gas density at control volume i     * +
!c           gij                = gas concentration at i-j            * +
!c           gmfracij           = gas molar fractions at i-j          * +
!c           gpivol(nn)         = gas pressure at control volume i    * +
!c           gvisc(ivol)        = gas viscosity at control vol i      * +
!c           ludecomp(ng,ng,ncon) = LU decomp of matrix of DGM system * +
!c           ms_gflux(nc)       = total diffusive flux                * +
!c                                (as computed with Stefan-Maxwell)
!c           ms_gflux_s(ng)     = diffusive flux of gas species       * +
!c                                (as computed with Stefan-Maxwell)
!c           neflux(nc)         = non-equimolar flux for multi-comp   * +
!c                                diffusion
!c           neflux_s(ng)       = non-equimolar flux of gas species   * +
!c                                in multi-comp diffusion 
!c           relpgij            = relative perm (gas) at i-j          * +
!c           totgafluxin(nc)    = total advective in-flux             * + 
!c           totgafluxout(nc)   = total advective out-flux            * + 
!c           totgij             = total gas concentrations of         * +
!c                                components at interface i-j         * +
!c           viscgij            = gas viscosity at interface i-j      * +
!c
!c           character:
!c           ----------
!c           spt_weight         = spatial weighting for gas transp    * +
!c
!c
!c           integer*4:
!c           ----------
!c           iaq                = counter (intra-aqueous kinetic
!c                                         reactions)
!c           ibrt               = counter (source control volumes)
!c           ic                 = counter (components)
!c           im                 = counter (minerals)
!c           ir                 = counter (redox couples)
!c           ivol               = counter (control volumes)
!c
!c external: acoff     = compute activity coefficient
!c           bdryflux  = compute water flux across boundary control 
!c                       volumes
!c           ddbdflux  = compute water flux across boundary control 
!c                       volumes - density dependent flow
!c           bulkconc  = convert from [moles/l water] to
!c                       [moles/l bulk]
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           diffcoff  = compute effective diffusion coefficient
!c           fluxv     = advective flux
!c           fluxd     = diffusive/dispersive flux
!c           molconc   = compute average molar concentration for
!c                       organic mixture
!c           msysrt    = compute total system mass (reactive 
!c                       transport) 
!c           rategas   = compute degassing rates
!c           rategasd  = compute degassing rates for density
!c                       dependent flow
!c           rateint   = compute rate for intra-aqueous kinetic
!c                       reactions
!c           rateint_new   = compute rate for intra-aqueous kinetic
!c                       reactions (new database format)
!c           ratemin   = compute dissolution-precipitation
!c                       rate for mineral phase
!c           ratemin_new   = compute dissolution-precipitation
!c                       rate for mineral phase (new database format)
!c           rateredx  = compute total oxidation-reduction rates 
!c                       for redox couples 
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totint    = compute total source-sink terms towards
!c                       total aqueous component concentrations
!c                       due to intra-aqueous reactions
!c           totredx   = compute total source/sink term towards total 
!c                       aqueous component concentrations due to
!c                       oxidation-reduction reactions or derivative 
!c                       thereof
!c           zero_r8   = clear real*8 array
!c
!c           dgm_fluxdg   = compute total gas diffusive fluxes using
!c                          the Dusty Gas Model
!c           dgm_fluxdg_s = compute diffusive fluxes of gas species 
!c                          using the Dusty Gas Model        
!c           gasdiff2     = compute gas diffusion coeff for components 
!c                          with LeBlanc's approx
!c           gasdiff2_s   = compute gas diffusion coeff for species
!c                          with LeBlanc's approx
!c           ms_fluxdg    = compute total gas diffusive fluxes using
!c                          the Stefan-Maxwell equations
!c           ms_fluxdg_s  = compute diffusive fluxes of gas species 
!c                          using the Stefan-Maxwell equations
!c           wgprop    = weighting for gas transport properties
!c
!c ----------------------------------------------------------------------
  
      subroutine mbalrt
 
      use parm
      use gen
      use phys
      use chem
      use dens
      use bbls
      use dgml
      use writeversion 
      use biol !FG sept 2021
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only : binary_write_data
      
      implicit none
      
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif
      
#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif
      
      integer :: ierr, ivol, ibrt, istart ,iend, ic, i1, jvol, ibvs,   &
                 ix, ir, iaq, imb, ig, im, istop, ireac
      
      real*8 :: absbalance, acoff, area_ivol, totvsflux, ddbdflux,     &
                bdryflux, diff_eff, diffcoff, bdyinfrt_da,             &
                bdyinfrt_dg, bulkconc, fluxv_vl, fluxvg, fluxd,        &
                gasp_m, gasd_m, gasv, relbalance,                      &
                diffcoff_g, gasdiff2, gasdiff2_s
      
      integer :: tid

      external acoff, bulkconc, bdryflux, comptotc, ddbdflux,         &
               diffcoff,fluxv_vl, fluxd, msysrt,                      &
               rateredx, totconcg, zero_r8,                           &
               diffcoff_g, gasdiff2, gasdiff2_s
     
      logical :: compute_diff

      real*8, parameter :: r0 = 0.0d0,r1=1.0d0,r100 = 100.0d0,         &
                           conv3 = 1.0d3,rverysmall = 1.0d-30

!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------
      real*8   :: dpdt
      !real*8   :: area_ivol, totvsflux, diff_eff, bdyinfrt_da
      
      real (type_r8), allocatable :: bdyinfrt_da_ic(:)
      
!cdsu-------------------------------------------------------------------
!cdsu---------------------Gas transport variables-----------------------
!cdsu-------------------------------------------------------------------
      character*12 :: spt_weight
    
      real*8    relpgij,          &
                densgij,          &
                viscgij,          &
                gpij,             &
                gpivol_ivol,      &
                gdens_ivol,       &
                gvisc_ivol,       &
                gpivol_jvol,      &
                gdens_jvol,       &
                gvisc_jvol
      
!cdsu  added for dgm model
!c dgm and s-m variables and initialization
	  real*8 :: dgm_gflux(nc), dgm_gflux_s(ng)

	  real*8 :: ms_gflux(nc), ms_gflux_s(ng)

	  real*8 :: ludecomp(ng,ng), fmat(ng), neflux(nc), neflux_s(ng)

	  integer*4 :: ipvt(ng)
      real*8 :: so_av, gflux_ic, gflux_ig, cinfrt
      
      integer :: nvarsimrt
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
      
        !>interface of molconc
        subroutine molconc(phim)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: phim   
        end subroutine molconc
        
        !>interface of rategas
        subroutine rategas(g,tkel,hhead,zg,sg_loc)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: g
          real(type_r8) :: tkel
          real(type_r8) :: hhead
          real(type_r8) :: zg  
          real(type_r8) :: sg_loc
        end subroutine rategas
        
        !>interface of rategasd
        subroutine rategasd(g,tkel,phead,sg_loc)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: g
          real(type_r8) :: tkel
          real(type_r8) :: phead 
          real(type_r8) :: sg_loc
        end subroutine rategasd
        
        !>interface of rateint
        subroutine rateint(rate,totc,c,gammac,phim,iaq,scalfacaq)
          use parm, only : type_i4, type_r8
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: phim
          integer(type_i4) :: iaq
          real(type_r8) :: scalfacaq
        end subroutine rateint
        
        !>interface of rateint_new
        subroutine rateint_new(rate,totc,c,cx,gammac,gammax,phim,iaq,  &
                               scalfacaq)
          use parm, only : type_i4, type_r8     
          real(type_r8) :: rate
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: phim
          integer(type_i4) :: iaq
          real(type_r8) :: scalfacaq
        end subroutine rateint_new    
                               
        !> interface of ratemin
        subroutine ratemin(totc,c,cx,gammac,gammax,ratem,phim,    &
                           phimold,aream,im) 
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
        end subroutine ratemin  
                           
        !> interface of ratemin_new
        subroutine ratemin_new(totc,c,cx,gammac,gammax,ratem,phim,    &
                               phimold,aream,im) 
          use parm, only: type_i4, type_r8
          real(type_r8), dimension(*) :: totc
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: ratem
          real(type_r8), dimension(*) :: phim 
          real(type_r8) :: phimold
          real(type_r8) :: aream
          integer(type_i4) :: im
        end subroutine ratemin_new
                               
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel
        end subroutine tcorr
                    
        !>interface of totint
        subroutine totint(totintaq,idbg)
          use parm, only :type_i4, type_r8   
          real(type_r8), dimension(*) :: totintaq
          integer(type_i4) :: idbg
        end subroutine totint
        
        !>interface of totredx
        subroutine totredx(totoxrd,idbg)
          use parm, only :type_i4, type_r8   
          real(type_r8), dimension(*) :: totoxrd
          integer(type_i4) :: idbg
        end subroutine totredx        
                             
        !>interface of modrate
        subroutine modrate(ratem,cmnewm,delt,im)
          use parm, only : type_i4, type_r8
          real(type_r8) :: ratem
          real(type_r8) :: cmnewm
          real(type_r8) :: delt
          integer(type_i4) :: im
        end subroutine modrate
        
        !!>interface of jacbevap
        !subroutine jacbevap(ivol,typeequation)
        !  integer, intent(in)           :: ivol 
        !  character(len=*), intent(in)  :: typeequation    
        !end subroutine jacbevap
        
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      totvsflux = r0      
      spt_weight      = spatial_weighting            ! spatial weighting

      allocate (bdyinfrt_da_ic(nc), stat = ierr)
      bdyinfrt_da_ic(1:nc)=0.0d0 
      call checkerr(ierr,'bdyinfrt_da_ic',ilog)
!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------
!cprovi----------------------------------------------------------------------      
      compute_diff = .true. 
!c  zero arrays
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_r8(cfluxin,n,1,1)
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_r8(cfluxout,n,1,1)
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      call zero_r8(cstordiff,n,1,1)
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (ng.gt.0) then
        call zero_r8(gfluxin,n,1,1)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (ng.gt.0) then
        call zero_r8(gfluxout,n,1,1)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (ng.gt.0) then
        call zero_r8(gafluxin,n,1,1)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (ng.gt.0) then
        call zero_r8(gafluxout,n,1,1)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (ng.gt.0) then
        call zero_r8(gstordiff,n,1,1)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (ng.gt.0) then
        call zero_r8(gdegas,n,1,1)
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (naq.gt.0.or.nr.gt.0) then
        call zero_r8(ordiff,n,1,1)
      end if 
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (nsb_ion.gt.0.or.nsb_surf.gt.0.or.noncompetitive_sorption) then
        call zero_r8(sbdiff,n,1,1)
      end if 
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
      if (nm.gt.0) then
        call zero_r8(dpdiff,n,1,1)
      end if 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif
 
!c  compute total system mass at current time step
 
      call msysrt
 
!c  compress total aqueous component concentration vector and
!c  total gaseous component concentration vector for mass 
!c  balance calculations
      if (redox_equil.and.nr.gt.0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_1)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)
    !$omp do schedule(static)
#endif
        do ivol = 1,nngl
          call comptotc(totcnew(1,ivol))
          if (ng.gt.0) then
            call comptotc(totgnew(1,ivol))
          end if
          if (noncompetitive_sorption) then
          call comptotc(totanew(1,ivol))
          end if
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif        
      end if

!c  calculate mass balance for water phase in terms of total 
!c  aqueous component concentrations [moles/unit time]

!c  flux contributions
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mbalrt_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(i1, ibrt, ibvs, ic, iend, istart, ivol, jvol)       &
    !$omp firstprivate(area_ivol, bdyinfrt_da, bdyinfrt_da_ic,        &
    !$omp compute_diff, diff_eff, totcflux, totvsflux)                &
    !$omp reduction(+:cfluxin, cfluxout)
    !$omp do schedule(static)
#endif
      do ibrt = 1,nbrt                 !boundary control volumes

        ivol = jabrt(ibrt)             !pointer to control volume
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif
!c  Dirichlet type boundary conditions

        if (btypert(ivol).eq.'first') then

          istart = iavs(ivol)+1 
          iend = iavs(ivol+1)-1

          do ic=1,n              !loop over components

            if (component_type(ic).eq.'aqueous') then
            
              totcflux(ic) = r0
              do i1 = istart,iend        !loop over local connections
              
              
!cprovi----------------------------------------------------------------------
!cprovi Component dependent influence coefficient if specified
!cprovi----------------------------------------------------------------------
                if (diff_coff) then
                   cinfrt_da(i1) = cinfrt_da_ic(i1,ic)
                end if
!cprovi----------------------------------------------------------------------              
!cprovi----------------------------------------------------------------------              
!cprovi----------------------------------------------------------------------            

                jvol = javs(i1)
     
                if (multi_diff) then 
         
                    totcflux(ic) = totcflux(ic) + conv3 *                 &
                                    (fluxv_vl(totcnew(ic,ivol),  & !advective term
                                            totcnew(ic,jvol),       &
                                            ivol,jvol,       &
                                            cinfrt_va(i1),ic)    &
                                - fluxd(totviscnew(ic,ivol),    & !diffusive term
                                        totviscnew(ic,jvol),    &
                                        cinfrt_mcd(i1))       &
!                              + mdiff_ic_cvol(ic,i1) * chargec(ic) 
!                              * cnew(ic,ivol) * Dzdeltac_loc/Dz2c_loc 
                                - fluxd(electromignew(ic,ivol),r0,  &
                                        cinfrt_mcd(i1)))           
      
                    !totbcfluxd = - conv3 * fluxd(totviscnew(ic,ivol),   &  !diffusive term 
                    !                    totviscnew(ic,jvol),            &   !never used, comment out by DSU
                    !                    cinfrt_mcd(i1))
                    !totbcfluxe = - conv3 * fluxd(electromignew(ic,ivol),r0, &
                    !                    cinfrt_mcd(i1))
      
                else 
                    totcflux(ic) = totcflux(ic) + conv3 *                 &
                                    (fluxv_vl(totcnew(ic,ivol),             &
                                            totcnew(ic,jvol),             &
                                            ivol,jvol,                    &
                                            cinfrt_va(i1),ic)             &
                                - fluxd(totcnew(ic,ivol),totcnew(ic,jvol), &
                                            cinfrt_da(i1)))
      
                    !totbcfluxd = - conv3 * fluxd(totcnew(ic,ivol),          &   !never used, comment out by DSU
                    !                        totcnew(ic,jvol),cinfrt_da(i1))
     
                end if 
              end do

            end if                     !loop over local connections

          end do                       !loop over components

!c  Neumann, Cauchy or mixed type boundary conditions

        else

!c  compute water flux across boundary [volume, not mass!]
          if (density_dependence) then
             if (evaporation) then
               ibvs = ivol2bvs(ivol)
               if(ibvs==0) then
                  if (rank == 0) then 
                    write(ilog,*)'error in boundary cond.'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
               end if 
               if (btypevs(ibvs)=='atmospheric') then 
                   area_ivol=bcondvs(ibvs)
                   !cprovi---------------------------------------------------
                   !cprovi Change the inflow/for m3/day
                   !cprovi---------------------------------------------------
              !    call jacbevap(ivol,' ') 
                   totvsflux = totwflux_atm*area_ivol/ref_dens
                   if (totvsflux<r0) then
                     compute_diff = .false. 
                     totvsflux =r0
                   end if
               else
                   totvsflux = ddbdflux(ivol)
               end if
             end if
          else
            totvsflux = bdryflux(ivol) 
          end if

!c  total mass fluxes across Neumann type boundary control volumes
 
          if (btypert(ivol).eq.'second') then

            do ic = 1,n
              if (component_type(ic).eq.'aqueous') then
                totcflux(ic) = conv3 * totvsflux              & !advective flux
                             * totcnew(ic,ivol)
              end if
            end do

!c  total mass fluxes across Cauchy type boundary control volumes or 
!c  injection points

          elseif ((btypert(ivol).eq.'third') .or.             &
     &                (btypert(ivol).eq.'point')) then

!cbdy-start
            if (totvsflux.gt.0) then
!cbdy-end
!cbdy - flux enters domain

            
              do ic = 1,n
                if (component_type(ic).eq.'aqueous') then
                  totcflux(ic) = conv3 * totvsflux              & !advective flux
                               * bcondrt_a(ic,ibrt)
                end if
              end do
!cbdy-start
!cbdy - flux leaves domain

            else
            
              do ic = 1,n
                if (component_type(ic).eq.'aqueous') then
                  totcflux(ic) = conv3 * totvsflux          &  !advective flux
                               * totcnew(ic,ivol)
                end if
              end do

          end if

!cbdy-end

!c  total mass fluxes across mixed type boundary control volumes

          elseif (btypert(ivol).eq.'mixed') then

!cprovi--------------------------------------------------------------------            
!cprovi Use component dependent diff coefficient if speciifed
!cprovi--------------------------------------------------------------------      
            if (compute_diff) then 
              so_av=dmin1(r1, sonew(ivol))  
              if (.not.diff_coff) then
                     diff_eff = diffcoff(diff_a, sanew(ivol),pornew(ivol), &
                                 tortuosity_corr,assigned_tau,             &
                                 tau(ivol)*tau_fac(ivol),                  &
                                 type_tortuosity,marchies(ivol),so_av)
                     bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
              else
                do ic = 1,nc
                     diff_eff = diffcoff(diff_ic(ic), sanew(ivol),           &
                                pornew(ivol),tortuosity_corr,assigned_tau,  &
                                tau(ivol)*tau_fac(ivol),                    &
                                type_tortuosity,marchies(ivol),so_av)
                    bdyinfrt_da_ic(ic) = diff_eff * bdycrt_d(ibrt)
                end do
              end if
            else 
              if (diff_coff) then
                 bdyinfrt_da_ic(1:nc) = r0
              else
                 bdyinfrt_da = r0
              end if       
            end if 
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------            
            
            do ic = 1,n
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------                     

     
              if (diff_coff) then
                bdyinfrt_da = bdyinfrt_da_ic(ic)
              end if
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------            
!cprovi--------------------------------------------------------------------                        
              if (component_type(ic).eq.'aqueous') then
                totcflux(ic) = conv3 *                        &
                             ( totvsflux                      & !advective flux
                             * bcondrt_a(ic,ibrt)             &
                             + fluxd(totcnew(ic,ivol),        &!diffusive flux
                                     bcondrt_a(ic,ibrt),      &
                                     bdyinfrt_da))
              end if
            end do

          end if

        end if                !boundary type (transport) 

!c  assign flux contributions

        do ic = 1,n
          if (component_type(ic).eq.'aqueous') then
            if (totcflux(ic).gt.r0 ) then
              cfluxin(ic) = cfluxin(ic) + totcflux(ic)    !mass in
            else
              cfluxout(ic) = cfluxout(ic) - totcflux(ic)  !mass out
            end if
          end if
        end do

      end do                  !loop over boundary control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(cfluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxin(1:n) = mpireduce_n(1:n)
      
      call MPI_Allreduce(cfluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM,   &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cfluxout(1:n) = mpireduce_n(1:n)    
#endif

 
!c  change in storage [moles/unit time]
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol)                                          &
    !$omp reduction (+:cstordiff)
    !$omp do schedule(static) 
#endif
      do ivol = 1,nngl
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif
        do ic = 1,n
          cstordiff(ic) = cstordiff(ic)                       &
     &                  + conv3 * cvol(ivol)/delt             &
     &                  * (bulkconc(totcnew(ic,ivol),         &
     &                              sanew(ivol),              &
     &                              pornew(ivol))             &
     &                  -  bulkconc(totcold(ic,ivol),         &
     &                              saold(ivol),              &
     &                              porold(ivol)))
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(cstordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cstordiff(1:n) = mpireduce_n(1:n)  
#endif

!c  contributions from exchange with air phase
!c  Q_ex = inflow - outflow - change in storage
!c
!c  flux contributions 
      if (ng.gt.0) then

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mbalrt_4)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, ibrt, ic, iend, istart, ivol, jvol,            &
    !$omp densgij, gij, gpij, gmfracij, relpgij,                      &
    !$omp totgij, totgflux, totgaflux, viscgij,                       &
    !$omp gpivol_ivol, gdens_ivol, gvisc_ivol,                        &
    !$omp gpivol_jvol, gdens_jvol, gvisc_jvol,                        &
    !$omp diff_eff, bdyinfrt_dg, fmat, ipvt, ludecomp,                &
    !$omp cinfrt, dgm_gflux, gflux_ic, ms_gflux, neflux)              &
    !$omp reduction (+:gfluxin, gfluxout, gafluxin, gafluxout)
    !$omp do schedule(static)
#endif
        do ibrt = 1,nbrt                 !boundary control volumes

          ivol = jabrt(ibrt)             !pointer to control volume

          call zero_r8 (totgflux,n,1,1)  !zero flux array
          call zero_r8 (totgaflux,n,1,1) !zero flux array
          call zero_r8 (totgij,nc,1,1)
          
          
!c  Dirichlet type boundary conditions

          if (btypert(ivol).eq.'first') then

            istart = iavs(ivol)+1
            iend = iavs(ivol+1)-1

!c          gas advection variables
            if (gas_advection) then
              gpivol_ivol = gasp_m(mdens_g(ivol),ivol)           ! pressure
              gdens_ivol  = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! density
              gvisc_ivol  = gasv(gmfrac(:,ivol))                 ! viscosity
            else
              gpivol_ivol = 0.0d0
              gdens_ivol  = 0.0d0
              gvisc_ivol  = 0.0d0
            end if


            do ic=1,n                 !loop over components

              do i1 = istart,iend        !loop over local connections

                jvol = javs(i1)

                if (blanc_diff_g .or. gas_advection) then
                    gpivol_jvol  = gasp_m(mdens_g(jvol),jvol)          ! pressure
                    gdens_jvol   = gasd_m(mdens_g(jvol),gmfrac(:,jvol))! density
                    gvisc_jvol   = gasv(gmfrac(:,jvol))                ! viscosity
                else
                    gpivol_jvol = 0.0d0
                    gdens_jvol  = 0.0d0
                    gvisc_jvol  = 0.0d0
                endif

!c              calculate gas properties at interface according to weighting scheme
                call wgprop(totgnew(1,ivol),totgnew(1,jvol),totgij   , &
                            gnew(1,ivol)   ,gnew(1,jvol)   ,gij      , &
                            gmfrac(1,ivol) ,gmfrac(1,jvol) ,gmfracij , &
                            relpermg(ivol) ,relpermg(jvol) ,relpgij  , &
                            gdens_ivol     ,gdens_jvol     ,densgij  , &
                            gvisc_ivol     ,gvisc_jvol     ,viscgij  , &
                            gpivol_ivol    ,gpivol_jvol    ,gpij     , &
                            zg(ivol)       ,zg(jvol)       ,           &
                            spt_weight     ,iupsg(i1)      ,           &
                            nc             ,ng             ,gacc     )
                
                
!c -------------- DGM module ----------------------------------------------------
!c               solve A F = B
!c               computes fluxes F of all gas components at current c.v. interphase

                gflux_ic = 0.0d0
          
		        if ((ng.gt.0).and.dgm) then
                
		          call dgm_fluxdg (gnew(1,ivol)    ,gnew(1,jvol) ,     &
     &                             gij             ,gmfracij     ,     &
     &                             zg(ivol)        ,zg(jvol)     ,     &
     &                             densgij         ,gpij         ,     &
     &                             tkel(ivol)      ,permij(i1)   ,     &
     &                             relpgij         ,tauij(i1)    ,     &
     &                             gporij(i1)      ,deltaij(i1)  ,     &
     &                             rverysmall      ,                   &
     &                             ludecomp        ,                   &
     &                             fmat            ,ipvt         ,     &
     &                             dgm_gflux       ,neflux       )
                
!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else
                
                    gflux_ic =                                         &
     &                       + cinfrt_dg(i1)                           &
     &                       * deltaij(i1)                             &
     &                       * dgm_gflux(ic)                           &
     &                       / tauij(i1)                               &
     &                       / gporij(i1)
                
	              endif
                
!c --------------- Maxwell Stefan module ----------------------------------------

		        else if ((ng.gt.0).and.maxwell) then
                
	              call ms_fluxdg (gnew(1,ivol)    ,gnew(1,jvol) ,      &
     &                            gij             ,gmfracij     ,      &
     &                            zg(ivol)        ,zg(jvol)     ,      &
     &                            densgij         ,gpij         ,      &
     &                            tkel(ivol)      ,tauij(i1)    ,      &
     &                            gporij(i1)      ,deltaij(i1)  ,      &
     &                            rverysmall      ,                    &
     &                            ludecomp        ,fmat         ,      &
     &                            ipvt            ,equimolar    ,      &
     &                            ms_gflux        ,neflux       )
                
!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else
                
                    gflux_ic =                                         &
     &                       + cinfrt_dg(i1)                           &
     &                       * deltaij(i1)                             &
     &                       * ms_gflux(ic)                            &
     &                       / tauij(i1)                               &
     &                       / gporij(i1)
                
	              endif
                
!c--------ficks law, business as usual------------------------------------

	            else if ((.not.dgm).and.(.not.maxwell)) then
                
                  if (blanc_diff_g) then
!c                    diffusion coefficient calc'd with LeBlanc's law
                      
				    cinfrt = cinfrt_dg(i1) * gasdiff2                  &
     &                               (gmfrac(1,ivol)  ,gmfrac(1,jvol), &
     &                                gpivol_ivol     ,gpivol_jvol   , &
     &                                zg(ivol)        ,zg(jvol)      , &
     &                                gdens_ivol      ,gdens_jvol    , &
     &                                ic              ,                &
     &                                iupsg(i1)       ,spt_weight    )
			      else 
!c                   single constant diffusion
	                cinfrt = cinfrt_dg(i1)
			      endif    
                
!c new - diffusion expressed in terms of concentration gradients
                  gflux_ic = - fluxd(totgnew(ic,ivol),                 &
     &                               totgnew(ic,jvol),                 &
     &                               cinfrt)                            ! cinfrt_dg(i1) -> cinfrt
	           
                endif
!c  -----------> diffusion component 
#ifdef PETSC
                if(node_idx_lg2l(ivol) > 0) then
#endif
                  totgflux(ic) = totgflux(ic) + conv3 * gflux_ic
#ifdef PETSC                  
                end if
#endif
!cold     &                       ( - fluxd(totgnew(ic,ivol),
!cold     &                                 totgnew(ic,jvol),
!cold     &                                 cinfrt))        ! cinfrt_dg(i1)-->cinfrt

!c  -----------> advection component 
                if (gas_advection) then
#ifdef PETSC
                  if(node_idx_lg2l(ivol) > 0) then   
#endif
                    totgaflux(ic) = totgaflux(ic) + conv3 *            &
                                    (fluxvg(gpivol_ivol, gpivol_jvol,  &
                                           zg(ivol)    ,zg(jvol)    ,  &
                                           totgij(ic)  ,relpgij     ,  &
                                           densgij     ,viscgij     ,  &
                                           cinfvs_g(i1),               &
                                           gas_gravity ,gacc))
#ifdef PETSC
                  end if
#endif

                endif 
 
              end do                     !loop over local connections

            end do                       !loop over components

!c  total mass fluxes across mixed type boundary control volumes

          elseif (btypert(ivol).eq.'mixed') then
              
            so_av=dmin1(r1, sonew(ivol))  

            diff_eff = diffcoff_g(diff_g,sgnew(ivol),pornew(ivol),     &
                              tortuosity_corr,assigned_tau,            &
                              tau(ivol)*tau_fac(ivol),                 &
                              type_tortuosity,marchies(ivol),          &
                              gas_tortuosity,so_av)
            bdyinfrt_dg = diff_eff * bdycrt_d(ibrt)
#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
#endif
              do ic = 1,n
                totgflux(ic) = conv3 *                                 &
                             ( + fluxd(totgnew(ic,ivol),               & !diffusive flux
                                       bcondrt_g(ic,ibrt),             &
                                       bdyinfrt_dg))
              end do
#ifdef PETSC
            end if
#endif

          end if                         !boundary type

#ifdef PETSC
          if(node_idx_lg2l(ivol) > 0) then
#endif
            do ic = 1,n
            
              if (totgflux(ic).gt.r0) then
                gfluxin(ic) = gfluxin(ic) + totgflux(ic)    !influx
              else
                gfluxout(ic) = gfluxout(ic) - totgflux(ic)  !outflux
              end if
            
              if (gas_advection) then
              
                if (totgaflux(ic).gt.r0) then
                    gafluxin(ic) = gafluxin(ic) + totgaflux(ic)    !influx
                else
                    gafluxout(ic) = gafluxout(ic) - totgaflux(ic)  !outflux
                end if
              
              endif 
            
            end do
#ifdef PETSC
          end if
#endif

        end do                           !boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(gfluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxin(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(gfluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxout(1:n) = mpireduce_n(1:n)
      
      if (ng .gt. 0 .and. gas_advection) then
        call MPI_Allreduce(gafluxin, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gafluxin(1:n) = mpireduce_n(1:n)
      
        call MPI_Allreduce(gafluxout, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gafluxout(1:n) = mpireduce_n(1:n)
      end if
#endif

!c  change in storage [moles/unit time]
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_5)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, ic)                                          &
    !$omp reduction (+:gstordiff)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
#ifdef PETSC 
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if 
#endif
            
          do ic = 1,n
            gstordiff(ic) = gstordiff(ic)                             &
     &                    + conv3 * cvol(ivol)/delt                   &
     &                    * (bulkconc(totgnew(ic,ivol),               &
     &                                sgnew(ivol),                    &
     &                                pornew(ivol))                   &
     &                    -  bulkconc(totgold(ic,ivol),               &
     &                                sgold(ivol),                    &
     &                                porold(ivol)))
          end do
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
        call MPI_Allreduce(gstordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM, &
                         Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gstordiff(1:n) = mpireduce_n(1:n) 
#endif


!c  mass loss due to degassing

        if (gas_removal) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_6)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ic, ivol)                                     &
    !$omp firstprivate(totrateg)                                      &
    !$omp reduction (+:gdegas)
    !$omp do schedule(static) 
#endif
          do ivol = 1,nngl 
!#ifdef PETSC 
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif
              
#ifdef OPENMP    
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif

            if (density_dependence) then
              call rategasd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),      &
                            sgnew(ivol))
            else
              call rategas(gnew(1,ivol),tkel(ivol),hhead(ivol),        &
                           zg(ivol),sgnew(ivol))
            end if

            call totconcg(rateg(:,tid),totrateg)

!c  scale total rates for removal af aqueous components due to
!c  degassing [mol L^-1 bulk s^-1]

#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
#endif
              do ic = 1,n
                gdegas(ic) = gdegas(ic) + conv3 * cvol(ivol)           &
     &                     * bulkconc(totrateg(ic),sanew(ivol),        &
     &                                pornew(ivol))
              end do
#ifdef PETSC
            end if
#endif

          end do               !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif      

#ifdef PETSC
          call MPI_Allreduce(gdegas, mpireduce_n,n,MPI_REAL8,MPI_SUM,  &
                             Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          gdegas(1:n) = mpireduce_n(1:n) 
#endif

!c  compress total rates for removal of aqueous components
!c  due to degassing in case of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(gdegas)
          end if

        end if                 !(gas_removal)

!c  total contributions due to exchange with gaseous phase

        do ic = 1,n
          gdiff(ic) = gfluxin(ic) - gfluxout(ic) - gstordiff(ic)      &
     &              - gdegas(ic)
          
          if (ng .gt. 0 .and. gas_advection) then
            gdiff(ic) = gdiff(ic) + gafluxin(ic) - gafluxout(ic)
          endif        
        end do

      end if                                             !(ng.gt.0)
 
!c  total source-sink term due to intra-aqueous kinetic reactions
!c  [moles/unit time]

      if (naq.gt.0.or.nr.gt.0.and..not.redox_equil) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_7)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, iaq, ic, ir, ivol, ix)                        &
    !$omp firstprivate(totor)                                         &
    !$omp reduction (+:ordiff)
    !$omp do schedule(static) 
#endif
        do ivol = 1,nngl
!#ifdef PETSC
!          if(node_idx_lg2l(ivol) < 0) then
!              cycle
!          end if
!#endif
            
#ifdef OPENMP
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif

!c  exclude first type boundary control volumes

          if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

            if (temp_field.or.heat_transport) then 
              call tcorr(tkel(ivol))
            end if

!c  recompute activity coefficients

            if (update_activity(tid).eq.'double_update') then
               if (ispitzer) then 
                     call pitzer (phase,gamma(1:nc,ivol),             &
                                  gamma(nc+1:nc+nx,ivol),             &
                                  cnew(1:nc,ivol),cx(1:nx,ivol),      &
                                  nc,nx,ilog)
               else
!c  --> for free species

                  do ic=1,nc
                     gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),  &
                                      sionnew(ivol),chargec(ic),      &
                                      dhac(ic),dhbc(ic),              &
                                      dhad(tid),dhbd(tid),            &
                                      adav,bdav,acth2omin,nc,         &
                                      nx,namec(ic),namec)
                  end do

!c  --> for secondary aqueous species

                  do ix=1,nx
                    gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
                                        sionnew(ivol),chargex(ix),    &
                                        dhax(ix),dhbx(ix),            &
                                        dhad(tid),dhbd(tid),          &
                                        adav,bdav,acth2omin,nc,       &
                                        nx,namex(ix),namec)
                  end do
                end if 
            end if

!c  overall oxidation-reduction rates for redox couples

            if (nr.gt.0) then

              do ir = 1,nr
                call rateredx(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),  &
     &                        gamma(nc+1,ivol),rateor(ir,tid),        &
     &                        totcnew(1,ivol),ir)
              end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to oxidation-reduction reactions

              call totredx(totor,idbg)

!c  scale total source-sink term due to oxidation-reduction reactions
!c  and sum up over control volumes
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
#endif
                do ic = 1,n
                  totor(ic) = conv3 * cvol(ivol) * bulkconc(totor(ic), &
                              sanew(ivol),pornew(ivol))
                  ordiff(ic) = ordiff(ic) - totor(ic)
                end do
#ifdef PETSC
              end if
#endif
           end if          !(nr.gt.0)

!c  reaction rates of intra-aqueous kinetic reactions

            if (naq.gt.0) then

              do iaq = 1,naq
                if (new_database) then
                  call rateint_new(rateaq(iaq,tid),totcnew(1,ivol),   &
                                   cnew(1,ivol),cx(1,ivol),           &
                                   gamma(1,ivol),gamma(nc+1,ivol),    &
                                   phi(1,ivol),iaq,                   &
                                   scalfac_aq_ivol(iaq,ivol))             
                else
                  call rateint(rateaq(iaq,tid),totcnew(1,ivol),       &
                               cnew(1,ivol),gamma(1,ivol),            &
                               phi(1,ivol),iaq,                       &
                               scalfac_aq_ivol(iaq,ivol))
                end if
              end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions

              call totint(totaq(:,tid),idbg)

!c  scale total source-sink term due to intra-aqueous kinetic
!c  reactions and sum up over control volumes
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
#endif
                do ic = 1,n
                  totaq(ic,tid) = conv3 * cvol(ivol) *                 &
                                  bulkconc(totaq(ic,tid), sanew(ivol), &
     &                            pornew(ivol))
                  ordiff(ic) = ordiff(ic) - totaq(ic,tid)
                end do
#ifdef PETSC
              end if
#endif

            end if         !(naq.gt.0)

          end if           !exclude first type boundary control volumes

        end do             !number of control volumes
#ifdef OPENMP        
      !$omp end do
      !$omp end parallel  
#endif

#ifdef PETSC
        call MPI_Allreduce(ordiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        ordiff(1:n) = mpireduce_n(1:n) 
#endif

      end if               !(nr.gt.0)

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_8)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivol)                                          
#endif      
      
!c  total source-sink term due to sorption reactions
!c  non-competitive sorption
!c  [moles/unit time]

      if (noncompetitive_sorption) then
#ifdef OPENMP
    !$omp do schedule(static) reduction (+:sbdiff)
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
!c  exclude first type boundary control volumes

          if (btypert(ivol).ne.'first') then
            
            do ic = 1,n
              sbdiff(ic) = sbdiff(ic) - conv3 * cvol(ivol)/delt       &
                         * (totanew(ic,ivol) -  totaold(ic,ivol))
            end do

          end if           !exclude first type boundary control volumes

        end do             !loop over control volumes
#ifdef OPENMP        
      !$omp end do
#endif  

      end if

!c  total source-sink term due to sorption reactions
!c  competitive sorption
!c  [moles/unit time]

      if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
        
        if (sorption_group.eq.'surface-complexation'.or.(nsb_surf.gt.0 &
            .and.sorption_group.eq.'surface-complex and ion-exchange')) then  
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:sbdiff)
#endif             
            do ivol = 1,nngl
#ifdef PETSC  
              if(node_idx_lg2l(ivol) < 0) then
                  cycle
              end if
#endif
!c  exclude first type boundary control volumes

              if (btypert(ivol).ne.'first') then
                do ic = 1,n
                    sbdiff(ic) = sbdiff(ic) - conv3 * cvol(ivol)/delt           &
                              * (sanew(ivol)*pornew(ivol)*totsnew_surf(ic,ivol) &
                              -  saold(ivol)*porold(ivol)*totsold_surf(ic,ivol))
                end do

              end if           !exclude first type boundary control volumes

            end do             !loop over control volumes 
#ifdef OPENMP
    !$omp end do
#endif     
        end if
            
        if (sorption_group.eq.'ion-exchange'.or.(nsb_ion.gt.0 &
            .and.sorption_group.eq.'surface-complex and ion-exchange')) then  
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:sbdiff)
#endif         
            do ivol = 1,nngl
#ifdef PETSC
              if(node_idx_lg2l(ivol) < 0) then
                  cycle
              end if
#endif
!c  exclude first type boundary control volumes

              if (btypert(ivol).ne.'first') then
                do ic = 1,n
                    sbdiff(ic) = sbdiff(ic) - conv3 * cvol(ivol)/delt        &
                               * (totsnew_ion(ic,ivol)-totsold_ion(ic,ivol))
                end do

              end if           !exclude first type boundary control volumes

            end do             !loop over control volumes 
#ifdef OPENMP
    !$omp end do
#endif
        end if  

      end if               !(nsb.gt.0)  

!c  total source-sink term due to dissolution-precipitation
!c  reactions [moles/unit time]
 
      if (nm.gt.0) then
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:dpdiff)
#endif   
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
!c  exclude first type boundary control volumes

          if (btypert(ivol).ne.'first') then

            do ic = 1,n
              dpdiff(ic) = dpdiff(ic)                                 &
     &                   - conv3 * cvol(ivol) * totmdp(ic,ivol)
            end do

          end if           !exclude first type boundary control volumes
 
        end do             !loop over control volumes
#ifdef OPENMP
    !$omp end do
#endif
      end if               !(nm.gt.0)
#ifdef OPENMP
    !$omp end parallel
#endif   

#ifdef PETSC
      call MPI_Allreduce(sbdiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      sbdiff(1:n) = mpireduce_n(1:n) 
      
      call MPI_Allreduce(dpdiff, mpireduce_n,n,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      dpdiff(1:n) = mpireduce_n(1:n)      
#endif

 
      do ic = 1,n

!c compute accumulative changes over time

        totcfluxin(ic) = totcfluxin(ic) + cfluxin(ic)*delt
        totcfluxout(ic) = totcfluxout(ic) + cfluxout(ic)*delt
        totcstordiff(ic) = totcstordiff(ic) + cstordiff(ic)*delt
        totordiff(ic) = totordiff(ic) + ordiff(ic)*delt
        totdpdiff(ic) = totdpdiff(ic) + dpdiff(ic)*delt
        totsbdiff(ic) = totsbdiff(ic) + sbdiff(ic)*delt

      if (ng.gt.0) then ! for lattice run time error thh 4/12/05
          totgdiff(ic) = totgdiff(ic) + gdiff(ic)*delt
          totgfluxin(ic) = totgfluxin(ic) + gfluxin(ic)*delt
          totgfluxout(ic) = totgfluxout(ic) + gfluxout(ic)*delt
          totgafluxin(ic) = totgafluxin(ic) + gafluxin(ic)*delt
          totgafluxout(ic) = totgafluxout(ic) + gafluxout(ic)*delt
          totgstordiff(ic) = totgstordiff(ic) + gstordiff(ic)*delt
          totgdegas(ic) = totgdegas(ic) + gdegas(ic)*delt
      else
          totgdiff(ic) = r0
          totgfluxin(ic) = r0
          totgfluxout(ic) = r0
          totgafluxin(ic) = r0
          totgafluxout(ic) = r0
          totgstordiff(ic) = r0
          totgdegas(ic) = r0
          gdiff(ic)= r0
          gfluxin(ic)= r0
          gfluxout(ic)= r0
          gstordiff(ic)= r0
          gdegas(ic)= r0
      end if


!c  write results
 
        imrt = imrt+1
      
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
        if (b_output_binary) then
          if (ng .gt. 0 .and. gas_advection) then
            nvarsimrt = 27
            realbuffer_gb(1:nvarsimrt) = (/time_io,cfluxin(ic),         &
                                      cfluxout(ic),cstordiff(ic),       &
                                      ordiff(ic),dpdiff(ic),gdiff(ic),  &
                                      gfluxin(ic),gfluxout(ic),         &
                                      gafluxin(ic),gafluxout(ic),       &
                                      gstordiff(ic),gdegas(ic),         &
                                      sbdiff(ic),totcfluxin(ic),        &
                                      totcfluxout(ic),totcstordiff(ic), &
                                      totordiff(ic),totdpdiff(ic),      &
                                      totgdiff(ic),totgfluxin(ic),      &
                                      totgfluxout(ic),totgafluxin(ic),  &
                                      totgafluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic)/)
          else
            nvarsimrt = 23
            realbuffer_gb(1:nvarsimrt) = (/time_io,cfluxin(ic),        &
                                      cfluxout(ic),cstordiff(ic),      &
                                      ordiff(ic),dpdiff(ic),gdiff(ic), &
                                      gfluxin(ic),gfluxout(ic),        &
                                      gstordiff(ic),gdegas(ic),        &
                                      sbdiff(ic),totcfluxin(ic),       &
                                      totcfluxout(ic),totcstordiff(ic),&
                                      totordiff(ic),totdpdiff(ic),     &
                                      totgdiff(ic),totgfluxin(ic),     &
                                      totgfluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic)/)

          end if

          call binary_write_data(imrt_mpi(imrt), 1,            &
                       (/mtime/),offset_imrt_ijk(imrt),.true.)
          call binary_write_data(imrt_mpi(imrt), nvarsimrt,    &
                       realbuffer_gb,offset_imrt(imrt),.true.) 

          offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

        else
          if (ng .gt. 0 .and. gas_advection) then
            write(imrt,'(27(1pe12.4))') time_io,cfluxin(ic),            &
                                      cfluxout(ic),cstordiff(ic),       &
                                      ordiff(ic),dpdiff(ic),gdiff(ic),  &
                                      gfluxin(ic),gfluxout(ic),         &
                                      gafluxin(ic),gafluxout(ic),       &
                                      gstordiff(ic),gdegas(ic),         &
                                      sbdiff(ic),totcfluxin(ic),        &
                                      totcfluxout(ic),totcstordiff(ic), &
                                      totordiff(ic),totdpdiff(ic),      &
                                      totgdiff(ic),totgfluxin(ic),      &
                                      totgfluxout(ic),totgafluxin(ic),  &
                                      totgafluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic)
         
          else
            write(imrt,'(23(1pe12.4))') time_io,cfluxin(ic),           &
                                      cfluxout(ic),cstordiff(ic),      &
                                      ordiff(ic),dpdiff(ic),gdiff(ic), &
                                      gfluxin(ic),gfluxout(ic),        &
                                      gstordiff(ic),gdegas(ic),        &
                                      sbdiff(ic),totcfluxin(ic),       &
                                      totcfluxout(ic),totcstordiff(ic),&
                                      totordiff(ic),totdpdiff(ic),     &
                                      totgdiff(ic),totgfluxin(ic),     &
                                      totgfluxout(ic),totgstordiff(ic),&
                                      totgdegas(ic),totsbdiff(ic)
          end if
         end if      
        end if
      
      end do

!c  absolute mass balance error [moles/time unit]
!c  relative mass balance error in [%] = [moles/moles in system] x 100
!c  accumulative mass balance error [moles]
!c  relative accumulative mass balance error in [%] = 
!c  [moles/moles in system] x 100
 
      do ic = 1,n
        absbalance = (cfluxin(ic) - cfluxout(ic)                      &
     &             - cstordiff(ic) + dpdiff(ic) + ordiff(ic)          &
     &             + gdiff(ic) + sbdiff(ic))*delt
        relbalance = dabs(absbalance)/tmass(ic)*r100
        cculabsbal(ic) = cculabsbal(ic) + absbalance
        cculrelbal(ic) = cculabsbal(ic)/tmass(ic)*r100
        imrt = imrt+1

        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        
        !Note: There is round-error in cstordiff in parallel version.
        !The different may be a little different in the following output. DSU
        
          if (b_output_binary) then
            nvarsimrt = 5
            realbuffer_gb(1:nvarsimrt) = (/time_io,absbalance,         &
                                          relbalance,cculabsbal(ic),   &
                                          cculrelbal(ic)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)       
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
          else
            write(imrt,'(5(1pe12.4,4x))') time_io,absbalance,          &
                                          relbalance,cculabsbal(ic),   &
                                          cculrelbal(ic)  
          end if
        
        end if
        
      end do
   
!c ----------------------------------------------------------------------
!c  compute mass balance for selected species in aqueous phase
!c  only if selected species are specified
!c ----------------------------------------------------------------------

      if (nmb.gt.0) then
    
        do imb = 1,nmb
          imrt = imrt + 1
        end do

      end if

!c ----------------------------------------------------------------------
!c  mass balance contributions - intra-aqueous kinetic reactions
!c ----------------------------------------------------------------------
  
      if (naq.gt.0) then

        call zero_r8 (rateaqtot,naq,1,1)

!c  reaction rates of intra-aqueous kinetic reactions
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_9)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol)                                          
#endif
        do iaq = 1,naq
          
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:rateaqtot)
#endif
          do ivol=1,nngl
!#ifdef PETSC 
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif

#ifdef OPENMP
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif  
          
!c  exclude first type boundary control volumes

            if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

              if (temp_field.or.heat_transport) then      
                call tcorr(tkel(ivol))
              end if

!c  recompute reactions rates

              if (new_database) then
                call rateint_new(rateaq(iaq,tid),totcnew(1,ivol),      &
                                 cnew(1,ivol),cx(1,ivol),              &
                                 gamma(1,ivol),gamma(nc+1,ivol),       &
                                 phi(1,ivol),iaq,                      &
                                 scalfac_aq_ivol(iaq,ivol))
              else
                call rateint(rateaq(iaq,tid),totcnew(1,ivol),          &
                             cnew(1,ivol),gamma(1,ivol),phi(1,ivol),   &
                             iaq,scalfac_aq_ivol(iaq,ivol))
              end if

!c  sum up total reaction rate
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
#endif
                rateaqtot(iaq) = rateaqtot(iaq)                        &
                               - conv3 * cvol(ivol)                    &
                               * bulkconc(rateaq(iaq,tid),sanew(ivol), &
                                        pornew(ivol))
#ifdef PETSC
              end if
#endif

            end if          !exclude first type boundary conditions    

          end do            !loop over control volumes
#ifdef OPENMP
    !$omp end do
#endif
        end do              !iaq = 1,naq        
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
        call MPI_Allreduce(rateaqtot, mpireduce_naq,naq,MPI_REAL8,     &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        rateaqtot(1:naq) = mpireduce_naq(1:naq) 
#endif

!c  sum up total accumulative contribution
        do iaq = 1,naq         
          contaqtot(iaq) = contaqtot(iaq) + rateaqtot(iaq)*delt 
        end do

        do iaq = 1,naq
          imrt = imrt+1 
          if(rank == 0 .and. b_enable_output .and.                     &
             .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
            if (b_output_binary) then
              nvarsimrt = 3
              realbuffer_gb(1:nvarsimrt) = (/time_io, rateaqtot(iaq),  &
                                         contaqtot(iaq)/)
              call binary_write_data(imrt_mpi(imrt), 1,        &
                           (/mtime/),offset_imrt_ijk(imrt),.true.)
              call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                           realbuffer_gb,offset_imrt(imrt),.true.) 

              offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
            else 
              write(imrt,'(3(1pe12.4))') time_io, rateaqtot(iaq),      &
                                         contaqtot(iaq)
            end if
          end if
        end do  

      end if                !(naq.gt.0) 

!c ----------------------------------------------------------------------
!c  compute mass balance for gaseous phase
!c  only if gases are specified
!c ----------------------------------------------------------------------

      if (ng.gt.0) then

!c  clear arrays

        call zero_r8(gfluxin,ng,1,1)
        call zero_r8(gfluxout,ng,1,1)
        call zero_r8(gafluxin,ng,1,1)
        call zero_r8(gafluxout,ng,1,1)
        call zero_r8(gfluxtbdy,ng,1,1)      !This variable is never used
        call zero_r8(gstordiff,ng,1,1)
        call zero_r8(gdegas,ng,1,1)

!c  flux contributions [moles/time unit]
!c  (for now: advective flow components are negligible)
!c  (inflow/outflow occurs only where first type boundary is specified)
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbrt > numofloops_thred_mbalrt_10)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, ibrt, istart, iend, ig, ivol, jvol,            &
    !$omp densgij, gij, gmfracij, gpij, relpgij,                      &
    !$omp totgflux, totgaflux, totgij, viscgij,                       &
    !$omp gpivol_ivol, gdens_ivol, gvisc_ivol,                        &
    !$omp gpivol_jvol, gdens_jvol, gvisc_jvol,                        &
    !$omp cinfrt, dgm_gflux_s, fmat, gflux_ig, ipvt,                  &
    !$omp ludecomp, neflux, neflux_s)                                 &
    !$omp firstprivate(bdyinfrt_dg, diff_eff)                                          
#endif

#ifdef OPENMP
    !$omp do schedule(static) reduction(+: gfluxtbdy,                &
    !$omp gfluxin, gfluxout, gafluxin, gafluxout)
#endif
        do ibrt = 1,nbrt                 !boundary control volumes

          ivol = jabrt(ibrt)             !pointer to control volume
          
!#ifdef PETSC
!          if(node_idx_lg2l(ivol) < 0) then
!              cycle
!          end if
!#endif

          call zero_r8(totgflux,n,1,1)   !zero flux vector
          call zero_r8(totgaflux,n,1,1)  !zero flux vector

!c  Dirichlet type boundary conditions

          if (btypert(ivol).eq.'first') then

            istart = iavs(ivol)+1
            iend = iavs(ivol+1)-1

!c          gas advection variables
            if (gas_advection) then                
              gpivol_ivol     = gasp_m(mdens_g(ivol),ivol)           ! pressure 
              gdens_ivol      = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! density
              gvisc_ivol      = gasv(gmfrac(:,ivol))                 ! viscosity
            else
              gpivol_ivol     = 0.0d0
              gdens_ivol      = 0.0d0
              gvisc_ivol      = 0.0d0
            end if

            do ig=1,ng                   !loop over gaseous species

              do i1 = istart,iend        !loop over local connections

                jvol = javs(i1)

                if (blanc_diff_g .or. gas_advection) then
                  gpivol_jvol  = gasp_m(mdens_g(jvol),jvol)          ! pressure
                  gdens_jvol   = gasd_m(mdens_g(jvol),gmfrac(:,jvol))! density
                  gvisc_jvol   = gasv(gmfrac(:,jvol))                ! viscosity
                else                    
                  gpivol_jvol  = 0.0d0
                  gdens_jvol   = 0.0d0
                  gvisc_jvol   = 0.0d0
                endif

!               calculate gas properties at interface according to weighting scheme
                call wgprop(totgnew(1,ivol),totgnew(1,jvol),totgij   ,&
     &                      gnew(1,ivol)   ,gnew(1,jvol)   ,gij      ,&
     &                      gmfrac(1,ivol) ,gmfrac(1,jvol) ,gmfracij ,&
     &                      relpermg(ivol) ,relpermg(jvol) ,relpgij  ,&
     &                      gdens_ivol     ,gdens_jvol     ,densgij  ,&
     &                      gvisc_ivol     ,gvisc_jvol     ,viscgij  ,&
     &                      gpivol_ivol    ,gpivol_jvol    ,gpij     ,&
     &                      zg(ivol)       ,zg(jvol)       ,          &
     &                      spt_weight     ,iupsg(i1)      ,          &
     &                      nc             ,ng             ,gacc     )
                
!c -------------- DGM module ----------------------------------------------------
!c               solve A F = B
!c               computes fluxes F of all gas components at current c.v. interphase
          
		        if ((ng.gt.0).and.dgm) then
                
		          call dgm_fluxdg_s (gnew(1,ivol)    ,gnew(1,jvol) ,   &
     &                               gij             ,gmfracij     ,   &
     &                               zg(ivol)        ,zg(jvol)     ,   &
     &                               densgij         ,gpij         ,   &
     &                               tkel(ivol)      ,permij(i1)   ,   &
     &                               relpgij         ,tauij(i1)    ,   &
     &                               gporij(i1)      ,deltaij(i1)  ,   &
     &                               rverysmall      ,                 &
     &                               ludecomp        ,                 &
     &                               fmat            ,ipvt         ,   &
     &                               dgm_gflux_s     ,neflux       )
                
!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else
                
                    gflux_ig =                                         &
     &                         + cinfrt_dg(i1)                         &
     &                         * deltaij(i1)                           &
     &                         * dgm_gflux_s(ig)                       &
     &                         / tauij(i1)                             &
     &                         / gporij(i1)
                
	              endif
                
!c --------------- Maxwell Stefan module ----------------------------------------

		        else if ((ng.gt.0).and.maxwell) then
                
	              call ms_fluxdg_s (gnew(1,ivol)     ,gnew(1,jvol)  ,  &
     &                              gij              ,gmfracij      ,  &
     &                              zg(ivol)         ,zg(jvol)      ,  &
     &                              densgij          ,gpij          ,  &
     &                              tkel(ivol)       ,tauij(i1)     ,  &
     &                              gporij(i1)       ,deltaij(i1)   ,  &
     &                              rverysmall       ,                 &
     &                              ludecomp         ,                 &
     &                              ipvt             ,equimolar     ,  &
     &                              dgm_gflux_s      ,neflux_s      )
                
!c                   check if there is gas phase
                  if (gporij(i1).lt.rverysmall) then
!c                  no gas phase                 
                  else
                
                    gflux_ig =                                         & 
     &                         + cinfrt_dg(i1)                         &
     &                         * deltaij(i1)                           &
     &                         * ms_gflux_s(ig)                        &
     &                         / tauij(i1)                             &
     &                         / gporij(i1)
                
	              endif
                
                else if ((.not.dgm).and.(.not.maxwell)) then
             
			      if (blanc_diff_g) then
!c                   diffusion coefficient calc'd with LeBlanc's law
                      cinfrt = cinfrt_dg(i1) * gasdiff2_s              &
     &                         (gmfrac(1,ivol),gmfrac(1,jvol),         &
     &                          gpivol_ivol   ,gpivol_jvol  ,          &
     &                          zg(ivol)      ,zg(jvol)      ,         &
     &                          gdens_ivol    ,gdens_jvol    ,         &
     &                          ig            ,                        &
     &                          iupsg(i1)     ,spt_weight    )
			      else 
!c                   unique constant diffusion
	                cinfrt = cinfrt_dg(i1)
			      endif
                  
	              gflux_ig = - fluxd(gnew(ig,ivol),                    &
     &                               gnew(ig,jvol),                    &
     &                               cinfrt)                            ! cinfrt_dg(i1) -> cinfrt
                  
	            endif
				
!c ------------> diffusion component
#ifdef PETSC
                if(node_idx_lg2l(ivol) > 0) then
#endif
                  totgflux(ig) = totgflux(ig) + conv3 * gflux_ig
#ifdef PETSC
                end if
#endif

!c ----------- advection component
                if (gas_advection) then
#ifdef PETSC
                  if(node_idx_lg2l(ivol) > 0) then
#endif
                    totgaflux(ig) = totgaflux(ig) + conv3 *           &
     &                          ( + fluxvg(gpivol_ivol ,gpivol_jvol , &
     &                                     zg(ivol)    ,zg(jvol)    , &
     &                                     gij(ig)     ,relpgij     , &
     &                                     densgij     ,viscgij     , &
     &                                     cinfvs_g(i1),              &
     &                                     gas_gravity ,gacc)       )
#ifdef PETSC
                  end if
#endif
                endif

              end do                     !loop over local connections

            end do

!c  mixed type boundary conditions

          elseif (btypert(ivol).eq.'mixed') then

!c  compute boundary influence coefficient
            so_av=dmin1(r1, sonew(ivol)) 
            diff_eff = diffcoff_g(diff_g, sgnew(ivol),pornew(ivol),   &
                              tortuosity_corr,assigned_tau,           &
                              tau(ivol)*tau_fac(ivol),                &
                              type_tortuosity,marchies(ivol),         &
                              gas_tortuosity,so_av)                
            bdyinfrt_dg = diff_eff * bdycrt_d(ibrt)
#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
#endif
              do ig = 1,ng
                totgflux(ig) = conv3 *                                 &
     &                       ( fluxd(gnew(ig,ivol),                    & !diffusive flux
     &                               gbrt(ig,ibrt),                    &
     &                               bdyinfrt_dg))             
              end do
#ifdef PETSC
            end if
#endif
          end if                         !boundary type

#ifdef PETSC
          if(node_idx_lg2l(ivol) > 0) then
#endif
            do ig = 1,ng
            
              if (totgflux(ig).gt.r0) then
                gfluxin(ig) = gfluxin(ig) + totgflux(ig)     !influx
              else
                gfluxout(ig) = gfluxout(ig) - totgflux(ig)   !outflux
              end if
            
              if (gas_advection) then
              
                if (totgaflux(ig).gt.r0) then
                    gafluxin(ig) = gafluxin(ig) + totgaflux(ig)     !influx
                else
                    gafluxout(ig) = gafluxout(ig) - totgaflux(ig)   !outflux
                end if
              
              endif
            
            end do                         !loop over components
#ifdef PETSC
          end if
#endif

        end do                           !boundary control volumes
#ifdef OPENMP
    !$omp end do
#endif       

!c  contributions due to changes in storage [moles/time unit]
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:gstordiff)
#endif
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          do ig = 1,ng
            gstordiff(ig) = gstordiff(ig)                             &
     &                    + conv3 * cvol(ivol)/delt                   &
     &                    * (bulkconc(gnew(ig,ivol),                  &
     &                                sgnew(ivol),                    &
     &                                pornew(ivol))                   &
     &                    -  bulkconc(gold(ig,ivol),                  &
     &                                sgold(ivol),                    &
     &                                porold(ivol)))
          end do
        end do
#ifdef OPENMP
    !$omp end do
#endif

!!c  total contributions due to exchange with water phase 
!!c  [moles/unit time]
!
!#ifdef OPENMP
!    !$omp single
!#endif
!        do ig = 1,ng
!          gdiff(ig) = gfluxin(ig) - gfluxout(ig) - gstordiff(ig)
!        end do
!#ifdef OPENMP
!    !$omp end single
!#endif

!c  mass loss due to degassing

        if (gas_removal) then
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:gdegas)
#endif
          do ivol = 1,nngl
!#ifdef PETSC
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif

!c  compute degassing rates

            if (density_dependence) then     
              call rategasd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),      &
                            sgnew(ivol))
            else      
              call rategas(gnew(1,ivol),tkel(ivol),hhead(ivol),        &
                           zg(ivol),sgnew(ivol))        
            end if

!c  scale total degassing rates to [mol L^-1 bulk s^-1]
#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
#endif
              do ig = 1,ng
                gdegas(ig) = gdegas(ig) + conv3 * cvol(ivol)           &
                           * bulkconc(rateg(ig,tid),sanew(ivol),       &
                                      pornew(ivol))                     
              end do 
#ifdef PETSC
            end if
#endif
                                                                      
          end do               !loop over control volumes  
#ifdef OPENMP
    !$omp end do
#endif          
                                                                      
        end if                 !(gas_removal)
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
      call MPI_Allreduce(gfluxtbdy,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxtbdy(1:ng) = mpireduce_ng(1:ng) 
      
      
      call MPI_Allreduce(gfluxin,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxin(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gfluxout,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gfluxout(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gafluxin,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gafluxin(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gafluxout,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gafluxout(1:ng) = mpireduce_ng(1:ng) 
      
      call MPI_Allreduce(gstordiff,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      gstordiff(1:ng) = mpireduce_ng(1:ng) 
      
      if (gas_removal) then
        call MPI_Allreduce(gdegas,mpireduce_ng,ng,MPI_REAL8,MPI_SUM,     &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gdegas(1:ng) = mpireduce_ng(1:ng) 
      end if
#endif


!c  total contributions due to exchange with water phase 
!c  [moles/unit time]
       do ig = 1,ng
         gdiff(ig) = gfluxin(ig) - gfluxout(ig) - gstordiff(ig)
       end do


!c  write results to output files [moles/unit time]
        do ig = 1,ng
          imrt = imrt+1
          if(rank == 0 .and. b_enable_output .and.                     &
             .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
            if (b_output_binary) then
              nvarsimrt = 9
              realbuffer_gb(1:nvarsimrt) = (/time_io,                  &
                                         gfluxin(ig),                  &
                                         gfluxout(ig),                 &
                                         gafluxin(ig),                 &
                                         gafluxout(ig),                &
                                         gfluxtbdy(ig),                &
                                         gstordiff(ig),                &
                                         gdiff(ig),                    &
                                         gdegas(ig)/)
              call binary_write_data(imrt_mpi(imrt), 1,        &
                           (/mtime/),offset_imrt_ijk(imrt),.true.)
              call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                           realbuffer_gb,offset_imrt(imrt),.true.) 

              offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
     
            else 
              write(imrt,'(9(1pe12.4))') time_io,                      &
                                         gfluxin(ig),                  &
                                         gfluxout(ig),                 &
                                         gafluxin(ig),                 &
                                         gafluxout(ig),                &
                                         gfluxtbdy(ig),                &
                                         gstordiff(ig),                &
                                         gdiff(ig),                    &
                                         gdegas(ig)
            end if  
          
          end if
        end do

        
        
        
      end if                                             !(ng.gt.0)

!c ----------------------------------------------------------------------
!c  compute mass balance for minerals
!c  only if minerals are specified
!c ----------------------------------------------------------------------
 
      if (nm.gt.0) then
 
!c  clear arrays

        call zero_r8(cstordiff,nm,1,1)
        call zero_r8(dpdiff,nm,1,1)
        call zero_r8(dpdiffp,maxndr*nm,1,1)
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_mbalrt_11)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ireac, istart, istop, ivol)                   &
    !$omp reduction(+: contmintot, cstordiff,                         &
    !$omp dpdiff, dpdiffp, totdpdiffp)                     
#endif

!c  change in storage and total dissolved/precipitated mass
!c  [moles/unit time]
 
        do im = 1,nm
#ifdef OPENMP
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl
              
!#ifdef PETSC
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif
              
#ifdef OPENMP
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif   

!c  exclude first type boundary control volumes

            if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

              if (temp_field.or.heat_transport) then
                call tcorr(tkel(ivol))
              end if

!c  compute average molar concentrations for organic mixture
!c  in solid phase
              call molconc(phiold(1,ivol))     

!c  recompute rates for output of mass balance contributions of 
!c  parallel reaction pathways

              if (new_database) then
!FG sept 2021 - get root density             
               if (root_uptake) then
                  rootdens=rld(ivol)
!                  write(*,*) 'mbalrt',rootdens, ivol
               endif
!--------------------------------------------------------------------------
                call ratemin_new(totcnew(1,ivol),cnew(1,ivol),        &
     &                           cx(1,ivol),gamma(1,ivol),            &
     &                           gamma(nc+1,ivol),ratemdp(im,ivol),   &
     &                           phi(1,ivol),phiold(im,ivol),         &
     &                           area(im,ivol),im)  
              else
                call ratemin(totcnew(1,ivol),cnew(1,ivol),cx(1,ivol), &
     &                       gamma(1,ivol),gamma(nc+1,ivol),          &
     &                       ratemdp(im,ivol),phi(im,ivol),           &
     &                       phiold(im,ivol),area(im,ivol),im)        
              end if

!c  modify computed rates in the same manner as done in the residual
!c  assembly
              call modrate(ratemdp(im,ivol),cmnew(im,ivol),delt,im)
              
!cdsu  Assign mineral rate for frozen water
              if(b_water_freezing .and. b_water_freezing_ratemin) then
                if (tempnew(ivol) < water_freezing_temper) then
                  ratemdp(im,ivol) = water_freezing_ratemin
                end if
              end if
    
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
#endif
                cstordiff(im) = cstordiff(im)                          & 
     &                        + conv3 * cvol(ivol)/delt                &
     &                        * (cmnew(im,ivol)-cmold(im,ivol))        
                dpdiff(im) = dpdiff(im) + conv3 * cvol(ivol)           & 
     &                     * ratemdp(im,ivol)

                istart = iamd(im)
                istop = iamd(im+1)-1
                
                do ireac = istart,istop
                  dpdiffp(ireac) = dpdiffp(ireac) + conv3 * cvol(ivol) &
     &                           * ratemp(ireac,tid) 
                end do
#ifdef PETSC
              end if
#endif

            end if       !exclude first type control volumes

          end do         !number of control volumes
#ifdef OPENMP
    !$omp end do
#endif
          contmintot(im) = contmintot(im) + dpdiff(im)*delt
          
          istart = iamd(im)
          istop = iamd(im+1)-1
          
          do ireac = istart,istop
            totdpdiffp(ireac) = totdpdiffp(ireac) + dpdiffp(ireac)*delt
          end do
         
        end do
#ifdef OPENMP
    !$omp end parallel
#endif  

#ifdef PETSC
        call MPI_Allreduce(contmintot, mpireduce_nm,nm,MPI_REAL8,      &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        contmintot_mpi(1:nm) = mpireduce_nm(1:nm) 
        
        call MPI_Allreduce(cstordiff, mpireduce_nm,nm,MPI_REAL8,       &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        cstordiff(1:nm) = mpireduce_nm(1:nm) 
        
        call MPI_Allreduce(dpdiff, mpireduce_nm,nm,MPI_REAL8,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        dpdiff(1:nm) = mpireduce_nm(1:nm) 
#endif

        do im = 1,nm

          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop
              
#ifdef PETSC
            call MPI_Allreduce(dpdiffp(ireac), mpireduce_gbl,1,MPI_REAL8,MPI_SUM,     &
                               Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            dpdiffp(ireac) = mpireduce_gbl 
            
            call MPI_Allreduce(totdpdiffp(ireac), mpireduce_gbl,1,MPI_REAL8,MPI_SUM,     &
                               Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            totdpdiffp_mpi(ireac) = mpireduce_gbl
#endif              
          end do
       
        end do        
        
!c  write results to output file
 
        do im = 1,nm

          imrt = imrt + 1
          istart = iamd(im)
          istop = iamd(im+1)-1

          if(rank == 0 .and. b_enable_output .and.                     &
             .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
              
            if (b_output_binary) then
              nvarsimrt = 2*(istop-istart+1)+4
#ifdef PETSC
              realbuffer_gb(1:nvarsimrt) = (/                          &
                   time_io,cstordiff(im),dpdiff(im),contmintot_mpi(im),&
                   (dpdiffp(ireac),totdpdiffp_mpi(ireac),              &
                   ireac=istart,istop)/)
#else
              realbuffer_gb(1:nvarsimrt) = (/                          &
                   time_io,cstordiff(im),dpdiff(im),contmintot(im),    &
                   (dpdiffp(ireac),totdpdiffp(ireac),                  &
                   ireac=istart,istop)/)
#endif
              call binary_write_data(imrt_mpi(imrt), 1,        &
                           (/mtime/),offset_imrt_ijk(imrt),.true.)
              call binary_write_data(imrt_mpi(imrt), nvarsimrt,&
                           realbuffer_gb,offset_imrt(imrt),.true.) 

              offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
  
            else
                
#ifdef PETSC
              write(imrt,'(20(1pe12.4))')                              &
                  time_io,cstordiff(im),dpdiff(im),contmintot_mpi(im), &
                  (dpdiffp(ireac),totdpdiffp_mpi(ireac),               &
                  ireac=istart,istop)
#else       
              write(imrt,'(20(1pe12.4))')                              &
                  time_io,cstordiff(im),dpdiff(im),contmintot(im),     &
                  (dpdiffp(ireac),totdpdiffp(ireac),                   &
                  ireac=istart,istop)
#endif      
            end if
          end if
        end do
 
      end if      !(nm.gt.0)
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------      
      deallocate(bdyinfrt_da_ic)
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi-------------------------------------------------------------------------- 
      return
      end
