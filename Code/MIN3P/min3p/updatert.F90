!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/updatert.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updatert
!c -------------------
!c
!c update free species concentrations and check for convergence
!c (reactive transport)
!c
!c written by:      Uli Mayer - May 11, 96
!c
!c last modified:   Tom Henderson - March 3, 2004
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           c(nc,nn)           = concentrations of free species      + -
!c                                - old time level [moles/l water] 
!c           cnew(nc,nn)        = concentrations of free species      + +
!c                                - new time level [moles/l water]
!c           restol_rt          = solver residual tolerance           + -
!c           rnorm              = residual 2-norm                     + - 
!c           srelfac_rt         = user specified underrelaxation      + -
!c                                factor
!c           tol_rt             = convergence tolerance               + -
!c                                (reactive transport)
!c           urt(nn*n)          = update towards solution-vector      + +
!c           urtlim_log         = maximum tolerated update            + -
!c                                in log cycles
!c
!c           integer*4:
!c           ----------
!c           ilog               = unit number, log file               + -
!c           idetail_rt         = information level                   + -
!c           iter_rt            = current newton iteration            + -
!c           itsolv             = actual number of solver iterations  + - 
!c           maxit_rt           = max. number of iterations           + -
!c                                (reactive transport)
!c           n                  = number of primary unknowns          + -
!c           nexvol_old_rt      = number of nonconvergent control     + +
!c                                volumes from last time step
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           not_converged      = .true.  -> continue Newton          + -
!c                                           iteration
!c           under_relax_rt     = .true.  -> underrelaxation          + -
!c           reduce_timestep    = .true.  -> restart with reduced     + -
!c                                           timestep
!c
!c
!c chem.f:   character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c
!c local:    real*8:
!c           -------
!c           enat               = e
!c           rnorm_max          = tolerance for maximum residual
!c           urtmax             = actual maximum update
!c           urtlim_ln          = maximum tolerated update 
!c                                in ln cycles
!c           r0                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (number of unknowns)
!c           ic                 = counter (components)
!c           icount             = counter (non-convergent components)
!c           ivol               = counter (number of control volumes)
!c           maxvol             = volume with maximum solution update
!c           nexvol             = number of volumes exceeding update
!c                                tolerance
!c
!c           logical:
!c           --------
!c           force_convergence  = .true.  -> enforce global 
!c                                           convergence
!c
!c           character:
!c           ----------
!c           name               = name of chemical species
!c
!c external: checksat  = check for supersaturated conditions during 
!c                       dissolution of organic compounds from organic
!c                       mixture
!c ----------------------------------------------------------------------

      subroutine updatert
 
      use parm
      use gen
      use chem
      
#ifdef OPENMP
      use omp_lib 
#endif 
 
      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif
      
#ifdef PETSC
      real*8 :: urtmax_gbl
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer :: nexvol_gbl, mpireduce_irank
      PetscErrorCode :: ierrcode
#endif
      
      integer :: i, i1, ic, icount, ivol, nexvol, maxvol
      
      real*8 :: urtmax, urtlim_ln, rnorm_max, urtlim_ln_temp

      integer :: tid, chunk

      character*72 name

      real*8, parameter :: r0 = 0.0d0, r10 = 1.0d1,                    &
              enat = 2.71828182845904509d0

      logical force_convergence, bflag_goto

      force_convergence = .false.
      reduce_timestep=.false. 

!c  update solution after new iteration, check for global convergence
!c  and reduce time step if necessary
  

!c old      urtlim_ln = urtlim_log*enat    !error in this conversion: THH 3/2/04

!c  ln(x) = log10(x) * ln(10)
      urtlim_ln = urtlim_log * dlog(r10)

!c     The norm value for Pardiso solver is ||ax*-b||=sqrt(sum((ax*-b)^2))
!c     different from WatSolv that use the norm in iternal iteration.
!c     For pardiso, a larger value of rnorm_max (bad residual) is acceptable. 
!c     DSU, 2013-09-20
!cff   rnorm_max = 1.d-5
      if (i_solver_type_react == 0) then
        rnorm_max = 1.0d-2
      else if (i_solver_type_react == 1) then
        rnorm_max = 1.0d2
      else if (i_solver_type_react == 2) then 
        rnorm_max = 1.0d30  
      end if

!c  reduce time step, if residual is NaN

!cintellinux *** replace isnan(rnorm) by rnorm_max ***
#ifdef STANDARD_FORTRAN
      !By definition, NAN is not equal to anything, even itself.
      if (rnorm /= rnorm .or. over_flow_rt) then
#else
      !isnan is not fortran standard, this is gnu extension.
      if (isnan(rnorm) .or. over_flow_rt) then
#endif
        if(rank == 0 .and. b_enable_output)  then  
          
          write(ilog,'(72a)') ('-',i=1,72)
          write(ilog,'(a)')               &
     &         'solver failed to converge'
          write(ilog,'(a)') 'Nan or over_flow obtained in updatert'
          write(ilog,'(a)') 'reducing time step'
          write(ilog,'(72a)') ('-',i=1,72)
          
          if (idetail_rt.gt.2) then       
              write(*,'(a)') 'reduce time step: Nan or over_flow obtained in rnorm'
              write(ilog,'(a)') 'reduce time step: Nan or over_flow obtained in rnorm'
          end if
        
        end if
        
        reduce_timestep = .true.
        return
      end if

!c  reduce time step, if maximum residual exceeds tolerance
!c  or maximum number of inner iterations is exceeded
!c
      
      !if (rnorm.gt.rnorm_max.or.itsolv.eq.msolvit_rt) then
      if (rnorm.gt.rnorm_max) then
        if(rank == 0 .and. b_enable_output)  then  
          
          if (idetail_rt.gt.0) then
            write(ilog,'(72a)') ('-',i=1,72)
            if (itsolv.eq.msolvit_rt) then
              write(ilog,'(a)')             &
     &       'maximum number of inner iterations exceeded'
            end if
            if (rnorm.gt.rnorm_max) then
              write(ilog,'(a)') 'maximum residual exceeds tolerance'
            end if
            write(ilog,'(a,1pd11.4)') 'maximum residual = ', rnorm
            write(ilog,'(a,i10)') 'solver iterations = ',itsolv
            write(ilog,'(a)') 'reducing time step'
            write(ilog,'(72a)') ('-',i=1,72)
          end if
          
          if (idetail_rt.gt.2) then
            write(*,'(a, 2(1x, e12.4), 2(1x, i4))')                     &
            'reduce time step: rnorm, rnorm_max, itsolv, msolvit_rt ',  &
            rnorm, rnorm_max, itsolv, msolvit_rt
          
            write(ilog,'(a, 2(1x, e12.4), 2(1x, i4))')                  &
            'reduce time step: rnorm, rnorm_max, itsolv, msolvit_rt ',  &
            rnorm, rnorm_max, itsolv, msolvit_rt
          end if
        
        end if
        
        reduce_timestep = .true.        
        return
      end if
      
    
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_react
      if(mod(nngl, numofthreads_matrix_react) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_react > 1) then
          if(mod(chunk, i_chunksize_factor_react) > 0) then
              chunk = chunk/i_chunksize_factor_react + 1
          else
              chunk = chunk/i_chunksize_factor_react
          end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_react == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif    

!dsu start of maximum log cycles control
1000  continue   
!c  check size of updates (relaxed/un-relaxed) to determine convergence
      i1 = 0
      urtmax = r0
      nexvol = 0
#ifdef OPENMP
      bflag_omp1 = .false.
      bflag_omp2 = .false.
      bflag_omp3 = .false.     
      maxval_omp = urtmax
#endif
      bflag_goto = .false.

!c  update solution
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, ic, icount, ivol, tid, urtlim_ln_temp)         &
    !$omp reduction(+:nexvol)
#endif

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif

      do ivol = 1,nngl             !loop over control volumes
!#ifdef PETSC 
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#endif
          
#ifdef OPENMP    
        tid = omp_get_thread_num()+1
#else        
        tid = 1
#endif

#ifdef OPENMP
        if (bflag_omp1(tid).or.bflag_omp2(tid).or.bflag_omp3(tid)) then
          cycle
        end if
#endif
          
        icount = 0

        do ic = 1,n              !loop over components

          i1 = (ivol-1)*n + ic
          

          
!c  use line search, if computed update too small or too large
!c  check update 
!c  resulting concentrations positive and user specified underrelaxation 
!c  -> scale update

          if (under_relax_rt) then
            urt(i1) = srelfac_rt*urt(i1)
          end if

!c  limit update to urtlim_log orders of magnitude

          if (urt(i1).gt.urtlim_ln) then
            urt(i1) = urtlim_ln
          elseif (urt(i1).lt.-urtlim_ln) then
            urt(i1) = -urtlim_ln
          end if

!c  update ln c = ln c + delta (ln c)

          cnew(ic,ivol) = dlog(cnew(ic,ivol)) + urt(i1)

!c  convert to concentrations

          cnew(ic,ivol) = enat**cnew(ic,ivol)
          
!cdsu add maximum log cycles control
          if(cnew(ic,ivol) < moleconcorr_min .or. cnew(ic,ivol) > moleconcorr_max) then 
            urtlim_ln_temp = urtlim_ln*0.5
            if(urtlim_ln_temp < 1.0d-8) then
              if (cnew(ic,ivol) < moleconcorr_min)  then
                write(*,'(a,2(1x,i6))') "reduce timestep: concentration is below correction range, ivol, ic", ivol, ic
                write(ilog,'(a,2(1x,i6))') "reduce timestep: concentration is below correction range, ivol, ic", ivol, ic
              else
                write(*,'(a,2(1x,i6))') "reduce timestep: concentration is above correction range, ivol, ic", ivol, ic
                write(ilog,'(a,2(1x,i6))') "reduce timestep: concentration is above correction range, ivol, ic", ivol, ic
              end if
#ifdef OPENMP
              bflag_omp1(tid) = .true.
#else
              not_converged = .true.
#endif
              if(iter_rt >= maxit_rt) then
#ifdef OPENMP
                bflag_omp2(tid) = .true.
#else
                reduce_timestep = .true. 
#ifndef MPI
                return
#endif
#endif
              end if

            else
#ifdef OPENMP
              bflag_omp3(tid) = .true.
#else
              bflag_goto = .true.
#endif  
            end if
          end if 

!c  determine maximum update in global system
!c  identify component and location
!c  For parallel version, the value of urtmax is different
!c  as the comparison order is not in sequential order.
#ifdef OPENMP
          if (dabs(urt(i1)).gt.dabs(maxval_omp(tid))) then
            maxval_omp(tid) = urt(i1)
            string_omp(tid) = namec(ic)
            maxvol_omp(tid) = ivol    
          end if
#else
          if (dabs(urt(i1)).gt.dabs(urtmax)) then
            urtmax = urt(i1)
            name = namec(ic)
            maxvol = ivol    
          end if
#endif

!c  check if convergence is obtained for all components at
!c  current control volume 

!c old     if (dabs(urt(i1)/enat).gt.tol_rt) then   !error in this calculation THH 3/2/04

          if (dabs(urt(i1)/dlog(r10)).gt.tol_rt) then
            icount = icount+1 
          end if

        end do                           !loop over components

!c  determine number of control volumes, which do not meet
!c  convergence criteria

        if (icount.gt.0) then
          nexvol = nexvol+1
        end if                 

      end do                             !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef OPENMP
      if (any(bflag_omp1,1) .eqv. .true.) then
        not_converged = .true.
        if (any(bflag_omp2,1) .eqv. .true.) then
          reduce_timestep = .true.  
        end if
      end if
#endif


#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(not_converged, b_mpi_process_flag,1,          &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      not_converged = b_mpi_process_flag
      
      b_mpi_process_flag = .false.
      call MPI_Allreduce(reduce_timestep, b_mpi_process_flag,1,        &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      reduce_timestep = b_mpi_process_flag
#endif

      if (reduce_timestep) then
        return
      end if
      
      

#ifdef OPENMP
      if (any(bflag_omp3,1) .eqv. .true.) then
        bflag_goto = .true.
      end if
#endif


#ifdef PETSC
      b_mpi_process_flag = .false.
      call MPI_Allreduce(bflag_goto, b_mpi_process_flag,1,             &
                    MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      bflag_goto = b_mpi_process_flag    
#endif

      if (bflag_goto) then        
        urtlim_ln = urtlim_ln*0.5    
        goto 1000
      end if

!dsu end of maximum log cycles control

!c  restart time step, if convergence failure occurred
#ifdef OPENMP
      i1 = maxloc(dabs(maxval_omp),1)
      urtmax = maxval_omp(i1) 
      name = string_omp(i1)
      maxvol = maxvol_omp(i1) 
#endif

#ifdef PETSC
      mpireduce_in(1) = dabs(urtmax)      !returns the reduced value
      mpireduce_in(2) = rank              !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(urtmax, 1, MPI_REAL8, mpireduce_irank,            &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
      
      call MPI_BCAST(maxvol, 1, MPI_INTEGER4, mpireduce_irank,         &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
      
      call MPI_BCAST(name, len(name), MPI_CHARACTER, mpireduce_irank,  &
                     Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      
      call MPI_Allreduce(nexvol, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvol = nexvol_gbl
#endif
      !c bug here, should treat this as converged, DSU 2017-05-29
      !if (dabs(urtmax).lt.1.0d-300) then        
      !  reduce_timestep = .true.
      !  if (idetail_rt.gt.2 .and. rank == 0 .and. b_enable_output) then        
      !      write(*,'(a, 1x, e12.4)') 'reduce time step: urtmax',     &
      !      urtmax
      !      write(ilog,'(a, 1x, e12.4)') 'reduce time step: urtmax',  &
      !      urtmax
      !  end if        
      !  return
      !end if

!c  report maximum update in log_10 cycles

      urtmax = urtmax/dlog(r10)

!c  determine, if global convergence is achieved
 
      if (dabs(urtmax).lt.tol_rt) then
        not_converged = .false.
      end if
      
      if(rank == 0 .and. b_enable_output) then
        if (idetail_rt.gt.2) then
          write(*,'(a, 2(1x, e12.4), 1x, l1)')                         &
              "abs(urtmax), tol_rt, not_converged ",                   &
              abs(urtmax), tol_rt, not_converged
        end if
      end if
      
!c  write convergence history to log file and screen
 
      if(rank == 0 .and. b_enable_output) then

      if (idetail_rt.gt.0) then

        if (iter_rt.eq.1 .or. idetail_rt.eq.2) then
          write(ilog,'(a)') ' Newton Iteration Convergence Summary: rt1'
          write(ilog,'(2a)')' Newton     maximum    for',             &
     &                   '           maximum    solver'                
          write(ilog,'(2a)')' iteration  update     component     ',  &
     &                   'residual   iterations maxvol nexvol'         
        end if
                                                                       
        write(ilog,'(i6,5x,1pd11.4,1x,a12,1pd11.4,i8,4x,2(i7))')      &
     &       iter_rt,urtmax,name,rnorm,itsolv,maxvol,nexvol
        
        !if(b_doublecheck_residual) then
        !    write(ilog,'(a36,e10.4)') "residual checked in reactran        ", rnorm_check
        !end if
                                                                       
        if (iter_rt.eq.1.and.idetail_rt.eq.2) then                     
          write(*,'(a)') ' Newton Iteration Convergence Summary: rt2'      
          write(*,'(2a)')' Newton     maximum    for',                &
     &                   '           maximum    solver'                
          write(*,'(2a)')' iteration  update     component     ',     &
     &                   'residual   iterations maxvol nexvol'         
        end if                                                         
        if (idetail_rt.eq.2) then                                      
          write(*,'(i6,5x,1pd11.4,1x,a12,1pd11.4,i8,4x,2(i7))')       &
     &          iter_rt,urtmax,name,rnorm,itsolv,maxvol,nexvol
        end if

      end if
      
      end if

!c  reduce timestep, if number of control volumes, which do 
!c  not meet the convergence criteria, is increasing

      if (force_convergence) then
        if (iter_rt.gt.1 .and. nexvol.gt.nexvol_old_rt) then
          
          if(rank == 0 .and. b_enable_output) then  
            
          if (idetail_rt.gt.0) then
            write(ilog,'(72a)') ('-',i=1,72)
            write(ilog,'(a)') 'solution not convergent'
            write(ilog,'(a)') 'reducing time step'
            write(ilog,'(72a)') ('-',i=1,72)
          end if
          
          if (idetail_rt.gt.2) then          
            write(*,'(a)')                                            &
            'reduce time step: force, nexvol gt nexvol_old'
            write(ilog,'(a)')                                         &
            'reduce time step: force, nexvol gt nexvol_old'
          end if
          
          end if
          
          reduce_timestep = .true.
          return
        end if
        nexvol_old_rt = nexvol
      end if

!c  reduce timestep, if maximum number of outer iterations exceeded

      if (iter_rt.eq.maxit_rt .and. not_converged) then
        
        if(rank == 0 .and. b_enable_output) then    
          
        if (idetail_rt.gt.0) then
          write(ilog,'(72a)') ('-',i=1,72)
          write(ilog,'(a)')       &
     &    'maximum number of outer iterations exceeded'
          write(ilog,'(a)') 'reducing time step'
          write(ilog,'(72a)') ('-',i=1,72)
        end if
        
        if (idetail_rt.gt.2) then        
          write(*,'(a, 1x, i4)')                                      &
          'reduce time step: max outer iterations exceed', iter_rt
          write(ilog,'(a, 1x, i4)')                                   &
          'reduce time step: max outer iterations exceed', iter_rt
        end if
        
        end if
        
        reduce_timestep = .true.
        return
      end if

!c  reduce timestep, if outer iteration converged, but inner iteration
!c  not converged to ensure proper solution of problem

      if (.not.not_converged .and.                                   &
          ((rnorm.gt.restol_rt .and. rmupdate.gt.deltol_rt .and.     &
            i_solver_type_react == 0) .or.                           &
          (iter_rt.eq.maxit_rt .and. i_solver_type_react == 2))) then
          
         if(rank == 0 .and. b_enable_output) then  
             
           if (idetail_rt.gt.0) then
             write(ilog,'(72a)') ('-',i=1,72)
             write(ilog,'(a)')                                       &
                   'convergence in outer iteration achieved'                    
             write(ilog,'(a)')                                       &
                   'inner iteration does not converge'
             write(ilog,'(a)') 'reducing time step'
             write(ilog,'(72a)') ('-',i=1,72)
           end if
       
           if (idetail_rt.gt.2) then
             write(*,'(2a, 3(1x, e12.4))') 'reduce time step: ',     &
              'inner iteration not converged, rnorm, restol, deltol',&
              rnorm, restol_rt, deltol_rt
             write(ilog,'(2a, 3(1x, e12.4))') 'reduce time step: ',  &
              'inner iteration not converged, rnorm, restol, deltol',&
              rnorm, restol_rt, deltol_rt
           end if
        
         end if
       
          reduce_timestep = .true.
        end if

!c  reduce time step, if supersaturated conditions exist for dissolution
!c  of organics from organic mixtures

!cff      if (nm.gt.0.and.(.not.not_converged)) then

!cff       call checksat

!cff      end if

        return
      end 
