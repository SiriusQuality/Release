!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/updtbcdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updtbcdd
!c -------------------
!c
!c update boundary conditions (density dependent variably saturated flow) 
!c
!c first type boundary conditions: 
!c -> define zone by delineating nodes located within zone
!c
!c second type boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c seepage face boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c modified from Uli Mayer template 
!c
!c written by:      Tom Henderson - October 20, 2002
!c
!c last modified:   Tom Henderson - February 11, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  * +
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           dimcv(3,nn)        = spatial dimensions of control       + -
!c                                volumes
!c           rwork(:,:)         = real*8 work array                   * *
!c           time_bcvs          = next read time for flow boundary    * +
!c                                conditions
!c           uvsold(nn)         = solution vector (old time level)    + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           sec_per_days       = conversion factor from SI input     + -
!c                                units for physico-chemical 
!c                                parameters internal time units
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           time_io            = current solution time (I/O units)   + -
!c           tfinal             = final solution time                 + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           ibcvs              = unit number, transient boundary     * +
!c                                             conditions, variably
!c                                             saturated flow
!c           icnv               = unit number, data conversion        + -
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        * +
!c                                control volumes
!c                                (variably saturated flow)
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions 
!c           hydraulic_head     = .true.  -> initial condition in     + -
!c                                           terms of hydraulic head
!c           pressure_head      = .true.  -> initial condition in     + -
!c                                           terms of pressure heada
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           zone_name          = name of zone                        * +
!c           section_header     = section header                      * +
!c
!c local:    real*8:
!c           -------
!c           areaf              = interfacial area
!c           dummy              = dummy variable
!c           tiny               = small increment
!c           xbmin              = min. x-coordinate of boundary
!c                                zone
!c           xbmax              = max. x-coordinate of boundary
!c                                zone
!c           ybmin              = min. y-coordinate of boundary
!c                                zone
!c           ybmax              = max. y-coordinate of boundary
!c                                zone
!c           zbmin              = min. z-coordinate of boundary
!c                                zone
!c           zbmax              = max. z-coordinate of boundary
!c                                zone
!c
!c           integer*4:
!c           ----------
!c           ibvs               = counter (boundary control volumes)
!c           ibz                = counter (zones)
!c           ierr               = 0 -> memory allocation successful
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c           nbz                = number of boundary zones
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit search 
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           xy_plane           = boundary zone parallel tp xy-plane
!c           xz_plane           = boundary zone parallel to xz-plane
!c           yz_plane           = boundary zone parallel to yz-plane
!c
!c           character:
!c           ----------
!c           btypezn            = boundary type of zone        
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine updtbcdd
 
      use parm
      use gen
      use dens
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none

      external checkerr, findstrg, findzone, readbloc, readzone

      real*8, parameter :: tiny = 1.d-5, tiny_time=1.0d-10, r0=0.0d0

      logical xy_plane,xz_plane,yz_plane,found,found_section,         &
     &        found_subsection                                         
      character*12 btypezn                                             
      character*72 subsection
      
      integer :: i, ibz, ibvs, ierr, ivol, l_string, nbz
      real*8 :: timebcvsloc, dummy, xbmin, xbmax, ybmin, ybmax,        &
                zbmin, zbmax, areaf

      xy_plane = .false. 
      xz_plane = .false.
      yz_plane = .false.

      areaf = r0
      l_string = 0
                                                                       
      if (time_io.gt.time_bcvs-tiny_time .or. b_restart_update_bcvs) then
          
        if(rank == 0 .and. b_enable_output)  then  
                                                                       
        write(*,*)                                                     
        write(*,*) 'update boundary conditions - ',                   &
     &             'density dependent variably saturated flow'         
        write(*,*) ('-',i=1,72)                                        
        write(*,*)
                                                                       
        write(ilog,*)
        write(ilog,'(2a)') 'update boundary conditions - ',           &
     &                     'density dependent variably saturated flow'
        write(ilog,'(72a/)')('-',i=1,72)
        write(ilog,*)
        
        end if

!c  read section header for boundary conditions of variably saturated
!c  flow simulation
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------       
       bcondvs=r0
       btypevs=' '
       if(update_ext_type_bcvs) then
          do 
           section_header = 'time for boundary condition' 
           call readbloc (ibcvs1,icnv,section_header,found_section,   &
     &                    .false.)
           if (found_section) then 
            read(icnv,*,err=999,end=999) timebcvsloc

            if (timebcvsloc==time_bcvs) then
              !cprovi  preliminary allocation of memory for boundary conditions
              read(icnv,*,err=999,end=999)
              exit 
            end if 
           else
             if (rank == 0) then  
               write(ilog,*) 'SIMULATION TERMINATED'
               write(ilog,*) 'error in input file'
               write(ilog,*) 'time for boundary condition' 
               write(ilog,*) 'time not found:',time_bcvs 
               close(ilog)
             end if
#ifdef PETSC
             call petsc_mpi_finalize
#endif
             stop 
           end if 
          end do 
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------          
       else
        section_header = 'boundary conditions - variably saturated flow'
        call readbloc (idat,icnv,section_header,found_section,.true.)
       end if
        
 
!c  define length of section header

        l_string = index(section_header,'  ')-1
        if (l_string.eq.-1.or.l_string.gt.72) then
           l_string=72
        end if



!c  read number of boundary zones

        read(icnv,*,err=999,end=999) nbz

!c  allocate array for reading new boundary conditions

        allocate (rwork(nbz,1), stat = ierr)
        rwork=r0 
        call checkerr(ierr,'rwork',ilog)

!c  assign new boundary conditions for variably-saturated flow
      
        backspace(ibcvs)
        read(ibcvs,*,err=998,end=998) dummy, (rwork(ibz,1),ibz=1,nbz)

!c  initialize counter for boundary control volumes
 
        ibvs =0
        ivol2bvs(:) = 0        
        
!c  read name of zone

        do ibz=1,nbz                !loop over number of zones

!c  find current zone in input file and write to temporary file

          subsection = 'number and name of zone'

          call findzone(subsection,icnv,found_subsection,ibz,zone_name)

          if (found_subsection) then

            call readzone(icnv,itmp,ilog,zone_name,found_subsection)

          end if

!c  define length of zone name

          l_zone_name = index(zone_name,'  ')-1
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
            l_zone_name = 72
          end if

!c  define type of boundary condition
      
          subsection = 'boundary type'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            read(itmp,*,err=999,end=999) btypezn

          end if

!c  read coordiantes defining boundary zone, 

          subsection = 'extent of zone'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            read(itmp,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,     &
     &                                   zbmin,zbmax

          end if

!c  define boundary face to be considered (only needed for calculation
!c  of boundary face area for second type boundary conditions) 

          if (btypezn.eq.'second') then
   
            found = .false.
            xy_plane = .false.
            xz_plane = .false.
            yz_plane = .false.

            if (dabs(zbmax-zbmin).lt.tiny) then     !xy_plane
              if ((dabs(xbmax-xbmin).lt.tiny).or.                     &
     &            (dabs(ybmax-ybmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "', section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                xy_plane = .true.
                found = .true.
              end if
            end if

            if (.not.found) then                     !xz_plane
              if (dabs(ybmax-ybmin).lt.tiny) then
                if ((dabs(xbmax-xbmin).lt.tiny).or.                   &
     &              (dabs(zbmax-zbmin).lt.tiny)) then
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                          &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                else
                  xz_plane = .true.
                  if (xy_plane) then 
                    if (rank == 0) then  
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'error in input file'
                      write(ilog,*) 'section "',                        &
     &                               section_header(:l_string),'"'
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                      write(ilog,*) 'unable to specify boundary face'
                      close(ilog)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if
                  found = .true.
                end if
              end if
            end if

            if (.not.found) then                     !yz_plane
              if (dabs(xbmax-xbmin).lt.tiny) then
                if ((dabs(ybmax-ybmin).lt.tiny).or.                    &
     &              (dabs(zbmax-zbmin).lt.tiny)) then
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                         &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "',zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                else
                  yz_plane = .true.
                  if (xy_plane.or.xz_plane) then 
                    if (rank == 0) then  
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'error in input file'
                      write(ilog,*) 'section "',                        &
     &                               section_header(:l_string),'"'
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                      write(ilog,*) 'unable to specify boundary face'
                      close(ilog)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                end if
                  found = .true.
                end if
              end if
            end if

!c  exit if boundary face was not found 

            if (.not.found) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "',                              &
     &                         section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

          end if                    !(btypezn.eq.'second')

!c  increment boundary coordinates

          xbmin = xbmin-tiny
          xbmax = xbmax+tiny
          ybmin = ybmin-tiny
          ybmax = ybmax+tiny
          zbmin = zbmin-tiny
          zbmax = zbmax+tiny

!c  store type of boundary condition and boundary condition
!c  for global system in compressed storage

          do ivol = 1,nngl

!c  check limits of boundary zone

            if ((xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)) then
              if ((yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)) then
                if ((zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) then

!c  assign boundary condition

                  ibvs = ibvs + 1
                  
                  if (ibvs.gt.nngl) then
                    if (rank == 0) then  
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'nbvs > nn ...'
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

!c  assign pointer and 
!c
                  iabvs(ibvs) = ivol
                  btypevs(ibvs) = btypezn
                  
                  ivol2bvs(ivol) = ibvs
                  
                  if (btypezn.eq.'initial') then
                      
                      btypevs(ibvs) = 'first'
                      bcondvs(ibvs) = uvsnew(ivol)                 
                  
!c  first type boundary condition - constant pressure head

                  elseif (btypezn.eq.'first') then

                    if (fluid_pressure) then
                      bcondvs(ibvs) = rwork(ibz,1)
                    elseif (pressure_head) then
                      bcondvs(ibvs) = rwork(ibz,1)*density(ivol)*gacc
                    elseif (fresh_head) then
                      bcondvs(ibvs) = (rwork(ibz,1) - zg(ivol)) *      &
     &                                 gacc * ref_dens
                    elseif (hydraulic_head) then
                      bcondvs(ibvs) = (rwork(ibz,1) - zg(ivol)) *      &
     &                                 gacc * density(ivol)
                    end if !fluid pressure

                    if (.not. b_restart_update_bcvs) then
                      uvsnew(ivol)  = rwork(ibz,1)
                    end if

!c  second type boundary condition - specified flux

                  elseif (btypezn.eq.'second') then

!c  calculate flux area

                    if (xy_plane) then
                      areaf = dimcv(1,ivol) * dimcv(2,ivol)
                    elseif (xz_plane) then
                      areaf = dimcv(1,ivol) * dimcv(3,ivol)
                    elseif (yz_plane) then
                      areaf = dimcv(2,ivol) * dimcv(3,ivol)
                    end if

!c  assign second type boundary condition and convert to internal 
!c  time units

                    bcondvs(ibvs) = areaf*rwork(ibz,1)*sec_per_days

                  elseif (btypezn.eq.'point') then

                    bcondvs(ibvs) = rwork(ibz,1)*sec_per_days

                  end if !(btypezn.eq.'first'.or.btypezn.eq.'second')
                end if   !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
              end if     !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
            end if       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
          end do         !loop over control volumes

        end do           !end loop over zones
        
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------        
       if (nbvs.ne.ibvs .and. b_enable_output) then
         write(*,*)'Warning, different number of assigned cells for ',&
     &             ' boundary  conditions'
         write(*,*)'Previous:',nbvs,'cells'
         write(*,*)'Now:',ibvs,'cells'
       end if 
       nbvs=ibvs
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!c  deallocate workarray for reading transient boundary conditions

        deallocate (rwork, stat = ierr)
        call checkerr(ierr,'rwork',ilog)

!c  assign next read time

        read(ibcvs,*,err=998,end=997) time_bcvs

        return

!c  assign next read time greater than final solution time, if no more
!c  read times left and return

997     time_bcvs = 1.1d0*tfinal/time_factor
        return

998     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

999     continue
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'"'
          write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop

      end if

    return

      end
