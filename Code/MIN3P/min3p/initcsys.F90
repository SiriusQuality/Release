!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initcsys.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcsys
!c -------------------
!c
!c define geochemical system
!c
!c written by:      Uli Mayer - May 12, 96
!c
!c last modified:   Tom Henderson - August 30, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed: -
!c
!c common: 
!c gen.f:    integer*4:
!c           ----------
!c           icnv               = unit number, data conversion        + -
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging file         + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           icdbs              = unit number, database for
!c                                             components
!c           igdbs              = unit number, database gases         + -
!c           imdbs              = unit number, database for minerals  + -
!c           ipsp               = unit number, list of possible       + -
!c                                             secondary aqueous 
!c                                             species, gases and 
!c                                             minerals
!c           isdbs              = unit number, database for sorbed    + -
!c                                             species 
!c           irdbs              = unit number, database for redox     + -
!c                                             couples
!c           ixdbs              = unit number, database for           + -
!c                                             aqueous complexes
!c           l_dbs_dir          = length of string for database       * +
!c                                directory
!c           n                  = number of primary unknowns          * +
!c
!c           logical:
!c           --------
!c           full_path          = .true.  -> path for database        * +
!c                                           specified in problem
!c                                           specific input file
!c
!c           character:
!c           ----------
!c           dbs_dir            = database directory                  * +
!c           section_header     = section header                      * +
!c
!c chem.f:   real*8:
!c           -------
!c           scalfac_aq(naq)    = scaling factors for intra-aqueous   * +
!c                                kinetic reactions
!c           tempc              = temperature [deg C]                 * +
!c           tempk              = temperature [deg K]                 * +
!c           tempcs             = standard temperature [deg C]        * +
!c           tempks             = standard temperature [deg K]        * +
!c           tconv              = temperature correction factor       + -
!c 
!c           integer*4:
!c           ---------- 
!c           iaic(nsites)       = pointer array for compressed        * +
!c                                storage of surface site data
!c           iais(nc)           = row pointer array for compressed    * +
!c                                storage of surface site data
!c           l_nameanc(nc)      = length of names of sorbed           * + 
!c                                components (non-competitive
!c                                sorption)
!c           l_nameaq(naq)      = length of names of intra-aqueous    * +
!c                                kinetic reactions
!c           l_namec(nc)        = length of component names           * +
!c           l_nameg(ng)        = length of names of gases            * +
!c           l_namem(nm)        = length of mineral names             * +
!c           l_namemx(nmx)      = length of names of excluded         * +
!c                                minerals
!c           l_namesb(nsb)      = length of names of sorbed species   * +
!c           l_namesb_ion(nsb_ion)      = length of names of sorbed   * +
!c                                        species of ion-exchange
!c           l_namesb_surf(nsb_surf)    = length of names of sorbed   * +
!c                                        species of surface-complex
!c           l_namer(nr)        = length of names of redox couples    * +
!c           l_namerp(nr)       = length of names of primary          * +
!c                                components of redox couples
!c           l_namers(nr)       = length of names of secondary        * +
!c                                components of redox couples
!c           l_namex(nx)        = length of names of secondary        * +
!c                                aqueous species
!c           nanc               = number of sorbed species            * +
!c                                non-competitive sorption
!c           naq                = number of intra-aqueous kinetic     * +
!c                                reactions
!c           nbio               = number of biomass components        * +
!c           nc                 = number of components including h2o  * +
!c           ng                 = number of gases                     * +
!c           nlinear            = number of linear sorption reactions * +
!c           nm                 = number of minerals                  * +
!c           nmx                = number of excluded minerals         * +
!c           nsb                = number of sorbed species            * +
!c           nsb_ion            = number of sorbed species            * +
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            * +
!c                                (surface-complex)
!c           nsites             = number of surface sites             * +
!c           nr                 = number of redox couples             * + 
!c           nx                 = number of secondary aqueous species * +
!c
!c           logical:
!c           --------
!c           compute_alkalinity = .true.  -> calculate alkalinity     * +
!c           linear_sorption    = .true.  -> components undergoing    * +
!c                                           linear sorption are 
!c                                           present
!c           new_database       = .true.  -> use new database format  * +
!c           noncompetitive_sorption = logical array for activation   * +  
!c                                     of noncompetitive sorption
!c                                     reactions
!c           ph_output          = .true.  -> output of pH             * +
!c           pe_output          = .true.  -> output of pe and Eh      * +
!c           search_database    = .true.  -> search database for      * +
!c                                           all secondary species
!c                                           possible and list in
!c                                           file prefix_o.psp
!c           temp_corr          = .true.  -> specify constant         * +
!c                                           temperature
!c                                .false. -> use standard
!c                                           temperature
!c           temp_field         = .true.  -> nodal temperatures       * +
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       * +
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           input_units        = 'mol/l'                             * +
!c                                'mmol/l'
!c                                'mg/l'
!c                                'g/l'
!c           isotherm_type(nc)  = definition of sorption isotherm     * +   
!c                                'none' = no sorption
!c                                'linear' = linear adsorption
!c                                'freundlich' = Freundlich isotherm
!c                                'langmuir' = Langmuir isotherm
!c           nameanc(nc)        = names of sorbed species             * +
!c                                (non-competitive sorption)
!c           nameaq(naq)        = names of intra-aqueous kinetic      * +
!c                                reactions
!c           namec(nc)          = component names                     * +
!c           nameg(ng)          = names of gases                      * +
!c           namem(nm)          - mineral names                       * +
!c           namemx(nm)         = names of excluded minerals          * +
!c           namesb(nsb)        = names of sorbed species             * +
!c           namesb_ion(nsb_ion)= names of sorbed species             * +
!c                                (ion-exchange)
!c           namesb_surf(nsb_surf)= names of sorbed species           * +
!c                                  (surface-complex)
!c           namer(nr)          = names of redox couples              * +
!c           namerp(nr)         = names of primary components of      * +
!c                                redox couples
!c           namers(nr)         = names of secondary components of    * +
!c                                redox couples
!c           namex(nx)          = names of secondary aqueous species  * +
!c           output_unit_sb     = output unit for surface species     * +
!c           output_unit_sb_ion = output unit for sorption            * +
!c                                reactions of ion-exchange
!c           output_unit_sb_surf= output unit for sorption            * +
!c                                reactions of surface-complex
!c           redox_master       = 'o2(aq)'                            * +
!c                                'h2(aq)'
!c                                'e-1'
!c           sorption_group     = 'ion-exchange'                      * +
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     * +
!c                                'gapon'
!c           sorption_type_ion  = 'gaines-thomas'                     * +
!c                                'gapon'
!c           sorption_type_surf = 'surface-complex'                   * +
!c                                'constant-capacitance'
!c
!c bbls.f      integer
!c          --------
!c           gas_pair(ng)       = component or species number for
!c                               gas pair for each gas
!c
!c              logical
!c          --------
!c           gas_bubbles        =.true. -> gas phase saturation is calculated      
!c                                    below the water table
!c             gas_species(ng,nx)    =.true.-> species ix has a common 
!c                                    component with gas ig 
!c
!c             character
!c          ---------
!c             pair_type(ng)        = type for each gas pair
!c                                  "component"
!c                                  'species"
!c
!c
!c local:    real*8:
!c           -------
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           ianc               = counter (non-competitive sorption)
!c           iaq                = counter (intra-aqueous kinetic 
!c                                         reactions)
!c           ic                 = counter (components)
!c           idummy             = integer dummy variable
!c           ig                 = counter (gases)
!c           ix                 = counter (secondary aqueous species)
!c           im                 = counter (minerals)
!c           imx                = counter (excluded minerals)
!c           isb                = counter (sorbed species)
!c           isites             = counter (surface sites)
!c           ilinear            = counter (linear sorption reactions)
!c           ir                 = counter (redox couples)
!c           l_string           = length of text string
!c           nna                = number of non-aqueous components
!c
!c           logical:
!c           --------
!c           found              = .true.  -> found component
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c           name               = name of component
!c           pair                = name of component paired with each gas
!c
!c external: findstrg  = find text string in file
!c           mem_nc    = allocate memory for one-dimensional arrays
!c                       of size n and nc
!c           mem_naq   = allocate memory for one-dimensional arrays
!c                       of size naq and related arrays
!c           mem_ng    = allocate memory for one-dimensional arrays
!c                       of size ng and related arrays
!c           mem_nm    = allocate memory for one-dimensional arrays
!c                       of size nm and related arrays
!c           mem_nmx   = allocate memory for one-dimensional arrays
!c                       of size nmx and related arrays
!c           mem_nr    = allocate memory for one-dimensional arrays
!c                       of size nr and related arrays
!c           mem_nsb   = allocate memory for one-dimensional arrays
!c                       of size nsb and related arrays
!c           mem_nx    = allocate memory for one-dimensional arrays
!c                       of size nx and related arrays
!c             mem_bbls  = allocate memory for one-dimensional arrays
!c                       for bubble problem, size = nc
!c           opndbfls  = open data base files
!c           sortcomp  = sort components and construct ordering vector
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readcomp  = read database for components and assign
!c                       to permanent storage
!c           readint   = read database for intra-aqueous kinetic
!c                       reactions and assign to permanent storage
!c           readsspc  = read database for secondary aqueous
!c                       species and assign to permanent storage
!c           readgses  = read database for gases and
!c                       assign to permanent storage
!c           readmin   = read database for minerals and assign
!c                       to permanent storage
!c           readminx  = read database for excluded minerals and 
!c                       assign to permanent storage
!c           readmin_new  = read database for minerals and assign
!c                       to permanent storage (new database format)
!c           readminx_new  = read database for excluded minerals and 
!c                       assign to permanent storage (new database
!c                       format
!c           readsorb  = read database for sorbed species and 
!c                       assign to permanent storage
!c           readredx  = read database for redox couples and assign
!c                       to permanent storage
!c           readredx_new  = read database for redox couples and 
!c                       assign to permanent storage (new database 
!c                       format)
!c             assnpair  = assigns pair_type and component/species
!c                          number to each gas pair
!c ----------------------------------------------------------------------
 
      subroutine initcsys
 
      use parm
      use gen
      use chem
      use bbls
      use file_utility, only : replacecharacter
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none

      external findstrg, mem_naq, mem_nc, mem_ng, mem_nm, mem_nmx,    &
               mem_nr, mem_nsb, mem_nx, mem_bbls,                     &
               assnpair, opndbfls, sortcomp, readint,                 &
               readbloc, readcomp, readsorb, readsspc, readgses,      &
               readmin, readmin_new, readminx, readminx_new,          &
               readredx, readredx_new

      logical found_section, found_subsection, found
      logical found_surface_complex, found_ion_exchange,               &
              multisite_ion_exchange
      character*72 subsection, name, string, pair, dummy

      real*8, parameter :: r1 = 1.0d0
      
      !local variables
!      integer :: l_string, l_string2, nna, ic, idummy, ir, ix, ig,     &
      integer :: l_string, l_string2, ic, idummy, ir, ix, ig,     &
                 ilinear, ianc, isb, nss_counter, jsb, itemp, isites,  &
                 im, iaq, ierr, idbs, imx, i1, nmp, im2, i, ipts, npts
      real*8 :: alpha
      
      !interface      
      !    subroutine mem_nsb (itype_in)
      !      integer, intent(in), optional :: itype_in
      !    end subroutine mem_nsb      
      !end interface

      search_database = .true.   !hardwired for now

!c  read database directory, number and names of chemical species 
!c  from input file and write to temporary storage 
   
      section_header = 'geochemical system'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  define defaults for geochemical system

      compute_alkalinity = .false.
      full_path = .false.
      dbs_dir = 'default'
      input_units = 'moles/l'
      redox_master = 'o2(aq)'
      naq = 0
      nx = 0
      nna = 0
      nm = 0
      nr = 0
      ng = 0
      nmx = 0
      nsites = 0
      nbio = 0
      
!c_bubbles - initailize gas_bubbles

      gas_bubbles = .false.

!c_trap - initailize trap_bubbles

      trap_bubbles = .false.

!c  read in parameters for geochemical system

      if (found_section) then

!c  database directory - old definition

        subsection = 'define database directory'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) dbs_dir
          !replace '\' with '/'
          call replacecharacter(dbs_dir,achar(92),achar(47))
        end if
!cprovi---------------------------------------------------
!cproci It was added by Sergio Andr�s Bea Jofr?
!cprovi               18/01/2009 
!cprovi---------------------------------------------------
        subsection = 'use pitzer model' 
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ispitzer=.true.
          subsection = 'use macinnes convention'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ismacinnes=.true.
          else
            ismacinnes=.false.
          end if
        else
          ispitzer=.false.
          ismacinnes=.false.  
        end if
!cprovi---------------------------------------------------
!c  database directory - new definition

        subsection = 'database directory'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          full_path = .true. 
          read(itmp,*,err=999,end=999) dbs_dir
          !replace '\' with '/'
          call replacecharacter(dbs_dir,achar(92),achar(47))
        end if

!c  define database format

        subsection = 'use new database format'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          new_database = .true.
        else
          new_database = .false.
        end if

!c       settings for alkalinity calculations

        subsection = 'compute alkalinity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          compute_alkalinity = .true.
        end if
        
!c  read setting of exponent n for reaction rate law
        subsection = 'consider exponent n for reaction rate law'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
            b_ratelaw_exponent_n = .true.
            if (rank == 0 .and. b_enable_output) then
              write (ilog, '(a)') 'consider exponent n for reaction rate law: true'
            end if
        else
            b_ratelaw_exponent_n = .false.
            if (rank == 0 .and. b_enable_output) then
              write (ilog, '(a)') 'consider exponent n for reaction rate law: false'
            end if
        end if

!c  input units

        subsection = 'define input units'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) input_units
        end if

!c  set default parameters for temperature
        
        tempc = tempcs
        tempk = tempks
        temp_corr = .false.
        temp_field = .false.
        sorption_group = 'undefined'

!c  temperature

        subsection = 'define temperature'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) tempc
          tempk = tempc + tconv
          temp_corr = .true.
        end if

!c  temperature field 
 
        subsection = 'define temperature field'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          temp_corr = .true.
          temp_field = .true.
        end if

!c  redox master variable

        subsection = 'define redox master variable'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) redox_master
        end if

!c  define length of string for database directory

        l_dbs_dir=index(dbs_dir,' ')-1

!c  open database files

        call opndbfls(redox_master,search_database)

!c  ---------------------------------------------------------------------
!c  initialize chemical system for primary unknowns
!c  read number of components excluding h2o

        subsection = 'components'

        call findstrg(subsection,itmp,found_subsection)

        if (.not.found_subsection) then

          l_string = index(subsection,'  ')-1
          if (l_string.eq.-1.or.l_string.gt.72) then
             l_string=72
          end if
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'subsection "',subsection(:l_string),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        elseif (found_subsection) then

          read(itmp,*,err=999,end=999) n

        end if            !(subsection)
        
!c  read number of biomass components

        subsection = 'biomass components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) nbio

        end if               !(subsection)
        

!c  read number of non-aqueous components

        subsection = 'non-aqueous components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) nna

        end if               !(subsection)

       
!c  read number of surface complexation sites 
!c  (alternative for non-aqueous components)

        subsection = 'surface complexation sites'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) nna

        end if               !(subsection)

!c  number of components including biomass and surface compelxation sites

        n = n+nbio+nna


!c  number of components including h2o

        nc=n+1
 
!c  allocate memory for one-dimensional arrays of size n and nc

        call mem_nc

!c  include h2o as component 

        namec(nc) = 'h2o'

!c  set defaults for component types

        do ic = 1,nc
          component_type(ic) = 'aqueous'
        end do

!c  read aqueous component names

        subsection = 'components'

        call findstrg(subsection,itmp,found_subsection)

        read(itmp,*,err=999,end=999) idummy
        idummy = idummy   !avoid error messages

        do ic=1,n-nbio-nna
          read(itmp,*,err=999,end=999) namec(ic)
        end do

!c  read biomass component names

        subsection = 'biomass components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          
          read(itmp,*,err=999,end=999) idummy
          idummy = idummy   !avoid error messages

          do ic=n-nbio-nna+1,n-nna
            read(itmp,*,err=999,end=999) namec(ic)
            component_type(ic) = 'biomass'
          end do
          
        end if
        
!c  read names of non-aqueous components and define number of 
!c  surface sites

        subsection = 'non-aqueous components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) idummy

          do ic=n-nna+1,n

            read(itmp,*,err=999,end=999) namec(ic), component_type(ic)

            if (component_type(ic).eq.'surface') then
              nsites = nsites+1
            end if

          end do

        end if
!c  read names of surface complexation sites and define number of 
!c  surface sites
!c  (alternative for non-aqueous components)

        subsection = 'surface complexation sites'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) idummy

          do ic=n-nna+1,n

            read(itmp,*,err=999,end=999) namec(ic), component_type(ic)
 
            if (component_type(ic).eq.'surface') then
              nsites = nsites+1
            end if

          end do

        end if
        
!c ----------------------------------------------------------------------
!c  read number of redox couples
  
        subsection = 'redox couples'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) nr

!c  allocate memory for one-dimensional arrays of size nr and
!c  related arrays

          call mem_nr

!c  read names of primary and secondary components of redox couple
   
          do ir=1,nr
            read(itmp,*,err=999,end=999) namerp(ir), namers(ir)
          end do

!c  define length of primary and secondary components of redox couples

          do ir = 1,nr
            l_namerp(ir) = index(namerp(ir),' ')-1
            if (l_namerp(ir).eq.-1.or.l_namerp(ir).gt.72) then
              l_namerp(ir) = 72
            end if
            l_namers(ir) = index(namers(ir),' ')-1
            if (l_namers(ir).eq.-1.or.l_namers(ir).gt.72) then
              l_namers(ir) = 72
            end if
          end do

!c  assign name to redox couple and define length of name

          do ir = 1,nr
            namer(ir) = namerp(ir)(:l_namerp(ir))//'/'//  &
     &                  namers(ir)(:l_namers(ir))
            l_namer(ir) = l_namerp(ir)+l_namers(ir)+1
          end do

        end if                !(subsection)

!c  sort components in consideration of oxidation-reduction reactions
!c  amd construct ordering vector

        call sortcomp(idbg,ilog)

!c  define length of component names

        do ic = 1,nc
          l_namec(ic) = index(namec(ic),' ')-1
          if (l_namec(ic).eq.-1.or.l_namec(ic).gt.72) then
            l_namec(ic) = 72
          end if
        end do

!c ----------------------------------------------------------------------
!c  read number of secondary aqueous species

        subsection = 'secondary aqueous species'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          read(itmp,*,err=999,end=999) nx

        end if 

!c  allocate memory for one-dimensional arrays of size nx and related
!c  arrays

        call mem_nx

        if (found_subsection) then

!c  read names of aqueous complexes

          do ix=1,nx
            read(itmp,*,err=999,end=999) namex(ix)
          end do

!c  define length of names of secondary aqueous species

          do ix = 1,nx
            l_namex(ix) = index(namex(ix),' ')-1
            if (l_namex(ix).eq.-1.or.l_namex(ix).gt.72) then
              l_namex(ix) = 72
            end if
          end do

        end if                         !(found_subsection)
        
!c_bubbles Determine if bubble formation is required

        subsection = 'bubble formation'
        
        call findstrg(subsection,itmp,found_subsection)
        
        if (found_subsection) then
          gas_bubbles = .true.
        end if

!c_trap Determine if bubble entrapment is required

        subsection = 'trap bubbles'
        
        call findstrg(subsection,itmp,found_subsection)
        
        if (found_subsection) then
          trap_bubbles = .true.
        end if

!c ----------------------------------------------------------------------
!c  read number of gaseous species

        subsection = 'gases'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          read(itmp,*,err=999,end=999) ng

!c  allocate memory for one-dimensional arrays of size ng and related
!c  arrays

          call mem_ng

!c_bubbles If gas_bubbles is true then read gas names and
!c_bubbles pairs and call mem_bbls
        
          if (gas_bubbles) then

!c_bubbles allocate memory for one-dimensional arrays for bubble 
!c_bubbles problem
            call mem_bbls
            gas_species = .false.
            update_component = .false.

            do ig=1,ng

!c_bubbles read gas names and gas pair

                read(itmp,*,err=999,end=999) nameg(ig), pair

!c_bubbles Look for 'pair' in components then species

                call assnpair(pair, ig)
            
            end do
!c  If gas_bubbles is false then just read names of gaseous species
          else 
            do ig=1,ng
                read(itmp,*,err=999,end=999) nameg(ig)
            end do
          end if

!c  define length of names of gases

          do ig = 1,ng
            l_nameg(ig) = index(nameg(ig),' ')-1
            if (l_nameg(ig).eq.-1.or.l_nameg(ig).gt.72) then
              l_nameg(ig) = 72
            end if
          end do

        else

          call mem_ng

        end if             !(found_subsection)

!c ----------------------------------------------------------------------
!c  read number of components undergoing linear sorption

        subsection = 'linear sorption'

      noncompetitive_sorption = .false.
      linear_sorption = .false.

!c  initialize logical array for non-competitive sorption

      do ic = 1,nc
        isotherm_type(ic) = 'none'
      end do
    
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

        noncompetitive_sorption = .true.
        linear_sorption = .true.

!c  allocate memory for non-competitive sorption reactions

          call mem_nsb

!c  number of components undergoing linear sorption
      
          read(itmp,*,err=999,end=999) nlinear

!c  read names of components undergoing linear sorption and update 
!c  isotherm array

          do ilinear=1,nlinear
            
          found = .false.
          read(itmp,*,err=999,end=999) name
                    
          do ic = 1,nc
            if (name.eq.namec(ic)) then
              isotherm_type(ic) = 'linear'
                found = .true.
            end if
          end do

!c  terminate simulation, if specified component not part
!c  of current dataset

            l_string = index(subsection,'  ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
              l_string=72
            end if
          if (.not.found) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'subsection "',subsection(:l_string),'"'
                write(ilog,*) 'erroneous component definition'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
          end if

        end do

      end if

!c  define number and assign names for sorbed components 
!c  (non-competitive sorption)

        if (noncompetitive_sorption) then      
          ianc = 0
        do ic = 1,nc
          if (isotherm_type(ic).ne.'none') then
            ianc = ianc+1
            nameanc(ianc) = namec(ic)
            l_nameanc(ianc) = l_namec(ic)
          end if
        end do
        nanc = ianc
      end if

!c ----------------------------------------------------------------------
!c  read number of sorbed species

        nsb_surf = 0
        nsb_ion = 0

        subsection = 'sorbed species'        

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          read(itmp,*,err=999,end=999) nsb_ion
          
          nsb_surf = nsb_ion

!c  allocate memory for one-dimensional arrays of size nsb and related
!c  arrays

          call mem_nsb

!c  read names of sorbed species

          do isb=1,nsb_ion
            read(itmp,*,err=999,end=999) namesb_ion(isb)
          end do
          namesb_surf(1:nsb_surf) = namesb_ion(1:nsb_ion)

!c  define length of names of sorbed species

          do isb = 1,nsb_ion
            l_namesb_ion(isb) = index(namesb_ion(isb),' ')-1
            if (l_namesb_ion(isb).eq.-1.or.l_namesb_ion(isb).gt.72) then
              l_namesb_ion(isb) = 72
            end if
          end do
          
          l_namesb_surf(1:nsb_surf) = l_namesb_ion(1:nsb_ion)

!cmx  Check sorbed species input file: no sorbed species then no sorbed sites
          if (nsb_ion .eq. 0) then
              if (nsites_ion > 1) then
                  if (rank == 0) then
                    write(ilog,*) 'error reading input file'
                    write(ilog,*) 'subsection "',subsection(:l_string), '" missing or with error'
                  end if
                  goto 999
              end if
              nsites_ion = 0
          end if
                    
!cmx  Find the number of sorbed species (nss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                  end if
              end do
              nss_onIsite_ion(isb) = nss_counter
          end do
 
!cmx  Find the index of sorbed species (ss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                      idx_ss2isite_ion(isb,nss_counter)=jsb
                  end if
              end do
          end do

        end if
        
        
!c ----------------------------------------------------------------------
!c  read number of sorbed species of surface-complex and ion-exchange

        found_surface_complex = .false.
        found_ion_exchange = .false.
        multisite_ion_exchange = .false.

        subsection = 'sorbed species of surface-complex'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            
          found_surface_complex = .true.
      
          read(itmp,*,err=999,end=999) nsb_surf
          
        end if
        
        subsection = 'sorbed species of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            
          found_ion_exchange = .true.
      
          read(itmp,*,err=999,end=999) nsb_ion
          
        end if 

!c  read number of surface sites of ion-exchange   !CMX
        subsection = 'surface sites of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            
          found_ion_exchange = .true.
      
          read(itmp,*,err=999,end=999) nsites_ion

         if ((nsb_ion < 1 .and. nsites_ion > 1) .or. nsites_ion < 1)  then
          
              l_string = index(subsection,' ')-1
              if (l_string.eq.-1.or.l_string.gt.72) then
              l_string=72
              end if
              
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'subsection "',subsection(:l_string), '" missing or with error'
                write(ilog,*) 'sorbed species for ion exchange not specified'
                write(ilog,*) 'surface sites for ion exchange not less than 1'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop          

         end if

        end if

!c ----------------------------------------------------------------------
!c  read number of sorbed species of surface-complex and ion-exchange
        if (found_surface_complex .or. found_ion_exchange) then
            
!c  allocate memory for one-dimensional arrays of size nsb and related
!c  arrays
          call mem_nsb

!c  read names of sorbed species of surface-complex

          subsection = 'sorbed species of surface-complex'
          
          call findstrg(subsection,itmp,found_subsection)
          
          if (found_subsection) then
          
            read(itmp,*,err=999,end=999) nsb_surf
            
            do isb=1,nsb_surf
              read(itmp,*,err=999,end=999) namesb_surf(isb)
            end do

!c  define length of names of sorbed species of surface-complex

            do isb = 1,nsb_surf
              l_namesb_surf(isb) = index(namesb_surf(isb),' ')-1
              if (l_namesb_surf(isb).eq.-1.or.l_namesb_surf(isb).gt.72) then
                l_namesb_surf(isb) = 72
              end if
            end do

          end if

!c  read names of sorbed species of ion-exchange

        subsection = 'sorbed species of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then            
     
          read(itmp,*,err=999,end=999) nsb_ion
          
!c  read names of sorbed species of ion-exchange

          do isb=1,nsb_ion
            read(itmp,*,err=999,end=999) namesb_ion(isb)
          end do

!c  define length of names of sorbed species of ion-exchange

          do isb = 1,nsb_ion
            l_namesb_ion(isb) = index(namesb_ion(isb),' ')-1
            if (l_namesb_ion(isb).eq.-1.or.l_namesb_ion(isb).gt.72) then
              l_namesb_ion(isb) = 72
            end if
          end do
          
        end if


!c  read names of sorbed species of ion-exchange

        subsection = 'surface sites of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then     
            read(itmp,*,err=999,end=999) nsites_ion
     
            itemp = 0
         
            if (nsites_ion .gt. 1) then
                  multisite_ion_exchange = .true.
                do isb=1,nsites_ion
                  read(itmp,*,err=999,end=999) namesb_sites_ion(isb)
                 !!! if (TRIM(namesb_sites_ion(isb))='-PS')
                  l_string = index(namesb_sites_ion(isb),' ')-1
                  if (l_string.eq.-1.or.l_string.gt.72) then
                  l_string=72
                  itemp = itemp + 1
                  end if
                end do
            
                l_string = index(namesb_sites_ion(nsites_ion),'sorbed species of ion-exchange')-1
            
                if (itemp > 0 .or. l_string >= 0) then
                  if (rank == 0) then 
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error reading input file'
                    write(ilog,*) 'subsection "',subsection(:), '" missing or with error'
                    write(ilog,*) 'sorbed species for ion exchange not specified'
                    write(ilog,*) 'surface sites for ion exchange not less than 1'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if

                !c  define length of names of surface sites of ion-exchange

              do isb = 1,nsites_ion
                l_namesb_nsites_ion(isb) = index(namesb_sites_ion(isb),' ')-1
                if (l_namesb_nsites_ion(isb).eq.-1.or.l_namesb_nsites_ion(isb).gt.72) then
                  l_namesb_nsites_ion(isb) = 72
                end if
              end do
          
            end if    
        end if
      end if
        
!c  Find the site index of each sorbed species for multisite ionic excahnge 
!c  and store them in idx_nsites_ion(nsites_ion).
!c  It is assumed that the name of sites contains '-' and '('. The site name in 
!c  the name of the sorbed species is located between '-' and '(' from the back.
!cmx  Example 'cs-FES(na)' is associated with site '-FES'.
      if (nsb_ion >0) then
        if (multisite_ion_exchange) then
          do isb = 1,nsb_ion
              l_string = index(namesb_ion(isb),'-', BACK=.true.)
              l_string2 = index(namesb_ion(isb),'(', BACK=.true.)-1
              string = namesb_ion(isb)(l_string:l_string2)
              
              itemp = 0
              do jsb = 1,nsites_ion
                  l_string = index(string,' ')
                  l_string2 = index(namesb_sites_ion(jsb),' ')
                  
                  if (l_string .eq. l_string2) then
                      l_string = index(namesb_sites_ion(jsb), string)-1
                      if (l_string .eq. 0) then
                        idx_nsites_ion(isb) = jsb
                        itemp = itemp +1
                      end if
                  end if
              end do
              
              if (itemp .eq. 0 .or. itemp>2) then
                if (rank == 0) then  
                  write(ilog,*) 
                  write(ilog,*) 'Error reading site index from sorbed species in'
                  write(ilog,*) 'subsection ''sorbed species of ion-exchange'', missing or with error'
                  write(ilog,*) 'check the names of surface sites and/or sorbed species!'
                  write(ilog,*) 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              end if
              
          end do
        end if
 
!cmx  Find the number of sorbed species (nss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                  end if
              end do
              nss_onIsite_ion(isb) = nss_counter
          end do
          
!cmx  Find the index of sorbed species (ss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                      idx_ss2isite_ion(isb,nss_counter)=jsb
                  end if
              end do
          end do
        
        end if      !multisite_ion_exchange
        
            
 
!c  optional definition of sorption convention
            
      if (nsb_ion > 0 .or. nsb_surf > 0) then
     
         subsection = 'use concentrations in cation-exchange'

         call findstrg(subsection,itmp,found_subsection)

         if (found_subsection) then

             isactcexch=.false. 

         else

             isactcexch=.true. 

         end if             !(found_subsection) 

         subsection = 'define sorption type'

         call findstrg(subsection,itmp,found_subsection)

         if (found_subsection) then

             read(itmp,*,err=999,end=999) sorption_type

         else

             sorption_type = 'gaines-thomas'

         end if             !(found_subsection)
         
         subsection = 'define sorption type of surface-complex'

         call findstrg(subsection,itmp,found_subsection)

         if (found_subsection) then

             read(itmp,*,err=999,end=999) sorption_type_surf

         else

             sorption_type_surf = 'surface-complex'

         end if             !(found_subsection)
         
         
   ! User specified unit for the output of the SCM sorbed species concentration
         
         if (sorption_type_surf .eq. 'surface-complex') then
             subsection = 'specify output unit for SCM sorbed species concentration'
             call findstrg(subsection,itmp,found_subsection)

             if (found_subsection) then

                 read(itmp,*,err=999,end=999) output_unit_sb_surf
                                  
                 if ((trim(output_unit_sb_surf) .ne. 'mol/L H2O') .and. (trim(output_unit_sb_surf) .ne. 'mol/L bulk')) then
                     l_string = index(subsection,'  ')-1
                   if (rank == 0) then  
                     write(ilog,*) 'SIMULATION TERMINATED'
                     write(ilog,*) 'error reading input file'
                     write(ilog,*) 'subsection "',subsection(:l_string), '"'
                     write(ilog,*) 'The specified SCM sepcies unit: ''', trim(output_unit_sb_surf), '''is not valid.'
                     write(ilog,*) 'This should be ''mol/L H2O'' or ''mol/L bulk''.'
                   end if  
                   goto 999
                 end if
                 
             else

                 output_unit_sb_surf = 'mol/L H2O'

             end if             !(found_subsection)
         end if            !sorption_type_surf
         
         subsection = 'define sorption type of ion-exchange'

         call findstrg(subsection,itmp,found_subsection)

         if (found_subsection) then

             read(itmp,*,err=999,end=999) sorption_type_ion

         else

             sorption_type_ion = 'gaines-thomas'

         end if             !(found_subsection)

!c  set default to surface complexation, if nsites > 0, and type 
!c  is set to gapon or gaines-thomas

         if (nsites.gt.0.and.(sorption_type.eq.'gaines-thomas'.or.   &
             sorption_type.eq.'gapon')) then
             sorption_type = 'surface-complex'
         end if
          
          
!c  define sorption group

         if (sorption_type.eq.'gaines-thomas') then
             sorption_group = 'ion-exchange'
         elseif (sorption_type.eq.'gapon') then
             sorption_group = 'ion-exchange'
         elseif (sorption_type.eq.'surface-complex') then
             sorption_group = 'surface-complexation'
         elseif (sorption_type.eq.'constant-capacitance') then
             sorption_group = 'surface-complexation'
         !elseif (sorption_type.eq.'surface-complex and ion-exchange') then
         !  sorption_group = 'surface-complex and ion-exchange'
         end if
         
         if(.not. found_surface_complex .and. .not. found_ion_exchange) then
             if (sorption_group.eq.'ion-exchange') then
                nsb_surf = 0
                !release the pre-allocated memory for surface-complex variables
             elseif (sorption_group.eq.'surface-complexation') then
                nsb_ion = 0
                !release the pre-allocated memory for ion-exchange variables
             end if
         end if
         
         if (nsb_ion.gt.0.and.nsb_surf.gt.0) then
             sorption_group = 'surface-complex and ion-exchange'
         end if

         if ((sorption_group.eq. 'surface_complexation' .or.       &
             (sorption_group.eq.'surface-complex and ion-exchange'  &
             .and. nsb_surf > 0)).and.nsites.eq.0 .and. nsites_ion.eq.0) then

             subsection = 'non-aqueous components'
             l_string = index(subsection,'  ')-1
             if (l_string.eq.-1.or.l_string.gt.72) then
                 l_string=72
             end if
             if (rank == 0) then
               write(ilog,*) 'SIMULATION TERMINATED'
               write(ilog,*) 'error reading input file'
               write(ilog,*) 'subsection "',subsection(:l_string),'" missing'
               write(ilog,*) 'no surface sites specified'
               close(ilog)
             end if
#ifdef PETSC
             call petsc_mpi_finalize
#endif
             stop

         end if

!c  define output unit for surface species

         if (sorption_group.eq.'ion-exchange') then
             output_unit_sb_ion = 'meq/100g'
         !elseif (sorption_group.eq.'surface-complexation') then       !removed as user defined
         !    output_unit_sb_surf = 'mol/L h2o'
         elseif (sorption_group.eq.'surface-complex and ion-exchange') then
             output_unit_sb_ion = 'meq/100g'
 !MX            output_unit_sb_surf = 'mol/L h2o'
         end if

!c  define compressed data structure for surface sites

         if (sorption_group.eq.'surface-complexation' .or.         &
             (sorption_group.eq.'surface-complex and ion-exchange' &
             .and. nsb_surf > 0)) then

         isites = 0

         do ic = 1,nc

             if (component_type(ic).eq.'surface') then
             isites = isites+1
             iais(ic) = isites
             iaic(isites) = ic
             end if

         end do
#ifdef DEBUG
         do ic = 1,nc
             isites = iais(ic)
             write(idbg,"(i8, 1x, a, 1x, a, i8)") ic,namec(ic),component_type(ic),isites
         end do
#endif

#ifdef DEBUG
         do isites = 1,nsites
             ic = iaic(isites)
             write(idbg,"(i8,1x,a,1x,a,i8)") isites,namec(ic),component_type(ic),ic
         end do
#endif

         end if

      end if               !(nsb.gt.0)
        
      if (nsb_surf < 1 .and. nsites > 0) then
          
          l_string = index(subsection,'  ')-1
          if (l_string.eq.-1.or.l_string.gt.72) then
          l_string=72
          end if
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'subsection "',subsection(:l_string), '" missing'
            write(ilog,*) 'surface complexes not specified'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop          

      end if
        
        !write(*,*) "sorption_group ", trim(sorption_group)
        !write(*,*) "nsb_surf ", nsb_surf, " nsb_ion ", nsb_ion
        
!c ----------------------------------------------------------------------
!c  read number of minerals 
 
        subsection = 'minerals'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          read(itmp,*,err=999,end=999) nm
 
!c  allocate memory for one-dimensional arrays of size nm and
!c  related arrays

          call mem_nm

!c  read mineral names
 
          do im = 1,nm
            read(itmp,*,err=999,end=999) namem(im)
          end do

!c  define length of mineral names

          do im = 1,nm
            l_namem(im) = index(namem(im),' ')-1
            if (l_namem(im).eq.-1.or.l_namem(im).gt.72) then
              l_namem(im) = 72
            end if
          end do
 
        end if              !(found_subsection)
        
        if (nm > 0) then
          subsection = 'mineral water removal coefficient'
          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then 
            water_removal = .true.  
            do im = 1,nm
              read(itmp,*,err=999,end=999) rwaterremovalcoeff(im)
            end do
          end if              !(found_subsection)  
        else
          water_removal = .false.  
        end if

!c ----------------------------------------------------------------------
!c  read number of intra-aqueous kinetic reactions

        subsection = 'intra-aqueous kinetic reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          read(itmp,*,err=999,end=999) naq

!c  allocate memory for one-dimensional arrays of size naq and
!c  related arrays

          call mem_naq

!c  read names of intra-aqueous kinetic reactions
   
          do iaq=1,naq
            read(itmp,*,err=999,end=999) nameaq(iaq)
          end do

!c  define length of names of intra-aqueous kinetic reactions

          do iaq = 1,naq
            l_nameaq(iaq) = index(nameaq(iaq),' ')-1
            if (l_nameaq(iaq).eq.-1.or.l_nameaq(iaq).gt.72) then
              l_nameaq(iaq) = 72
            end if
          end do

        end if

!c  read scaling factors for intra-aqueous kinetic reactions

        subsection = 'scaling for intra-aqueous kinetic reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          do iaq = 1,naq
            read(itmp,*,err=999,end=999) scalfac_aq(iaq)
          end do

        else

          do iaq = 1,naq
            scalfac_aq(iaq) = r1
          end do

        end if

! prc ---------------------------------------------------------------
! prc allocating the vectors for diffusion coefficients for components 
! prc including h2o (mdiff_ic) and secondary aqueous species (mdiff_ix)
! prc ---------------------------------------------------------------        
        
        if (multi_diff) then          !CMX
            allocate (mdiff_ic(nc), stat = ierr)
            
            mdiff_ic = 0.0d0
                
            call checkerr(ierr,'mdiff_ic',ilog)           

           
            allocate (mdiff_ix(nx), stat = ierr)
                
            mdiff_ix = 0.0d0
                    
            call checkerr(ierr,'mdiff_ix',ilog)
            
        end if
! prc ---------------------------------------------------------------
!c ----------------------------------------------------------------------
!c  read database for components, secondary aqueous species, redox 
!c  couples, gases, sorbed species, minerals and intra-aqueous 
!c  kinetic reactions, search database for possible secondary aqueous species
 
        call readcomp(icdbs,ilog,idbg)

        call readsspc(ixdbs,ipsp,ilog,idbg)

        if (nr.gt.0) then
        if (new_database) then
            call readredx_new(irdbs,ilog,idbg)
        else
          call readredx(irdbs,ilog,idbg)
        end if
        end if

        if (ng.gt.0) then
          call readgses(igdbs,ipsp,ilog,idbg)
        end if

        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
          call readsorb(isdbs,ipsp,ilog,idbg)
        end if

        if (nm.gt.0) then
        if (new_database) then
            call readmin_new(imdbs,ilog,idbg,icnv)
        else
            call readmin(imdbs,ilog,idbg,icnv)
        end if
        end if

        if (naq.gt.0) then
        if (new_database) then
            call readint_new(irdbs,ilog,idbg)
        else
            call readint(irdbs,ilog,idbg)
          end if
      end if

!c ----------------------------------------------------------------------
!c  read number of excluded minerals

        subsection = 'excluded minerals'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          read(itmp,*,err=999,end=999) nmx

!c  allocate memory for one-dimensional arrays of size nmx and
!c  related arrays

          call mem_nmx

!c  read mineral names

          do imx = 1,nmx
            read(itmp,*,err=999,end=999) namemx(imx)
          end do

!c  define length of names of excluded minerals

          do imx = 1,nmx
            l_namemx(imx) = index(namemx(imx),' ')-1
            if (l_namemx(imx).eq.-1.or.l_namemx(imx).gt.72) then
              l_namemx(imx) = 72
            end if
          end do

        end if             !(found_subsection)
      
!c  search mineral database and read data for specified excluded minerals

        if (nmx .gt. 0) then  ! THH Aug 30, 2003 edit
          if (new_database) then
            call readminx_new(imdbs,ipsp,ilog,idbg)           
          else
            call readminx(imdbs,ipsp,ilog,idbg)
          end if
        end if

!c  close file containing possible secondary aqueous species, 
!c  gases and minerals

        close(ipsp)
        call lun_free(ipsp)

!c  define default for pointer array for mineralogical parameters

        if (nm.gt.0) then

          do im = 1,nm
            iamp(im) = im
            jamp(im) = im
          end do
          iamp(nm+1) = nm+1

        end if

!c  optional input section to allow the combined use and update
!c  of reactive surface area and volume fractions

        subsection = 'combine mineralogical parameters'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
     
!c  define mapping 

          do im = 1,nm
            read(itmp,*,err=999,end=999) namet(im)
          end do
     
!c  define pointer arrays

          iamp(1) = 1
          do im = 1,nm
            i1 = iamp(im)
            if (namet(im).eq.namem(im)) then
              nmp = 0
              do im2 = 1,nm
                if (namet(im2).eq.namem(im)) then
                  jamp(i1+nmp) = im2
                  nmp = nmp+1 
                end if
              end do
              iamp(im+1) = iamp(im)+nmp 
            elseif (namet(im).ne.namem(im)) then
              iamp(im+1) = iamp(im) 
            end if
          end do

        end if              !(found_subsection)


!c  sung-wook      
!c  optional input section to allow update od reactive
!c  surface area by mineral precipitation
        if (nm > 0) then
          sur_prec=.false.
          alph_prec=0
        end if

        subsection = 'surface precipitates'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
        
          read(itmp,*,err=999,end=999) npts
     
!c  define mapping 
          do ipts = 1,npts
            read(itmp,*,err=999,end=999) dummy, alpha
            do im=1,nm
                if(namem(im).eq.dummy) then
                    sur_prec(im)=.true.
                    alph_prec(im)=alpha
                end if
            end do                    
          end do
    
        end if              !(found_subsection)

      end if                !(found_section)

      if (b_enable_output .and. b_enable_output_gen) then

!c ----------------------------------------------------------------------
!c  write number and names of chemical species to generic output file
 
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)
 
!c  output database to generic output file

      write(igen,'(2a)') 'database: ',dbs_dir
      if (redox_master.eq.'e-1') then
        write(igen,'(a)') 'redox master variable: e-1'
      elseif (redox_master.eq.'o2(aq)') then
        write(igen,'(a)') 'redox master variable: o2(aq)'
      elseif (redox_master.eq.'h2(aq)') then
        write(igen,'(a)') 'redox master variable: h2(aq)'
      end if
      write(igen,'(2a)') 'input units: ',input_units
      if (.not.temp_field) then
        write(igen,'(a,f6.2,a/)') 'temperature = ',tempc,' deg C'
      end if

!c  write number of components to generic output file

      write(igen,'(a,i10/)')  &
     &'number of components:                           = ', nc           
 
!c  write component names to generic output file
 
      write(igen,'(a)')'aqueous components:'
      write(igen,'(a)')'-------------------'
      do ic=1,nc 
        if (component_type(ic).eq.'aqueous') then
          write(igen,'(a72)') namec(ic)
        end if
      end do
      
!c  write biomass component names to generic output file

      if (nbio.gt.0) then
      
        write(igen,'(/a)')'biomass components:'
        write(igen,'(a)')'-------------------'
        do ic=1,nc 
          if (component_type(ic).eq.'biomass') then
            write(igen,'(a72)') namec(ic)
          end if
        end do
      
      end if

!c  write names of surface complexation sites to generic output file
      
      if (nna.gt.0) then

        write(igen,'(/a)')'non-aqueous components:'
        write(igen,'(a)')'-----------------------'
        do ic=1,nc 
          if (component_type(ic).eq.'surface') then
            write(igen,'(a72)') namec(ic)
          end if
        end do

      end if

!c  write number of redox couples to generic output file

      if (nr.gt.0) then

        write(igen,'(/a,i10/)')   &
     &  'number of redox couples:                        = ', nr           

!c  write names of redox couples to generic output file
 
        write(igen,'(a)')'redox couples:'
        write(igen,'(a)')'--------------'
        do ir=1,nr 
          write(igen,'(a)') namer(ir)(:l_namer(ir))
        end do
 
      end if             !(nr.gt.0)
 
!c  write number of intra-aqueous kinetic reactions to generic 
!c  output file

      if (naq.gt.0) then

        write(igen,'(/a,i10/)')   &
     &  'number of intra-aqueous kinetic reactions       = ', naq

!c  write names of intra-aqueous kinetic reactions to generic 
!c  output file

        write(igen,'(a)')'intra-aqueous kinetic reactions:'
        write(igen,'(a)')'--------------------------------'
        write(igen,'(a)')'name            scaling factor'
        do iaq=1,naq
          write(igen,'(a12,1x,1pe12.4)') nameaq(iaq),scalfac_aq(iaq)
        end do

      end if             !(naq.gt.0)

!c  write number of aqueous complexes to generic output file
 
      if (nx.gt.0) then

        write(igen,'(/a,i10/)')   &
     &  'number of aqueous complexes:                    = ', nx           
 
!c  write names of aqueous complexes to generic output file
 
        write(igen,'(a)')'aqueous complexes:'
        write(igen,'(a)')'------------------'
        do ix=1,nx
          write(igen,'(a72)') namex(ix)
        end do

      end if
 
!c  write number of gases to generic output file 
 
      if (ng.gt.0) then
        write(igen,'(/a,i10/)')   &
     &  'number of gases:                                = ', ng           

!c  write names of gases to generic output file 
!c_bubbles If gas_bubles is true then write gases, gas pair
    
         if (gas_bubbles) then

          call assngasspc

          write(igen,'(a/)') 'gas bubble formation'           
          write(igen,'(a8,a12,a12)')' gas: ','gas pair'
          write(igen,'(a8,a12,a12)')'------','---------'
          do ig = 1,ng
            i = gas_pair(ig)
            write(igen,'(a12,a12,a12)') nameg(ig),namec(i)
          end do
!c_bubbles Else just write names of gases
        else
          write(igen,'(a)')'gases:'
          write(igen,'(a)')'------'
          do ig = 1,ng
            write(igen,'(a72)') nameg(ig)
          end do        
        end if 
      end if
 
!c  write names of species undergoing sorption to generic output file

      if (noncompetitive_sorption) then
      
      write(igen,'(/2a)')'components undergoing ',  &
     &                     'non-competitive adsorption:'
        write(igen,'(2a)')'------------------------', &
     &                    '--------------------------'
      
      do ic = 1,nc
        if (isotherm_type(ic).ne.'none') then
            write(igen,'(a12,1x,a)') namec(ic), isotherm_type(ic)
          end if
      end do
      
      end if
        
      if (nsb_ion.gt.0.or.nsb_surf.gt.0) then

!c  write number of sorbed species to generic output file

        write(igen,'(/a,i10/)')   &
     &  'number of sorbed species:                       = ', nsb_ion+nsb_surf+nsites
      
!c  write names of sorbed species to generic output file

        write(igen,'(a)')'sorbed species:'
        write(igen,'(a)')'---------------'
        if (sorption_group.eq.'surface-complexation'.or.(nsb_surf.gt.0 .and. &
            sorption_group.eq.'surface-complex and ion-exchange')) then
          do isites = 1,nsites
            ic = iaic(isites)
            write(igen,'(a72)') namec(ic)
          end do
        end if
            
        do isb = 1,nsb_ion
          write(igen,'(a72)') namesb_ion(isb)
        end do
        
        do isb = 1,nsb_surf
          write(igen,'(a72)') namesb_surf(isb)
        end do

      end if

!c  write number of minerals to generic output file 
 
      if (nm.gt.0) then

        write(igen,'(/a,i10/)')   &
     &  'number of minerals:                             = ', nm           
 
!c  write mineral names to generic output file 
 
        write(igen,'(a)')'minerals:'
        write(igen,'(a)')'---------'
        do im = 1,nm
          write(igen,'(a72)') namem(im)
        end do

      end if

!c  write number of excluded minerals to generic output file 
 
      if (nmx.gt.0) then

        write(igen,'(/a,i10/)')   &
     &  'number of excluded minerals:                    = ', nmx

!c  write names of excluded minerals to generic output file

        write(igen,'(a)')'excluded minerals:'
        write(igen,'(a)')'------------------'
        do imx = 1,nmx
          write(igen,'(a72)') namemx(imx)
        end do

      end if
      
      end if

!c  set logical variables for output of master variables

      ph_output = .false.
      pe_output = .false.
      do ic = 1,nc-1
        if (namec(ic).eq.'h+1') then
          ph_output = .true.
        end if
        if (redox_master.eq.'o2(aq)'.and.namec(ic).eq.'o2(aq)'.or.    &
     &      redox_master.eq.'h2(aq)'.and.namec(ic).eq.'h2(aq)'.or.    &
     &      redox_master.eq.'e-1'.and.namec(ic).eq.'e-1') then
          pe_output = .true.
        end if
      end do 
 
      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
