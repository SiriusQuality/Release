!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 488 $
!> $Author: cblitz $
!> $Date: 2017-07-17 18:22:05 +0200 (lun. 17 juil. 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/cblitz_1/src/min3p/rootwat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine mem_etr
!c ------------------
!c
!c allocate memory for evapo-transpiration parameters 
!c
!c written by:      Valerie Maquere - January, 2008
!c
!c last modified:   Frederic Gerard - June, 2009
!c                  arrays initialized, except logical and character ones
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    integer*4:
!c           ----------
!c           ilog               = unit number, logbook file           + -
!c           nn                 = number of control volumes           + -
!c           qroot(nn)      = root water uptake for current 
!c                            control volume
!c           qrootinc(nn)   = root water uptake for current 
!c                            control volume (incremented)
!c           dqroot(nn)     = derivative of root water uptake
!c
!c phys.f:   real*8:
!c           rootlengthdens(nzn)= root length density
!c           rld(nn)            = root length density  in each control volume,
!c                                read from external file
!c           dualhcrit(nzn)     = h value for onset of increased hydr conductivity         
!c           dualmag(nzn)       = scaling factor for dual permeability composite fn 
!c           uptakefactor(nzn) = passive uptake factor (by zone)
!c           puf(nn)            = passive uptake factor (by control volume)

!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c
!c external: checkerr  = check for error during memory allocation
!c ----------------------------------------------------------------------
!CBF : !! Ã  decommenter

  
      subroutine mem_etr
 
      use parm
      use gen
      use phys
	use dual
	use biol
 
      external checkerr, zero_i4, zero_r8 !FG added zero-x subroutine to initialize the arrays (integer and relative numbers)

!c allocate memory for material parameters read from file

      allocate (rld(nn), stat = ierr)
     call checkerr(ierr,'rld',ilog)
      call zero_r8(rld,nn,1,1) ! clean array 

!!      allocate (rldbck(nn), stat = ierr)
!!      call checkerr(ierr,'rldbck',ilog)
!!      call zero_r8(rldbck,nn,1,1) ! clean array 
      
      
	allocate (rootlengthdens(nzn), stat = ierr)
      call checkerr(ierr,'rootlengthdens',ilog)
      call zero_r8(rootlengthdens,nzn,1,1) ! clean array 
      
      
!!	allocate (rootdiff(n), stat = ierr)
!!      call checkerr(ierr,'rootdiff',ilog)
!!      call zero_r8(rootdiff,n,1,1) ! clean array 
     
!!	allocate (totrootdiff(n), stat = ierr)
!!      call checkerr(ierr,'totrootdiff',ilog)
!!     call zero_r8(totrootdiff,n,1,1) ! clean array 

      allocate (uptakefactor(nzn), stat = ierr)
     call checkerr(ierr,'uptakefactor',ilog)
      call zero_r8(uptakefactor,nzn,1,1) ! clean array 
      
	allocate (puf(nn), stat = ierr)
      call checkerr(ierr,'puf(nn)',ilog)
      call zero_r8(puf,nn,1,1) ! clean array

!c  evaporation and transpiration fluxes - variably saturated flow

	allocate (BINev(nn), stat = ierr)
! CBF
      call checkerr(ierr,'BINev',ilog)
!CBF
!FG not an integer => conflict      call zero_i4(BINev,nn,1,1) ! clean array !FG april 2013, corrected. It is a binary matrix
! CBF

	allocate (BINT(nn), stat = ierr)
! CBF
      call checkerr(ierr,'BINT',ilog)
! CBF
!FG not an integer => conflict      call zero_i4(BINT,nn,1,1) ! clean array !FG april 2013, corrected. It is a binary matrix
! CBF
	
!c	allocate (evaporat(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (evaporat_inc(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (sanew_after_ev(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (sainc_after_ev(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (rootwat(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (rootwat_inc(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c 	allocate (Rev(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (Rev_inc(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)
	 
!c	allocate (Rt(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

!c	allocate (Rt_inc(nn), stat = ierr)
!c      call checkerr(ierr,'mpropvs',ilog)

	allocate (qroot(nn), stat = ierr)
      call checkerr(ierr,'mpropvs',ilog)
      call zero_r8(qroot,nn,1,1) ! clean array

	allocate (qrootinc(nn), stat = ierr)
      call checkerr(ierr,'mpropvs',ilog)
      call zero_r8(qrootinc,nn,1,1) ! clear array

	allocate (dqroot(nn), stat = ierr)
      call checkerr(ierr,'mpropvs',ilog)
      call zero_r8(dqroot,nn,1,1) ! clear array
	
	return
	
	end
