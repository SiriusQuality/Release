!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initcpdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpdd
!c -------------------
!c
!c control parameters for density dependent flow
!c
!c written by:      Tom Henderson - August 21, 2002
!c
!c last modified:   Tom Henderson - September 3, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           deltol_vs          = solver update tolerance             * +
!c           dinc_vs            = increment for numerical             * +
!c                                differentiation
!c           perm_fac(nngl)       = scaling factor for permeability   * +
!c                                as a function of porosity changes 
!c           restol_vs          = solver residual tolerance           * +
!c           srelfac_vs         = user specified underrelaxation      * +
!c                                factor
!c           sw_star            = anticipated change in saturation    * +
!c                                per time step
!c           tol_vs             = convergence tolerance               * +
!c                                (variably saturated flow)
!c           uvslim             = max. allowed update                 * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           idetail_vs         = solver information level            * +
!c           level_vs           = incomplete factorization level      * +
!c           maxit_vs           = max. number of newton iterations    * +
!c                                (variably saturated flow)
!c           msolvit_vs         = max. number of solver iterations    * +
!c           nngl               = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   * +
!c                                           factor
!c           hydraulic_head     = .true.  -> initial condition in     * +
!c                                           terms of hydraulic head
!c           mass_balance_vs    = .true.  -> compute mass balance     * +
!c                                           (variably_saturated
!c                                            flow)
!c           pressure_head      = .true.  -> initial condition in     * +
!c                                           terms of pressure head
!c           rcm_ordering_vs    = .true.  -> rcm ordering for         * +
!c                                           1d scalar matrix
!c           under_relax        = .true.  -> underrelaxation          * +
!c           upstream           = .true.  -> upstream weighting       * +
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c dens.f:
!c           real*8:
!c           -------
!c           courant_target     = target courant number               * +
!c           drho_dc            = density-TDS constant drho / dTDS    * +
!c
!c
!c           integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         + -
!c           inpl               = counter for napl components         * +
!c           iter_target        = target number of Picard iterations  + -
!c           maxit_sia          = maximum number of Picard iterations * +
!c           ndd                = number of components used for       * +  
!c                                fluid density calculation
!c           nnpl               = total number of napl components     * +
!c  
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density         * + 
!c                                           dependent flow
!c           fluid_pressure     = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c           fresh_head         = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of freshwater head 
!c           init_perm          = .true. -> initial media             * +
!c                                           properties in 
!c                                           permeability units
!c           init_cond          = .true. -> initial media             * +
!c                                           properties in hydraulic 
!c                                           conductivity units
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c local:    
!c           real*8:
!c           -------
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures       * +   
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpdd
 
      use parm
      use gen
      use dens
      use chem
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, i1, ic, ierr, im, ivol, l_string

      external findstrg, readbloc, zero_r8_parallel

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0

      logical found_section, found_subsection
      character*72 subsection
 
!c  define or read control parameters for density dependent flow
!c  and write to temporary file
   
      section_header = 'control parameters - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if


!c  general control parameters

      tol_vs = 1.0d-6  
      rtol_relbalance_vs = 1.0d100
      rtol_absbalance_vs = 1.0d100
      relbalance_vs = 0.0d0
      absbalance_vs = 0.0d0
      mass_balance_vs = .true.
      specify_dd_comp = .false.
      napl_kfunction = 'none'

!c  sequential iterative cupling parameters
!c default constant relating changes in density to changes
!c in concentration: drho_dc = drho / dTDS 

      drho_dc = 0.688   !SOLMINEQ.88 [drho_dc = 0.7143 in SEAWAT]
      maxit_sia = 10
      tol_sia = 0.1
      iter_target = 4
      courant_target = 1.0

!c  toggle for flow verification problems assuming constant density
!c  fluids.  If .true. -> flow only solution using pressure formulation

      flow_verification = .false.

!c update viscosity using polynomial in subroutine ddtds

      update_viscosity = .false.

!c  control parameters for density dependent flow
!c  default input units = fluid pressure and intrinsic permeability

      fluid_pressure = .true.
      init_perm = .true.

!c  alternate input units for fluid and media properties

      pressure_head = .false.
      fresh_head = .false.
      init_cond = .false.
      hydraulic_head = .false.

!c  default reference density for converting freshwater head
!c  initial and boundary conditions to fluid pressures

      ref_dens = 1.0d+3

!c  hardwire upstream weighting for density dependent flow
      upstream = .true.

!c  Newton iteration
!c  increase by a factor of 10,000 for pressure formulation
!c  1 m head = 9,806.65 Pa freshwater
      dinc_vs = 1.0d+0 
      maxit_vs = 15 
      sw_star = 0.1

!c  underrelaxation

      if (variably_saturated) then
        under_relax = .false.
        comp_relax = .false.
      end if

!c  solver settings

      level_vs = 0
      msolvit_vs = 100
      idetail_vs = 1
      restol_vs = 0.1d0 * tol_vs
      deltol_vs = 0.1d0 * tol_vs
      if(i_solver_type_flow == 0) then
        rcm_ordering_vs = .true.
      else
        rcm_ordering_vs = .false.  
      end if

!c  initialize scaling factor for permeability update
 
      do ivol = 1,nngl
        perm_fac(ivol) = r1
      end do

      if (found_section) then

!c flow verification setting

        subsection = 'flow verification'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          flow_verification = .true.
        end if

!c  mass balance settings - new definition

        subsection = 'mass balance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
        else
          mass_balance_vs = .false.
        end if

        subsection = 'relative mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
        end if

        subsection = 'absolute mass balance tolerance'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if


        subsection = 'mass balance convergence tolerance settings'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_vs = .true.
          read(itmp,*,err=999,end=999) rtol_relbalance_vs
          read(itmp,*,err=999,end=999) rtol_absbalance_vs
        end if


!c  mass balance settings - old definition

        subsection = 'mass balance settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) mass_balance_vs
        end if
        
!cprovi----------------------------------------------------        
!cprovi Upstream factor for flow  
!cprovi----------------------------------------------------
        subsection = 'upstream factor for flow equation'
        !cprovi--------------------------------------------
        !cprovi Assign default reference mass fraction
        !cprovi--------------------------------------------
        ups_flow=r1 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) ups_flow
          if (ups_flow>r1.or.ups_flow<r0) ups_flow=r1         
        end if  




!cprovi split changes in densities in components
!cprovi mixing and chemical components

        subsection = 'split density changes'
        issplitdens=.false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          issplitdens=.true.          
        end if       

!cprovi Integration in hydrostatic condition 

        subsection = 'vertical integration in hydrostatic condition'
        ishydrostatic2=.false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ishydrostatic2=.true.
        end if         
!c napl identification for relative permeability calculation for
!c aqueous phase in the presence of residual (non-mobile) napl phase
!c van genuchten and corey wetting phase relative permeability options

        subsection = 'update napl permeability'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          napl_permeability = .true.
 
          read(itmp,*,err=999,end=999) napl_kfunction
          if (napl_kfunction.eq.'van genuchten') then
            napl_kfunction = 'vangenuchten'
          end if
          if (napl_kfunction.ne.'corey'.and.          &
     &        napl_kfunction.ne.'vangenuchten') then
            if (rank == 0) then  
              write(ilog,'(a)')                         &
     &        'error reading subsection "napl relative k function"'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
      
          read(itmp,*,err=999,end=999) nnpl

!c  allocate memory for one-dimensional arrays of size nm and
!c  related arrays

          allocate (namenpl(nnpl), stat = ierr)
          namenpl=''
          call checkerr(ierr,'namenpl',ilog)

          allocate (ianpl(nnpl), stat = ierr)
          ianpl=0 
          call checkerr(ierr,'ianpl',ilog)

          allocate (l_namenpl(nnpl), stat = ierr)
          l_namenpl=0 
          call checkerr(ierr,'l_namenpl',ilog)

!c  read napl names
 
          do inpl = 1,nnpl
            read(itmp,*,err=999,end=999) namenpl(inpl)
          end do

!c  define length of napl names

          do inpl = 1,nnpl
            l_namenpl(inpl) = index(namenpl(inpl),' ')-1
            if (l_namenpl(inpl).eq.-1.or.l_namenpl(inpl).gt.72) then
              l_namenpl(inpl) = 72
            end if
          end do

!c  define pointer arrays locating napl phases in mineral list

          i1 = 0
          im = 1
          do inpl = 1,nnpl
          napl_match = .false.
          do while ((im .le. nm) .and. (.not.napl_match))

            if (namenpl(inpl).eq.namem(im)) then
              i1 = i1 + 1
              ianpl(i1) = im
                napl_match = .true.
              im = 0
            end if
          im = im + 1
          end do

!c error message if napl component not located in mineral list

          if ((im .gt. nm) .and. (.not.napl_match)) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,'(72a)')('-',i=1,72)
              write(ilog,'(a)')'cannot find NAPL components in minerals'
              if (b_enable_output_gen) then
                write(igen,'(72a)')('-',i=1,72)
                write(igen,'(a)')'cannot find NAPL components in minerals'
              end if
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

          end do        !inpl = 1,nnpl   

        end if !found_subsection

!c density-dependent flow and picard iteration parameters

        subsection = 'variable density parameters'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) ref_dens
          read(itmp,*,err=999,end=999) drho_dc
          read(itmp,*,err=999,end=999) maxit_sia
          read(itmp,*,err=999,end=999) iter_target
          read(itmp,*,err=999,end=999) tol_sia
          read(itmp,*,err=999,end=999) courant_target
        end if

        subsection = 'update viscosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          update_viscosity = .true.
        end if 

        subsection = 'variable density components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          specify_dd_comp = .true.

          read(itmp,*,err=999,end=999) ndd

!c allocate memory for arrays for density calculatation componenets

          allocate (namedd(ndd), stat = ierr)
          namedd='' 
          call checkerr(ierr,'namedd',ilog)

          allocate (gfwdd(nc), stat = ierr)
          gfwdd=0.0d0
          call checkerr(ierr,'gfwdd',ilog)

          do ic = 1,ndd
              read(itmp,*,err=999,end=999) namedd(ic)
          end do

!c create gram formula weight vector with gram formula weights for
!c components identified for density calculation.  Gram formula weights
!c for remaining componenets set to 0.0d0

          call zero_r8_parallel(gfwdd,nc,1,1)

          do ic = 1,nc-1
            do i1 = 1,ndd
              if (namec(ic) .eq. namedd(i1)) then
                gfwdd(ic) = gfwc(ic)
                goto 101
              end if
              end do
101           continue
          end do               

        end if  !found_subsection

!c allocate memory for sequential iteration results vectors

        allocate (sia_dens(maxit_sia), stat = ierr)
        sia_dens=r0
        call checkerr(ierr,'sia_dens',ilog)
        
        allocate (sia_maxvol(maxit_sia), stat = ierr)
        sia_maxvol=0
        call checkerr(ierr,'sia_maxvol',ilog)
        
        allocate (sia_nexvol(maxit_sia), stat = ierr)
        sia_nexvol=0 
        call checkerr(ierr,'sia_nexvol',ilog)
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
        subsection = 'density model'
        ispitzerdens=.false. 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection) then
          
          read(itmp,*,err=999,end=999) subsection
          
          if (subsection=='pitzer'.and.ispitzer) then
             ispitzerdens=.true. 
             if (heat_transport) then
                allocate (density_pitzer(nngl), stat = ierr)
                density_pitzer=r0 
                call checkerr(ierr,'density_pitzer',ilog)
                
                allocate (densold_pitzer(nngl), stat = ierr)
                densold_pitzer=r0 
                call checkerr(ierr,'densold_pitzer',ilog)               
             end if
          end if 
          
        end if 
!cprovi----------------------------------------------------
!cprovi Update porosity for flow processes
!cprovi----------------------------------------------------
        subsection = 'update porosity'
        update_porosity_flow=.false. 
        facpormin=1.0d-3 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection) then
          
          read(itmp,*,err=999,end=999) facpormin 
          update_porosity_flow=.true. 
          
        end if 
!cprovi----------------------------------------------------
!cprovi Read reference viscosity 
!cprovi----------------------------------------------------
        subsection = 'reference viscosity'
        ref_visco=1.0d-3 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection) then
          
          read(itmp,*,err=999,end=999) ref_visco
          
        end if                   
!cprovi----------------------------------------------------
!cprovi Update the permeability for flow processes
!cprovi----------------------------------------------------
        subsection = 'update permeability'
        update_permeability_flow=.false. 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection.and.update_porosity_flow) then             
           
           update_permeability_flow=.true. 
      
        end if 
!cprovi----------------------------------------------------
!cprovi Update porosity for flow processes
!cprovi----------------------------------------------------
        subsection = 'iterative solver'
        iterative_solver_flow=.false. 
        call findstrg(subsection,itmp,found_subsection)
       
        if (found_subsection) then
          
           iterative_solver_flow=.true. 
          
        end if             
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!c  input units for  media permeability
!c  density dependent flow
!c  default units - permeability
        subsection = 'input units for media permeability'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'permeability') then
            init_perm = .true.
          elseif (subsection.eq.'hydraulic conductivity') then
            init_cond = .true.
            init_perm = .false.
          else
            goto 999
          end if
        end if

!c  input units for boundary and initial conditions
!c  density dependent flow
!c  default units - fluid pressure

        subsection = 'input units for boundary and initial conditions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'pressure') then
            fluid_pressure = .true.
          
          elseif (subsection.eq.'pressure head') then
            pressure_head = .true.
            fluid_pressure = .false.
          
          elseif (subsection.eq.'freshwater head') then
            fresh_head = .true.
            fluid_pressure = .false.

          elseif (subsection.eq.'hydraulic head') then
            hydraulic_head = .true.
            fluid_pressure = .false.
          else
            goto 999
          end if
        end if
        
        
        subsection = 'user specified underrelaxation factor'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          under_relax = .true.
          read(itmp,*,err=999,end=999) srelfac_vs
        end if
        
        
        subsection = 'compute underrelaxation factor'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          under_relax = .true.
          comp_relax = .true.
          read(itmp,*,err=999,end=999) uvslim
        end if

        if (variably_saturated) then

          subsection = 'user specified underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            read(itmp,*,err=999,end=999) srelfac_vs
          end if

!c  compute underrelaxation factor

          subsection = 'compute underrelaxation factor'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            under_relax = .true.
            comp_relax = .true.
            read(itmp,*,err=999,end=999) uvslim
          end if

        end if              !(variably saturated) moved above Newton iteration 
!c                             settings July 14, 2003

!c  newton iteration settings
!c  these parameters read for both fully and variably saturated simulations
!c  THH change - July 14, 2003

        subsection = 'newton iteration settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) dinc_vs
          read(itmp,*,err=999,end=999) maxit_vs
          read(itmp,*,err=999,end=999) tol_vs 
          read(itmp,*,err=999,end=999) sw_star
        end if

!c  solver settings

        subsection = 'solver settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) level_vs 
          read(itmp,*,err=999,end=999) msolvit_vs
          read(itmp,*,err=999,end=999) idetail_vs
          read(itmp,*,err=999,end=999) restol_vs
          read(itmp,*,err=999,end=999) deltol_vs
          read(itmp,*,err=998,end=998) rcm_ordering_vs      !old
        end if

 998    subsection = 'natural ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .false.
        end if
        
        subsection = 'rcm ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          rcm_ordering_vs = .true.
        end if

      end if                 !(found_section)

!c  assign related control parameters

!c      if (.not.pressure_head) then
!c         hydraulic_head = .true.
!c      end if

!c  write control parameters for reactive transport
!c  to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
          
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

      if (fluid_pressure) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'fluid pressure'

      elseif (pressure_head) then
        write(igen,'(2a)')                                        &
     &  'input of boundary and initial conditions in terms of ',  &
     &  'pressure head'

      elseif (fresh_head) then
        write(igen,'(2a)')                                        &   
     &  'input of boundary and initial conditions in terms of ',  &
     &  'freshwater head'
      end if

      write(igen,'(a)')                                           &
     &  'upstream weighting of relative permeabilities, ',        &
     &  'fluid viscosity, and density'   
      
    if (variably_saturated) then
        if (under_relax) then
          if (comp_relax) then
            write(igen,'(a)')                                     &
     &      'computation of underrelaxation factor                '
            write(igen,'(a,1pe10.3)')                             &
     &      'max. allowed update                             = ', &
     &       uvslim 
          else
            write(igen,'(a,1pe10.3)')                             &
     &      'user specified underrelaxation factor           = ', &
     &       srelfac_vs
          end if
        end if
   
        write(igen,'(a,1pe10.3)')                                 &
     &  'increment for numerical differentiation         = ',     &
     &   dinc_vs
        write(igen,'(a,i10)')                                     &
     &  'max. number of newton iterations                = ',     &
     &   maxit_vs
        write(igen,'(a,1pe10.3)')                                 &
     &  'convergence tolerance                           = ',     &
     &   tol_vs
        write(igen,'(a,1pe10.3)')                                 &
     &  'anticipated change in saturation per time step  = ',     &
     &   sw_star
      end if
      write(igen,'(a,i10)')                                       &
     &'incomplete factorization level                  = ',       &
     & level_vs
      write(igen,'(a,i10)')                                       &
     &'max. number of solver iterations                = ',       &
     & msolvit_vs
      write(igen,'(a,i10)')                                       &
     &'solver information level                        = ',       &
     & idetail_vs
      write(igen,'(a,1pe10.3)')                                   &
     &'solver residual tolerance                       = ',       &
     & restol_vs
      write(igen,'(a,1pe10.3)')                                   &
     &'solver update tolerance                         = ',       &
     & deltol_vs
      if (rcm_ordering_vs) then
        write(igen,'(a)')'reverse Cuthill McKee ordering'
      else
        write(igen,'(a)')'natural ordering'
      end if
      
      end if

      goto 1000

999   continue
      
      if (rank == 0) then
        write(ilog,*) 'error reading input file in initcpdd'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
