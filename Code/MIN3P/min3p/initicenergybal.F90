!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initicenergybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initicenergybal
!c -------------------
!c
!c initial condition (energy balance)
!c
!c written by:      Sergio Andres Bea Jofre 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    * +
!c
!c           integer*4:
!c           ----------
!c           icnv               = unit number, data conversion and    + -
!c                                             temporary storage
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging file         + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           itmp               = unit number, temporary storage      + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           pressure_head      = .true.  -> initial condition in     + -
!c                                           terms of pressure head
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           section_header     = section header                      + -
!c           zone_name          = name of zone                        * +
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      * +
!c           density(nn)        = fluid density                       * +
!c           viscosity(nn)      = fluid viscosity                     * +
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures  * +
!c           logical:
!c           --------
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c local:    real*8:
!c           -------
!c           rdummy             = real*8 dummy variable
!c           tiny               = small increment
!c           ximin              = min. limit of zone in 
!c                                x-direction
!c           ximax              = max. limit of zone in 
!c                                x-direction
!c           yimin              = min. limit of zone in 
!c                                y-direction
!c           yimax              = max. limit of zone in 
!c                                y-direction
!c           zimin              = min. limit of zone in 
!c                                z-direction
!c           zimax              = max. limit of zone in 
!c                                z-direction
!c
!c           integer*4:
!c           ----------
!c           icvs               = unit number - initial condition 
!c                                              for variably 
!c                                              saturated flow
!c           iiz                = counter (zones)
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c           niz                = number of zones           
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           initcond_file      = .true.  -> read initial condition 
!c                                           from file
!c
!c           character:
!c           ----------
!c           cdummy             = character dummy variable
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file 
!c           findzone  = find zone in input section
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine initicenergybal
 
      use parm
      use gen
      use dens
      use file_unit, only : lun_get, lun_free
      use chem, only : temp_field, tconv
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, icvs, ivol, iiz, l_string, niz
      
      real*8 :: tempinitial, rdummy, densityloc, gradtemp, toptemp,    &
                ximin, ximax, yimin, yimax, zimin, zimax
      
      integer :: iskip, nskip

      external findstrg, findzone, readbloc, readzone

      logical found_section, found_subsection, initcond_file
      character*1 cdummy
      character*72 subsection
      real*8   maxz

      real*8, parameter :: tiny = 1.d-5,r0 = 0.0d0, r25 = 25.0d0
     

!cprovi-------------------------------------------------------
!cprovi-------------------------------------------------------
!cprovi-------------------------------------------------------
      if(rank == 0) then
        write(*,*) 'initial conditions - ',                            &
     &         'energy balance'
        write(*,*) ('-',i=1,72)

        write(ilog,'(2a)') 'initial conditions - ',                    &
     &                     'energy balance'
        write(ilog,'(72a/)')('-',i=1,72)
      end if  
!cprovi-------------------------------------------------------
!cprovi-------------------------------------------------------
!cprovi-------------------------------------------------------      
      niz=0 
      tempinitial = tempref_dens
      tempnew = tempref_dens 
      tempold = tempref_dens
   
      section_header = 'initial condition - energy balance'
      call readbloc (idat,itmp,section_header,found_section,.true.)
 
!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to generic output file  
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

      subsection = 'read density from file'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
        density_field=.true.
      else
        density_field=.false. 
      end if


!c  define logical flag to determine if initial condition will be
!c  - read from file (steady state)
!c  - specified in input file
     



      subsection = 'read initial condition from file'

      call findstrg(subsection,itmp,found_subsection)

      !icvs = 13
      icvs = lun_get()

      if (found_subsection) then
        open(icvs,file=prefix(:l_prfx)//'.ivs',status='old',  &
     &            form='formatted')

        read(icvs,*,err=998,end=998) cdummy       !skip header
        read(icvs,*,err=998,end=998) cdummy       !skip header
        read(icvs,*,err=998,end=998) cdummy       !skip header
        
        nskip = 0
        do ivol = 1,nngl
            
#ifdef PETSC
          do iskip = 1, node_idx_lg2g(ivol) - nskip -1  
              read(icvs,*,end=999,err=999) rdummy
          end do
          nskip = node_idx_lg2g(ivol)
#endif
            
            if (variably_saturated) then
                  read(icvs,*,err=998,end=998) rdummy,rdummy,rdummy,  &
     &                                   rdummy,rdummy,rdummy,        &
     &                                   densityloc,rdummy,           &
     &                                   rdummy,rdummy,rdummy,        &
     &                                   rdummy,rdummy,rdummy,        &
     &                                   tempnew(ivol)
             
            else  
               read(icvs,*,err=998,end=998) rdummy,rdummy,rdummy,     &
     &                                   rdummy,rdummy,rdummy,        &
     &                                   densityloc,rdummy,           &
     &                                   rdummy,rdummy,rdummy,        &
     &                                   tempnew(ivol)
            end if 
            tempold(ivol)=tempnew(ivol)
            if (density_field) then
               density(ivol)=densityloc
            end if                          
        end do
         

        close(icvs)
        call lun_free(icvs)

!c  initial condition specified in input file

      else
      
      
      subsection = 'geothermic gradient'
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
         read(itmp,*,err=999,end=999) gradtemp    ! oC m-1
           read(itmp,*,err=999,end=999) toptemp
           !maxz = maxval(zg)
           maxz = zlmaxgbl
           do ivol =1,nngl
              tempnew(ivol) = toptemp + gradtemp * (maxz-zg(ivol))
              tempold(ivol) = tempnew(ivol) 
           end do   
           return 
      end if

!c  read number of zones for initial condition
 
        rewind(itmp)
        read(itmp,*,err=999,end=999) niz
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(a,i10)')     &
     &    'number of zones for initial condition           = ',niz
        end if

!c  read name of zone

        do iiz=1,niz                !loop over number of zones

          subsection = 'number and name of zone'

          call findzone(subsection,itmp,found_subsection,iiz, &
     &                  zone_name)

          if (found_subsection) then

            call readzone(itmp,icnv,ilog,zone_name,found_subsection)

          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone number "',iiz, '" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if

!c  define length of zone name

          l_zone_name = index(zone_name,'  ')-1
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
            l_zone_name = 72
          end if
          
          subsection = 'initial condition'
          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
              read(icnv,*,err=999,end=999) tempinitial
          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
              l_string = index(subsection,'  ')-1
              if (l_string.eq.-1.or.l_string.gt.72) then
                 l_string=72
              end if
              write(ilog,*) 'subsection "',subsection(:l_string),   &
     &                   '" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
            
          end if 

          subsection = 'extent of zone'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            read(icnv,*,err=999,end=999) ximin,ximax,yimin,yimax, &
     &                                   zimin,zimax

          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
              l_string = index(subsection,'  ')-1
              if (l_string.eq.-1.or.l_string.gt.72) then
                 l_string=72
              end if
              write(ilog,*) 'subsection "',subsection(:l_string),   &
     &                   '" missing'
              close(ilog)
            end if
            
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if

!c  increment coordinates delineating zone

          ximin = ximin-tiny
          ximax = ximax+tiny
          yimin = yimin-tiny
          yimax = yimax+tiny
          zimin = zimin-tiny
          zimax = zimax+tiny

!c  assign initial condition to global system

          do ivol = 1,nngl

!c  check limits of boundary zone
!c  temp setup
            if ((xg(ivol).gt.ximin).and.(xg(ivol).lt.ximax)) then
              if ((yg(ivol).gt.yimin).and.(yg(ivol).lt.yimax)) then
                if ((zg(ivol).gt.zimin).and.(zg(ivol).lt.zimax)) then
                  ! To account for temperature field data through external file  MX 10.20114
                  if (temp_field) then    
                    tempnew(ivol) = tkel(ivol) - tconv 
                  else
                    tempnew(ivol) = tempinitial
                  end if 
         
                  tempold(ivol) = tempnew(ivol)

                end if      !(zg(ivol).gt.zimin).and.(zg(ivol).lt.zimax)
              end if        !(yg(ivol).gt.yimin).and.(yg(ivol).lt.yimax)
            end if          !(xg(ivol).gt.ximin).and.(xg(ivol).lt.ximax)
          end do



        end do              !end loop over zones

      end if                !initcond_file

!c  write output info to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/3a)') 'for detailed output see file ',    &
     &                       prefix(:l_prfx)//'_0.gsp'
      end if

      goto 1000

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading initial condition for energy', &
     &                ' balance'
        write(ilog,*) 'file "',prefix(:l_prfx),'.ivs"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
