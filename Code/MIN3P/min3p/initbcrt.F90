!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initbcrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initbcrt  
!c ------------------- 
!c
!c boundary conditions (reactive transport)
!c
!c modified with addition of point source boundary and calculation of
!c density of multcomponent source boundary
!c
!c written by:      Uli Mayer - August 21, 96
!c
!c last modified:   Tom Henderson - September 3, 2003
!c                  Sergi Molins - May 2, 2006 
!c                  added 'pn2', 'pch4', pco2', 'pco2x', 'par'
!c                  module phys added for permx, permy, permz, 
!c                  permbrt
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   
!c
!c common:
!c parm.f:   -
!c
!c gen.f:    real*8:
!c           -------
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  * +
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third type b.c. -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  * +
!c                                volumes (gaseous phase)
!c                                third type b.c. -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for * +
!c                                diffusive mass fluxes across 
!c                                boundary
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           dimcv(3,nn)        = dimension of control volumes        + -
!c           gbrt(ng,nbrt)      = gas concentrations in boundary      * +
!c                                control volumes
!c           rwork(:,:)         = real*8 work array                   * *
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           tsrc(nbrt)         = read times - transient source       * +
!c                                chemistry
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           iwork(:)           = integer work array                  * *
!c           iabrt(nbzrt+1)     = pointer array - boundary conditions * +
!c                                (reactive transport)
!c           jabrt(nbrt)        = pointer array - boundary conditions * +
!c                                (reactive transport)
!c           icnv               = unit number, data conversion and    + -
!c                                             temporary storage
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging information  + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           itsrc              = pointer to current target read
!c                                time for updating boundary 
!c                                conditions 
!c                                (reactive transport) 
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           nn                 = total number of control volumes     + -
!c           nbrt               = number of specified boundary        * +
!c                                control volumes
!c           nbzrt              = number of boundary zones            * +
!c                                (reactive transport)
!c           ntsrc              = number of read times for            * +
!c                                transient source chemistry
!c
!c           logical:
!c           --------
!c           explicit_surface   = .true.  -> include surface sites    + -
!c                                           in equilibrium
!c                                           calculations
!c           explicit_surface_ion  = .true.  -> include surface sites + -
!c                                           in equilibrium 
!c                                           calculations
!c                                           of ion-exchange
!c           explicit_surface_surf = .true.  -> include surface sites + -
!c                                           in equilibrium 
!c                                           calculations
!c                                           of surface-complex
!c           implicit_surface   = .true.  -> equilibrate surface      + -
!c                                           sites with fixed
!c                                           solution composition
!c           implicit_surface_ion  = .true.  -> equilibrate surface   + -
!c                                           sites with fixed 
!c                                           solution composition
!c                                           of ion-exchange
!c           implicit_surface_surf = .true.  -> equilibrate surface   + -
!c                                           sites with fixed 
!c                                           solution composition
!c                                           of surface-complex
!c           redox_equil_rt     = .true.  -> equilibrium redox        + -
!c                                           reactions
!c           spec_conc          = .true.  -> source concentrations    * +
!c                                           specified
!c                                .false. -> background
!c                                           concentrations as
!c                                           boundary condition
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_source   = .true.  -> transient source         * +
!c                                           chemistry
!c                                .false. -> constant source
!c                                           chemistry
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    * +
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (free advective mass
!c                                            outflux for aqueous
!c                                            phase)
!c                                'third'  = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase
!c           prefix             = prefix name for all I/O files       + -
!c           section_header     = section header                      * +
!c           zone_name          = name of zone                        * +
!c           
!c
!c chem.f:   real*8:
!c           -------
!c           actv(nc)           = activities of free species          * +
!c                                - new time level
!c           ccnew(nc)          = concentrations of free species      + +
!c                                - new time level [moles/l water]
!c           ccold(nc)          = concentrations of free species      + +
!c                                - old time level [moles/l water]
!c           cgc(ng)            = gas concentrations                  * +
!c                                - new time level [moles/l air]
!c           cxc(nx)            = concentrations of secondary         * +
!c                                aqueous species
!c                                - new time level [moles/l water]
!c           delt_lc(nthreads)  = time step for local chemistry       * +
!c                                computations
!c           gamma_l(nc+nx)     = activity coefficients for aqueous   * *
!c                                species
!c           gfwc(nc)           = gram formula weight of components   + -
!c           phguess            = guess for pH                        * +
!c           tempk              = temperature [deg K]                 + -
!c           totcn(n,nthreads)  = total aqueous component             * +
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totco(n,nthreads)  = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgn(n,nthreads)  = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c
!c           integer*4:
!c           ----------
!c           l_namec(nc)        = length of component names           + -
!c           nc                 = number of components including h2o  + -
!c           ncorder(nc)        = ordering array for components       + -
!c                                ncorder(old order) = new order
!c           ng                 = number of gases                     + -
!c           nr                 = number of redox couples             + -
!c
!c           logical:
!c           --------
!c           reactive_minerals  = .true.  -> consider mineral         * +
!c                                           dissolution-
!c                                           precipitation reactions
!c           redox_equil_lc     = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       * +
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           ctype(nc-1)        = 'charge' = correct total aqueous    * +
!c                                           component concentration
!c                                           for specified component 
!c                                           to satisfy charge balance
!c                                'fixed'  = compute total aqueous
!c                                           component concentrations
!c                                           based on fixed activities
!c                                           of components as species
!c                                           in solution
!c                                'free'   = compute concentrations
!c                                           of components as species
!c                                           in solution based on 
!c                                           specified total aqueous
!c                                           component concentrations
!c                                'ph'    =  pH specified for 'h+1'
!c           input_units        = 'mol/l'                             + -
!c                                'mmol/l'
!c                                'mg/l'
!c                                'g/l'
!c           namec(nc)          = component names                     + -
!c
!c
!c dens.f:   real*8:
!c           -------
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density 
!c                                           dependent flow
!c
!c local:    real*8:
!c           -------
!c           porc               = porosity for local chemistry
!c                                calculations
!c           r1                 = constant
!c           r2                 = constant
!c           r1000              = constant
!c           sgc                = gaseous phase saturation for local
!c                                chemistry calculations
!c           sac                = aqueous phase saturation for local
!c                                chemistry saturations
!c           tiny               = small increment
!c           xbmax              = max. x-coordinate of boundary zone
!c           xbmin              = min. x-coordinate of boundary zone
!c           ybmax              = max. y-coordinate of boundary zone
!c           ybmin              = min. y-coordinate of boundary zone
!c           zbmax              = max. z-coordinate of boundary zone
!c           zbmin              = min. z-coordinate of boundary zone
!c
!c           integer*4:
!c           ----------
!c           ibrt               = counter (boundary control volumes)
!c           ibrt_start         = start of current boundary zone
!c           ibrt_stop          = end of current boundary zone
!c           ibz                = counter (boundary zones)
!c           ierr               = 0 -> memory allocation successful
!c           ic                 = counter (components)
!c           icount             = counter
!c           ig                 = counter (gases)
!c           itemp              = pointer
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit search
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           xy_plane           = boundary zone parallel tp xy-plane
!c           xz_plane           = boundary zone parallel to xz-plane
!c           yz_plane           = boundary zone parallel to yz-plane
!c
!c           character:
!c           ----------
!c           btypezn            = boundary type of zone
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           gcreact   = geochemical reactions for batch system
!c           guess     = guess for concentrations of
!c                       free species
!c           icbcrt    = assign initial or boundary condition
!c                       to global system (reactive transport)
!c           minmaxwd  = determine minimum total aqueous component
!c                       concentrations and maximum secondary aqueous
!c                       species concentration in solution domain
!c           outputlc  = write results of local chemistry
!c                       computations to generic output file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c           rtrvpprm  = retrieve physical parameters
!c           setsize   = define number of primary unknowns
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c ----------------------------------------------------------------------
 
      subroutine initbcrt
 
      use parm
      use gen
      use chem
      use dens
      use phys
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: tid, i, iaq, ic, icount, itemp, ierr, ibz, ibrt,      &
                 ibrt_start, ibrt_stop, ig, itid, ivol, l_string
      
      real*8 :: sac, sgc, porc, xbmin, xbmax, ybmin, ybmax,            &
                zbmin, zbmax, rtemp_scaling, boundary_func

      external checkerr, comptotc, findstrg, findzone,  guess,         &
               icbcrt, outputlc, minmaxwd, readbloc, readzone,         &
               rtrvpprm, setsize, totconc, totconcg, boundary_func,    &
               minmaxwd_mpi
      
      logical xy_plane,xz_plane,yz_plane,found,found_section,          &
              found_subsection
      character*12 btypezn, bctypefunc
      character*72 subsection
      
      logical iserror      
     
      integer, parameter :: iscreen=6
      
      character(len=100) :: msg 

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r2 = 2.0d0,         &
                 r1000 = 1.0d+3, small = 1.0d-7, tiny = 1.d-10,        &
                 tiny_time = 1.0d-5
      
     
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
      
        !>interface of gcreact           
        subroutine gcreact(cnew,cold,cx,gammac,gammax,gnew,sw,sa,por,   &
                        igen,ilog,idbg,tec_header,prefix,l_prfx,        &
                        zone_name,l_zone_name) 
          use parm, only : type_i4, type_r8
          real(type_r8), dimension(*) :: cnew
          real(type_r8), dimension(*) :: cold
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8), dimension(*) :: gnew
          real (type_r8) :: sw
          real (type_r8) :: sa
          real (type_r8) :: por
          integer(type_i4) :: igen
          integer(type_i4) :: ilog
          integer(type_i4) :: idbg
          logical :: tec_header
          character*72 :: prefix
          integer(type_i4) :: l_prfx
          character*72 :: zone_name
          integer(type_i4) :: l_zone_name
        end subroutine
      
      end interface
      logical :: b_fluxd_mixed_bcond_zn
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      xy_plane = .false. 
      xz_plane = .false.
      yz_plane = .false.
      
      dens_h2o = 1.0d+3
      
      msg=' ' 

!c  read section header for boundary conditions (reactive transport)
 
      section_header = 'boundary conditions - reactive transport'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to generic output file
      if(b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a)')('-',i=1,72)
      end if

      if(rank == 0 .and. b_enable_output) then
        write(*,'(/1x,a)') section_header(:l_string)
        write(*,'(1x,72a)')('-',i=1,72)
     
        write(ilog,'(a)') section_header(:l_string)
        write(ilog,'(72a/)')('-',i=1,72)
      end if

!c  control parameters for processing initial condition for minerals
!c  only equilibrium for source chemistry

      reactive_minerals = .false.
      delt_lc(:) = r1
      !implicit_surface = .false.
      !explicit_surface = .false.
      implicit_surface_ion = .false.
      explicit_surface_ion = .false.
      implicit_surface_surf = .false.
      explicit_surface_surf = .false.
      
      b_fluxd_mixed_bcond_zn = .true.

!c  read number of boundary zones

      read(itmp,*,err=999,end=999) nbzrt
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/a,i10)')  &
     &  'number of boundary zones                        = ',nbzrt
      end if

!c  preliminary allocation of memory for boundary conditions
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (bcondrt_a(nc,nngl), stat = ierr)
      bcondrt_a=0.0d0 
      call checkerr(ierr,'bcondrt_a',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (bcondrt_g(nc,nngl), stat = ierr)
      bcondrt_g=0.0d0 
      call checkerr(ierr,'bcondrt_g',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (bdycrt_d(nngl), stat = ierr)
      bdycrt_d=0.0d0 
      call checkerr(ierr,'bdycrt_d',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (zgbrt(nngl), stat = ierr)
      zgbrt=0.0d0 
      call checkerr(ierr,'zgbrt',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (gbrt(ng,nngl), stat = ierr)
      gbrt=0.0d0 
      call checkerr(ierr,'gbrt',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (iabrt(nbzrt+1), stat = ierr)
      iabrt=0 
      call checkerr(ierr,'iabrt',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (jabrt(nngl), stat = ierr)
      jabrt=0 
      call checkerr(ierr,'jabrt',ilog)  
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (btypert(nngl), stat = ierr)
      btypert='undefined'
      call checkerr(ierr,'btypert',ilog)
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (b_fluxd_mixed_bcond(nngl), stat = ierr)
      b_fluxd_mixed_bcond=.true.
      call checkerr(ierr,'b_fluxd_mixed_bcond',ilog)

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (dijbrt(nngl), stat = ierr)
      dijbrt=0.0d0 
      call checkerr(ierr,'dijbrt',ilog) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (permbrt(nngl), stat = ierr)
      permbrt=0.0d0 
      call checkerr(ierr,'permbrt',ilog)  
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (cinfvs_gbrt(nngl), stat = ierr)
      cinfvs_gbrt=0.0d0 
      call checkerr(ierr,'cinfvs_gbrt',ilog)  
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      !transient boundary condition function
      allocate (totco_func(6,nc-1,nbzrt), stat = ierr)
      totco_func=0.0d0
      totco_func(2,:,:) = 1.0d0
      call checkerr(ierr,'totco_func',ilog)
      
      allocate (scalfac_aq_func(6,naq,nbzrt), stat = ierr)
      scalfac_aq_func=0.0d0
      scalfac_aq_func(2,:,:)=1.0d0
      call checkerr(ierr,'scalfac_aq_func',ilog)
      
      allocate (phguess_func(6,nbzrt), stat = ierr)
      phguess_func=0.0d0
      phguess_func(2,:) = 1.0d0
      call checkerr(ierr,'phguess_func',ilog) 
      
      allocate (b_update_zone_func(nbzrt), stat = ierr)
      b_update_zone_func=.false.
      call checkerr(ierr,'b_update_zone_func',ilog)
        
      !transient boundary condition for linear interpolation
      allocate (totco_init(nc-1,nbzrt), stat = ierr)
      totco_init=0.0d0
      call checkerr(ierr,'totco_init',ilog)
      
      allocate (scalfac_aq_init(naq,nbzrt), stat = ierr)
      scalfac_aq_init=0.0d0
      call checkerr(ierr,'scalfac_aq_init',ilog)
      
      allocate (phguess_init(nbzrt), stat = ierr)
      phguess_init=0.0d0
      call checkerr(ierr,'phguess_init',ilog)      
      
      allocate (ctype_bzrt_init(nc-1,nbzrt), stat = ierr)
      ctype_bzrt_init=' ' 
      call checkerr(ierr,'ctype_bzrt_init',ilog)
      
      allocate (spatial_weight_bd_inter(nbzrt), stat = ierr)
      spatial_weight_bd_inter = 0.0d0
      call checkerr(ierr,'spatial_weight_bd_inter',ilog)
      
!c  set default value for ssdens vector
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      if (density_dependence) then
        do ivol = 1, nngl
          ssdens(ivol) = ref_dens
        end do
      end if
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

      transient_source_function = .false. 

!c  initialize counter for boundary control volumes

      iabrt(1) = 1

!c  read number of boundary zones 

      do ibz=1,nbzrt                      !loop over number of zones

        ibrt = iabrt(ibz)-1               !set counter for current zone

!c  find current zone in input file and write to temporary file

        subsection = 'number and name of zone'

        call findzone(subsection,itmp,found_subsection,ibz,zone_name)

        if (found_subsection) then

          call readzone(itmp,icnv,ilog,zone_name,found_subsection)

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error in input file'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define length of zone name

        l_zone_name = index(zone_name,'  ')-1
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
          l_zone_name = 72
        end if

!c  write header for boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/a,i1,a,1x,a)') 'zone ',ibz,':', &
     &                                 zone_name(:l_zone_name)
          write(igen,'(72a)')('-',i=1,72)
        end if
        
        subsection = 'use function for transient boundary input'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then
          b_update_zone_func(ibz) = .true.  
          transient_source_function = .true.
          if (b_enable_output .and. b_enable_output_gen) then
              write(igen,'(/2a,i4)') trim(subsection), "for zone ",ibz
          end if
        end if
        
      
!c  determine interpolation spatial weighting for transient source chemistry is to be used

      subsection = 'spatial weighting of boundary condition interpolation'
!cdsu  Time spatial weighting, [0-1], 0.0d0 is prefered and 1.0 is apt 
!cdsu  to cause occillation. By default, 1 is used as spatial weithting
!cdsu  so as to backward compatible

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then

        read(itmp,*,err=999,end=999) spatial_weight_bd_inter(ibz)
        
        if (spatial_weight_bd_inter(ibz) < 0 .or.                      &
            spatial_weight_bd_inter(ibz) > 1) then
          if (rank == 0) then
            write(*,*) "Error: spatial weighting should be between 0 and 1"
            write(ilog,*) "Error: spatial weighting should be between 0 and 1"            
          end if
          goto 999
        end if
        
      else
          
        spatial_weight_bd_inter(ibz) = 1.0d0

      end if

!c  define type of boundary condition

        subsection = 'boundary type'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          read(icnv,*,err=999,end=999) btypezn

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
            l_string = index(subsection,'  ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
               l_string=72
            end if
            write(ilog,*) 'subsection "',subsection(:l_string), &
     &                 '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define, if background concentrations are to be used as boundary 
!c  condition

        if (btypezn.eq.'first') then

          subsection = 'use background chemistry for boundary zone'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            spec_conc = .false.
          else
            spec_conc = .true.
          end if

        end if

!c  concentration input for current zone
 
        if ((btypezn.eq.'first'.and.spec_conc).or.    &
     &      (btypezn.eq.'third').or.                  &
     &      (btypezn.eq.'mixed') .or.                 &
     &      (btypezn.eq.'point')) then

          if (rank == 0 .and. b_enable_output) then  
            write(ilog,'(a/72a)') zone_name,('-',i=1,72)
          end if

          subsection = 'concentration input'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then

            do ic=1,nc-1

              itemp = ncorder(ic)                     !internal order

              if (component_type(itemp).eq.'aqueous'.or.               &
                  component_type(itemp).eq.'biomass') then

                if (b_update_zone_func(ibz)) then
                  read(icnv,*,err=999,end=999) bctypefunc,             &
                       totco_func(3:6,itemp,ibz),ctype(itemp) 
                  
                  if (trim(bctypefunc)=='polynomial') then
                    totco_func(1,itemp,ibz) = 2.0d0  
                  else if (trim(bctypefunc)=='sine') then
                    totco_func(1,itemp,ibz) = 4.0d0  
                  else
                    if (rank == 0) then
                      write(ilog,*) 'SIMULATION TERMINATED'
                      write(ilog,*) 'error reading input file'
                      write(ilog,*) 'section "',section_header(:l_string),'"'
                      write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                      write(ilog,*) 'unknow boundary function type ',trim(bctypefunc)
                      close(ilog)
                    end if
#ifdef PETSC        
                    call petsc_mpi_finalize
#endif              
                    stop
                  end if
                  
                else
                  read(icnv,*,err=999,end=999) totco(itemp,tid),       &
                       ctype(itemp)
                end if  

!c  -> convert input units to internal units [moles/l]

                rtemp_scaling = 1.0d0

                if (ctype(itemp).ne.'ph'.and.     &
                    ctype(itemp).ne.'eh'.and.     &
                    ctype(itemp).ne.'pe'.and.     &
                    ctype(itemp).ne.'po2'.and.    &
                    ctype(itemp).ne.'pn2'.and.    &
                    ctype(itemp).ne.'pch4'.and.   &
                    ctype(itemp).ne.'pco2x'.and.  &
                    ctype(itemp).ne.'par'.and.    &
                    ctype(itemp).ne.'pco2') then
                  if (input_units.eq.'mmol/l') then
                    rtemp_scaling = rtemp_scaling / r1000
                  elseif (input_units.eq.'mg/l') then
                    rtemp_scaling = rtemp_scaling / r1000 / gfwc(itemp)
                  elseif (input_units.eq.'g/l') then
                    rtemp_scaling = rtemp_scaling / gfwc(itemp)
                  end if
                end if
     
                if (b_update_zone_func(ibz)) then
                  totco_func(2,itemp,ibz) = rtemp_scaling
                  totco(itemp,tid) =                                   &
                        boundary_func(6,totco_func(1:6,itemp,ibz),time)
                end if
                
                totco(itemp,:) = totco(itemp,tid)*rtemp_scaling
                
              end if     

            end do

          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
              l_string = index(subsection,'  ')-1
              if (l_string.eq.-1.or.l_string.gt.72) then
                 l_string=72
              end if
              write(ilog,*) 'subsection "',subsection(:l_string),   &
     &                   '" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if
          
          totco_init(1:nc-1,ibz) = totco(1:nc-1,tid)
          totco_init(1:nc-1,ibz) = totco(1:nc-1,tid)
          ctype_bzrt_init(1:nc-1,ibz) = ctype(1:nc-1)
         
!c  define if diffusive flux is applied for mixed boundary condition
          subsection = 'exclude diffusive flux from mixed boundary condition'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            b_fluxd_mixed_bcond_zn = .false.
          else
            b_fluxd_mixed_bcond_zn = .true.
          end if
          
!c  define guess for pH

          subsection = 'guess for ph'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            if (b_update_zone_func(ibz)) then
              read(icnv,*,err=999,end=999) bctypefunc,phguess_func(3:6,ibz)
              if (trim(bctypefunc)=='polynomial') then
                phguess_func(1,ibz) = 2.0d0  
              else if (trim(bctypefunc)=='sine') then
                phguess_func(1,ibz) = 4.0d0  
              else
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error reading input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unknow boundary function type ',trim(bctypefunc)
                  close(ilog)
                end if
#ifdef PETSC    
                call petsc_mpi_finalize
#endif          
                stop
              end if
              phguess = boundary_func(6,phguess_func(1:6,ibz),time)
            else
              read(icnv,*,err=999,end=999) phguess
            end if
          else
            if (b_update_zone_func(ibz)) then
              phguess_func(3:5,ibz) = 0.0d0
              phguess_func(6,ibz) = 7.0d0
            end if
            phguess = 7.0d0
          end if
          
          phguess_init(ibz) = phguess
         
!c_bubbles - spatial dependent intra-aqueous scaling factors

          subsection = 'scaling for intra-aqueous kinetic reactions'

          call findstrg(subsection,icnv,found_subsection)

          if (found_subsection) then
            if (b_update_zone_func(ibz)) then
              do iaq = 1,naq
                read(icnv,*,err=999,end=999) bctypefunc,               &
                     scalfac_aq_func(3:6,iaq,ibz)
                
                if (trim(bctypefunc)=='polynomial') then
                  scalfac_aq_func(1,iaq,ibz) = 2.0d0  
                else if (trim(bctypefunc)=='sine') then
                  scalfac_aq_func(1,iaq,ibz) = 4.0d0  
                else
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error reading input file'
                    write(ilog,*) 'section "',section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unknow boundary function type ',trim(bctypefunc)
                    close(ilog)
                  end if
#ifdef PETSC      
                  call petsc_mpi_finalize
#endif            
                  stop
                end if                
                scalfac_aq(iaq) = boundary_func(6,scalfac_aq_func(1:6,iaq,ibz),time)                
              end do
            else
              do iaq = 1,naq
                read(icnv,*,err=999,end=999) scalfac_aq(iaq)
              end do
            end if
            
          else
            if (b_update_zone_func(ibz)) then
              do iaq = 1,naq
                scalfac_aq_func(3:5,iaq,ibz) = 0.0d0
                scalfac_aq_func(6,iaq,ibz) = r1
              end do
            end if
            do iaq = 1,naq
              scalfac_aq(iaq) = r1
            end do

          end if
          
          scalfac_aq_init(1:naq,ibz) = scalfac_aq(1:naq)
  
!c  guess for concentrations of free species

          call guess(ccnew,ccold,tempk,ilog)

!c  write input parameters for current zone to generic output file
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(/2a)') 'control parameters: ',zone_name
            write(igen,'(72a/)') ('-',i=1,72)
            
            write(igen,'(a/)') 'equilibration of aqueous species'
            
            write(igen,'(/2a)') 'input parameters: ',zone_name
            write(igen,'(72a)')('-',i=1,72)
            
            write(igen,'(/a)')'total aqueous component concentrations:'
            write(igen,'(a)')'---------------------------------------'
            write(igen,'(a)')'component             conc.'
            write(igen,'(a)')'---------------------------'
            do ic=1,nc-1
              if (component_type(ic).eq.'aqueous'.and.      &
     &            ctype(ic).eq.'free') then
                  write(igen,'(a12,1x,1pe15.4)') namec(ic),totco(ic,tid)
              end if
            end do
            
            icount = 0
            do ic=1,nc-1
              if (ctype(ic).eq.'fixed') then
                icount = icount+1
                if (icount.eq.1) then
                  write(igen,'(/a)')'fixed activities:'
                  write(igen,'(a)')'------------------'
                  write(igen,'(a)')'species               actv.'
                  write(igen,'(a)')'---------------------------'
                end if
                write(igen,'(a12,1x,1pe15.4)') namec(ic),actv(ic)
              end if
            end do
            
            do ic=1,nc-1
              if (ctype(ic).eq.'charge') then
                write(igen,'(/3a)')'total aqueous component ',      &
     &                             'concentrations of component ',  &
     &                              namec(ic)(:l_namec(ic))
                write(igen,'(a)')'to be determined by charge balance'
              end if
            end do          
          end if
          
!c  biomass concentrations

          if (nbio.gt.0) then
            if (b_enable_output .and. b_enable_output_gen) then
              write(igen,'(/a)')'biomass concentrations:'
              write(igen,'(a)')'-----------------------'
              write(igen,'(a)')'component             conc.'
              write(igen,'(a)')'---------------------------'
              do ic=1,nc-1
                if (component_type(ic).eq.'biomass'.and.                &
     &              ctype(ic).eq.'free') then
                    write(igen,'(a12,1x,1pe15.4)') namec(ic),           &
                          totco(ic,tid)
                end if
              end do
            end if
          end if

!c  guess for pH
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(/a,f8.4)')                                 &
     &      'guess for pH of solution:          pH =', phguess
          end if

!c  set number of primary unknowns for current batch problem

          call setsize(redox_equil_lc)

!c  retrieve physical parameters for scaling

          call rtrvpprm(sac,sgc,porc,section_header)

!c  temperature correction
          if (temp_field.or.heat_transport) then
            call tcorr(tempk)
          end if

!c  compute concentration distribution at boundary

          call gcreact(ccnew,ccold,cxc,gamma_l(1),gamma_l(nc+1),      &
     &                 cgc,sac,sgc,porc,igen,ilog,idbg,tec_header,    &
     &                 prefix,l_prfx,zone_name,l_zone_name)

!c  determine minimum total aqueous component concentrations and maximum
!c  secondary aqueous species concentration in solution domain

          call minmaxwd(cxc,totcn(:,tid))

#ifdef PETSC
          call minmaxwd_mpi
#endif

!c  write results to generic output file

          if(b_enable_output .and. b_enable_output_gen)  then
            call outputlc(ccnew,cxc,gamma_l(1),gamma_l(nc+1),          &
     &                    cgc,igen,ilog,section_header)
          end if

        end if


!c  assign boundary condition to control volumes located in boundary zone

!c  read coordiantes defining boundary zone

        subsection = 'extent of zone'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,       &
     &                                 zbmin,zbmax

        elseif (.not.found_subsection) then
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "', section_header(:l_string),'"'
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
            l_string = index(subsection,'  ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
               l_string=72
            end if
            write(ilog,*) 'subsection "',subsection(:l_string),         &
     &                 '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define boundary face to be considered (only needed for calculation
!c  of boundary face area for second type boundary conditions)

        if (btypezn.eq.'mixed') then

          found = .false.
          xy_plane = .false.
          xz_plane = .false.
          yz_plane = .false.

          if (dabs(zbmax-zbmin).lt.tiny) then     !xy_plane
            if ((dabs(xbmax-xbmin).lt.tiny).or.                       &
     &          (dabs(ybmax-ybmin).lt.tiny)) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            else
              xy_plane = .true.
              found = .true.
            end if
          end if

          if (.not.found) then                     !xz_plane
            if (dabs(ybmax-ybmin).lt.tiny) then
              if ((dabs(xbmax-xbmin).lt.tiny).or.                     &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                xz_plane = .true.
                if (xy_plane) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                          &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

          if (.not.found) then                     !yz_plane
            if (dabs(xbmax-xbmin).lt.tiny) then
              if ((dabs(ybmax-ybmin).lt.tiny).or.                     &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                yz_plane = .true.
                if (xy_plane.or.xz_plane) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                          &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

!c  exit if boundary face was not found

          if (.not.found) then
            if (rank == 0) then  
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
              write(ilog,*) 'unable to specify boundary face'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

        end if                    !(btypezn.eq.'mixed')

!c  increment boundary coordinates

        xbmin = xbmin-tiny
        xbmax = xbmax+tiny
        ybmin = ybmin-tiny
        ybmax = ybmax+tiny
        zbmin = zbmin-tiny
        zbmax = zbmax+tiny

        do ivol = 1,nngl         !loop over control volumes

!c  check limits of boundary zone

          if ((xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)) then
            if ((yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)) then
              if ((zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) then

                ibrt = ibrt+1
                
                if(ibrt > nngl) then
                  if (rank == 0) then  
                    write(ilog,*) 'Error in setting boundary conditions'
                    write(ilog,*) 'Check duplicated boundary volumes.'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if    

!c  assign pointer arrays and and boundary type

                jabrt(ibrt) = ivol

                btypert(ivol) = btypezn
                
                b_fluxd_mixed_bcond(ivol) = b_fluxd_mixed_bcond_zn

                if (btypert(ivol).eq.'mixed') then

!c  calculate boundary influence coefficient for diffusive mass
!c  fluxes across boundary

                  if (xy_plane) then
                    bdycrt_d(ibrt) = r2 * dimcv(1,ivol)               &
     &                             * dimcv(2,ivol) / dimcv(3,ivol)
                    permbrt(ibrt)     = permz(ivol)            
                    cinfvs_gbrt(ibrt) = permbrt(ibrt)                 &
     &                                * dimcv(1,ivol) * dimcv(2,ivol) &
     &                                / dimcv(3,ivol) ! * r2

                    dijbrt(ibrt)      = dimcv(3,ivol) ! / r2 
                  elseif (xz_plane) then      
                    bdycrt_d(ibrt) = r2 * dimcv(1,ivol)               &
     &                             * dimcv(3,ivol) / dimcv(2,ivol)
                    permbrt(ibrt)     = permy(ivol)
                    cinfvs_gbrt(ibrt) = permbrt(ibrt)                 &
     &                                * dimcv(1,ivol) * dimcv(3,ivol) &
     &                                / dimcv(2,ivol) ! * r2

                    dijbrt(ibrt)      = dimcv(2,ivol) ! / r2
                  elseif (yz_plane) then
                    bdycrt_d(ibrt) = r2 * dimcv(2,ivol)               &
     &                             * dimcv(3,ivol) / dimcv(1,ivol)
                    permbrt(ibrt)     = permx(ivol)
                    cinfvs_gbrt(ibrt) = permbrt(ibrt)                 &
     &                                * dimcv(2,ivol) * dimcv(3,ivol) &
     &                                / dimcv(1,ivol) ! * r2

                    dijbrt(ibrt)      = dimcv(1,ivol) ! / r2
                  end if
                  
                  if (abs(zg(ivol)-zbmax).lt.small) then
                    zgbrt(ibrt) = zg(ivol) + dimcv(3,ivol) ! / r2
                  else
                    zgbrt(ibrt) = zg(ivol) - dimcv(3,ivol) ! / r2
                  endif
                  
                end if

              end if      !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
            end if        !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
          end if          !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do            !loop over control volumes

!c  define pointer to next boundary zone

        iabrt(ibz+1) = ibrt+1

!c  write extent and type of boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/2a)') 'extent of ',zone_name(:l_zone_name)
          write(igen,'(72a/)')('-',i=1,72)
          write(igen,'(a,3x,a/)') 'volume','boundary type'
        end if

        ibrt_start = iabrt(ibz)
        ibrt_stop = iabrt(ibz+1)-1

        if (b_enable_output .and. b_enable_output_gen) then
          do ibrt = ibrt_start,ibrt_stop
            ivol = jabrt(ibrt)
            write(igen,'(i6,3x,a12)') ivol,btypert(ivol)
          end do
        end if

!c  assign boundary conditions to global system

        do ibrt = ibrt_start,ibrt_stop              !boundary zone

          ivol = jabrt(ibrt)                        

!c  first type boundary condition (specified source concentrations 
!c  in terms of free species concentrations)

          if (btypert(ivol).eq.'first'.and.spec_conc) then

            do ic=1,nc
              bcondrt_a(ic,ibrt) = ccnew(ic)
            end do
            call icbcrt(ivol,1)

            if (density_dependence) then
              tot_tds = r0
              do ic=1,nc-1
              itemp = ncorder(ic)                 !internal order
              tds_ic = bcondrt_a(ic,ibrt) * gfwc(itemp) ! M/L --> g/L = Kg/M^3
                tot_tds = tot_tds + tds_ic
              end do
                !cprovi------------------------------------------------       
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
               if (ispitzerdens) then                   
                !cprovi------------------------------------------------
                !cprovi Allocate local pointers 
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
                !cprovi Copy the molalities in the local vector 
                !cprovi------------------------------------------------
                  cpz_loc(1:nc)=ccnew(1:nc)
                  cpz_loc(nc+1:nc+nx)=cxc(1:nx)  
                call compute_density_ (phase,0.0d0,0.0d0,cpz_loc,       &
                                      ssdens(ivol),.false.,iserror)
                if (iserror) then 
                 msg='Error when call compute_density_ in the phase object'
                 goto 10 
                end if
              else
                 ssdens(ivol) = ref_dens + drho_dc * tot_tds
              end if 
                   
            
            continue
           end if 

!c  first type boundary condition (background concentrations in terms
!c  of free species concentrations)

          elseif ((btypert(ivol).eq.'first').and.(.not.spec_conc)) then

            do ic = 1,nc
              bcondrt_a(ic,ibrt) = cnew(ic,ivol)
            end do

!c  assign boundary condition for density dependent flow
            if (density_dependence) then
              tot_tds = r0
              do ic=1,nc-1
              itemp = ncorder(ic)                 !internal order
              tds_ic = bcondrt_a(ic,ibrt) * gfwc(itemp) ! M/L --> g/L = Kg/M^3
                tot_tds = tot_tds + tds_ic
              end do
                !cprovi------------------------------------------------       
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
               if (ispitzerdens) then                   
                !cprovi------------------------------------------------
                !cprovi Copy the molalities in the local vector 
                !cprovi------------------------------------------------
                   cpz_loc(1:nc)=cnew(1:nc,ivol)
                   cpz_loc(nc+1:nc+nx)=cx(1:nx,ivol)  
                 call compute_density_ (phase,0.0d0,0.0d0,cpz_loc,      &
                                      ssdens(ivol),.false.,iserror)
                 if (iserror) then 
                 msg='Error when call compute_density_ in the phase object'
                 goto 10 
                 end if
              else
                 ssdens(ivol) = ref_dens + drho_dc * tot_tds
              end if
            
           end if     

!c  third type boundary condition (specified source concentrations 
!c  in terms of total aqueous component concentrations)

          elseif ((btypert(ivol).eq.'third').or.      &
     &      (btypezn.eq.'point')) then

!c  compute total aqueous component concentrations

            call totconc(ccnew,cxc,totcn(:,tid))

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil_rt.and.nr.gt.0) then
              call comptotc(totcn(:,tid))
            end if

!c  assign boundary condition for density dependent flow
            if (density_dependence) then
              tot_tds = r0
              do ic=1,nc-1
                bcondrt_a(ic,ibrt) = totcn(ic,tid)   !total aqueous component
                itemp = ncorder(ic)                 !internal order
                tds_ic = bcondrt_a(ic,ibrt) * gfwc(itemp) ! M/L --> g/L = Kg/M^3
                tot_tds = tot_tds + tds_ic
              end do
                !cprovi------------------------------------------------       
                !cprovi------------------------------------------------
                !cprovi------------------------------------------------
               if (ispitzerdens) then                   
                !cprovi------------------------------------------------
                !cprovi Copy the molalities in the local vector 
                !cprovi------------------------------------------------
                  cpz_loc(1:nc)=ccnew(1:nc)
                  cpz_loc(nc+1:nc+nx)=cxc(1:nx)  
                call compute_density_ (phase,0.0d0,0.0d0,cpz_loc,        &
                                        ssdens(ivol),.false.,iserror) 
                 if (iserror) then 
                 msg='Error when call compute_density_ in the phase object'
                 goto 10 
                end if
              else
                 ssdens(ivol) = ref_dens + drho_dc * tot_tds
              end if 
            
           else 
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi I was added by Sergio Andres Bea Jofre
!cprovi----------------------------------------------------------------               
              do ic=1,nc-1
                bcondrt_a(ic,ibrt) = totcn(ic,tid)   !total aqueous component
              end do
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------            
           end if      
           
!cdsu------------------------------------------------------------------
!cdsu  Sync data for other slave threads
!cdsu------------------------------------------------------------------
           do itid = 1, nthreads
             totcn(:,itid) = totcn(:,tid)
           end do

!c  mixed type boundary condition (specified source concentrations 
!c  in terms of total aqueous component concentrations and total
!c  gaseous component concentrations, also assign gas concentrations
!c  for mass balance calculations)

          elseif (btypert(ivol).eq.'mixed') then

!c  compute total aqueous component concentrations

            call totconc(ccnew,cxc,totcn(:,tid))

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil_rt.and.nr.gt.0) then
              call comptotc(totcn(:,tid))
            end if

!c  assign boundary condition

            do ic=1,nc-1
              bcondrt_a(ic,ibrt) = totcn(ic,tid)   !total aqueous component
            end do                             !concentrations

            if (ng.gt.0) then

!c  compute total gaseous component concentrations

              call totconcg(cgc,totgn(:,tid))

!c  compress total gaseous component concentration vector in case
!c  of redox equilibrium reactions

              if (redox_equil_rt.and.nr.gt.0) then
                call comptotc(totgn(:,tid))
              end if

!c  assign boundary condition

              do ic=1,nc-1
                bcondrt_g(ic,ibrt) = totgn(ic,tid) !total gaseous component
              end do                               !concentrations
              do ig = 1,ng
                gbrt(ig,ibrt) = cgc(ig)        !gas concentrations
              end do
            end if
            
!cdsu------------------------------------------------------------------
!cdsu  Sync data for other slave threads
!cdsu------------------------------------------------------------------
           do itid = 1, nthreads
             totcn(:,itid) = totcn(:,tid)
             totgn(:,itid) = totgn(:,tid)
           end do

          end if                               !boundary type

        end do                                 !boundary zone

      end do                              !number of zones

!c  define absolute number of boundary control volumes

      nbrt = iabrt(nbzrt+1)-1

!c  minimize memory requirement for boundary arrays

!c  array bcondrt_a

      allocate (rwork(nc,nbrt), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ic = 1,nc
        do ibrt = 1,nbrt
          rwork(ic,ibrt) = bcondrt_a(ic,ibrt)
        end do
      end do

      deallocate (bcondrt_a, stat = ierr)
      call checkerr(ierr,'bcondrt_a',ilog)

      allocate (bcondrt_a(nc,nbrt), stat = ierr)
      call checkerr(ierr,'bcondrt_a',ilog)

      do ic = 1,nc
        do ibrt = 1,nbrt
          bcondrt_a(ic,ibrt) = rwork(ic,ibrt)
        end do
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array bcondrt_g

      allocate (rwork(nc,nbrt), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ic = 1,nc
        do ibrt = 1,nbrt
          rwork(ic,ibrt) = bcondrt_g(ic,ibrt)
        end do
      end do

      deallocate (bcondrt_g, stat = ierr)
      call checkerr(ierr,'bcondrt_g',ilog)

      allocate (bcondrt_g(nc,nbrt), stat = ierr)
      call checkerr(ierr,'bcondrt_g',ilog)

      do ic = 1,nc
        do ibrt = 1,nbrt
          bcondrt_g(ic,ibrt) = rwork(ic,ibrt)
        end do
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array gbrt

      allocate (rwork(ng,nbrt), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ig = 1,ng
        do ibrt = 1,nbrt
          rwork(ig,ibrt) = gbrt(ig,ibrt)
        end do
      end do

      deallocate (gbrt, stat = ierr)
      call checkerr(ierr,'gbrt',ilog)

      allocate (gbrt(ng,nbrt), stat = ierr)
      call checkerr(ierr,'gbrt',ilog)

      do ig = 1,ng
        do ibrt = 1,nbrt
          gbrt(ig,ibrt) = rwork(ig,ibrt)
        end do
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array bdycrt_d

      allocate (rwork(nbrt,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ibrt = 1,nbrt
        rwork(ibrt,1) = bdycrt_d(ibrt)
      end do

      deallocate (bdycrt_d, stat = ierr)
      call checkerr(ierr,'bdycrt_d',ilog)

      allocate (bdycrt_d(nbrt), stat = ierr)
      call checkerr(ierr,'bdycrt_d',ilog)

      do ibrt = 1,nbrt
        bdycrt_d(ibrt) = rwork(ibrt,1)
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array jabrt

      allocate (iwork(nbrt), stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      do ibrt = 1,nbrt
        iwork(ibrt) = jabrt(ibrt)
      end do

      deallocate (jabrt, stat = ierr)
      call checkerr(ierr,'jabrt',ilog)

      allocate (jabrt(nbrt), stat = ierr)
      call checkerr(ierr,'jabrt',ilog)

      do ibrt = 1,nbrt
        jabrt(ibrt) = iwork(ibrt)
      end do

      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      
!c  array permbrt

      allocate (rwork(nbrt,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ibrt = 1,nbrt
        rwork(ibrt,1) = permbrt(ibrt)
      end do

      deallocate (permbrt, stat = ierr)
      call checkerr(ierr,'permbrt',ilog)

      allocate (permbrt(nbrt), stat = ierr)
      call checkerr(ierr,'permbrt',ilog)

      do ibrt = 1,nbrt
        permbrt(ibrt) = rwork(ibrt,1)
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array cinfvs_gbrt

      allocate (rwork(nbrt,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ibrt = 1,nbrt
        rwork(ibrt,1) = cinfvs_gbrt(ibrt)
      end do

      deallocate (cinfvs_gbrt, stat = ierr)
      call checkerr(ierr,'cinfvs_gbrt',ilog)

      allocate (cinfvs_gbrt(nbrt), stat = ierr)
      call checkerr(ierr,'cinfvs_gbrt',ilog)

      do ibrt = 1,nbrt
        cinfvs_gbrt(ibrt) = rwork(ibrt,1)
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)
      
!c  array iupsgbrt
      
      allocate (iupsgbrt(nbrt), stat = ierr)
      call checkerr(ierr,'iupsgbrt',ilog)

      do ibrt=1,nbrt
        iupsgbrt(ibrt)='a'
      enddo

!c  clear array ctype for transport calculations

      do ic = 1,nc-1
        ctype(ic) = 'free'
      end do

!c  determine if transient source chemistry is to be used

      subsection = 'update boundary conditions'

      call findstrg(subsection,itmp,found_subsection)

!c  read number of target times, target times and convert 
!c  time units of target times to internal time units [days]

      if (found_subsection) then

        transient_source = .true.

        read(itmp,*,err=999,end=999) ntsrc

        allocate (tsrc(ntsrc+1), stat = ierr)
        tsrc=0.0d0
        call checkerr(ierr,'tsrc',ilog)

        do itsrc = 1,ntsrc
          read(itmp,*,err=999,end=999) tsrc(itsrc)
          tsrc(itsrc) = time_factor * tsrc(itsrc)
        end do
        tsrc(ntsrc+1) = tfinal+tiny_time

!c  define pointer to first target time for reading source chemistry

        itsrc = 1

      else

        transient_source = .false.

      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
10    continue 
      if (rank == 0) then
        write (ilog,*) msg
        write (iscreen,*) msg
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
      end
