!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/cvolume.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine cvolume
!c ------------------
!c
!c compute volumes on a nodal basis for a block discretization
!c
!c written by:      Uli Mayer - June 10, 96 
!c
!c last modified:   Tom Henderson - April 7,2005
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           delx(nvx)          = spatial increment in x-direction    + -
!c           dely(nvy)          = spatial increment in y-direction    + -
!c           delz(nvz)          = spatial increment in z-direction    + -
!c           cvol(nn)           = nodal volumes                       * +
!c
!c           integer*4:
!c           ----------
!c           nvx                = number of control volumes in        + - 
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c
!c local:    integer*4:
!c           ----------
!c           ivx                = counter (number of control volumes
!c                                in x-direction)
!c           ivy                = counter (number of control volumes
!c                                in y-direction)
!c           ivz                = counter (number of control volumes
!c                                in z-direction)
!c           ivol               = pointer (current control volume)
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine cvolume
 
      use parm
      use gen
#ifdef OPENMP
      use omp_lib
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      real, parameter  ::                 &
          pi = 3.141592653589790E+00,     &
          r2=2.0d0,                       &
          rhalf=0.5d0
      
#ifdef OPENMP      
      integer :: nvols
#endif
      integer :: info_dbg, ivol, ivx, ivy, ivz 
     
      info_dbg = 0

!c  optional radial coordinates
!c  see infcvs.f
    


!c  loop over control volumes  
 
      ivol = 0
      

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_cvolume_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, ivx, ivy, ivz)
    !$omp do schedule(static)
#endif 
      do ivz = nvzgls,nvzgle                  ! number of control volumes in z
        do ivy = nvygls,nvygle                ! number of control volumes in y 
          do ivx = nvxgls,nvxgle              ! number of control volumes in x

!c  pointer to current control volume
#ifdef OPENMP
            ivol = (ivz-nvzgls)*nvygl*nvxgl + (ivy-nvygls)*nvxgl +     &
                    ivx-nvxgls+1 
#else
            ivol = ivol+1
#endif

!c  calculate volume
 
            cvol(ivol) = delx(ivx)*dely(ivy)*delz(ivz)

!c correct for radial coord
            if (radial_coord) then
              if (half_cells) then
                if (ivx .eq. 1) then

!----------------------------------old------------------------------------------
!                !cvol(ivol) = pi*delx(ivx)*delx(ivx)*delz(ivz)
!                 cvol(ivol) = pi*rhalf*delx(ivx)*delx(ivx)  &
!                               *delz(ivz)
!              elseif (ivx .eq. nvx) then
!   !               cvol(ivol) = r2*pi*
!   !  &                (xg(ivol)-rhalf*delx(ivx))*delx(ivx)*delz(ivz)
!                   cvol(ivol) = r2*pi*xg(ivol)*delx(ivx)*delz(ivz)
!              else ! full cell in xx direction
!               ! cvol(ivol) = r2*pi*xg(ivol)*delx(ivx)*delz(ivz)
!                 cvol(ivol) = r2*pi*xg(ivol)*rhalf*(delx(ivx-1)+delx(ivx))&
!                               *delz(ivz)
!----------------------------------old-------------------------------------------                 

!----------------------------------M. Xie, 2012-12-07-----------------------------
                cvol(ivol) = pi*delx(ivx)*delx(ivx)*delz(ivz)
                ! cvol(ivol) = pi*rhalf*delx(ivx)*delx(ivx) 
  !   &                          *delz(ivz)
                elseif (ivx .eq. nvxgbl) then
                  cvol(ivol) = r2*pi*                                   &
     &                (xg(ivol)-rhalf*delx(ivx))*delx(ivx)*delz(ivz)
   !                cvol(ivol) = r2*pi*xg(ivol)*delx(ivx)*delz(ivz)
                else ! full cell in xx direction
                cvol(ivol) = r2*pi*xg(ivol)*delx(ivx)*delz(ivz)
               !  cvol(ivol) = r2*pi*xg(ivol)*rhalf*(delx(ivx-1)+delx(ivx))
  !   &                          *delz(ivz)                 
 !----------------------------------M. Xie, 2012-12-07-----------------------------
                end if
              else ! full cells
                cvol(ivol) = r2*pi*xg(ivol)*delx(ivx)*delz(ivz)
              end if
            end if
          continue

          end do                      ! number of increments in x
        end do                        ! number of increments in y
      end do                          ! number of increments in z
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

      info_dbg = 0
      if (info_dbg .gt. 0) then
        if (b_enable_output .and. b_enable_output_gen) then          
        write(igen,'(2a)') "  ivol   ivx   ivy   ivz              xg", &
              "              yg              zg            cvol"
        ivol = 0
        do ivz = nvzgls,nvzgle                  ! number of control volumes in z
          do ivy = nvygls,nvygle                ! number of control volumes in y 
            do ivx = nvxgls,nvxgle              ! number of control volumes in x    
              ivol = ivol+1
              write(igen,'(4i6,4(1x,es15.7))') ivol,ivx,ivy,ivz,      &
                    xg(ivol),yg(ivol),zg(ivol),cvol(ivol) 
            end do                
          end do                 
        end do
        end if
        
        if (info_dbg .gt. 1) then
          if (rank == 0) then
            write(ilog,*) 'program stopped by dbg in cvolume.f'
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if
      info_dbg = 0

      return
      end
