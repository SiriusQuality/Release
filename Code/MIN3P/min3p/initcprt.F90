!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initcprt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcprt
!c -------------------
!c
!c control parameters for reactive transport
!c
!c written by:      Uli Mayer - May 12, 96
!c
!c last modified:   Uli Mayer - November 22, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           dinc_rt            = factor to compute increment for     * +
!c                                numerical differentiation
!c           srelfac_rt         = underrelaxation factor              * +
!c                                (reactive transport)
!c           tol_rt             = convergence tolerance               * +
!c                                (reactive transport)
!c           por_thresh_max     = maximum porosity threshold          * +
!c                                avoid division by 0 in 
!c                                Kozeny-Carman equation
!c           por_thresh_min     = minimum porosity threshold          * +
!c           permfac_thresh_max = maximum permeability factor threshold  * +
!c           permfac_thresh_min = minimum permeability factor threshold  * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     * +
!c                                             file
!c           igen               = unit number, generic output file    * +
!c           ilog               = unit number, log file               * +
!c           itmp               = unit number, temporary storage      * +
!c           maxit_rt           = max. number of iterations           * +
!c                                (reactive transport)
!c           level_rt           = incomplete factorization level      * +
!c
!c           logical:
!c           --------
!c           mass_balance_rt    = .true.  -> compute mass balance     * +
!c                                           (reactive tramsport)
!c           rcm_ordering_rt    = .true.  -> rcm ordering for         * +
!c                                           n-d scalar matrix
!c           redox_equil_rt     = .true,  -> equilibrium redox        * +
!c                                           reactions
!c           sparse_blocks      = .true.  -> make use of sparsity     * +
!c                                           of block matrices
!c           tortuosity_corr    = .true.  -> Millington-Quirk         * +
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c           under_relax_rt     = .true.  -> underrelaxation          * +
!c           update_activity_rt = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c           update_porosity    = .true.  -> update porosity as       * +
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   * +
!c                                           a function of porosity
!c           gas_advection      = .true.  -> include gas advection    * +
!c           cum_molfrac        = .true.  -> .gs2 outout in terms     * +
!c                                           of cummulative molar fr 
!c           gas_gravity        = .true.  -> enable gas gravity term  * +
!c                                           in gas transport
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c           spatial_weighting  = 'upstream' -> upstream weigthing    * +
!c                                'centered' -> centered weighting
!c                                'vanleer' -> Van Leer flux limiter
!c                                              (upstream-downstream)
!c                                'vanleer2' -> Van Leer flux limiter
!c                                              (upstream-centered)
!c
!c chem.f:   real*8:
!c           -------
!c           degas_rate         = rate constant for degassing         * +
!c
!c                                [mol L^-^1 h2o s^-^1]
!c           integer*4:
!c           ----------
!c           nr                 = number of redox couples             + -
!c
!c           logical:
!c           --------
!c           gas_removal        = .true.  -> degassing occurs, if     * +
!c                                           gas pressure above
!c                                           confining pressure
!c
!c           character:
!c           ----------
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c           update_activity_lc = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (local chemistry)
!c
!c dual.f:   logical:
!c           --------
!c           dual_porosity      = .true.  -> dual porosity            * + 
!c                                           simulation 
!c
!c
!c bbls.f:      logical
!c           --------
!c             gas_bubbles        =.true. -> gas phase saturation       * -
!c                                   is calculated below the water table
!c
!c multidiff.f90
!c            character:
!c           -------
!c           type_averaging_De   = types of diffusion coefficient averaging 
!c                'harmonic' - harmonic averaging  
!c                'arithmetic' - arithmetic averaging  
!c                'no averaging' - no averaging  
!c           logical:
!c           --------
!c         averaging_diffusion = .true. -> averaging diffusion coefficient

!c local:    real*8:
!c           -------
!c           r86400             = conversion factor
!c
!c           integer*4:
!c           ----------
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to 
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcprt
 
      use parm
      use gen
      use chem
      use dual
      use bbls
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use solver_snes_common, only : stencil_width
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, l_string
      
      real*8 :: value_tau
      
      integer :: tid

      external findstrg, readbloc

      real*8, parameter :: r86400 = 8.64d4

      logical found_section, found_subsection
      character*72 subsection
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
 
!c  read control parameters for reactive transport
!c  and write to temporary file
   
      section_header = 'control parameters - reactive transport'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for control parameters for reactive transport

!c  general control parameters

      dual_porosity = .false.
      redox_equil_rt = .true.
      mass_balance_rt = .true.
      spatial_weighting = 'upstream'
      update_activity(:) = 'time_lagged'
      if (update_activity(tid).eq.'time_lagged') then
        update_activity_rt = 'time_lagged'
        update_activity_lc = 'double_update'
      end if
      tortuosity_corr = .true.
      gas_tortuosity = 'same as aqueous'
      gas_removal = .false.
      update_porosity = .false.
      update_permeability = .false.
      por_thresh_max = 1.0d0
      por_thresh_min = 0.0d0
      permfac_thresh_max = 1.0d200
      permfac_thresh_min = 0
      tau_fac = 1.0d0

!c  Newton iteration

      dinc_rt = 1.0d-4
      iter_rt_ant = 12
      maxit_rt = 15 
      urtant_log = 0.5d0
      urtlim_log = 1.0d0
      tol_rt = 1.0d-6

!c  underrelaxation

      under_relax_rt = .false.
      srelfac_rt = 1.0d0

!c  sparse block matrices

      sparse_blocks = .true.

!c  solver settings

      level_rt = 0
      msolvit_rt = 100
      idetail_rt = 1
      restol_rt = 0.1d0 * tol_rt
      deltol_rt = 0.1d0 * tol_rt
      if(i_solver_type_react == 0) then
        rcm_ordering_rt = .true.
      else
        rcm_ordering_rt = .false.
      end if

!c  read in control parameters for reactive transport

      if (found_section) then

!c  read control parameters for reactive transport

!c  general control parameters

!c  dual porosity simulation

        subsection = 'dual porosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          dual_porosity = .true.
        end if

!c  type of redox reactions

        subsection = 'redox reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nr.gt.0) then
            read(itmp,*,err=999,end=999) redox_equil_rt
          end if
        end if

!c  mass balance settings - new definition

        subsection = 'mass balance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_rt = .true.
        else
          mass_balance_rt = .false.
        end if
        
!c  mass balance settings - old definition

        subsection = 'mass balance settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) mass_balance_rt
        end if


!c  stpatial averaging type for canculation diffusion coefficients

        subsection = 'averaging diffusion'
        averaging_diffusion=.false. 
        no_average=.false.
        type_averaging_De=' ' 
        call findstrg(subsection,itmp,found_subsection)
        
        if (.not. found_subsection) then
          subsection = 'spatial averaging - diffusion'
          call findstrg(subsection,itmp,found_subsection)
        end if

        if (found_subsection) then
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'harmonic') then
            averaging_diffusion = .true.
            type_averaging_De='harmonic'
          elseif (subsection.eq.'arithmetic') then  ! De averaging done with por_av
            averaging_diffusion = .true.
            type_averaging_De='arithmetic'
          elseif (subsection.eq.'arithmetic De') then ! De averaging done with De_av
            averaging_diffusion = .true.
            type_averaging_De='arithmetic De'            
          elseif (subsection.eq.'no averaging') then
            averaging_diffusion = .false.
            type_averaging_De='no averaging'
            no_average=.true.
          else
            if (rank == 0) then  
              write(ilog,*) 'Sapatial Averaging Type of Diffusion coefficient not recognized'
              write(*,*) 'Sapatial Averaging Type of Diffusion coefficient not recognized'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
          end if
        end if
        
!c    added by Danyang Su, 2014
      gas_advection=.false.
      subsection = 'gas advection'
      call findstrg(subsection,itmp,found_subsection)
      
      if (found_subsection) then
          gas_advection=.true.
          if (rank == 0 .and. b_enable_output) then              
            write(ilog,'(a)') 'gas advection is included'
          end if
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(a)') 'gas advection is included'
          end if
      else 
          gas_advection=.false.
          if (rank == 0 .and. b_enable_output) then
            write(ilog,'(a)') 'gas advection is ignored'
          end if
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(a)') 'gas advection is ignored'
          end if
      end if
      
!c    added by Danyang Su, 2014
      subsection = 'cumulative mole fractions'
           
      call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          cum_molfrac = .true.
        else 
          cum_molfrac = .false.
        end if
      
!c    added by Danyang Su, 2014
      gas_gravity=.false.
       subsection = 'enable gravity for gas phase'           
      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
          gas_gravity=.true.
      else 
          gas_gravity=.false.
      end if

!c  write fluxes in output files

      subsection = 'output fluxes'

      call findstrg(subsection,itmp,found_subsection)

      if (found_subsection) then
          flux_out = .true.
      else
          flux_out = .false.
      end if
        
!c  type of spatial weighting

        subsection = 'spatial weighting'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) spatial_weighting
          if (spatial_weighting.eq.'van leer') then
            spatial_weighting = 'vanleer'
#ifdef PETSC
            if (nprcs > 1 .and. stencil_width < 2) then
              if (rank == 0) then
                write(*,'(2a)')"Error: van leer spatial weighting ",   &
                      "requires stencil width 2 or larger"
                write(ilog,'(2a)')"Error: van leer spatial weighting ",&
                      "requires stencil width 2 or larger"
                close(ilog)
              end if
              call petsc_mpi_finalize
              stop
            end if
#endif
          end if


          if (spatial_weighting.ne.'upstream'.and.        &
     &        spatial_weighting.ne.'centered'.and.        &
     &        spatial_weighting.ne.'vanleer'.and.         &
     &        spatial_weighting.ne.'vanleer2') then
            if (rank == 0) then  
              write(ilog,'(a)')                           &
     &        'error reading subsection "spatial weighting"'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
        end if

!cprovi----------------------------------------------------------
!c  compute harmonic average in porosity
!cprovi----------------------------------------------------------

        subsection = 'harmonic average in porosity'
        harmonic_porosity=.false.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          harmonic_porosity=.true.
        end if
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------

!c  update porosity

        subsection = 'update porosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            update_porosity = .true.
          end if
        end if
        
!c  porosity threshold, this value is set to avoid division by 0 in Kozeny-Carman equation

        subsection = 'porosity threshold'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            read(itmp,*,err=999,end=999) por_thresh_max
          end if
        end if
        
!c  maximum porosity threshold, this value is set to avoid division by 0 in Kozeny-Carman equation

        subsection = 'porosity threshold maximum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            read(itmp,*,err=999,end=999) por_thresh_max
          end if
        end if 
        
!c  minimum porosity threshold, this value is set to avoid division by 0 in Kozeny-Carman equation

        subsection = 'porosity threshold minimum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            read(itmp,*,err=999,end=999) por_thresh_min
          end if
        end if        

!c  update permeability

       subsection = 'update permeability'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            update_permeability = .true.
            
!c if permeabilities are updated, switch to transient flow
          
            if (update_permeability) then
              steady_flow = .false.
              transient_flow = .true.
            end if
            
            if (.not.update_porosity) then

!c  need porosity update for permeability update
 
              update_porosity = .true.

            end if
          end if
        end if
        
!c  maximum permeability factor

        subsection = 'permeability scaling factor threshold maximum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            read(itmp,*,err=999,end=999) permfac_thresh_max
          end if
        end if 
        
!c  minimum permeability factor

        subsection ='permeability scaling factor threshold minimum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            read(itmp,*,err=999,end=999) permfac_thresh_min
          end if
        end if

!c  type of activity update

        subsection = 'activity update settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) update_activity(tid)
          update_activity(:) = update_activity(tid)
        end if

        if (update_activity(tid).eq.'no_update'.or.                &
     &      update_activity(tid).eq.'no update') then
          update_activity_rt = 'no_update'
          update_activity_lc = 'no_update'
        elseif (update_activity(tid).eq.'double_update'.or.        &
     &          update_activity(tid).eq.'double update') then
          update_activity_rt = 'double_update'
          update_activity_lc = 'double_update'
        end if

!c  tortuosity corrections - new definition

        subsection = 'tortuosity correction'
        tortuosity_corr=.false. 
        assigned_tau=.false.
        value_tau=1.0d0
        marchie=1.0d0
        marchies = 1.0d0
        assign_marchies = .false.
        update_tortuosity = .false.
        type_tortuosity=' ' 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'millington') then
            tortuosity_corr = .true.
            type_tortuosity='millington'
          elseif (subsection.eq.'archie') then
            tortuosity_corr = .true.
            type_tortuosity='archie'
            assign_marchies = .true.
            !read(itmp,*,err=999,end=999) marchie
            !marchies = marchie
          elseif (subsection.eq.'no correction') then
            tortuosity_corr = .false.
          elseif (subsection.eq.'assigned tau') then  
            tortuosity_corr = .true.
            assigned_tau=.true.
            if (update_tortuosity) then
                assign_marchies = .true.
            end if
          else
            if (rank == 0) then
              write(ilog,*) 'Tortuosity correction not recognized'
              write(*,*) 'Tortuosity correction not recognized'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
          end if
        end if
        
!c  tortuosity corrections - old definition

        subsection = 'tortuosity corrections'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) tortuosity_corr
          if (tortuosity_corr) then  
           type_tortuosity='millington'
          end if
        end if
        
!c  tortuosity corrections in the gas phase - new - sergi
        
	    subsection = 'gas tortuosity correction'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) gas_tortuosity
          if ((gas_tortuosity.eq.'millington').or.                     &
              (gas_tortuosity.eq.'no correction').or.                  &
      	      (gas_tortuosity.eq.'moldrup repacked').or.               &
              (gas_tortuosity.eq.'millington-2').or.                   &
              (gas_tortuosity.eq.'same as aqueous').or.                &
              (gas_tortuosity.eq.'manual')) then
		
          else            
		    write(ilog,'(a)')                                          &
                  'error reading subsection "gas tortuosity correction"'
            stop
          end if
        else 
	      gas_tortuosity = 'same as aqueous'	  
	    end if
        
!c  update tortuosity

        subsection = 'update tortuosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            update_tortuosity = .true.
            if(assigned_tau) then
                assign_marchies = .true.
            end if
        end if        

!c  degassing of dissolved gases
!c_bubbles if 'bubble formation' and 'degassing' are both true then
!c_bubbles display an error message

        subsection = 'degassing'

        call findstrg(subsection,itmp,found_subsection)
!c_bub_degas
        if (found_subsection) then
          gas_removal = .true.
          read(itmp,*,err=999,end=999) degas_rate
          degas_rate = degas_rate * r86400
          if(gas_bubbles) then
            read(itmp,*,err=999,end=999) max_sg_degas  
          end if
        end if
        
!cdsu----------------------------------------------------
!cdsu Correction temperature for solution update
!cdsu----------------------------------------------------
        moleconcorr_min = -1.0d300
        moleconcorr_max = 1.0d300
        subsection = 'concentration correction for solution'        
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          read(itmp,*,err=999,end=999) moleconcorr_min, moleconcorr_max
        end if

!c  settings for Newton iteration

        subsection = 'newton iteration settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) dinc_rt
          read(itmp,*,err=999,end=999) iter_rt_ant
          read(itmp,*,err=999,end=999) maxit_rt 
          read(itmp,*,err=999,end=999) urtant_log
          read(itmp,*,err=999,end=999) urtlim_log
          read(itmp,*,err=999,end=999) tol_rt 
        end if

!c  underrelaxation

        subsection = 'user specified underrelaxation factor'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          under_relax_rt = .true.
          read(itmp,*,err=999,end=999) srelfac_rt
        end if
        
        
!c  dense block matrices

        subsection = 'dense block matrices'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          sparse_blocks = .false.
        end if      


!c  sparse block matrices

        subsection = 'sparse block matrices'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          sparse_blocks = .true.
        end if

!c  solver

        subsection = 'solver settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) level_rt
          read(itmp,*,err=999,end=999) msolvit_rt
          read(itmp,*,err=999,end=999) idetail_rt
          read(itmp,*,err=999,end=999) restol_rt
          read(itmp,*,err=999,end=999) deltol_rt
          read(itmp,*,err=998,end=998) rcm_ordering_rt     !old
        end if

 998    subsection = 'natural ordering'

        call findstrg(subsection,itmp,found_subsection)    !new

        if (found_subsection) then
          rcm_ordering_rt = .false.
        end if
        
        subsection = 'rcm ordering'

        call findstrg(subsection,itmp,found_subsection)    !new

        if (found_subsection) then
          rcm_ordering_rt = .true.
        end if

      end if                 !(found_section)
      
      if (b_enable_output .and. b_enable_output_gen) then

!c  write control parameters for reactive transport
!c  to generic output file
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

!c  general control parameters

      if (update_activity(tid).eq.'no_update') then
        write(igen,'(a)') 'unity activity coefficients'
      elseif (update_activity(tid).eq.'time_lagged') then
        write(igen,'(a)')                                 &
     &  'activity coefficients updated each time step'
      elseif (update_activity(tid).eq.'double_update') then
        write(igen,'(a)')                                 &
     &  'activity coefficients updated twice during Newton iteration'
      end if
      if ((nr.gt.0).and.(redox_equil_rt)) then
        write(igen,'(a)') 'equilibrium controlled redox reactions'
      elseif ((nr.gt.0).and.(.not.redox_equil_rt)) then
        write(igen,'(a)') 'kinetically controlled redox reactions'
      end if
      if (dual_porosity) then
        write(igen,'(a)') 'perform dual porosity calculations'
      end if
      if (tortuosity_corr) then
        write(igen,'(a)') 'Millington-Quirk tortuosity correction'
      else
        write(igen,'(a)') 'no tortuosity correction'
      end if
	  write(igen,'(2a)') 'tortuosity correction in the gas phase: ',   &
                          gas_tortuosity
      if (update_porosity.and..not.update_permeability) then
        write(igen,'(a)') 'update of porosity'
      elseif (update_permeability) then
        write(igen,'(a)') 'update of porosity and permeability'
      else
        write(igen,'(a)') 'constant porosity and permeability'
      end if
      if (gas_removal) then
        write(igen,'(a)') 'degassing of dissolved gases'
        write(igen,'(a,1pe10.3)')                         &
     &  'rate constant [mol L-1 h2o s-1]                 = ',degas_rate 
      end if
      if (mass_balance_rt) then
        write(igen,'(a)') 'detailed mass balance output'
      end if
      if (spatial_weighting.eq.'centered') then
        write(igen,'(a)') 'centered weighting'
      elseif (spatial_weighting.eq.'upstream') then
        write(igen,'(a)') 'upstream weighting'
      elseif (spatial_weighting.eq.'vanleer') then
        write(igen,'(a)') 'Van Leer flux limiter'
      end if

!c  Newton iteration

      write(igen,'(a,1pe10.3)')                           &
     &'factor for numerical differentiation            = ',dinc_rt
      write(igen,'(a,i10)')                               &
     &'ant. number of iterations per time step         = ',iter_rt_ant
      write(igen,'(a,i10)')                               &
     &'max. number of iterations per time step         = ',maxit_rt
      write(igen,'(a,1pe10.3)')                           &
     &'ant. update in log cycles                       = ',urtant_log
      write(igen,'(a,1pe10.3)')                           &
     &'max. tolerable update in log cycles             = ',urtlim_log
      write(igen,'(a,1pe10.3)')                           &
     &'convergence tolerance                           = ',tol_rt
      if (under_relax_rt) then
        write(igen,'(a)')'underrelaxation'
        write(igen,'(a,1pe10.3)')                         &
     &  'underrelaxation factor                          = ',srelfac_rt
      end if

!c  sparse block matrices

      if (sparse_blocks) then
        write(igen,'(a)')'sparse block matrices'
      else
        write(igen,'(a)')'dense block matrices'
      end if

!c  solver

      write(igen,'(a,i10)')                               &
     &'incomplete factorization level                  = ',level_rt
      write(igen,'(a,i10)')                               &
     &'max. number of solver iterations                = ',msolvit_rt
      write(igen,'(a,i10)')                               &
     &'solver information level                        = ',idetail_rt
      write(igen,'(a,1pe10.3)')                           &
     &'solver residual tolerance                       = ',restol_rt
      write(igen,'(a,1pe10.3)')                           &
     &'solver update tolerance                         = ',deltol_rt
      if (rcm_ordering_rt) then
        write(igen,'(a)')'reverse Cuthill McKee ordering'
      else
        write(igen,'(a)')'natural ordering'
      end if
      
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,'(a)') 'error reading input file'
        write(ilog,'(a)') 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
