!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/reactran.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine reactran
!c -------------------
!c
!c driver subroutine for reactive transport
!c
!c modified for density dependent flow
!c
!c written by:      Uli Mayer - August 15, 96
!c
!c last modified:   Tom Henderson - June 1, 2006
!c                  Sergi Molins - May 2, 2006
!c                  added skip, nskip
!c                  added giups -> upstream node
!c                  Sergi Molins - June 7, 2006
!c                  added chemical_water, rateh2o
!c                  Sergi Molins - Feb 18, 2007
!c                  tortuosity corrected due to oil presence
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c bbls.f    logical
!c           -------
!c          gas_bubbles         =.true. -> gas phase saturation       + -
!c                                        is calculated
!c                                         below the water table
!c gen.f:    real*8:
!c           -------
!c           area(nm,nn)        = reactivity term                     + +
!c           art(njart)         = jacobian matrix                     * *    
!c           afrt(njafrt)       = incomplete factorization            * *
!c           brt(nn*n)          = rhs vector                          * *
!c           c(nc,nn)           = concentrations of free species      + +
!c                                - old time level [moles/l water]
!c           cinfvs(njavs)      = influence coefficients              + -
!c                                (variably saturated flow)
!c           cnew(nc,nn)        = concentrations of free species      + +
!c                                - new time level [moles/l water]
!c           cmnew(nm,nn)       = mineral concentrations              + +
!c                                - new time level [moles/l bulk]
!c           cmold(nm,nn)       = mineral concentrations              + +
!c                                - old time level [moles/l bulk]]
!c           cx(nx,nn)          = concentrations of secondary aqueous + +
!c                                species [moles/l water]
!c           delt               = time step                           + -
!c           deltol_rt          = solver update tolerance             + -
!c           dimcv(3,nn)        = dimension of control volumes        + -
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species
!c           phi(nm,nn)         = volume fractions of minerals        + +
!c           pornew(nn)         = porosity                            + -
!c           resrt(nn*n)        = residual                            * *
!c           restol_rt          = solver residual tolerance           + -
!c           rmupdate           = maximum solution update (solver)    * +
!c           rnorm              = residual 2-norm                     * +
!c           rwork(8*nn*n)      = real*8 work array                   * *
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                (new time level)
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                (new time level)
!c           sionnew(nn)        = ionic strength of solution          + +
!c                                - new time level
!c           sionold(nn)        = ionic strength of solution          + -
!c                                - old time level
!c           tfinal             = final solution time                 + -
!c           time               = current solution time               + -
!c           time_io            = current solution time (I/O units)   + -
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           tsrc(ntsrc)        = target read times - transient       + -
!c                                source chemistry
!c                                (reactive transport)
!c           urt(nn*n)          = update towards solution-vector      * +
!c
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           iart(nn*n+1)       = row pointer array for art           + -
!c           iafdrt(nn*n)       = diagonal pointer array for afrt     + -
!c           iafrt(nn*n+1)      = row pointer array for afrt          + -
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, log book               + -
!c           idetail_rt         = information level                   + -
!c           invordrt(nn*n)     = array containing inverse ordering   + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           iter_rt            = iteration counter                   * +
!c                                (reactive transport)
!c           itsrc              = pointer to target read time for     + +
!c                                transient source chemistry
!c                                (reactive transport)
!c           ittot_rt           = total number of iterations          + +
!c                                (reactive transport)
!c           iwork(*)           = integer work array                  * *
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           jart(njart)        = connectivity list                   + -
!c           jafrt(njafrt)      = column pointer array for afrt       + -
!c           lorderrt(nn*n)     = array containing ordering           + -
!c           msolvit_rt         = max. number of solver iterations    + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           mtime              = current time step                   + +
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volume      + -
!c           njart              = number of global connections        + -
!c           njafrt             = number of factored connections      + -
!c           ntsrc              = pointer to target read times for    + -
!c                                transient source chemistry
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c           itsolv             = actual number of solver iterations  * +
!c           itsolvtot_rt       = total number of solver              + +
!c                                iterations
!c                                (reactive transport)
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        + -
!c           
!c           
!c
!c           logical:
!c           --------
!c           half_cells         = .true.  -> half cells on boundary   + -
!c           mass_balance_rt    = .true.  -> compute mass balance     + -
!c                                           (reactive transport)
!c           not_converged      = .true.  -> continue Newton          + -
!c                                           iteration 
!c           reduce_timestep    = .true.  -> restart with reduced     + -
!c                                           timestep
!c           steady_flow        = .true.  -> steady state flow        + -
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           transient_source   = .true.  -> transient source         + -
!c                                           chemistry
!c                                .false. -> constant source
!c                                           chemistry
!c           chemical_water     = .true.  -> account for production   + -
!c                                           or consumption of water
!c                                           due to geochemical 
!c                                           reactions in flow eq.
!c
!c           character:
!c           ----------
!c           btypert(nbrt)      = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (free advective mass
!c                                            outflux for aqueous
!c                                            phase)
!c                                'third'  = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c           spatial_weighting  = 'upstream' -> upstream weigthing    + -
!c                                'centered' -> centered weighting
!c                                'vanleer' -> Van Leer flux limiter
!c                                              (upstream-downstream)
!c                                'vanleer2' -> Van Leer flux limiter
!c                                              (upstream-centered)
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           update_activity_rt = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c
!c chem.f:   integer*4:
!c           ----------
!c           nm                 = number of minerals                  + -
!c
!c           logical:
!c           --------
!c           redox_equil        = .true.  -> equilibrium reactions    * +
!c                                           for redox couples
!c
!c           character:
!c           ----------
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c           disx               = longitudinal dispersivity           + -
!c           disy               = transverse horizontal dispersivity  + -
!c           disz               = transverse vertical dispersivity    + -
!c
!c           integer*4:
!c           ----------
!c           nzn                = number of material property zones   + -
!c
!c dens.f:   integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         * -
!c           inpl               = counter for napl components         * +
!c           nnpl               = total number of napl components     * -
!c
!c           logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c           tiny_time          = tiny time increment
!c
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           ierr               = 0 -> memory allocation successful
!c           im                 = counter (minerals)
!c           ivol               = counter (number of control volumes)
!c
!c           logical:
!c           --------
!c           over_flow          = .true.  -> ||r||_2 norm -> infinity
!c
!c external: checkerr = check for error during memory allocation
!c           zero_r8  = clear real*8 array 
!c           i2upfind = assign pointers to second upstream point 
!c                      for flux limiter
!c           infcrt_a = influence coefficients for reactive
!c                      transport (aqueous phase)
!c           infcrtdd = influence coefficients for reactive
!c                      transport (density dependent aqueous)
!c           infcrt_g = influence coefficients for gas phase
!c           jacrt    = construct jacobian matrix and rhs vector 
!c                      (reactive transport)
!c           jacbrt   = incorporate dirichlet and cauchy type
!c                      boundary condition in Jacobian matrix and 
!c                      rhs-vector (reactive transport)
!c           updatert = update free species concentrations and 
!c                      check for convergence
!c           updtsvap = update secondary variables in aqueous phase
!c           updtsvmp = update secondary variables in mineral phase
!c           mbalrt   = compute mass balance (reactive transport)
!c           tcorr    = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           tsteprt  = estimate of time step (reactive transport)
!c           incompletefactorization = incomplete lu-decomposition of
!c                                     stiffness matrix
!c           ws209    = iterative solution of matrix equation
!c           giups    = choose upstream node
!c           rateh2o  = compute water production/consumption due
!c                      geochemical reactions
!c           diffcoff_mcd = compute  averaged diffusion coefficients 
!c                          for free and secondary aqueous species 
!c           mbal_mcd  =  compute mass balance (MCD - 
!c                         multicomponent diffusion)
!c           infcrt_mcd = influence coefficients for MCD - 
!c                         multicomponent diffusion
!c ----------------------------------------------------------------------

      subroutine reactran
 
      use parm
      use gen
      use chem
      use phys
      use dens
      use bbls
      use file_unit, only : lun_get, lun_set, lun_free
      use solver_results, only : solver_results_check_output, solver_results_readin
      
#ifdef PARDISO
      use solver_pardiso, only : pardiso_symbolicfactorization,      &
                                 pardiso_numfactorization,           &
                                 pardiso_substitution, ptrt, iparm_rt
#endif 

#ifdef PETSC
      use solver_dd, only : solver_dd_snes_solve_react
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef OPENMP
      use omp_lib 
#endif

      use matrix_utility, only : export_mmformat, export_arrays1d,     &
                                 export_mmformat_gbl                    !for test, dsu

      implicit none
      
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif

#ifdef PETSC
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer :: nexvol_gbl, mpireduce_irank
      PetscErrorCode :: ierrcode
#endif

      integer :: i, i1, ic, ilist, info_debug, ipest, ierr, ivol,      &
                 ivolume, nexvol, maxvol, n_unknown_rt, iunit, im, izn  
      real*8 :: sia_abs, ups_flow_loc, uuu, cputime
      
      integer :: ifile, idummy, iskip, nskip
      character*256 :: strdummy, strfile
      
      integer :: tid, istatus

      external checkerr, zero_r8, infcrt_a, infcrtdd, infcrt_g,             &
               jacrt, jacbrt, updatert, mbalrt,                             &
               tsteprt, incompletefactorization, ws209,                     &
               diffcoff_mcd,mbal_mcd,infcrt_mcd,                            &
               giups, cputime


      real*8, parameter :: tiny_time = 1.0d-10,r0 = 0.0d0,r1 = 1.0d0
      
      !mole water to liter water, 1mole water = 0.018L
      real*8, parameter :: rwater_mole2liter =  0.018d0  

      logical over_flow, b_redo_symbfac
      
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
      
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel   
        end subroutine tcorr
                    
        !>interface of updtsvap
        subroutine updtsvap (c,cx,gammac,gammax,strion)
          use parm, only : type_r8
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: cx
          real(type_r8), dimension(*) :: gammac
          real(type_r8), dimension(*) :: gammax
          real(type_r8) :: strion
        end subroutine updtsvap
                             
        !>interface of updtsvmp
        subroutine updtsvmp(cmnewm,cmoldm,phim,aream,ratem,deltsv,ivol)
          use parm, only: type_i4, type_r8        
          real(type_r8), dimension(*) :: cmnewm
          real(type_r8), dimension(*) :: cmoldm
          real(type_r8), dimension(*) :: phim 
          real(type_r8), dimension(*) :: aream
          real(type_r8), dimension(*) :: ratem
          real(type_r8) :: deltsv
          integer(type_i4) :: ivol      
        end subroutine                     
      
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      
      info_debug = 0
      
      napl_tol = 1.0d-10 ! defined real*8 in dens.f

      if(rank == 0) then      !if MPI rank 0

      if (idetail_rt.gt.0 .and. rank == 0 .and. b_enable_output .and.  &
          .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        write(ilog,'(a)') 'enter reactive transport'
        write(ilog,'(72a/)')('-',i=1,72)
      end if
  
      end if                  !end if MPI rank 0

!c  calculate influence coefficients and pointer array to second 
!c  upstream point
      b_mpi_process_flag = .false.

      if (transient_flow.or.(steady_flow.and.mtime.eq.1)) then
        
        if (density_dependence) then
          
          if (heat_transport) then
            ups_flow_loc=ups_heat
          else
            ups_flow_loc=ups_flow
          end if
          
          !infcrtdd Parallelized , OpenMP, DSU
          call infcrtdd (nvxgls, nvxgle, nvxgbl,                      &
                       nvygls, nvygle, nvygbl,                        &
                       nvzgls, nvzgle, nvzgbl,                        &
                       nvxgl, nvygl, nvzgl, iavs, javs, isymvs,       &
                       cinfvs_a, cinfrt_va, cinfrt_da, dimcv,         &
                       mpropvs, nzn, diff_a, disx, disy, disz,        &
                       pornew, sanew, uvsnew,                         &
                       density, zg, viscosity, relperm,               &
                       idbg, ilog, fully_saturated,                   &
                       variably_saturated, njavs, nngl,               &
                       tortuosity_corr, half_cells,time,tfinal,       &
                       cinfrt_da_ic,diff_coff, nc, diff_ic,           &
                       assigned_tau,tau,type_tortuosity,marchies,     &
                       harmonic_porosity,delx,dely,delz,av_dens_z,    &
                       ups_flow_loc,gacc,cinfrad,radial_coord,tau_fac,&
                       sonew) 
        else
          !infcrt_a Parallelized , OpenMP, DSU  
          call infcrt_a (nvxgls, nvxgle, nvxgbl,                      &
                       nvygls, nvygle, nvygbl,                        &
                       nvzgls, nvzgle, nvzgbl,                        &
                       nvxgl, nvygl, nvzgl, iavs, javs, isymvs,       &
                       cinfvs_a, cinfrt_va, cinfrt_da, dimcv,         &
                       mpropvs, nzn, diff_a, disx, disy, disz,        &
                       pornew, sanew, uvsnew, hhead, relperm,         &
                       idbg, ilog, upstream, fully_saturated,         &
                       variably_saturated, njavs, nngl,               &
                       tortuosity_corr, half_cells,cinfrt_da_ic,      &
                       diff_coff, nc, diff_ic,                        &
                       assigned_tau,tau,type_tortuosity,marchies,     &
                       cinfrad,radial_coord,multi_diff,tau_fac,       &
                       harmonic_porosity, delx,dely,delz,             &
                       type_averaging_De, xg,                         &
                       sonew,oil_saturation)  
        end if
        
!c_read_tau
        if (mtime .eq. 1 .and. gas_tortuosity.eq.'manual') then
		  call read_tau      
        endif

!cdbg
        if(info_debug .eq.1) then
          iunit = lun_get()  
          open(iunit,file='sg-dbg'//trim(str_rank)//'.out',              &
               status='unknown',form='formatted')
          do i1=1,nngl
            write(iunit,'(15es15.7)') sgnew(i1)
          end do
          close(iunit)
          call lun_free(iunit)
          
          if(rank == 0) then
            write(*,*) 'debug stop in reactran'
            !pause            
            write(*,*) "stop signal in sg-dbg"//trim(str_rank)//".out"
          end if
          
          b_mpi_process_flag = .true.
        end if     
        
        if(.not.b_mpi_process_flag) then
            
!c_trap if trap bubbles then exclude trapped gas in calculation of diffusion coefficients
          if (gas_bubbles) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol,izn)
    !$omp do schedule(static)
#endif
            do ivol=1,nngl
               izn = mpropvs(ivol)
               sg_temp(ivol)=sgnew(ivol)
               if ((uvsnew(ivol).ge.aentry(izn))                       &
                       .and.(.not.unsaturated(ivol))) then              
                 sgnew(ivol)=r0                                         
               else                                                     
                 sgnew(ivol)=dmax1(r0,                                 &
                             sgold(ivol)-sgt_old(ivol)*(r1-swr(izn)))
               end if
            end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
          end if

          !infcrt_g Parallelized , OpenMP, DSU 
          call infcrt_g (nvxgl, nvygl, nvzgl, iavs, javs, isymvs,     &
                       cinfrt_dg, dimcv, diff_g, pornew, sgnew,       &
                       idbg, ilog, njavs, nngl, tortuosity_corr,      &
                       half_cells,assigned_tau,tau,type_tortuosity,   &
                       marchies,cinfrad,radial_coord,tau_fac,         &
                       gsatij,gporij,deltaij,tauij,tauivol,           &
                       gas_tortuosity,sonew,oil_saturation)
          
!c_trap reset sgnew for other calculations
          if (gas_bubbles) then
            do ivol=1,nngl
              sgnew(ivol)=sg_temp(ivol)
            end do
          end if

          if (multi_diff) then
                                                                          
            !call vel_lin1 (nvxgl, nvygl, nvzgl, iavs, javs, isymvs,       &
            !               cinfvs,vel_lin,dimcv,                          &
            !               mpropvs, nzn, diff_a, disx, disy, disz,        &
            !               pornew, sanew, uvsnew, hhead, relperm,         &
            !               idbg, ilog, upstream, fully_saturated,         &
            !               variably_saturated, njavs, nngl,               &
            !               tortuosity_corr, half_cells,cinfrt_da_ic,      &
            !               diff_coff, nc, diff_ic,multi_diff,assigned_tau,& 
            !               tau,type_tortuosity,marchies,                  &
            !               cinfrad,radial_coord)                           !ToDo MX radial coordinate
               
            !infcrt_mcd Parallelized , OpenMP, DSU    
            call infcrt_mcd (nvxgl, nvygl, nvzgl, iavs, javs, isymvs,      &
                             cinfrt_mcd, dimcv, pornew, sanew,             & 
                             idbg, ilog, njavs, nngl, tortuosity_corr,     &
                             half_cells, deltaij, tauij,                   &
                             porij,satij,assigned_tau,                     &
                             tau,type_tortuosity,marchies,cinfrad,         &
                             radial_coord, multi_diff,tau_fac, sonew)             
            !diffcoff_mcd Parallelized , OpenMP, DSU                                                               
            call diffcoff_mcd (nvxgls, nvxgle, nvxgbl,                     &
                               nvygls, nvygle, nvygbl,                     &
                               nvzgls, nvzgle, nvzgbl,                     &
                               nvxgl, nvygl, nvzgl, iavs, javs,            &
                               mpropvs,pornew, sanew,tortuosity_corr,      &
                               half_cells,nc,nx, mdiff_ic,mdiff_ix,        &
                               njavs, nngl, mdiff_ic_cvol, mdiff_ix_cvol,  &
                               assigned_tau,tau,type_tortuosity,           &
                               marchies,delx,dely,delz,type_averaging_De,  &
                               tau_fac, epor_diff, f_epor, f_etau,         &
                               hmulti_diff,sonew)   
            
            
          end if 
          if (spatial_weighting.eq.'vanleer'.or.                       &
              spatial_weighting.eq.'vanleer2') then
            !Parallelized , OpenMP, DSU
            call i2upfind
          end if

        end if
        
      end if


      if(info_debug .eq.1) then
          
        if(b_mpi_process_flag) then
            if(rank == 0) then
              write(*,*) "b_mpi_process_flag reactran A: ", b_mpi_process_flag
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
      end if  

!c  start newton iteration
 
      iter_rt = 0
      not_converged = .true.

!c option look for file pest.stp, which will cause simulation to abort
      ipest = 0 !(0/1) -> 1 = activate PEST termination function

      do while (not_converged)              !newton iteration loop
          
        prt_react_tot = cputime()
        
        b_mpi_process_flag = .false.

        if(rank == 0) then      !if MPI rank 0

          if(ipest .eq. 1) then
              iunit = lun_get()
              open (iunit,file='../pest.stp',status='old',iostat=istatus)
              if(istatus .eq. 0) then
                write(ilog,'(a)')'execution halted due to pest.stp'
                close(iunit)
                open (iunit,file='pslave.fin',status='unknown') ! terminate slave
                write(iunit,'(a)') 'F'
                close(iunit)
                b_mpi_process_flag = .true.
                write(*,*) "stop signal in ../pest.stp"
              end if
              call lun_free(iunit)
          end if                  !end if MPI rank 0

        end if
       
#ifdef MPI
        call MPI_BCAST(b_mpi_process_flag, 1, MPI_LOGICAL, 0,        &
                       Petsc_Comm_World, ierrcode)
        CHKERRQ(ierrcode)
#endif  
        
        if(b_mpi_process_flag) then
            if(rank == 0) then
              write(*,*) "b_mpi_process_flag reactran B: ", b_mpi_process_flag
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
        
        iter_rt = iter_rt + 1               !iteration counter (current)
        ittot_rt = ittot_rt + 1             !iteration counter (total)

        if(rank == 0 .and. b_enable_output .and.                       &
           .not. ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then      !if MPI rank 0
            if (idetail_rt.eq.2) then
              write(ilog,'(/a,i3,a)') 'Newton iteration ',iter_rt,':'
              write(ilog,'(a)') '---------------------'
            end if
        end if                  !end if MPI rank 0

!c  allocate memory for solver       
        if (.not. allocated(art)) then
            allocate (art(njart), stat = ierr)
            art=r0 
            call checkerr(ierr,'art',ilog)
        end if 
        
        if (i_solver_type_react == 0) then
            if (.not. allocated(afrt)) then
                allocate (afrt(njafrt), stat = ierr)
                afrt=r0
                call checkerr(ierr,'afrt',ilog)
            end if
        end if

!c  clear arrays
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
        call zero_r8(art,njart,1,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
        call zero_r8(brt,n*nngl,1,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
        call zero_r8(urt,n*nngl,1,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif

!c  Check Charge balance in each iteration
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ic, ivolume)  
    !$omp do schedule(static)
#endif
        do ivolume = 1,nngl 
        zc(ivolume) = r0
            do ic =1,nc-1
             zc(ivolume) = zc(ivolume) + totcnew(ic,ivolume)*chargec(ic)
            end do
        enddo
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif  


        prt_react_jac = cputime()
  
!c  construct jacobian matrix and rhs vector
        call jacrt
        
        if((b_output_matrix.or.itimestep_output_matrix==mtime) .and.  &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(n*nngl, njart, iart, jart, art,  &
                brt, urt, .true., .true., .false., "reactran_rt",     &
                ittot_rt)
            else if(itype_matrix_format == 1) then
                call export_mmformat(n*nngl, njart, iart, jart, art,  &
                brt, urt, .true., .true., .false., "reactran_rt",     &
                ittot_rt)
#ifdef PETSC
                call export_mmformat_gbl(n*nngl, njart, iart, jart,   &
                     art, brt, urt, .true., .true., .false.,          &
                     "reactran_rt", nngl, nngbl, .true., ittot_rt)
#endif
            end if
        end if
 
!c  incorporate boundary terms  
        call jacbrt

        !Export sparse matrix dataset and right hand side. For test only, dsu.
        if((b_output_matrix.or.itimestep_output_matrix==mtime) .and.  &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(n*nngl, njart, iart, jart, art,  &
                brt, urt, .true., .true., .false., "reactran_rt",     &
                ittot_rt)
            else if(itype_matrix_format == 1) then
                call export_mmformat(n*nngl, njart, iart, jart, art,  &
                brt, urt, .true., .true., .false., "reactran_rt",     &
                ittot_rt)
#ifdef PETSC
                call export_mmformat_gbl(n*nngl, njart, iart, jart,   &
                     art, brt, urt, .true., .true., .false.,          &
                     "reactran_rt", nngl, nngbl, .true., ittot_rt)
#endif
            end if
        end if
        
!        write(*,*) "force stop after jacbrt"
!        stop
        
!        b_mpi_process_flag = .true.        
!        if(b_mpi_process_flag) then
!            write(*,*) "b_mpi_process_flag reactran B: ", b_mpi_process_flag
!#ifdef PETSC
!            call petsc_mpi_finalize
!#endif
!            stop
!        end if

!cdsu  debug part, use external solution (written in sequential order) to test
!        if (mtime == 1 .or. mtime == 7 .or. mtime == 13) then
!                call export_mmformat_gbl(n*nngl, njart, iart, jart,    &
!                     art, brt, urt, .true., .true., .false.,           &
!                     "reactran_rt_check", nngl, nngbl, .true., ittot_rt)
!        end if
!cdsu  debug part, use external solution (written in sequential order) to test, end
        
        prt_react_jac = cputime() - prt_react_jac
        
!cprovi--------------------------------------------------------------------
!cprovi Estimate condition number for the current matrix. 
!cprovi This is used for testing when newton iteration failed.
!cprovi--------------------------------------------------------------------
#ifdef CONDITION_NUMBER
         if(b_output_condition_number) then
            call cond_num_cal(n*nngl, njart, iart, jart, art, condition_number, condition_number_info)
            
            if (rank == 0 .and. b_enable_output) then
            
            if (condition_number_info(1) .ge. 0) then
              write(*,"(2(a, e10.3, 1x))")    " classical cond. num. ", condition_number(1), &
                                              " skeel cond. num. ", condition_number(2)
              write(ilog,"(2(a, e10.3, 1x))") " classical cond. num. ", condition_number(1), &
                                              " skeel cond. num. ", condition_number(2)
            else
              write(*,*)    ' error in estimating condition number, info(1) ', condition_number_info(1)
              write(ilog,*) ' error in estimating condition number, info(1) ', condition_number_info(1)
            endif 
            
            if(i_solver_type_react == 1) then
              if(condition_number(1) > 1.0e10 .and. condition_number(2) > 1.0e10) then
                  write(*,"(a)")    " Warning: matrix is ill-conditioned."
                  write(ilog,"(a)") " Warning: matrix is ill-conditioned."
              end if
            end if
            
            end if
            
         end if
#endif         
        prt_react_solver = 0.0d0 
        !! use ws209 solver
        if (i_solver_type_react == 0) then
#ifdef PARDISO  
         if (b_solver_test_pardiso) then
    !$omp parallel                                                    &
    !$omp if (njart > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            do i = 1, njart
                art_std(i) = art(imaprt_std(i))
            end do
    !$omp end do
    !$omp end parallel
            
            b_redo_symbfac = .true.
100         prt_react_symbfac_comp = cputime() 
            if(bsymbolicfactor_rt  .or. i_symfactor_type_react == 1) then
                call pardiso_symbolicfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
                n_unknown_rt = n*nngl
                bsymbolicfactor_rt = .false.
            end if    
            prt_react_symbfac_comp = cputime() - prt_react_symbfac_comp
            
            prt_react_fac_comp = cputime() 
            call pardiso_numfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
            prt_react_fac_comp = cputime() - prt_react_fac_comp

            prt_react_sub_comp = cputime() 
            call pardiso_substitution(ilog, msolvit_rt, itsolv, idetail_rt, resrt,          &
                                        restol_rt, deltol_rt, over_flow, rnorm, rmupdate,   &
                                        iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std, brt, urt_std)           
            prt_react_sub_comp = cputime() - prt_react_sub_comp
            
            if (b_redo_symbfac .and. (itsolv > n_max_iteration_react .or. rnorm > r_max_residual_react .or. over_flow)) then
                bsymbolicfactor_rt = .true.   
                b_redo_symbfac = .false.
                goto 100
            end if
            
         end if
#endif

#ifdef PETSC
        if(b_solver_test_petsc) then
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_react(ilog,idetail_rt,art,brt,    &
                    urt_std,iart,jart,nngl*n,itsolv,over_flow,rnorm,    &
                    row_idx_l2pg_rt,col_idx_l2pg_rt,.false.)
            over_flow_rt = over_flow
#ifdef DEBUG
             if(rank == 0) then
                write(*,'(a, 3(1x, i5), 1x, l1, 1x, e12.4)')         &
                "reactran-A: rank, new_iter_rt, iteration, over_flow, rnorm ",&
                rank, iter_rt, itsolv, over_flow, rnorm 
             end if
#endif
        end if
#endif

!c  Scale [art] and {brt} to produce unit diagonal
!c  Generate re-ordered preconditioner [af]
  
        ilist = 1
        prt_react_fac = cputime()

        call incompletefactorization (n*nngl,njart,njafrt,brt,art,afrt,   &
                                      rwork_max,iart,jart,iafrt,iafdrt,   &
                                      jafrt,iwork_max(ilist),lorderrt,    &
                                      invordrt,numofthreads_ws209)

        prt_react_fac = cputime() - prt_react_fac
                                                                      
!c  solve [art] * {urt} = {brt}   
        prt_react_sub = cputime() 
        call ws209(ilog,n*nngl,msolvit_rt,itsolv,idetail_rt,iart,jart, &
                   iafrt,iafdrt,jafrt,lorderrt,art,afrt,urt,brt,       &
                   resrt,rwork_max,restol_rt,deltol_rt,njart,njafrt,   &
                   over_flow,rnorm,rmupdate,numofthreads_ws209,        &
                   b_enable_output)

        prt_react_sub = cputime() - prt_react_sub
#ifdef PARDISO  
        if (b_solver_test_pardiso) then        
          call solver_results_check_output(ittot_rt, nngl*n, urt, urt_std, "reactran_rt") 
        end if
#endif    

#ifdef PETSC 
        if (b_solver_test_petsc) then        
            call solver_results_check_output(ittot_rt, nngl*n, urt, urt_std, "reactran_rt_petsc") 
        end if
#endif

        prt_react_solver = prt_react_symbfac + prt_react_fac + prt_react_sub

        !! use pardiso solver
        else if (i_solver_type_react == 1) then
#ifdef PARDISO
    !$omp parallel                                                    &
    !$omp if (njart > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            do i = 1, njart
                art_std(i) = art(imaprt_std(i))
            end do
    !$omp end do
    !$omp end parallel
            
            b_redo_symbfac = .true.
200         prt_react_symbfac = cputime() 
            if(bsymbolicfactor_rt  .or. i_symfactor_type_react == 1) then
                !write(idbg, *) "pardiso symbolic factorization for reactive transport line 474"
                call pardiso_symbolicfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
                n_unknown_rt = n*nngl
                bsymbolicfactor_rt = .false.
            end if    
            prt_react_symbfac = cputime() - prt_react_symbfac
            
            !write(idbg, *) "pardiso numerical factorization for reactive transport line 479"
            prt_react_fac = cputime()
            call pardiso_numfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
            prt_react_fac = cputime() - prt_react_fac
            
            !write(idbg, *) "pardiso substitution for reactive transport line 482"
            prt_react_sub = cputime()  
            call pardiso_substitution(ilog, msolvit_rt, itsolv, idetail_rt, resrt,          &
                                        restol_rt, deltol_rt, over_flow, rnorm, rmupdate,   &
                                        iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std, brt, urt) 
            prt_react_sub = cputime() - prt_react_sub
            
            if (b_redo_symbfac .and. (itsolv > n_max_iteration_react .or. rnorm > r_max_residual_react .or. over_flow)) then
                bsymbolicfactor_rt = .true.    
                b_redo_symbfac = .false.
                goto 200
            end if
#endif
            prt_react_solver = prt_react_symbfac + prt_react_fac + prt_react_sub         
        !! use PETSc solver
        else if (i_solver_type_react == 2) then            
#ifdef PETSC
            prt_react_solver = cputime()
            
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_react(ilog,idetail_rt,art,brt,    &
                    urt,iart,jart,nngl*n,itsolv,over_flow,rnorm,        &
                    row_idx_l2pg_rt,col_idx_l2pg_rt,.false.)
            over_flow_rt = over_flow
            
            prt_react_solver = cputime() - prt_react_solver
#ifdef DEBUG
             if(rank == 0 .and. b_enable_output) then

                write(*,'(a, 3(1x, i5), 1x, l1, 1x, e12.4)')         &
                "reactran-B: rank, new_iter_rt, iteration, over_flow, rnorm ",&
                rank, iter_rt, itsolv, over_flow, rnorm  

             end if
#endif
#endif        
        end if
        
        !Check residual of the solver
        !b_doublecheck_residual = .true.
        !if(rank == 0) then
        !    if(b_doublecheck_residual) then
        !        rnorm_check = 0.0d0            
        !        call mkl_dcsrgemv('N', n*nngl, art, iart, jart, urt, resrt_check) 
        !        resrt_check = resrt_check-brt
        !        rnorm_check = sqrt(sum(resrt_check**2))
        !    end if
        !end if
  
        
        !Export sparse matrix dataset and right hand side. For test only, dsu.
        if((b_output_matrix.or.itimestep_output_matrix == mtime) .and. &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(n*nngl, njart, iart, jart, art,   &
                brt, urt, .false., .false., .true., "reactran_rt",     &
                ittot_rt)
            else if(itype_matrix_format == 1) then
                call export_mmformat(n*nngl, njart, iart, jart, art,   &
                brt, urt, .false., .false., .true., "reactran_rt",     &
                ittot_rt)
#ifdef PETSC
                call export_mmformat_gbl(n*nngl, njart, iart, jart,    &
                     art, brt, urt, .false., .false., .true.,          &
                     "reactran_rt", nngl, nngbl, .true., ittot_rt)
#endif
            end if
        end if
        
            
!cdsu  debug part, use external solution (written in sequential order) to test
!        if (mtime == 1 .or. mtime == 7 .or. mtime == 13) then
!                call export_mmformat_gbl(n*nngl, njart, iart, jart,    &
!                     art, brt, urt, .false., .false., .true.,          &
!                     "reactran_rt", nngl, nngbl, .true., ittot_rt)
!        end if
!
!        if (rank == 0) then
!          write(*,*) "-->read concentration change from external file"
!        end if
!
!        ifile = lun_get()
!	     write(strfile, *) ittot_rt
!        strfile = "x_reactran_rt_"//trim(adjustl(strfile))//"_natgbl.txt"
!        open(ifile,file=trim(strfile),status='old',form='formatted')
!	    urt = 0.0d0
!        nskip = 0
!	    read(ifile,*) strdummy
!        do ivol = 1, nngl
!#ifdef PETSC
!          do iskip = 1, node_idx_lg2g(ivol) - nskip -1
!	        do i =1, n
!              read(ifile,*) idummy
!            end do
!          end do
!          nskip = node_idx_lg2g(ivol)
!#endif
!          do i = 1, n
!            read(ifile,*) idummy,urt((ivol-1)*n+i)
!          end do
!
!        end do
!        call lun_free(ifile)
!cdsu  debug part, use external solution (written in sequential order) to test, end

       
!c  deallocate memory for solver
       
        if (b_dynamic_memory) then
            
            deallocate (art, stat = ierr)
            call checkerr(ierr,'art',ilog)
            
            if (i_solver_type_react == 0) then
                deallocate (afrt, stat = ierr)
                call checkerr(ierr,'afrt',ilog)
            end if
        end if


!c  total number of solver iterations

        itsolvtot_rt = itsolvtot_rt + itsolv
 
!c  update solution after new iteration, check for global convergence
!c  and reduce time step if necessary
!c  Parallelized , OpenMP, DSU 
        call updatert


#ifdef DEBUG
        if(rank == 0) then

        if(info_debug > 10) then
            write(*,'(a, 2(1x, i4) ,2(1x, l1))')                       &
            "reactran: rank, iter_rt, not_converged, reduce_timestep", &
            rank, iter_rt, not_converged, reduce_timestep
        end if

        end if
#endif
        
        prt_react_tot = cputime() - prt_react_tot
        
!c  write runtime to file

        if(rank == 0 .and. b_prtfile) then      !if MPI rank 0
            write(iprt_react, "(i8,1x,2(i3, 1x),i8,1x,8(e12.4,2x))") mtime, iter_sia, iter_rt,          &
                ittot_rt, prt_react_jac, prt_react_symbfac, prt_react_fac, prt_react_sub,               &
                prt_react_solver, (prt_react_tot - prt_react_jac - prt_react_solver), prt_react_tot
            
            write(iprt_react_jac, "(i8,1x,2(i3, 1x),i8,1x,6(e12.4,2x))") mtime, iter_sia, iter_rt,      &
                ittot_rt, prt_react_jac_part
            
            if(b_solver_test_pardiso) then
                write(iprt_react_comp, "(i8,1x,2(i3, 1x),i8,1x,5(e12.4,2x))") mtime, iter_sia, iter_rt, &
                    ittot_rt, prt_react_fac, prt_react_sub, prt_react_symbfac_comp, prt_react_fac_comp, &
                    prt_react_sub_comp
            end if            
        end if                  !end if MPI rank 0 


!c  reset primary unknowns for reduced time step
!c  need ionic strength to compute reasonable activity coefficients
!c  during restart
        if (reduce_timestep) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, ic, im)  
    !$omp do schedule(static)
#endif
          do ivol=1,nngl
            sionnew(ivol) = sionold(ivol)
!c_bubbles reset saturations to old time level
            if (gas_bubbles)then
              sanew(ivol) = saold(ivol)
              if(zero_storage) then
                sgnew(ivol)=sgold(ivol)
              else
                sgnew(ivol) = r1-saold(ivol)
              end if
              uvsnew(ivol) = uvsold(ivol)
              hhead(ivol) = uvsold(ivol)+zg(ivol)
              if (trap_bubbles) then
                sa_min(ivol) = sa_min_old(ivol)
                big_bubble(ivol) = big_bub_old(ivol)
                sgt(ivol) = sgt_old(ivol)
              end if
!c_bubbles reset flow variables also
            end if 
            do ic=1,n
              cnew(ic,ivol) = c(ic,ivol) 
            end do
            if (nm.gt.r0)then
              do im=1,nm
                phi(im,ivol)=phiold(im,ivol)
                cmnew(im,ivol)=cmold(im,ivol)
              end do
            end if
          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c  return and start over with reduced time step

          return
       
        end if            ! reduce_timestep
        
      end do            ! newton loop
      
!cdbg
      b_mpi_process_flag = .false.

#ifdef DEBUG
      if (info_debug.gt.0) then
        write(idbg,'(/a,i3)')  'Reactran Newton iterations ',         &
     &                          iter_rt
                                                                       
        write(idbg,'(/a,3a/)') 'ivol   ',                             &
     &                         'conc. update        ',                &
     &                         'c old               ',                &
     &                         'c new               '

        do ivol = 1,nngl
          uuu = cnew(1,ivol) - c(1,ivol)
          write(idbg,'(I3,3es20.10)') ivol,uuu,c(1,ivol),cnew(1,ivol)
        end do
      end if
#endif
      
      if (info_debug.gt.1) then
        b_mpi_process_flag = .true.
        
        if(rank == 0) then
          write(*,*) "stop signal in info_debug.gt.1"
        end if
      end if 

      if (info_debug.gt.1) then

        if(b_mpi_process_flag) then
            if(rank == 0) then
              write(*,*) "b_mpi_process_flag reactran C: ", b_mpi_process_flag
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
      end if  
      
!cprovi---------------------------------------------------------------------
!cprovi This is necessary because we need to update the last Newton
!cprovi Raphson solution 
!cprovi---------------------------------------------------------------------         
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)                                              
    !$omp do schedule(static)
#endif
      do ivol=1,nngl

!c  exclude first type boundary control volumes

        if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

          if (temp_field.or.heat_transport) then         
            call tcorr(tkel(ivol))           
          end if
  
          call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),         &
                        gamma(nc+1,ivol),sionnew(ivol))
          if (hmulti_diff) then
                call updtsvap(c(1,ivol),cxold(1,ivol),gammaold(1,ivol),&        !MX June 2014
                            gammaold(nc+1,ivol),sionold(ivol))
          end if

        end if

!c  recompute total concentrations vectors
      
        if (redox_equil_rt.and.nr.gt.0) then
          call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol))

          if (ng.gt.0) then
              call totconcg(gnew(1,ivol),totgnew(1,ivol))
          end if  
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif   


!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!c check for Picard iteration convergence
!c variable density simulations only

      if (density_dependence) then 

!c update TDS and densities
!cprovi Here the densities are computed 
!cprovi----------------------------------------------
!cprovi----------------------------------------------
!cprovi----------------------------------------------          
          !cprovi-----------------------------------------------
          !cprovi Store densities density = f (cit+1,tempit+1)
          !cprovi Parallelized , OpenMP, DSU
          !cprovi-----------------------------------------------          
          if (heat_transport) then
             call ddtds_energybal(.false.)
          else
             call ddtds
          end if 
!cprovi----------------------------------------------
!cprovi----------------------------------------------
!cprovi----------------------------------------------        
!cprovi Here the densities are computed 

!c evaluate convergence using fluid densities

        sia_max = r0
        nexvol = 0
        maxvol = 0 
#ifdef OPENMP
        maxval_omp = r0
#endif        
        
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ivol, sia_abs)                                &
    !$omp reduction(+:nexvol)
    !$omp do schedule(static)
#endif
        do ivol = 1,nngl    
!#ifdef PETSC 
!          if(node_idx_lg2l(ivol) < 0) then
!              cycle
!          end if
!#endif
            
#ifdef OPENMP    
          tid = omp_get_thread_num()+1
#else
          tid = 1
#endif            

          sia_abs  = dabs(density(ivol) - densold1(ivol))
          
#ifdef OPENMP
          if (sia_abs>maxval_omp(tid)) then
            maxval_omp(tid) = sia_abs             !max solution update
            maxvol_omp(tid) = ivol                 !location of max update
          endif
#else
          if (sia_abs>sia_max) then
            sia_max = sia_abs                      !max solution update
            maxvol = ivol                          !location of max update
          endif
#endif          
          
          if (sia_abs>tol_sia) then                !number of volumes
            nexvol = nexvol + 1                    !exceeding convergence
          end if                                   !tolerance

        end do        !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  store iteration results into matrix for printing at the end of the timestep
#ifdef OPENMP
       i1 = maxloc(maxval_omp,1)
       sia_max = maxval_omp(i1)
       maxvol = maxvol_omp(i1)
#endif

#ifdef PETSC
      mpireduce_in(1) = sia_max      !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      sia_max = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvol, 1, MPI_INTEGER4, mpireduce_irank,         &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
      call MPI_Allreduce(nexvol, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvol = nexvol_gbl
#endif

        sia_dens(iter_sia) = sia_max
        sia_maxvol(iter_sia) = maxvol
        sia_nexvol(iter_sia) = nexvol
        
        
!c  coupling convergence check
        if (sia_max<tol_sia) then
          not_converged_sia = .false.
        else        
          return
        end if

      end if !(density_dependence)

!c  update concentrations of minerals, mineral volumes and
!c  reactivity term 
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, inpl, ivol)                               
#endif

#ifdef OPENMP
    !$omp do schedule(static)
#endif
      do ivol=1,nngl
          
!c  exclude first type boundary control volumes

        if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

          if (temp_field.or.heat_transport) then         
            call tcorr(tkel(ivol))           
          end if
   
          call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),         & 
                        gamma(nc+1,ivol),sionnew(ivol))
          if (hmulti_diff) then
             call updtsvap(c(1,ivol),cxold(1,ivol),gammaold(1,ivol),   &        !MX June 2014
                         gammaold(nc+1,ivol),sionold(ivol))
          end if

!c         THH edit: pass ivol # to updtsvmp to use in updating surface areas
!c         needed for initial volume fraction in phi-init matrix
          if (.not.gas_bubbles)then
            if (nm.gt.0) then
              call updtsvmp(cmnew(1,ivol),cmold(1,ivol),phi(1,ivol),   &
                            area(1,ivol),ratemdp(1,ivol),delt,ivol)    
              
!c         added by Anna H Jan 24, 2014 to remove water during hydrate carb pptn
!c         included artinite Anna H Feb 11 2014
              if (water_removal) then
                do im = 1,nm
                  qh2o(ivol) = rwaterremovalcoeff(im)*ratemdp(im,ivol)* &
                               delt*rwater_mole2liter
                end do
              end if
             
            end if
          end if
        end if

      end do
#ifdef OPENMP
    !$omp end do
#endif 

!c update napl saturations

      if (napl_permeability) then
#ifdef OPENMP
    !$omp do schedule(static)
#endif        
        do ivol = 1,nngl             !loop over control volumes
          snnew(ivol) = r0
          do inpl = 1, nnpl
            i1 = ianpl(inpl)
            snnew(ivol) = snnew(ivol) + phi(i1,ivol)/pornew(ivol)
          end do
          if (snnew(ivol) .lt. napl_tol) then
            snnew(ivol) = r0
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif        
      end if      

!c  recompute total concentrations vectors
!c  c_bubbles 
      if ((redox_equil_rt.and.nr.gt.0).or.gas_bubbles) then
#ifdef OPENMP
    !$omp do schedule(static)
#endif 
        do ivol = 1,nngl
          call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol))

          if (hmulti_diff) then
            call totconc(c(1,ivol),cxold(1,ivol),totcold(1,ivol))
          end if
          if (ng.gt.0) then
            call totconcg(gnew(1,ivol),totgnew(1,ivol))
          end if  
        end do
#ifdef OPENMP
    !$omp end do
#endif
      end if 
#ifdef OPENMP
    !$omp end parallel
#endif

      if(gas_bubbles) then
        return
      end if

!c  mass balance computation for reactive transport
!c  Parallelized , OpenMP, DSU

      if (mass_balance_rt) then
        call mbalrt
      end if

!c  smr: decide upstream weighting for gases in the next time step

      if (spatial_weighting.eq.'upstream') then
        call giups
      endif
      
      if (flux_out) then
        call mbal_mcd
      end if
      
!c  smr: calculate the production/consumption rate of water

      if (chemical_water) then
        call rateh2o
	  endif


!c  estimate time increment size for next time step
!c  Parallelized , OpenMP, DSU

      call tsteprt
  
      return

!c  update source chemistry at specified target read times
!c  this part is never called
!      if (transient_source) then
!        if (itsrc.le.ntsrc.and.tsrc(itsrc)-tiny_time.lt.time) then
!
!         if(rank == 0 .and. b_enable_output) then   
!!c  report to log file
!
!          write(ilog,'(/a,1pe12.4,1x,a)')                             &
!     &         'update source chemistry - reactive transport, T = ',  &
!     &          time_io, time_unit                                     
!          write(ilog,'(72a/)')('-',i=1,72)
!                                                                      
!!c  report to screen
!                                                                       
!          write(*,'(/1x,a,1pe12.4,1x,a)')                             &
!     &         'update source chemistry - reactive transport, T = ',  &
!     &          time_io, time_unit
!          write(*,'(1x,72a/)')('-',i=1,72)
!          
!          end if
!
!!c  update boundary conditions
!
!          call tranbcrt
!
!!c  set index for next target read time
!
!          itsrc = itsrc+1
!
!!c  set target read time to time larger than final solution time after
!!c  last update of boundary conditions
!
!          if (itsrc.gt.ntsrc) then
!            tsrc(itsrc) = tfinal+tiny_time
!          end if
!
!!c  redefine activity update technique for reactive transport
!
!          if (update_activity_rt.eq.'no_update') then
!           update_activity(tid) = 'no_update'
!          elseif (update_activity_rt.eq.'time_lagged') then
!            update_activity(tid) = 'time_lagged'
!          elseif (update_activity_rt.eq.'double_update') then
!            update_activity(tid) = 'double_update'
!          endif
!
!        end if
!      end if

      return
      end
