!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/energy_bal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine energy_bal
!c -----------------
!c
!c Compute the energy balance
!c
!c 
!c
!c 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  + -
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           relperm(nn)        = relative permeability               + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           time_io            = current solution time (I/O units)   + -
!c           totvsmass          = total system mass                   + +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c
!c           integer*4:
!c           ----------
!c           iabvs(nbvs)        = pointer to boundary control volumes + -
!c                                for variably saturated flow
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           imvs               = unit number, mass balance -         + *
!c                                             variably saturated
!c                                             flow
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           mtime              = current time step                   + -
!c           nbvs               = number of specified boundary        + -
!c                                control volumes
!c                                (variably saturated flow)
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> calculate root water     + -
!c                                           uptake
!c           steady_flow        = .true.  -> steady state flow        + -
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c
!c           character:
!c           ----------
!c           btypevs(nbvs)      = boundary type array                 + -
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + - 
!c           dcoef(ncon-1)      = coefficient including density,      + -
!c                                viscosity, and relative 
!c                                permeability
!c           psi_i              = total pressure potential in control + -
!c                                volume i currently considered
!c           psi_j              = total pressure potential in control + -
!c                                volume j currently considered
!c           ssdens(nn)         = density of point source fluid       + -
!c
!c local:    real*8:
!c           -------
!c           qroot              = root water uptake for current 
!c                                control volume
!c           qroot_tot_act      = total actual root water uptake
!c           r0                 = constant
!c           r100               = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c           totinflux          = total flux into domain
!c           totoutflux         = total flux out of domain
!c           totvsflux          = total flux into control volume
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ibvs               = counter (boundary control 
!c                                         volumes)
!c           icon               = pointer (connections - local)
!c           iend               = pointer (end of row)
!c           istart             = pointer (start of row)
!c           jvol               = row-column pointer
!c           ivol               = counter (control volumes)
!c
!c external: fluxdd   = flux function for density dependent 
!c                      flow 
!c           fluxfs   = flux function for fully saturated flow 
!c           msysdd   = compute total system mass
!c                      (density dependent flow)
!c           rootwat  = function for computing root water uptake 
!c           stordd   = storage function for variably saturated  
!c                      density dependent flow
!c           storddfs = storage function for fully saturated  
!c                      density dependent flow
!c ----------------------------------------------------------------------
      subroutine energy_bal    

      use parm
      use gen
      use phys
      use dens
      use writeversion
#ifdef OPENMP
      use omp_lib 
#endif

      use module_binary_mpiio, only : binary_write_data
      
      implicit none
      
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif
      
      integer :: i1, ibheat, ibvs, icon, ivol, istart, iend, jvol
      real*8 :: area_ivol, coeff, ddbdflux_energybal, densloc,         &
                diff_energybal, fluxdd, heatflux, totheatstor, rpor,   &
                porosity_flow, heatstor, stordheat, storevap, temploc, &
                totheatflux, totinflux, totoutflux, darcy_energybal,   &
                fluxheat, absbalance, relbalance

#ifdef PETSC
      real*8 :: totheatstor_gbl, totinflux_gbl, totoutflux_gbl
      PetscErrorCode :: ierrcode
#endif
      
      real(type_r8) :: rho_av_loc

      external fluxdd, msysdd, rootwat, stordd, storddfs, stordheat,   &
               storevap, porosity_flow, darcy_energybal, fluxheat
      
      character(len=100)  typebc 
      
     
      real*8 latvap_av

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r100 = 100.0d0
      real*8, parameter :: rhalf = 0.5d0
      
      integer :: nvarsimheat
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface

        !>interface of jacbevap
        !subroutine jacbevap(ivol,typeequation)
        !  integer, intent(in)           :: ivol 
        !  character(len=*), intent(in)  :: typeequation     
        !end subroutine jacbevap

      end interface      

!cprovi----------------------------------------------------
!cprovi  compute total energy in the energy
!cprovi  Parallelized, OpenMP, DSU
!cprovi----------------------------------------------------
      call energysys 
!cprovi----------------------------------------------------
!cprovi for transient conditions -> compute changes 
!cprovi in storage 
!cprovi----------------------------------------------------
      totheatstor = r0
      
      if (isstorheat) then
        
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_energy_bal_1)                   &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, heatstor, rpor)                               &
    !$omp reduction(+:totheatstor)
    !$omp do schedule(static)
#endif
        
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
        
          if (modify_por(ivol)) then
            rpor=porosity_flow(porold(ivol), &
                 uvsnew(ivol),uvsold(ivol),stor(ivol),  &
                 por_stress(ivol),por_init(ivol),facpormin)   
          else
            rpor=pornew(ivol)
          end if 
        
          
        
          heatstor = cvol(ivol)*stordheat(delt,delt,tempnew(ivol),  & 
                     tempold(ivol),sanew(ivol),saold(ivol), &
                     density(ivol),densold(ivol),density(ivol),densold(ivol), &
                     r0,r0,r0,r0,denssolid(ivol), & 
                     rpor,porold(ivol),heatcapw,  &
                     heatcaps(ivol),.true.,.false., &
                     cdens1,cdens2,cdens3,cdens4)  
                     
                     
          if (evaporation) then
             
              heatstor = heatstor + cvol(ivol)*storevap(delt,tempnew(ivol), &
                                    tempold(ivol),sgnew(ivol),sgold(ivol), &
                                    densvnew(ivol),densvold(ivol), &
                                    rpor,porold(ivol),heatcapv)
              heatstor = heatstor + cvol(ivol)*storevap(delt,latvapnew(ivol), &
                                    latvapold(ivol),sgnew(ivol),sgold(ivol), &
                                    densvnew(ivol),densvold(ivol), &
                                    rpor,porold(ivol),r1)                      
          end if          
                     
                     
                 
          totheatstor = totheatstor + heatstor
         
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
      
#ifdef PETSC
        call MPI_Allreduce(totheatstor, totheatstor_gbl,1,MPI_REAL8,           & 
                   MPI_SUM, Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        totheatstor = totheatstor_gbl
#endif

      end if 

!c  compute fluxes across boundary

      totinflux = r0               
      totoutflux = r0
!cprovi--------------------------------------------------------------------------------------
!cprovi Boundary conditions for energy balance
!cprovi--------------------------------------------------------------------------------------    
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nbheat > numofloops_thred_energy_bal_2)                 &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(i1, ibheat, ibvs, icon, iend, istart, ivol, jvol,   &
    !$omp area_ivol, coeff, del_p, del_z, del_temp, densloc,          &
    !$omp heatflux, heatflux_a, heatflux_c, heatflux_d, heatflux_v,   &
    !$omp latvap_av, rho_av_loc, temploc, totheatflux,                &
    !$omp vapfluxheat, vsfluxheat)                                    &
    !$omp reduction(+:totinflux, totoutflux)
    !$omp do schedule(dynamic)
#endif

      do ibheat = 1,nbheat
        
        ivol = iabheat(ibheat)
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif        
        totheatflux = r0
!c  modify for second type flow boundary condition and
!c  point source boundary
!c  calculate mass flux
        if (btypeheat(ibheat)=='free') then

          totheatflux=ddbdflux_energybal(ivol,density(ivol),viscosity(ivol),typebc)
          
          if (totheatflux<r0) then
            temploc=tempnew(ivol)           
            if (isboussinesq) then  
              densloc=r1
            else
              densloc=density(ivol)
            end if
          else
            temploc=bcondheat(ibheat)
            if (isboussinesq) then  
              densloc=ssdens(ivol)/density(ivol)
            else
              densloc=ssdens(ivol)*heatcapw
            end if
          end if
          
          if (massflux_second) then  
             totheatflux=totheatflux*temploc
          else
             totheatflux=totheatflux*densloc*temploc
          end if
          
          
        elseif (btypeheat(ibheat)=='fluxw+') then
          
          totheatflux=ddbdflux_energybal(ivol,density(ivol),viscosity(ivol),typebc)
          
          if (totheatflux<r0) then
            heatflux = r0
            temploc=r0
            densloc=r0
          else
            temploc=bcondheat(ibheat)
            if (isboussinesq) then  
              densloc=ssdens(ivol)/density(ivol)
            else
              densloc=ssdens(ivol)*heatcapw
            end if
          end if
          
          if (massflux_second) then  
            totheatflux=totheatflux*temploc
          else
            totheatflux=totheatflux*densloc*temploc 
          end if
          
            
        else if ((btypeheat(ibheat)=='second') .or.  &
                 (btypeheat(ibheat).eq.'point')) then
 
          totheatflux = bcondheat(ibheat) 
          
        else if (btypeheat(ibheat)=='atmospheric'.and.evaporation) then  
  
          ibvs = ivol2bvs(ivol)
          if(ibvs > 0) then
            area_ivol = bcondvs(ibvs)
            ! call jacbevap(ivol,' ') 
            totheatflux = tothflux_atm*area_ivol
          end if
 
        elseif ((btypeheat(ibheat)=='first').or.   &
                (btypeheat(ibheat)=='seepage'.and. &
                 bcondheat(ibheat)<r0)) then

          icon=0  
          istart = iavs(ivol)+1                                       
          iend = iavs(ivol+1)-1                                      
!cprovi---------------------------------------------------------------
!cprovi Loop on connected control volumes
!cprovi---------------------------------------------------------------             
          do i1=istart,iend          !loop over connected control volumes 
          
             icon = icon + 1   
             
             jvol = javs(i1)
             
             heatflux_a(icon)=r0
             heatflux_c(icon)=r0
             heatflux_d(icon)=r0
             vsfluxheat(icon)=r0
             if (evaporation) then
               vapfluxheat(icon)=r0
               heatflux_v(icon)=r0
             end if
             
             del_p(icon) = uvsnew(jvol) - uvsnew(ivol) 
             del_z(icon) = zg(jvol) - zg(ivol)
!cprovi---------------------------------------------------------------             
!cprovi     
!cprovi---------------------------------------------------------------  
             if (del_z(icon)/=r0) then
!cprovi---------------------------------------------------------------  
!cprovi Compute the average density
!cprovi---------------------------------------------------------------             
              rho_av_loc = rhalf * (density(ivol) + density(jvol))  
              if (av_dens_z) then  
                 del_p(icon)=rho_av_loc*(uvsnew(jvol)/density(jvol)-uvsnew(ivol)/density(ivol))
              end if
!cprovi---------------------------------------------------------------  
!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
!cprovi---------------------------------------------------------------   
              del_z(icon) = del_z(icon) * rho_av_loc * gacc 
              del_p(icon) = del_p(icon) + del_z(icon)             
             end if
             del_temp(icon) = tempnew(jvol) - tempnew(ivol)             
!cprovi--------------------------------------------------------------------------
!cprovi Advective term 
!cprovi--------------------------------------------------------------------------          
             if (isadvective) then 
              vsfluxheat(icon) = darcy_energybal(del_p(icon),del_p(icon),density(ivol), &
                                                 density(jvol),viscosity(ivol), &
                                                 viscosity(jvol),relperm(ivol),relperm(jvol), &
                                                 cinfvs(i1),ups_heat,isboussinesq)
              
                    
              if (isboussinesq) then                   
                 heatflux_a(icon)=fluxheat(tempnew(ivol), &
                                  tempnew(jvol),ivol,jvol,vsfluxheat(icon),nngl,tempold, &
                                  i2up,sp_weight_heat,distcells(i1,1),distcells(i1,2)) 
              else
                 heatflux_a(icon)=heatcapw*fluxheat(tempnew(ivol), &
                                  tempnew(jvol),ivol,jvol,vsfluxheat(icon),nngl,tempold, &
                                  i2up,sp_weight_heat,distcells(i1,1),distcells(i1,2)) 
              end if
            
             
            end if 
!cprovi--------------------------------------------------------------------------
!cprovi Conductive fluxes 
!cprovi--------------------------------------------------------------------------                
           if (isconductive) then
             if (isboussinesq) then
                coeff = r1/(heatcapw*density(ivol))       
             else   
                coeff = r1
             end if
             heatflux_c(icon) = - fluxdd(del_temp(icon),cinfheat_c(i1),coeff)             
           end if
!cprovi--------------------------------------------------------------------------
!cprovi Dispersive fluxes 
!cprovi--------------------------------------------------------------------------                
           if (isdispersive) then 
              heatflux_d(icon) = diff_energybal(tempnew(ivol),tempnew(jvol),density(ivol), &
                                 density(jvol),pornew(ivol),pornew(jvol), &
                                 sanew(ivol),sanew(jvol),cinfheat_d(i1),r1,r1,heatcapw, &
                                 ups_heat,isboussinesq)              
           end if 
!cprovi--------------------------------------------------------------------------
!cprovi Vapour fluxes 
!cprovi--------------------------------------------------------------------------           
           if (evaporation) then
              
              if (split_divdensv) then
                   vapfluxheat(icon)  = diff_energybal(uvsnew(ivol),uvsnew(jvol),r1, &
                                        r1,pornew(ivol),pornew(jvol), &
                                        sgnew(ivol),sgnew(jvol),cinfevap_pa(i1), &
                                        r1,r1,r1,ups_heat,.false.)
              
              
                   vapfluxheat(icon)  = vapfluxheat(icon) + diff_energybal(tempnew(ivol), &
                                        tempnew(jvol),r1,r1,pornew(ivol), &
                                        pornew(jvol),sgnew(ivol),sgnew(jvol),cinfevap_t(i1), &
                                        r1,r1,r1,ups_heat,.false.)
                                      
              else
                   vapfluxheat(icon)  = diff_energybal(densvnew(ivol),densvnew(jvol),r1, &
                                        r1,pornew(ivol),pornew(jvol), &
                                        sgnew(ivol),sgnew(jvol),cinfevap_pa(i1), &
                                        r1,r1,r1,ups_heat,.false.)
              
              end if
             
              heatflux_v(icon)   = heatcapv*fluxheat(tempnew(ivol), &
                                   tempnew(jvol),ivol,jvol,vapfluxheat(icon),nngl,tempold, &
                                   i2up,sp_weight_heat,distcells(i1,1),distcells(i1,2))
                                   
              latvap_av = rhalf*(latvapnew(ivol)+latvapnew(jvol))
                                    
              heatflux_v(icon)   = heatflux_v(icon) + latvap_av*vapfluxheat(icon)                      
                              
              totheatflux = totheatflux +  heatflux_v(icon)                                                        
           end if
!cprovi--------------------------------------------------------------------------
!cprovi Add the total fluxes
!cprovi--------------------------------------------------------------------------     
           totheatflux = totheatflux + heatflux_a(icon) + heatflux_c(icon) + heatflux_d(icon)
      
      
      end do                          !loop - boundary control volumes 

      end if
      
      if (totheatflux>r0) then   
          totinflux = totinflux + totheatflux
      else
          totoutflux = totoutflux - totheatflux
      end if

    end do                        !loop over boundary control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
    call MPI_Allreduce(totinflux, totinflux_gbl,1,MPI_REAL8,           & 
               MPI_SUM, Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    totinflux = totinflux_gbl
    
    call MPI_Allreduce(totoutflux, totoutflux_gbl,1,MPI_REAL8,         & 
               MPI_SUM, Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    totoutflux = totoutflux_gbl    
#endif

!cprovi----------------------------------------------------------------
!cprovi  write total contributions to file   
!cprovi----------------------------------------------------------------
    imheat = imheat + 1
    
    if(rank == 0 .and. b_enable_output) then    
      if (b_output_binary) then
        nvarsimheat = 4
        realbuffer_gb(1:nvarsimheat)=(/time_io,totinflux,totoutflux,   &
                                     totheatstor/)
        call binary_write_data(imheat_mpi(imheat), 1,          &
                     (/mtime/),offset_imheat_ijk(imheat),.true.)
        call binary_write_data(imheat_mpi(imheat), nvarsimheat,&
                     realbuffer_gb,offset_imheat(imheat),.true.) 

        offset_imheat(imheat) = offset_imheat(imheat) +                &
                                nvarsimheat*nfloatbit

      else
        write(imheat,'(4(1pe12.4))') time_io,totinflux,totoutflux,     &
                                     totheatstor
      end if
    end if
    
!cprovi---------------------------------------------------------------
!cprovi  compute absolute and relative mass balance error 
!cprovi---------------------------------------------------------------
      absbalance = (totinflux-totoutflux-totheatstor)*delt
      relbalance = absbalance/totenergy*r100
!cprovi--------------------------------------------------------------- 
!cprovi  compute accumulative absolute and relative mass balance error 
!cprovi---------------------------------------------------------------
      culabsbalheat = culabsbalheat + absbalance
      culrelbalheat = culabsbalheat/totenergy*r100

      imheat = imheat + 1
      
      if(rank == 0 .and. b_enable_output) then
        if (b_output_binary) then
          nvarsimheat = 5
          realbuffer_gb(1:nvarsimheat)=(/time_io,absbalance,relbalance,  &
                                   culabsbalheat,culrelbalheat/)
          call binary_write_data(imheat_mpi(imheat), 1,          &
                       (/mtime/),offset_imheat_ijk(imheat),.true.)
          call binary_write_data(imheat_mpi(imheat), nvarsimheat,&
                       realbuffer_gb,offset_imheat(imheat),.true.) 

          offset_imheat(imheat) = offset_imheat(imheat) +                &
                                  nvarsimheat*nfloatbit

        else
          write(imheat,'(5(1pe12.4))') time_io,absbalance,relbalance,    &
                                   culabsbalheat,culrelbalheat
        end if
    
      end if

      return
  
  end subroutine   
