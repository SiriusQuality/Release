!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 488 $
!> $Author: cblitz $
!> $Date: 2017-07-17 18:22:05 +0200 (Mon, 17 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/vsflow.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine vsflow
!c -----------------
!c
!c driver subroutine for variably saturated flow 
!c
!c written by:      Uli Mayer - May 6, 96
!c
!c last modified:   Uli Mayer - December 6, 96
!c                  Sergi Molins - January 18,2003
!c                  - computation of influence coeff.
!c                    in terms of conductivities
!c                  - new var passed to soilparm 
!c                  Sergi Molins - May 15, 2006
!c                  added new var -> passed to soilparm 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     * +
!c           afvs(njafvs)       = incomplete factorization            * +
!c           bvs(nn)            = rhs vector                          * +
!c           deltol_vs          = solver update tolerance             + -
!c           hhead(nn)          = hydraulic head                      + +
!c           sanew(nn)          = aqueous phase saturation            + +
!c                                - new tim level
!c           uvs(nn)            = update towards solution-vector      * +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           restol_vs          = solver residual tolerance           + -
!c           resvs(nn)          = residual                            * + 
!c           rmupdate           = maximum solution update (solver)    * +
!c           rnorm              = residual 2-norm                     * +
!c           rwork(8*nn)        = real*8 work array                   * *
!c           tol_vs             = convergence tolerance               + -
!c                                (variably saturated flow)
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           relperm()          = relative permeability               * +
!c           relpermg()         = relative permeability               * +
!c
!c
!c           integer*4:
!c           ----------
!c
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log file               + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           iafvs(nn+1)        = row pointer array for afvs          + -
!c           iafdvs(nn)         = diagonal pointer array for afvs     + -
!c           idbg               = unit number, debugging file         + -
!c           idetail_vs         = information level                   + -
!c           invordvs(nn)       = array containing inverse ordering   + -
!c           iter_seep          = iteration counter                   * +
!c                                (seepage face iteration)
!c           iter_vs            = iteration counter                   * +
!c                                (variably saturated flow)
!c           itseep_tot         = total number of seepage face        * +
!c                                iterations
!c           ittot_vs           = total number of iterations          * +
!c                                (variably saturated flow)
!c           iwork(*)           = integer work array                  * *
!c           javs(njavs)        = connectivity list                   + -
!c           jafvs(njafvs)      = column pointer array for afvs       + -
!c           lordervs(nn)       = array containing ordering           + -
!c           maxit_vs           = max. number of newton iterations    + -
!c                                (variably saturated flow)
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           msolvit_vs         = max. number of solver iterations    + -
!c           njavs              = number of global connections        + -
!c           njafvs             = number of factored connections      + -
!c           nn                 = total number of control volumes     + -
!c           itsolv             = actual number of solver iterations  * +
!c           itsolvtot_vs       = total number of solver              + +
!c                                iterations
!c                                (variably saturated flow)
!c          
!c           logical:
!c           --------
!c           not_converged      = .true.  -> continue Newton          * +
!c                                           iteration
!c           reduce_timestep    = .true.  -> restart with reduced     + +
!c                                           timestep
!c           seepage_face       = .true.  -> seepage face boundary    + -
!c                                           specified
!c           seep_iter          = .true.  -> continue seepage face    + +
!c                                           iteration
!c           steady_flow        = .true.  -> steady state flow        + -
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow   
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c           ilist              = pointer (integer work array)
!c           ivol               = counter (control volumes)
!c           izn                = pointer (material property)
!c     
!c           logical:
!c           --------
!c           over_flow          = .true.  -> ||r||_2 norm -> infinity
!c
!c external: checkerr = check for error during memory allocation
!c           zero_r8   = clear real*8 array
!c           jacvs     = construct Jacobian matrix 
!c                       (variably saturated flow)
!c           jacbvs    = incorporate boundary terms in Jacobian 
!c                       (variably saturated flow)
!c           incompletefactorization = incomplete lu-decomposition of
!c                                     stiffness matrix
!c           ws209     = iterative solution of matrix equation
!c           updatevs  = update solution vector, secondary variables
!c                       and check for convergence
!c           soilparm  = compute soil hydraulic parameters
!c           infcvs_cp = compute influence coefficients in terms 
!c                       of conductivities  
!c ----------------------------------------------------------------------

      subroutine vsflow

      use parm
      use gen
      use bbls
      use phys
      use chem
      use dgml, only : dgm, maxwell 
      use solver_results, only : solver_results_check_output
      
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PARDISO      
      use solver_pardiso, only : pardiso_symbolicfactorization,      &
                                 pardiso_numfactorization,           &
                                 pardiso_substitution, ptvs, iparm_vs
#endif      
      
#ifdef PETSC
      use solver_dd, only : solver_dd_snes_solve_flow
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      use matrix_utility, only: export_mmformat, export_arrays1d,      &
                                export_mmformat_gbl
      
      
      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif

      real*8 :: cputime
      integer :: i, ic, im, ierr, ilist, iter_sia, ivol, n_unknown_vs
      external checkerr, zero_r8, jacvs, jacbvs, updatevs, soilparm, &
                incompletefactorization, ws209, cputime, infcvs_cp
                                                                       
      logical over_flow, b_redo_symbfac
      
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
      
      iter_sia = 0
                                                                     
      not_converged = .true.
                                                                       
      if (seepage_face) then                                           
        iter_seep = 0                                                  
        seep_iter = .true.                                             
      end if
                                                                       
      do while (seep_iter.or.not_converged)   !seepage face iteration  
                                                                       
        if (seepage_face) then                                         
          iter_seep = iter_seep+1                                      
          itseep_tot = itseep_tot + 1   
 
          if(rank == 0 .and. b_enable_output)  then              
            write(ilog,'(/,2x,a,i2,a)') 'Seepage Face Iteration ',    &
                                       iter_seep,':'                   
            write(ilog,'(2x,a,i4/)')                                  &
                  'Number of seepage face nodes: ',nseep_first           
          end if
        end if

        iter_vs = 0
        not_converged = .true.
	


        do while (not_converged)          !newton iteration loop


          prt_flow_tot = cputime()

          iter_vs = iter_vs+1             !iteration counter (current)
          ittot_vs = ittot_vs+1           !iteration counter (total)
          if (idetail_vs.eq.2 .and. rank == 0 .and. b_enable_output) then
            write(ilog,'(/a,i3,a)') 'Newton iteration ',iter_vs,':'
            write(ilog,'(a)') '---------------------'
          end if

!c  allocate memory for solver
          !if (i_solver_type_flow == 0) then
          !    allocate (rwork(8*nn,1), stat = ierr)
          !    rwork=0.0d0 
          !    call checkerr(ierr,'rwork',ilog)
          !
          !    allocate (iwork(nn), stat = ierr)
          !    iwork=0 
          !    call checkerr(ierr,'iwork',ilog)
          !    
          !    allocate (afvs(njafvs), stat = ierr)
          !    afvs=0.0d0 
          !    call checkerr(ierr,'afvs',ilog)
          !end if
          
          if (.not. allocated(avs)) then
              allocate (avs(njavs), stat = ierr)
              avs=0.0d0 
              call checkerr(ierr,'avs',ilog)
          end if
          
          if (i_solver_type_flow == 0) then
              if (.not. allocated(afvs)) then
                  allocate (afvs(njafvs), stat = ierr)
                  afvs=0.0d0 
                  call checkerr(ierr,'afvs',ilog)
              end if
          end if      

         
!c  clear arrays
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          call zero_r8(avs,njavs,1,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          call zero_r8(bvs,nngl,1,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          call zero_r8(uvs,nngl,1,1)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif     

!c  construct jacobian matrix and rhs vector
          prt_flow_jac = cputime()

!c  compute influence coefficients in terms of conductivities
          if (gas_advection .or. dgm .or. maxwell) then
            call infcvs_cp
          end if 
	
          call jacvs
        !Export sparse matrix dataset and right hand side. For test only, dsu.  
        if((b_output_matrix.or.itimestep_output_matrix == mtime) .and. &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs_a", ittot_vs)
            else if(itype_matrix_format == 1) then
                call export_mmformat(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs_a", ittot_vs)
            end if
        end if

!c  incorporate boundary terms
          call jacbvs
       
        !Export sparse matrix dataset and right hand side. For test only, dsu.  
        if((b_output_matrix.or.itimestep_output_matrix == mtime) .and. &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs", ittot_vs)
            else if(itype_matrix_format == 1) then
                call export_mmformat(nngl, njavs, iavs, javs, avs, bvs,&
                uvs, .true., .true., .false., "vsflow_vs", ittot_vs)
            end if
        end if

!cprovi--------------------------------------------------------------------
!cprovi Estimate condition number for the current matrix. 
!cprovi This is used for testing when newton iteration failed.
!cprovi-------------------------------------------------------------------- 
#ifdef CONDITION_NUMBER
         if(b_output_condition_number) then
            call cond_num_cal(nngl, njavs, iavs, javs, avs,            &
                      condition_number, condition_number_info)
            
            if (rank == 0 .and. b_enable_output) then
            
            if (condition_number_info(1) .ge. 0) then
              write(*,"(2(a, e10.3, 1x))")  " classical cond. num. ",  &
                                            condition_number(1),       &
                                            " skeel cond. num. ",      &
                                            condition_number(2)
              write(ilog,"(2(a, e10.3, 1x))") " classical cond. num. ",&
                                              condition_number(1),     &
                                              " skeel cond. num. ",    &
                                              condition_number(2)
            else
              write(*,*)                                               &
                  ' error in estimating condition number, info(1) ',   &
                  condition_number_info(1)
              write(ilog,*)                                            &
                  ' error in estimating condition number, info(1) ',   &
                  condition_number_info(1)
            endif 
            
            if(i_solver_type_flow == 1) then
              if(condition_number(1) > 1.0d10 .and.                    &
                      condition_number(2) > 1.0d10) then
                  write(*,"(a)")                                       &
                      " Warning: matrix is ill-conditioned."
                  write(ilog,"(a)")                                    &
                      " Warning: matrix is ill-conditioned."
              end if
            end if
            
            end if
            
         end if     
#endif          
        prt_flow_jac = cputime() - prt_flow_jac        
       
        prt_flow_solver = 0.0d0
          
        !! use ws209 solver
        if (i_solver_type_flow == 0) then
#ifdef PARDISO   
          if(b_solver_test_pardiso) then
    !$omp parallel                                                    &
    !$omp if (njavs > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
              !!reset value of a
              do i = 1, njavs
                  avs_std(i) = avs(imapvs_std(i))
              end do
    !$omp end do
    !$omp end parallel
           
              b_redo_symbfac = .true.
100           prt_flow_symbfac_comp = cputime()
              if(bsymbolicfactor_vs .or.                               &
                      i_symfactor_type_flow == 1) then                 
                  call pardiso_symbolicfactorization(iparm_vs,ptvs,    &
                           nngl, njavs, iavs, javs_std, avs_std)       
                  n_unknown_vs = nngl                                  
                  bsymbolicfactor_vs = .false.                         
              end if                                                   
              prt_flow_symbfac_comp = cputime()-prt_flow_symbfac_comp  
                                                                       
              prt_flow_fac_comp = cputime()                            
              call pardiso_numfactorization(iparm_vs, ptvs, nngl,      &
                       njavs, iavs, javs_std, avs_std)                 
              prt_flow_fac_comp = cputime() - prt_flow_fac_comp        
                                                                       
              prt_flow_sub_comp = cputime()                            
              call pardiso_substitution(ilog, msolvit_vs, itsolv,      &
                       idetail_vs, resvs, restol_vs, deltol_vs,        &
                       over_flow, rnorm, rmupdate, iparm_vs, ptvs,     &
                       nngl, njavs, iavs, javs_std, avs_std, bvs,      &
                       uvs_std)   
              prt_flow_sub_comp = cputime() - prt_flow_sub_comp
              
              if (b_redo_symbfac .and. (itsolv > n_max_iteration_flow  &
                  .or. rnorm > r_max_residual_flow .or. over_flow)) then
                  bsymbolicfactor_vs = .true. 
                  b_redo_symbfac = .false.
                  goto 100
              end if

          end if
#endif            

#ifdef PETSC
          if(b_solver_test_petsc) then
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_flow(ilog,idetail_vs,avs,bvs,    &
                    uvs_std,iavs,javs,nngl,itsolv,over_flow,rnorm,     &
                    row_idx_l2pg_vs,col_idx_l2pg_vs,.false.)
            over_flow_vs = over_flow
#ifdef DEBUG
             if(rank == 0) then
                write(*,'(a, 2(1x, i5), 1x, l1, 1x, e12.4)')           &
                "vsflow-A: rank, iteration, over_flow, rnorm ",        &
                rank, itsolv, over_flow, rnorm 
             end if
#endif
          end if
#endif

!c  Scale [avs] and {bvs} to produce unit diagonal
!c  Generate re-ordered preconditioner [af]

          ilist = 1
          prt_flow_fac = cputime()
          call incompletefactorization(nngl,njavs,njafvs,bvs,avs,afvs, &
                                      rwork_max,iavs,javs,iafvs,iafdvs,&
                                      jafvs,iwork_max(ilist),lordervs, &
                                      invordvs,numofthreads_ws209)       
          prt_flow_fac = cputime() - prt_flow_fac   
                                                                    
!c  solve [avs] * {uvs} = {bvs}
          prt_flow_sub = cputime()      
          call ws209(ilog,nngl,msolvit_vs,itsolv,idetail_vs,iavs,javs, &
                     iafvs,iafdvs,jafvs,lordervs,avs,afvs,uvs,bvs,     &
                     resvs,rwork_max,restol_vs,deltol_vs,njavs,njafvs, &
                     over_flow,rnorm,rmupdate,numofthreads_ws209,      &
                     b_enable_output)
          prt_flow_sub = cputime() - prt_flow_sub

#ifdef PARDISO
          if (b_solver_test_pardiso) then
            call solver_results_check_output(ittot_vs, nngl, uvs,      &
                     uvs_std, "vsflow_vs") 
          end if     
#endif  

#ifdef PETSC             
          if (b_solver_test_petsc) then        
              call solver_results_check_output(ittot_vs, nngl, uvs,    &
                       uvs_std, "vsflow_vs_petsc") 
          end if       
#endif 
          prt_flow_solver = prt_flow_symbfac+prt_flow_fac+prt_flow_sub
          
        !! use pardiso solver
        else if (i_solver_type_flow == 1) then               
#ifdef PARDISO
    !$omp parallel                                                    &
    !$omp if (njavs > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            !!reset value of a
            do i = 1, njavs
                avs_std(i) = avs(imapvs_std(i))
            end do
    !$omp end do
    !$omp end parallel
           
            b_redo_symbfac = .true.
200         prt_flow_symbfac = cputime()
            if(bsymbolicfactor_vs  .or.                                &
                    i_symfactor_type_flow == 1) then
                !write(idbg, *) "pardiso symbolic factorization for vsflow line 280"
                call pardiso_symbolicfactorization(iparm_vs, ptvs,     &
                         nngl, njavs, iavs, javs_std, avs_std)
                n_unknown_vs = nngl
                bsymbolicfactor_vs = .false.
            end if  
            prt_flow_symbfac = cputime() - prt_flow_symbfac
            
            !write(idbg, *) "pardiso numerical factorization for vsflow line 285"
            prt_flow_fac = cputime()
            call pardiso_numfactorization(iparm_vs, ptvs, nngl,        &
                     njavs, iavs, javs_std, avs_std)
            prt_flow_fac = cputime() - prt_flow_fac

            !write(idbg, *) "pardiso substitution for vsflow line 290"
            prt_flow_sub = cputime()
            call pardiso_substitution(ilog, msolvit_vs, itsolv,        &
                     idetail_vs, resvs, restol_vs, deltol_vs,          &
                     over_flow, rnorm, rmupdate, iparm_vs, ptvs, nngl, &
                     njavs, iavs, javs_std, avs_std, bvs, uvs) 
            prt_flow_sub = cputime() - prt_flow_sub
            
            if (b_redo_symbfac .and. (itsolv > n_max_iteration_flow    &
                .or. rnorm > r_max_residual_flow .or. over_flow)) then
                bsymbolicfactor_vs = .true.
                b_redo_symbfac = .false.
                goto 200
            end if         
#endif    
            prt_flow_solver=prt_flow_symbfac+prt_flow_fac+prt_flow_sub 
        !! use PETSc solver
        else if (i_solver_type_flow == 2) then
#ifdef PETSC   
            prt_flow_solver = cputime()
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_flow(ilog,idetail_vs,avs,bvs,    &
                     uvs,iavs,javs,nngl,itsolv,over_flow,rnorm,        &
                     row_idx_l2pg_vs,col_idx_l2pg_vs,.false.) 
            over_flow_vs = over_flow
            prt_flow_solver = cputime() - prt_flow_solver
#ifdef DEBUG
             if(rank == 0 .and. b_enable_output) then
                write(*,'(a, 2(1x, i5), 1x, l1, 1x, e12.4)')           &
                "vsflow-A: rank, iteration, over_flow, rnorm ",        &
                rank, itsolv, over_flow, rnorm
             end if
#endif
#endif        
        end if  
      
        !Export sparse matrix dataset and right hand side. For test only, dsu.        
        if((b_output_matrix.or.itimestep_output_matrix == mtime) .and. &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(nngl,njavs,iavs,javs,avs,bvs,     &
                       uvs,.false.,.false.,.true.,"vsflow_vs",ittot_vs)
            else if(itype_matrix_format == 1) then
                call export_mmformat(nngl,njavs,iavs,javs,avs,bvs,     &
                       uvs,.false.,.false.,.true.,"vsflow_vs",ittot_vs)
            end if
        end if


!c  deallocate memory for solver
          !if (i_solver_type_flow == 0) then
          !    deallocate (rwork, stat = ierr)
          !    call checkerr(ierr,'rwork',ilog)
          !
          !    deallocate (iwork, stat = ierr)
          !    call checkerr(ierr,'iwork',ilog)
          !    
          !    deallocate (afvs, stat = ierr)
          !    call checkerr(ierr,'afvs',ilog)
          !end if
          
          if (b_dynamic_memory) then
              deallocate (avs, stat = ierr)
              call checkerr(ierr,'avs',ilog)
              
              if (i_solver_type_flow == 0) then
                  deallocate (afvs, stat = ierr)
                  call checkerr(ierr,'afvs',ilog)
              end if
          end if

!c  total number of solver iterations

          itsolvtot_vs = itsolvtot_vs + itsolv

!c  update solution vector and secondary variables and check for
!c  convergence if inner iteration successful  

          if (.not.over_flow) then
            
            !Parallelized, OpenMP, DSU 
            call updatevs

!c  max. number of iterations is exceeded and convergence tolerance
!c  not satisfied
!c  steady state problem -> terminate execution


            if ((iter_vs.eq.maxit_vs).and.(not_converged)) then
              if (steady_flow) then
                  
                if (rank == 0 ) then  
                  write(ilog,*)                                       &
                   '-------------------------------------------'       
                  write(ilog,*)                                       &
                   '   terminated in routine vsflow            '       
                  write(ilog,*)                                       &
                   '   maximum number of iterations exceeded   '       
                  write(ilog,*)                                       &
                   '   bye now ...                             '       
                  write(ilog,*)                                       &
                   '-------------------------------------------'   
                end if
                
                if (rank == 0 .and. b_enable_output .and. b_enable_output_gen) then 
                  write(igen,*)                                       &
                   '-------------------------------------------'       
                  write(igen,*)                                       &
                   '   terminated in routine vsflow            '       
                  write(igen,*)                                       &
                   '   maximum number of iterations exceeded   '       
                  write(igen,*)                                       &
                   '   bye now ...                             '       
                  write(igen,*)                                       &
                   '-------------------------------------------'
                end if

#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

!c  transient problem -> reduce time step

              elseif (transient_flow) then 
               
                if(rank == 0  .and. b_enable_output)  then                    
                  write(ilog,*)                                       &
                   '-------------------------------------------'       
                  write(ilog,*)                                       &
                   '   maximum number of iterations exceeded   '       
                  write(ilog,*)                                       &
                   '             reducing time step            '       
                  write(ilog,*)                                       &
                   '-------------------------------------------'  
                end if
                
                reduce_timestep = .true.
              end if
            end if

!c  overflow occurred
!c  steady state problem -> terminate execution

          elseif (over_flow) then
            if (steady_flow) then
              
              if (rank == 0) then
                write(ilog,*)'-------------------------------------------'
                write(ilog,*)'   failure in solver - overflow occurred in vsflow   '
                write(ilog,*)'   bye now ...                             '
                write(ilog,*)'-------------------------------------------'
              end if
              
              if (rank == 0 .and. b_enable_output .and. b_enable_output_gen) then 
                write(igen,*)'-------------------------------------------'
                write(igen,*)'   failure in solver - overflow occurred in vsflow   '
                write(igen,*)'   bye now ...                             '
                write(igen,*)'-------------------------------------------'
              end if

#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop

!c  transient problem -> reduce time step

            elseif (transient_flow) then
                
              if(rank == 0 .and. b_enable_output)  then   
                write(ilog,*)'-------------------------------------------'
                write(ilog,*)'   failure in solver - overflow occurred in vsflow   '
                write(ilog,*)'             reducing time step            '
                write(ilog,*)'-------------------------------------------'
              end if
              
              reduce_timestep = .true.
            end if
          end if                      !(over_flow)
          
          prt_flow_tot = cputime() - prt_flow_tot
          
!c  write runtime to file 
          if(rank == 0 .and. b_prtfile) then
              write(iprt_flow, "(i8,1x,3(i3, 1x),i8,1x,7(e12.4,2x))")  &
                  mtime, iter_sia, iter_seep, iter_vs, ittot_vs,       &
                  prt_flow_jac, prt_flow_symbfac, prt_flow_fac,        &
                  prt_flow_sub, prt_flow_solver, (prt_flow_tot -       &
                  prt_flow_jac - prt_flow_solver), prt_flow_tot
              
              if(b_solver_test_pardiso) then
                  write(iprt_flow_comp,                                &
                      "(i8,1x,3(i3, 1x),i8,1x,5(e12.4,2x))")           &
                      mtime, iter_sia, iter_seep, iter_vs, ittot_vs,   &
                      prt_flow_fac, prt_flow_sub,                      &
                      prt_flow_symbfac_comp, prt_flow_fac_comp,        &
                      prt_flow_sub_comp
              end if
          end if
          
!c  reset primary and secondary unknowns for reduced time step        
          if (reduce_timestep) then  
#ifdef OPENMP
    !$omp parallel                                                     &                                                                
    !$omp if (nngl > numofloops_thred_global)                          & 
    !$omp num_threads(numofthreads_global)                             &
    !$omp default(shared)                                              &
    !$omp private (ivol)                                             
    !$omp do schedule(static)
#endif               
            do ivol=1,nngl
              uvsnew(ivol) = uvsold(ivol)
              hhead(ivol) = uvsold(ivol)+zg(ivol)
!#ifdef DEBUG
!              if(ivol == 14) then
!                  write(idbg,*) "-->vsflow hhead(ivol)", hhead(ivol)
!              end if
!#endif
            end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c_bubbles update reactive transport varibale also
            if (gas_bubbles) then
#ifdef OPENMP
    !$omp parallel                                                     &                                                                
    !$omp if (nngl > numofloops_thred_global)                          & 
    !$omp num_threads(numofthreads_global)                             &
    !$omp default(shared)                                              &
    !$omp private (ivol, ic, im)                                             
    !$omp do schedule(static)
#endif 
              do ivol=1,nngl
                sionnew(ivol) = sionold(ivol)
!c_bubbles reset saturations to old time level
                sanew(ivol) = saold(ivol)
                if(zero_storage) then
                  sgnew(ivol)=sgold(ivol)
                else
                  sgnew(ivol) = r1-saold(ivol)
                end if
                if (trap_bubbles) then
                  sa_min(ivol) = sa_min_old(ivol)
                  big_bubble(ivol) = big_bub_old(ivol)
                  sgt(ivol) = sgt_old(ivol)
                end if
                do ic=1,n
                  cnew(ic,ivol) = c(ic,ivol)
                end do
                if (nm.gt.r0)then
                  do im=1,nm
                    phi(im,ivol)=phiold(im,ivol)
                    cmnew(im,ivol)=cmold(im,ivol)
                  end do
                end if
              end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            end if
!c  return and start over with reduced time step

            return
          end if
 
        end do          !newton iteration loop

!c  seepage face iteration update
        if (seepage_face) then
          !Parallelized, OpenMP, DSU   
          call seepface
        end if
        
      end do            !seepage face iteration loop
     
   
!c  update soil hydraulic parameters
!c  Parallelized, OpenMP, DSU
      call soilparm(uvsnew,sanew,relperm,relpermg,sonew,mpropvs,nngl)

!c  estimate time step size for next time level
!c  Parallelized, OpenMP, DSU
      if (transient_flow) then
        call tstepvs 
      end if 

      return
      end
