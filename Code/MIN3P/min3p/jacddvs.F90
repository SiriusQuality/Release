!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 493 $
!> $Author: fgerard $
!> $Date: 2017-07-18 20:29:24 +0200 (mar., 18 juil. 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacddvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacddvs
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (density-dependent flow)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - August 16, 2002
!c
!c last modified:    Tom Henderson - September 10, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     - +
!c           bvs(nn)            = rhs vector                          - +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation
!c           pornew(nn)         = porosity (new time level)           + -
!c           relperm(nn)        = relative permeability               * +
!c           relpinc(nn)        = relative permeability (incremented) * *
!c           sainc(nn)          = aqueous phase saturation            * *
!c                                - incremented
!c           sanew(nn)          = aqueous phase saturation            * +
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           uvsinc(nn)         = solution vector (incremented)       * *
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c dens.f:   real*8:
!c           -------
!c           density(nn)        = fluid density                       + - 
!c           dcoef(ncon-1)      = coefficient including density,      + -
!c                                viscosity, and relative 
!c                                permeability 
!c           viscosity(nn)      = fluid viscosity                     + -
!c
!c
!c
!c           integer*4
!c           ---------
!c           iter_sia           = iteration counter -Picard iteration * - 
!c
!c local:    real*8:
!c           -------
!c           dqroot             = derivative of root water uptake
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsstor            = derivative of storage term
!c           dvsflux            = derivative of flux term
!c           gacc               = gravitational acceleration [m s^-2]
!c           hhinc              = hydraulic head (incremented)
!c           qroot              = root water uptake for current
!c                                control volume
!c           qrootinc           = root water uptake for current 
!c                                control volume (incremented)
!c           totvsflux          = total flux into current control 
!c                                volume
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           r0                 = constant
!c           r1                 = constant
!c
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ivol               = counter (control volumes)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           isym               = symmetry pointer
!c           jvol               = row-column pointer
!c
!c external: fluxdd    = flux function for density dependent flow
!c           rhsvs     = assembly of rhs vector
!c           rootwat   = function for computing root water uptake
!c           soilparm  = soil hydraulic parameters
!c           stordd    = storage function for density dependent 
!c                       flow 
!c ----------------------------------------------------------------------
 
      subroutine jacddvs
 
      use parm
      use gen
      use phys
      use dens
#ifdef OPENMP
      use omp_lib 
#endif 
 
      implicit none
      
      real*8 :: delt_loc, densnew_ivol, densold_ivol,          &
! CBF removed qroot
                sginc_ivol, porinc_ivol, porosity_flow, totvsflux,     &
                fluxdd, vsstor, stordd, rootwat, dtotvsflux, del_pinc, &
                vsfluxinc, dvsflux, vsstorinc, dvsstor  
                ! CBF removed qrootinc, dqroot
      integer :: i1, icon, idiag, istart, iend, isym, ivol, izn, jvol
      
      integer :: chunk

      external fluxdd, rhsvs, rootwat, soilprdd, stordd, porosity_flow

      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1=1.0d0


    
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
            if(mod(chunk, i_chunksize_factor_flow) > 0) then
                chunk = chunk/i_chunksize_factor_flow + 1
            else
                chunk = chunk/i_chunksize_factor_flow
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif
    
      if (iter_sia==1) then
        delt_loc=delt_tds
      else
        delt_loc=delt
      end if


!c  compute total potential root uptake and estimate 
!c  scaling factor
      qroot=r0
      
!c  build jacobian matrix
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (i1, icon, idiag, iend, istart, isym, ivol, izn,    &
    !$omp iups, jvol,                                                 &
    !$omp dcoef, del_p, del_pinc, del_z, densnew_ivol, densold_ivol,  &
    !$omp dtotvsflux, dvsflux, dvsstor, porinc_ivol, rho_av,          &
    !$omp sginc_ivol, totvsflux, vsflux, vsfluxinc,                   &
    !$omp vsstor, vsstorinc)                                          &                               
    !$omp firstprivate (dqroot, qroot, qrootinc)
#endif

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
      do ivol = 1,nngl             !loop over control volumes
      
        if (iter_sia==1) then
          densnew_ivol = densold(ivol)
          densold_ivol = densold2(ivol)
        else
          densnew_ivol = density(ivol)
          densold_ivol = densold(ivol)
        end if
      
      
      

        idiag = iavs(ivol)       !pointer - diagonal 
        istart = iavs(ivol)+1    !pointer - start (off-diagonal entries)
        iend = iavs(ivol+1)-1    !pointer - end (off-diagonal entries)
        
        
!c  increment primary unknown (pressure)
!c  modified increment here        
        
        uvsinc(ivol) = uvsnew(ivol) + dinc_vs
        
        izn = mpropvs(ivol)
        
        call soilprdd(uvsinc(ivol),sainc(ivol),sginc_ivol,            &
     &                relpinc(ivol),relpermg(ivol),                   &
     &                snnew(ivol),swr(izn),aentry(izn),               & !private, swr(izn)?
     &                spalpha(izn),                                   &
     &                spbeta(izn),expn(izn),spgamma(izn),             &
     &                napl_permeability,                              &
     &                napl_kfunction,sgr,isovendrying(izn),           &
     &                beta_ovendry(izn),hm_ovendry(izn),              &
     &                w0_ovendry(izn),cp0_ovendry(izn),               &
     &                ref_dens,gacc)
     
     
        if (modify_por(ivol)) then
            porinc_ivol = porosity_flow(porold(ivol),uvsinc(ivol),    &
     &                    uvsold(ivol),stor(ivol),                    &
     &                    por_stress(ivol),por_init(ivol),            &
     &                    facpormin)  
        else                  
            porinc_ivol = pornew(ivol)               
        end if
        
        
        

!c  calculate storage and flux terms for current control volume

        totvsflux = r0           !initialize total influx
        icon = 0                 !counter (connections)

      do i1=istart,iend        !loop over connected control volumes 

          jvol = javs(i1)        !column pointer

!c  compute total pressure potentials (psi) for current and adjacent 
!c  control volumes
  
          icon = icon+1          !counter (row entries)

          del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
          del_z(icon) = zg(jvol) - zg(ivol)

          if (del_z(icon) .ne. r0) then
            rho_av = rhalf * (density(ivol) + density(jvol))

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
 
            del_z(icon) = del_z(icon) * rho_av * gacc
            del_p(icon) = del_p(icon) + del_z(icon) 
          end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
 
          if (del_p(icon) .gt. r0) then
            iups(icon) = 'j'
            dcoef(icon) = relperm(jvol) *                           &
     &            density(jvol)/viscosity(jvol)
           
          else
          iups(icon) = 'i'          
          dcoef(icon) = relperm(ivol) *                             &
     &           density(ivol)/viscosity(ivol) !upstream kr, density & visc
           
          end if

!c  compute fluxes between current control volume and adjacent 
!c  control volumes
       
          vsflux(icon) = - fluxdd(del_p(icon),                        &
     &                     cinfvs_a(i1), dcoef(icon))

          totvsflux = totvsflux + vsflux(icon)

        end do                   !loop over connected control volumes

!c  compute storage term (lumped) for current control volume, 
!c  only for transient conditions

        if (transient_flow) then
          vsstor = cvol(ivol)                                         &
     &             * stordd(delt,delt_loc,pornew(ivol),porold(ivol),  &
     &               sanew(ivol),saold(ivol),                         &
     &               densnew_ivol,densold_ivol)
        else
          
          vsstor = r0
     
        end if                    

!c  compute root water uptake for current control volume
      if (root_uptake) then
        qroot = cvol(ivol)*rootwat(sanew(ivol),izn)
      end if

!c  assembly of storage and flux terms in rhs vector
!c Anna Harrison added qh2o term Jan 24 2014
      if(water_removal) then
        totvsflux = totvsflux+qh2o(ivol)/delt  
      end if
      call rhsvs(vsstor,totvsflux,bvs(ivol))

!c  add root water uptake to rhs vector

      if (root_uptake) then
          
        bvs(ivol) = bvs(ivol)-qroot(ivol) ! CBF qroot -> qroot(ivol)
        
      end if

!c  calculate derivatives of storage and flux terms for current 
!c  control volume (assembly columnwise)

        dtotvsflux = r0          !initialize derivative of total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes

          jvol = javs(i1)        !column pointer
          isym = isymvs(i1)      !symmetry pointer

          icon = icon+1

        del_pinc = uvsnew(jvol) - uvsinc(ivol)
        del_pinc = del_pinc + del_z(icon)   

!c  Use incremented relative permeability only if psi_i >= psi_j

       if (iups(icon).eq.'i')  then
        dcoef(icon) = relpinc(ivol) *                               &
     &            density(ivol)/viscosity(ivol)
        end if 

!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions
!c  flux with incremented variables and derivative of flux

          vsfluxinc = - fluxdd(del_pinc,                              &
     &                   cinfvs_a(i1),dcoef(icon))
                        
          dvsflux = (vsfluxinc - vsflux(icon))/dinc_vs
          dtotvsflux = dtotvsflux + vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
 
          avs(isym) = avs(isym) - dvsflux    !off-diagonal entries 

        end do                  !loop over connected control volumes

!c  compute storage term with incremented variables (lumped) 
!c  for current control volume, only for transient conditions

        if (transient_flow) then

          vsstorinc = cvol(ivol)                                      &
     &                * stordd(delt,delt_loc,porinc_ivol,porold(ivol),&
     &                  sainc(ivol),saold(ivol),                      &
     &                  densnew_ivol,densold_ivol)
        else
         
          vsstorinc = r0
      
        end if                  
        
       
!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs

        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  !diagonal entry

!c      write(idbg,'(4x,4a12)') 'idiag       ',
!c     &                        'avs(idiag)  ',
!c     &                        'dvsstor     ',
!c     &                        'dtotvsflux  ' 
!c
!c      write(idbg,'(4(g12.4,2x))') idiag,
!c     &                            avs(idiag),
!c     &                            dvsstor,    
!c     &                            dtotvsflux

!c  compute derivative of root water uptake for current control volume

      if (root_uptake) then

        qrootinc = cvol(ivol)*rootwat(sainc(ivol),izn)
          dqroot(ivol) = (qrootinc(ivol)-qroot(ivol))/dinc_vs 
       
          avs(idiag) = avs(idiag) + dqroot(ivol)

      end if

      end do                        !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

 
!c      do ivol=1,nngl
!c        istart = iavs(ivol)
!c        iend = iavs(ivol+1)-1
!c        write(idbg,'(8es10.3)')(avs(i1),i1=istart,iend),bvs(ivol) 
!c      end do
!c      stop


      return
      end
