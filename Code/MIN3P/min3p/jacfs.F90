!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacfs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacfs
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (fully saturated flow)
!c
!c written by:      Uli Mayer - May 2, 96
!c
!c last modified:   Uli Mayer - December 5, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     + +
!c           bvs(nn)            = rhs vector                          + +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation 
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           uvsinc(nn)         = solution vector (incremented)       * +
!c           vsflux(ncon-1)     = interfacial fluxes                  * +
!c       
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging              + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties 
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c
!c local:    real*8:
!c           -------
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsflux            = derivative of flux term
!c           dvsstor            = derivative of storage term
!c           totvsflux          = total flux into current control
!c                                volume
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (spatial discretization 
!c                                points)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           i1                 = counter (row entries)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           jvol               = row-column pointer
!c           isym               = symmetry pointer
!c
!c external: rhsvs     = assembly of rhs vector 
!c           storfs    = storage function for variably saturated 
!c                       flow 
!c           fluxfs    = flux function for fully saturated flow
!c ----------------------------------------------------------------------
 
      subroutine jacfs 
 
      use parm
      use gen
      
#ifdef OPENMP
      use omp_lib 
#endif 

      implicit none
      
      integer :: i1, ivol, icon, idiag, istart, iend, isym, jvol
      
      real*8 :: vsstorinc, vsstor, totvsflux, storfs, fluxfs,          &
                dtotvsflux, vsfluxinc, dvsflux, dvsstor
      
      integer :: chunk

      external rhsvs, storfs, fluxfs
 
      real*8, parameter :: r0 = 0.0d0
      
       vsstorinc=r0 
       vsstor=r0
       
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
            if(mod(chunk, i_chunksize_factor_flow) > 0) then
                chunk = chunk/i_chunksize_factor_flow + 1
            else
                chunk = chunk/i_chunksize_factor_flow
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif 

!c  construct Jacobian matrix
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (i1, icon, idiag, iend, istart, isym, ivol, jvol,   &
    !$omp dvsstor)                                                    &
    !$omp firstprivate(dtotvsflux, dvsflux, totvsflux, vsstor,        &
    !$omp vsstorinc, vsflux, vsfluxinc ) 
#endif

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
      do ivol = 1,nngl               !loop over control volumes
        
        istart = iavs(ivol)          !pointer - start of row
        iend = iavs(ivol+1)-1        !pointer - end of row
        idiag = iavs(ivol)           !pointer - diagonal

!c  calculate storage and flux terms for current control volume

        totvsflux = r0               !initialize total influx
        icon = 0                     !counter (connections)

        do i1=istart,iend            !loop over connections

          jvol = javs(i1)            !column pointer
          isym = isymvs(i1)          !symmetry pointer

!c  compute storage term (lumped) for current control volume,
!c  only for transient conditions

          if (ivol.eq.jvol) then
            if (transient_flow) then

              vsstor = cvol(ivol)                                     &
     &               * storfs(uvsnew(ivol),uvsold(ivol),              &
     &                 mpropvs(ivol),stor(ivol))/delt

            end if                   !(transient_flow)

!c  compute fluxes between current control volume and adjacent
!c  control volumes

          elseif (ivol.ne.jvol) then

            icon = icon+1            !counter (row entries)

            vsflux(icon) = - fluxfs(uvsnew(ivol),uvsnew(jvol),        &
     &                              cinfvs_a(i1))
            totvsflux = totvsflux + vsflux(icon)

          end if                     !(ivol.eq.jvol)/(ivol.ne.jvol)
          
          !Test
          !if(idiag == 20) then
          !    write(idbg,'(5(a,1x,e13.6,1x),a,1x,i)') "vsstor",vsstor,   &
          !          "totvsflux",totvsflux,"uvsnew(ivol)",uvsnew(ivol),   &
          !          "uvsnew(jvol)",uvsnew(jvol),"cinfvs(i1)",cinfvs(i1), &
          !          "i1",i1     
          !end if
          
        end do                       !loop over connections
        
!c  assembly of storage and flux terms in rhs vector
!c Anna Harrison added qh2o term Jan 24 2014
        if(water_removal) then
          totvsflux = totvsflux+qh2o(ivol)/delt  
        end if
        call rhsvs(vsstor,totvsflux,bvs(ivol))

!c  calculate derivatives of storage and flux terms for current
!c  control volume (assembly columnwise)

        uvsinc(ivol) = uvsnew(ivol)+dinc_vs   !increment hydraulic head
        dtotvsflux = r0              !zero derivative (total influx)
        icon = 0                     !counter (connections)

        do i1=istart,iend            !loop over connections

          jvol = javs(i1)            !column pointer
          isym = isymvs(i1)          !symmetry pointer

!c  compute storage term with incremented variables (lumped)
!c  for current control volume, only for transient conditions

          if (ivol.eq.jvol) then
            if (transient_flow) then

!c  storage term for current control volume with incremented variables

              vsstorinc = cvol(ivol)                                  &
     &                  * storfs(uvsinc(ivol),uvsold(ivol),           &
     &                    mpropvs(ivol),stor(ivol))/delt

            end if                   !(transient_flow)

!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions

          elseif (ivol.ne.jvol) then

!c  flux with incremented variables and derivative of flux

            icon = icon+1
            vsfluxinc = - fluxfs(uvsinc(ivol),uvsnew(jvol),           &
     &                           cinfvs_a(i1))
            dvsflux = (vsfluxinc-vsflux(icon))/dinc_vs
            dtotvsflux = dtotvsflux+vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)

            !Test
            !if(idiag == 20) then
            !    write(idbg,'(7(a,1x,e13.6))') "avs_1",avs(isym),       &
            !          "dvsflux",dvsflux,"dtotvsflux",dtotvsflux,       &
            !          "vsfluxinc",vsfluxinc,"uvsinc(ivol)",            &
            !          uvsinc(ivol),"uvsnew(jvol)",uvsnew(jvol),        &
            !          "cinfvs(i1)",cinfvs(i1)
            !end if
            
            avs(isym) = avs(isym) - dvsflux      !off-diagonal entries

          end if                    !(ivol.eq.jvol)/(ivol.ne.jvol)
        end do                      !loop over connections

!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs       !derivatives
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs

        !Test
        !if(idiag == 20) then
        !    write(idbg,'(7(a,1x,e13.6,1x))') "avs_2",avs(idiag),       &
        !          "dvsstor",dvsstor,"dtotvsflux",dtotvsflux,           &
        !          "totvsflux",totvsflux,"dinc_vs",dinc_vs,             &
        !          "vsstorinc",vsstorinc,"vsstor",vsstor
        !end if
        
        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  !diagonal entry

      end do                        !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!cdbg
!c     do ivol=1,nngl
!c       istart = iavs(ivol)
!c       iend = iavs(ivol+1)-1
!c       write(idbg,'(8e10.3)')(avs(i1),i1=istart,iend),bvs(ivol)
!c     end do
!c     stop
!cdbg

      return
      end
