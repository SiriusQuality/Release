!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/iajavs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine iajavs
!c -----------------
!c
!c set up ia-ja data-structure for variably saturated flow 
!c      
!c                z
!c                     y
!c                7  
!c                |  5                  local connection list 
!c                | /                   for ja pointer array
!c                |/                    
!c       2--------1----------3  x     
!c               /|
!c              / |
!c             4  |
!c                6
!c
!c nonexistent connections (1D-2D-boundary effects) are skipped:
!c
!c      z
!c            
!c      4                     e.g.
!c      |                     x-z plane - on boundary x=0
!c      |                     
!c      |                     
!c      1----------2  x     
!c      |
!c      |
!c      |
!c      3
!c
!c written by:      Uli Mayer - June 6, 96 
!c
!c last modified:   -
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.f:   integer*4:
!c           ----------
!c           mnjavs             = max. number of entries in avs,javs  + -
!c           ncon               = number of node connections          + -
!c
!c gen.f:    integer*4:
!c           ---------- 
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook                + -
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c           iavs(nn+1)         = row pointer array for avs           * +
!c           javs(njavs)        = connectivity list                   * +
!c           isymvs(njavs)      = symmetry pointer array              * +
!c           njavs              = number of global connections        * +
!c
!c local:    idebug             = key for activation of debig output
!c           ivx                = counter (number of control volumes
!c                                in x-direction)
!c           ivy                = counter (number of control volumes
!c                                in y-direction)
!c           ivz                = counter (number of control volumes
!c                                in z-direction)
!c           ivol               = pointer (current control volume)
!c           ivxp               = pointer (previous control volume
!c                                in x-direction) 
!c           ivxn               = pointer (next control volume in 
!c                                x-direction)
!c           ivyp               = pointer (previous control volume
!c                                in y-direction)
!c           ivyn               = pointer (next control volume in
!c                                y-direction)
!c           ivzp               = pointer (previous control volume
!c                                in z-direction)
!c           ivzn               = pointer (next control volume in
!c                                z-direction)
!c           jtemp              = pointer to colum entries
!c           nedge              = number of adjacent control volumes
!c           irow1              = counter (rows)
!c           icol1              = pointer (columns)
!c           istart1            = pointer (first entry of row)
!c           iend1              = pointer (last entry of row)
!c           i1                 = counter (column entries in row)
!c           irow2              = counter (rows)
!c           icol2              = pointer (columns)
!c           istart2            = pointer (first entry of row)
!c           iend2              = pointer (last entry of row)
!c           i2                 = counter (column entries in row)
!c           found              = .true.  -> exit loop over columns
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine iajavs
 
      use parm
      use gen
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: i1, i2, icol1, icol2, idebug, irow, irow1, irow2,     &
                 istart, istart1, istart2, iend, iend1, iend2,         &
                 ivx, ivy, ivz, ivxp, ivxn, ivyp, ivyn, ivzp, ivzn,    &
                 ivol, jtemp, nedge

      logical found

!c  define initial row pointer
!c  this part cannot be parallelized because of "jtemp = iavs(ivol)"
   
      iavs(1) = 1
      ivol = 0
      jtemp = 0
 
      do ivz = 1,nvzgl                      ! number of control volumes in z
        do ivy = 1,nvygl                    ! number of control volumes in y 
          do ivx = 1,nvxgl                  ! number of control volumes in x

!c  pointer to current control volume

            ivol = ivol+1

!c  pointers to previous colums in x,y and z

            ivxp = ivx-1
            ivxn = ivx+1
            ivyp = ivy-1
            ivyn = ivy+1
            ivzp = ivz-1
            ivzn = ivz+1

!c  make sure array bounds are not violated

            if (jtemp+ncon.gt.mnjavs) then
              if (rank == 0) then  
                write(ilog,*) 'stop in routine iajavs'
                write(ilog,*) 'check array dimensions of mnjavs'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

            jtemp = iavs(ivol)            ! pointer to diagonal entry

!c  assign diagonal entry 

            javs(jtemp) = ivol            ! diagonal entry
            jtemp = jtemp+1               ! pointer to next entry 

!c  assign variables for set up of colum pointer for off-diagonal entries

            nedge = 0                     ! max. number of adjacent volumes

!c  assign column pointers for off-diagonal entries in x-direction

            if (nvxgl.gt.1) then            ! connections in x-direction

              if (ivxp.gt.0) then         ! left connection   (2)
                nedge = nedge+1
                javs(jtemp) = ivol-1
                jtemp = jtemp+1
              end if

              if (ivxn.le.nvxgl) then       ! right connection  (3)
                nedge = nedge+1
                javs(jtemp) = ivol+1
                jtemp = jtemp+1
              end if

            end if                        ! connections in x-direction

!c  assign column pointers for off-diagonal entries in y-direction

            if (nvygl.gt.1) then            ! connections in y-direction

              if (ivyp.gt.0) then         ! front connection (4)
                nedge = nedge+1
                javs(jtemp) = ivol-nvxgl
                jtemp = jtemp+1
              end if

              if (ivyn.le.nvygl) then       ! back connection (5)
                nedge = nedge+1
                javs(jtemp) = ivol+nvxgl
                jtemp = jtemp+1
              end if
 
            end if                        ! connections in y-direction


!c  assign column pointers for off-diagonal entries in z-direction

            if (nvzgl.gt.1) then            ! connections in z-direction

              if (ivzp.gt.0) then         ! bottom connection (6)
                nedge = nedge+1
                javs(jtemp) = ivol-nvxgl*nvygl
                jtemp = jtemp+1
              end if

              if (ivzn.le.nvzgl) then       ! top connection (6)
                nedge = nedge+1
                javs(jtemp) = ivol+nvxgl*nvygl
                jtemp = jtemp+1
              end if

            end if                        ! connections in z-direction

!c  assign next row pointer
     
            iavs(ivol+1) = iavs(ivol)+nedge+1
          
          end do                          ! number of increments in x
        end do                            ! number of increments in y
      end do                              ! number of increments in z

!c  assign number of entries

      njavs = iavs(nngl+1) - 1

!c  symmetry pointer
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_iajavs_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, i2, icol1, icol2, iend1, iend2,                &
    !$omp irow1, irow2, istart1, istart2, found)
    !$omp do schedule(static)
#endif
      do irow1=1,nngl                   ! loop over rows (control volumes)
        istart1 = iavs(irow1)
        iend1 = iavs(irow1+1)-1
        do i1=istart1,iend1           ! loop over column entries
          icol1=javs(i1)              ! current column 
          irow2=icol1                 ! row to be searched
          istart2=iavs(irow2)
          iend2 = iavs(irow2+1)-1
          i2 = istart2
          found = .false.
 
!c  search row for pointer to corresponding symmetric entry

          do while ((.not.found).and.(i2.le.iend2))  
            icol2 = javs(i2)           
            if (icol2.eq.irow1) then
              isymvs(i1) = i2         ! assign symmetry pointer
              found = .true.
            end if
            i2 = i2+1
          end do
        end do
      end do 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef PETSC  
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_iajavs_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i1, irow1, istart1, iend1)
    !$omp do schedule(static)
#endif
      do irow1=1,nngl                   ! loop over rows (control volumes)
        istart1 = iavs(irow1)
        iend1 = iavs(irow1+1)-1
        if(node_idx_lg2l(irow1) > 0) then
          row_idx_l2pg_vs(irow1) = node_idx_lg2pg(irow1)
        else
          row_idx_l2pg_vs(irow1) = - node_idx_lg2pg(irow1)  
        end if
        do i1=istart1,iend1           ! loop over column entries
            col_idx_l2pg_vs(i1) = node_idx_lg2pg(javs(i1))
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
#endif

!cdbg
#ifdef DEBUG
      idebug = 0
      if(idebug.gt.0) then
        do irow=1,nngl + 1
          write(idbg,*) 'ia(',irow,') = ',iavs(irow)
        end do
        do irow=1,nngl
          istart = iavs(irow)
          iend = iavs(irow+1)-1
          write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart,iend)
        end do
        do irow=1,nngl
          istart = iavs(irow)
          iend = iavs(irow+1)-1
          write(idbg,*) ('isymvs(',i1,') = ',isymvs(i1),i1=istart,iend)
        end do
      end if
#endif
!cdbg

     !if (b_solver_test_pardiso) then
     !    write(idbg,*) "set up ia-ja data-structure for variably saturated flow"
     !   do irow=1,nn + 1
     !     write(idbg,*) 'ia(',irow,') = ',iavs(irow)
     !   end do
     !   do irow=1,nn
     !     istart = iavs(irow)
     !     iend = iavs(irow+1)-1
     !     write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart,iend)
     !   end do
     !   do irow=1,nn
     !     istart = iavs(irow)
     !     iend = iavs(irow+1)-1
     !     write(idbg,*) ('isymvs(',i1,') = ',isymvs(i1),i1=istart,iend)
     !   end do   
     !end if
     
      return
      end
