!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/fluxheat.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function fluxv_vl
!c ------------------------
!c   at upstream control volume
!c
!c external: -  
!c ----------------------------------------------------------------------
 
      real*8 function fluxheat(temp_i,temp_j,i,j,vflux,       &
                                  ncell,tempold,i2up,         &
                                  spatial_weighting,d_i,d_j)
 
      implicit none
      
      integer :: i, j, ncell 
      real*8 :: temp_i, temp_j, vflux, d_i, d_j
      
      integer :: i2
      real*8 :: r0, rquarter, rhalf, r1, r2, eps, hugevalue, delta_temp
      real*8 :: temp_ij, totc_ups, totc_dwn, totc_i2up, r_ij, theta_r_ij
      
      parameter (r0 = 0.0d0, rquarter = 0.25d0, rhalf = 0.5d0, &
                r1 = 1.0d0, r2 = 2.0d0, eps = 1.d-300, hugevalue = 1.0d200)
     
      real*8 tempold(ncell)
      
      integer i2up(ncell)
     
      character(len=*)  spatial_weighting
      
      temp_ij = r0      
      
      if (spatial_weighting.eq.'upstream') then

        if (vflux>r0) then
          temp_ij = temp_i
        else
          temp_ij = temp_j
        end if
        
      elseif (spatial_weighting.eq.'centered2') then

        
        temp_ij =  temp_i*temp_j * (d_i + d_j) /  &
                 (temp_i*d_i + temp_j*d_j)
        

!c  centered weigthing 

      elseif (spatial_weighting.eq.'centered') then

        temp_ij = rhalf*(temp_i+temp_j)

!c  Van Leer flux limiter

      elseif (spatial_weighting.eq.'vanleer'.or.  &
             spatial_weighting.eq.'vanleer2') then

!c  define upstream and downstream point and retrieve pointer
!c  to second upstream point

        if (vflux>r0) then
          totc_ups = temp_i
          totc_dwn = temp_j
          i2 = i2up(i)
        else
          totc_ups = temp_j
          totc_dwn = temp_i
          i2 = i2up(j)
        end if

!c  second upstream point exitsts 
!c  compute weighting term

        if (i2.ne.0) then

!c  define second upstream point

          totc_i2up = tempold(i2)

!c  second upstream node exists
!c  compute smoothness sensor r_ij
!c  fix bug of infinity value when divided by eps, use hugevalue instead. DSU,2014-11-13

          if (vflux>r0) then
            delta_temp = tempold(j) - tempold(i)
            if (abs(delta_temp) < eps) then
              if (delta_temp + eps > 0) then
                r_ij = (tempold(i) - totc_i2up) * hugevalue
              else
                r_ij = -(tempold(i) - totc_i2up) * hugevalue
              end if
            else
              r_ij = (tempold(i) - totc_i2up)/  &
                     (tempold(j) - tempold(i) + eps)
            end if
          else
            delta_temp = tempold(i) - tempold(j)
            if (abs(delta_temp) < eps) then
              if (delta_temp + eps > 0) then
                r_ij = (tempold(j) - totc_i2up) * hugevalue
              else
                r_ij = -(tempold(j) - totc_i2up) * hugevalue
              end if
            else
              r_ij = (tempold(j) - totc_i2up)/  &
                    (tempold(i) - tempold(j) + eps)
            end if
          end if


!c  compute Van Leer flux limiter theta_r_ij

          if (r_ij.gt.0) then
            theta_r_ij = r2 * r_ij/(r1 + r_ij)
          else
            theta_r_ij = r0
          end if

!c  second upstream point does not exist
!c  set weighting term to zero

        else

          theta_r_ij = r0

        end if

!c  compute total aqueous component concentration at interface

        if (spatial_weighting.eq.'vanleer') then
          temp_ij = totc_ups                                  &
                 + rhalf * theta_r_ij * (totc_dwn - totc_ups) 
        elseif (spatial_weighting.eq.'vanleer2') then
          temp_ij = totc_ups                                  &
                 + rquarter * theta_r_ij * (totc_dwn - totc_ups) 
        end if

      end if

!c  compute advective flux

      fluxheat = vflux * temp_ij
 
      return
      end
