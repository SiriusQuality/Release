!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/sortcomp.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine sortcomp
!c -------------------
!c
!c  redox couples specified:
!c  ------------------------
!c
!c  sort components in the order
!c  - components which are not part of a redox couple
!c  - surface sites
!c  - primary component of redox couple
!c  - secondary component of redox couple
!c  - h2o
!c  and construct ordering vector
!c
!c  no redox couples specified:
!c  ---------------------------
!c  natural ordering
!c
!c written by:      Uli Mayer - June 11, 97
!c
!c last modified:   -
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, log file               + -
!c
!c common:
!c chem.f:   integer*4:
!c           ----------
!c           l_namerp(nr)       = length of names of primary          + -
!c                                components of redox couples
!c           l_namers(nr)       = length of names of secondary        + -
!c                                components of redox couples
!c           nc                 = number of components                + -
!c           ncorder(nc)        = ordering array for components
!c                                ncorder (old order) = new order
!c           nr                 = number of redox couples             + -
!c
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + +
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           namec(nc)          = component names                     + +
!c           namerp(nr)         = names of primary components of      * +
!c                                redox couples
!c           namers(nr)         = names of secondary components of    * +
!c                                redox couples
!c           namet(30)          = species names (temporary)           * *
!c
!c local:    integer*4:  
!c           ----------
!c           ic                 = counter (components)
!c           ic2                = counter (components)
!c           info_debug         = flag controlling debugging 
!c                                options
!c           ir                 = counter (redox couples)
!c           itemp              = counter (components)
!c
!c           logical:
!c           --------
!c           done               = .true.  -> exit search
!c           found              = .true.  -> exit search
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine sortcomp(idbg,ilog)
 
      use parm
      use chem
      use gen, only : rank, b_enable_output
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
      implicit none
      
      integer :: idbg, ilog
      integer :: i, ic, ic2, ir, info_debug, itemp

      logical done, found

!c  redox couples are specified, reorder components and construct
!c  ordering vector

      if (nr.gt.0) then

        itemp = 0

        do ic=1,nc-1                            !loop over components

!c  search for components which are not part of a redox couple

          found = .true.
          do ir = 1,nr  
            if (namec(ic).eq.namerp(ir).or.       &
     &          namec(ic).eq.namers(ir)) then
              found = .false.
            end if
          end do

          if (found) then
            itemp = itemp+1
            namet(itemp) = namec(ic)
            namet(nc-1+itemp) = trim(component_type(ic))
          end if

        end do                                  !loop over components

!c  search for primary components of redox couples

        ir = 0
        found = .false.

        do ir = 1,nr                           !loop over redox couples

          found = .false.
          ic = 0

          do while (.not.found.and.ic.lt.nc-1)  !loop over components

            ic = ic+1

!c  primary component found

            if (namec(ic).eq.namerp(ir)) then

              found = .true.
              itemp = itemp+1
              namet(itemp) = namerp(ir)
              namet(itemp+nr) = namers(ir)
              namet(nc-1+itemp) = 'aqueous'
              namet(nc-1+itemp+nr) = 'aqueous'

!c  check, if secondary component of redox couple is specified

              ic2 = 0
              done = .false.
              do while ((ic2.lt.nc).and.(.not.done))
                ic2 = ic2+1
                if (namers(ir).eq.namec(ic2)) then
                  done = .true.
                end if
              end do

!c  exit, if secondary component of redox couple is not specified

              if (.not.done) then
                if (rank == 0) then  
                  write(ilog,'(72a)') ('-',i=1,72)
                  write(ilog,'(a,1x,a,1x,a)')                           &
     &                 'secondary component',namers(ir)(:l_namers(ir)), &
     &                 'for redox couple is missing'
                  write(ilog,'(72a)') ('-',i=1,72)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if

            end if                     !(namec(ic).eq.namerp(ir))

          end do                       !loop over components

!c  exit if primary component is not specified in component input

          if (.not.found) then
            if (rank == 0) then
              write(ilog,'(72a)') ('-',i=1,72)
              write(ilog,'(a,1x,a,1x,a)')'primary component',           &
     &                                      namerp(ir)(:l_namerp(ir)),  &
     &                                      'for redox couple is missing'
              write(ilog,'(72a)') ('-',i=1,72)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if

        end do                                  !loop over redox couples

!c  assign ordering array: ncorder(old order) = new order

        do ic = 1,nc-1
          ic2 = 0
          found = .false.
          do while (.not.found.and.ic2.lt.nc-1) 
            ic2 = ic2+1
            if (namec(ic).eq.namet(ic2)) then
              found = .true.
              ncorder(ic) = ic2
            end if
          end do
        end do

        ncorder(nc) = nc

!c  reassign component names and component types to permanent storage

        do ic = 1,nc-1
          namec(ic) = namet(ic)
          component_type(ic) = trim(namet(nc-1+ic)) 
        end do

      else

!c  no redox species are specified, natural ordering

        do ic = 1,nc
          ncorder(ic) = ic
        end do

      end if

!cdbg  activate this section for purposes of debugging
#ifdef DEBUG 
      info_debug = 0

      if (info_debug.gt.0) then
        write(idbg,'(a)') 'returning from sortcomp ...'
        do ic=1,nc
          write(idbg,'(a72,1x,i5)') namec(ic),ncorder(ic)
        end do
        write(idbg,*) '----------------------------------------------'
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif 
        stop
      end if
#endif
!cdbg
      return
      end
  
