!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 488 $
!> $Author: cblitz $
!> $Date: 2017-07-17 18:22:05 +0200 (Mon, 17 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/sptldisc.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine sptldisc
!c -------------------
!c
!c read spatial discretization parameters,
!c discretize solution domain and compute nodal volumes
!c
!c written by:      Uli Mayer - May 11, 96
!c
!c last modified:   Uli Mayer - November 25, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.f:   -
!c
!c gen.f:    real*8:
!c           -------
!c           xmax(nxx)          = max. coordinate of discretization   * +
!c                                interval in x-direction
!c           xmin(nxx)          = min. coordinate of discretization   * +
!c                                interval in x-direction
!c           ymax(nyy)          = max. coordinate of discretization   * +
!c                                interval in y-direction
!c           ymin(nyy)          = min. extent of solution domain      * +
!c                                in y-direction
!c           zmax(nzz)          = max. extent of solution domain      * +
!c                                in z-direction
!c           zmin(nzz)          = min. extent of solution domain      * +
!c                                in z-direction
!c           cvol(nn)           = nodal volumes                       * +
!c           dimcv(3,nn)        = dimension of control volumes        * +
!c           xg(nn)             = spatial coordinates in x-direction  * +
!c           yg(nn)             = spatial coordinates in y-direction  * +
!c           zg(nn)             = spatial coordinates in z-direction  * +
!c           tkel(nn)           = nodal temperatures in Kelvin        * +
!c           delx(nvx)          = spatial increment in x-direction    * +
!c           dely(nvy)          = spatial increment in y-direction    * +
!c           delz(nvz)          = spatial increment in z-direction    * +
!c           toparea            = profil area exposed to atmosphere   * + CBF ADDED
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific inputs    + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log file               + -
!c           itmp               = unit number, temporary storage      + -
!c           nxx                = number of intervals in x-direction  * +
!c           nyy                = number of intervals in y-direction  * +
!c           nzz                = number of intervals in z-direction  * +
!c           nvix(nxx)          = number of control volumes in        * +
!c                                x-direction (intervals)
!c           nviy(nyy)          = number of control volumes in        * +
!c                                y-direction (intervals)
!c           nviz(nzz)          = number of control volumes in        * +
!c                                z-direction (intervals)
!c           nvx                = number of control volumes in        * +
!c                                x-direction
!c           nvy                = number of control volumes in        * +
!c                                y-direction
!c           nvz                = number of control volumes in        * +
!c                                z-direction
!c           nn                 = total number of control volumes     * +
!c
!c           logical:
!c           --------
!c           half_cells         = .true.  -> half cells on boundary   * +
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * *
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c           ixx                = counter (intervals in x-direction)
!c           iyy                = counter (intervals in y-direction)
!c           izz                = counter (intervals in z-direction)
!c           l_string           = length of text string
!c
!c           real*8:
!c           -------
!c           xtot               = total dimension in x-direction ! CBF ADDED for toparea
!c           ytot               = total dimension in y-direction ! CBF ADDED for toparea
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c
!c external: checkerr  = check for error during memory allocation 
!c           cvolume   = compute volumes on a nodal basis
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           xyzcoord  = compute spatial increments for x,y and 
!c                       z-direction and calculate xyz-coordinates 
!c                       of control volume centroids
!c---------------------------------------------------------------------- 
!c WARNING
!c---------------------------------------------------------------------- 
!c All allocated variables are initialized to some value. This depends  
!c of its type:
!c 
!c real*8      => 0.0d0
!c integer     => 0 
!c character   => ' '    
!c logical     => .false. 
!c 
!c Sergio Andres Bea Jofre (2009)
!c
!c ----------------------------------------------------------------------
 
      subroutine sptldisc
 
      use parm
      use gen
#ifdef PETSC
      use solver_dd, only : solver_dd_DMDACreate_flow
      use solver_snes_common, only: dmda_flow
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif      
      
      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif

      external checkerr, cvolume, readbloc, xyzcoord

      logical found_section,found_subsection
      character*72 subsection
      
      integer :: i, ierr, ixx, iyy, izz, l_string
      integer :: nvx_inter, nvy_inter, nvz_inter

      real*8 :: xtot, ytot! CBF to calculate toparea! Beware if n zones in x or y => calculation must be incorrect

!c  choose spatial discretization type, the default is strucutre grid


!c  radial coordinates option
      radial_coord = .false.  

!c  optional use of radial coordinates

      section_header = 'radial coordinates'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (found_section) then
        radial_coord = .true.
      end if

      section_header = 'full cells'
      call readbloc (idat,itmp,section_header,found_section,.true.)
      half_cells = .true.
      if (found_section) then
        half_cells = .false.
      end if


!c  read spatial discretization parameters and write to temporary file   
   
      section_header = 'spatial discretization'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  read spatial discretization parameters and allocate memory

!c  x-direction

      nvxgbl = 0
      read(itmp,*,err=999,end=999) nxx

      allocate (xmax(nxx), stat = ierr)
      xmax=0.0d0
      call checkerr(ierr,'xmax',ilog)
      allocate (xmin(nxx), stat = ierr)
      xmin=0.0d0
      call checkerr(ierr,'xmin',ilog)
      allocate (nvix(nxx), stat = ierr)
      nvix=0 
      call checkerr(ierr,'nvix',ilog)

      do ixx = 1,nxx
        read(itmp,*,err=999,end=999) nvix(ixx)
        read(itmp,*,err=999,end=999) xmin(ixx), xmax(ixx) 
        nvxgbl = nvxgbl+nvix(ixx)
	    xtot=xmax(ixx)-xmin(ixx)
      end do

      allocate (delx(nvxgbl), stat = ierr)
      delx=0.0d0
      call checkerr(ierr,'delx',ilog)
      
      allocate (xglat(nvxgbl), stat = ierr)
      xglat=0.0d0
      call checkerr(ierr,'xglat',ilog)

!c  y-direction

      nvygbl = 0
      read(itmp,*) nyy

      allocate (ymax(nyy), stat = ierr)
      ymax=0.0d0
      call checkerr(ierr,'ymax',ilog)
      allocate (ymin(nyy), stat = ierr)
      ymin=0.0d0
      call checkerr(ierr,'ymin',ilog)
      allocate (nviy(nyy), stat = ierr)
      nviy=0 
      call checkerr(ierr,'nviy',ilog)

      do iyy = 1,nyy
        read(itmp,*,err=999,end=999) nviy(iyy)
        read(itmp,*,err=999,end=999) ymin(iyy), ymax(iyy) 
        nvygbl = nvygbl+nviy(iyy)
	    ytot=ymax(iyy)-ymin(iyy)	! CBF
      end do
 
      allocate (dely(nvygbl), stat = ierr)
      dely=0.0d0
      call checkerr(ierr,'dely',ilog)
      
      allocate (yglat(nvygbl), stat = ierr)
      yglat=0.0d0
      call checkerr(ierr,'yglat',ilog)

!c  z-direction

      nvzgbl = 0
      read(itmp,*,err=999,end=999) nzz

      allocate (zmax(nzz), stat = ierr)
      zmax=0.0d0
      call checkerr(ierr,'zmax',ilog)
      allocate (zmin(nzz), stat = ierr)
      zmin=0.0d0
      call checkerr(ierr,'zmin',ilog)
      allocate (nviz(nzz), stat = ierr)
      nviz=0 
      call checkerr(ierr,'nviz',ilog)

      do izz = 1,nzz
        read(itmp,*,err=999,end=999) nviz(izz)
        read(itmp,*,err=999,end=999) zmin(izz), zmax(izz)
        nvzgbl = nvzgbl+nviz(izz)
      end do

      allocate (delz(nvzgbl), stat = ierr)
      delz=0.0d0
      call checkerr(ierr,'delz',ilog)
      
      allocate (zglat(nvzgbl), stat = ierr)
      zglat=0.0d0
      call checkerr(ierr,'zglat',ilog)

!c  calculate total number of control volumes
      nngbl = nvxgbl*nvygbl*nvzgbl

!c  calculate profil area exposed to atmosphere CBF ADDED

      toparea = xtot*ytot

#ifdef PETSC
      if (nngbl < nprcs*2) then
        if (rank == 0) then
          write(ilog,'(a)')                                            &
                'Error: Required minimum subdomain discretization is 2.'
          write(ilog,'(a)')                                            &
                '       Increase discretization or use less processors.'
          write(*,'(a)')                                               &
                'Error: Required minimum subdomain discretization is 2.'
          write(*,'(a)')                                               &
                '       Increase discretization or use less processors.'
        end if
        call petsc_mpi_finalize
        stop        
      end if
#endif
      
!c  domain decomposition
#ifdef PETSC 
      call solver_dd_DMDACreate_flow

      nvx = dmda_flow%xl
      nvy = dmda_flow%yl
      nvz = dmda_flow%zl
      nvxgl = dmda_flow%gxl
      nvygl = dmda_flow%gyl
      nvzgl = dmda_flow%gzl
      nvxls = dmda_flow%xs
      nvxle = dmda_flow%xe
      nvyls = dmda_flow%ys
      nvyle = dmda_flow%ye
      nvzls = dmda_flow%zs
      nvzle = dmda_flow%ze
      nvxgls = dmda_flow%gxs
      nvxgle = dmda_flow%gxe
      nvygls = dmda_flow%gys
      nvygle = dmda_flow%gye
      nvzgls = dmda_flow%gzs
      nvzgle = dmda_flow%gze
#else
      nvx = nvxgbl
      nvy = nvygbl
      nvz = nvzgbl
      nvxgl = nvxgbl
      nvygl = nvygbl
      nvzgl = nvzgbl
      nvxls = 1
      nvxle = nvxgbl
      nvyls = 1
      nvyle = nvygbl
      nvzls = 1
      nvzle = nvzgbl
      nvxgls = 1
      nvxgle = nvxgbl
      nvygls = 1
      nvygle = nvygbl
      nvzgls = 1
      nvzgle = nvzgbl       
#endif
      nn = nvx*nvy*nvz
      nngl  = nvxgl*nvygl*nvzgl 
      
      if(nvx > 1) then
        nvx_inter = nvx-1+nvxls-nvxgls
      else 
        nvx_inter = 1
      end if
      
      if(nvy > 1) then
        nvy_inter = nvy-1+nvyls-nvygls
      else 
        nvy_inter = 1
      end if
      
      if(nvz > 1) then
        nvz_inter = nvz-1+nvzls-nvzgls
      else 
        nvz_inter = 1
      end if   
      
      nn_interfacial = nvx_inter*nvy_inter*nvz_inter
      
#ifdef PETSC
      allocate(nn_ranks(nprcs))
      nn_ranks = 0
      allocate(nngl_ranks(nprcs))
      nngl_ranks = 0
      allocate(nn_interfacial_ranks(nprcs))
      nn_interfacial_ranks = 0
      
      call MPI_Allgather(nn, 1, MPI_INTEGER4, nn_ranks, 1,             &
                         MPI_INTEGER4, Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      
      call MPI_Allgather(nngl, 1, MPI_INTEGER4, nngl_ranks, 1,         &
                         MPI_INTEGER4, Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      
      call MPI_Allgather(nn_interfacial, 1, MPI_INTEGER4,              &
                         nn_interfacial_ranks, 1, MPI_INTEGER4,        &
                         Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      
      nn_offset = 0
      nngl_offset = 0 
      nn_interfacial_offset = 0
      do i = 1, rank
        nn_offset = nn_offset + nn_ranks(i)
        nngl_offset = nngl_offset + nngl_ranks(i)
        nn_interfacial_offset = nn_interfacial_offset +                &
                                nn_interfacial_ranks(i)
      end do
#endif

!c  allocate remaining arrays for spatial discretization
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif 
      allocate (cvol(nngl), stat = ierr)
      cvol=0.0d0
      call checkerr(ierr,'cvol',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif    
      allocate (xg(nngl), stat = ierr)
      xg=0.0d0
      call checkerr(ierr,'xg',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (yg(nngl), stat = ierr)
      yg=0.0d0
      call checkerr(ierr,'yg',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (zg(nngl), stat = ierr)
      zg=0.0d0
      call checkerr(ierr,'zg',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (dimcv(3,nngl), stat = ierr)
      dimcv=0.0d0
      call checkerr(ierr,'dimcv',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (tkel(nngl), stat = ierr)
      tkel=0.0d0
      call checkerr(ierr,'tkel',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

#ifdef PETSC
      allocate(rtempvals(nngbl),stat = ierr)
      rtempvals=0.0d0
      call checkerr(ierr,'rtempvals',ilog)
#endif

!c  calculate spatial increments and coordinates of for centroids of 
!c  control volumes
!c  Parallelized, OpenMP, DSU

      call xyzcoord
      
#ifdef PETSC
      xlmin = dmda_flow%xlmin
      xlmax = dmda_flow%xlmax
      ylmin = dmda_flow%ylmin
      ylmax = dmda_flow%ylmax
      zlmin = dmda_flow%zlmin
      zlmax = dmda_flow%zlmax
      xlmingbl = dmda_flow%xlmingbl
      xlmaxgbl = dmda_flow%xlmaxgbl
      ylmingbl = dmda_flow%ylmingbl
      ylmaxgbl = dmda_flow%ylmaxgbl
      zlmingbl = dmda_flow%zlmingbl
      zlmaxgbl = dmda_flow%zlmaxgbl      
#else
      xlmin = xg(1)
      xlmax = xg(nn)
      ylmin = yg(1)
      ylmax = yg(nn)
      zlmin = zg(1)
      zlmax = zg(nn)
      xlmingbl = xg(1)
      xlmaxgbl = xg(nn)
      ylmingbl = yg(1)
      ylmaxgbl = yg(nn)
      zlmingbl = zg(1)
      zlmaxgbl = zg(nn) 
#endif

      if (xglat(nvxgls)< xglat(nvxgle)) then
        gxlmin = xglat(nvxgls)
        gxlmax = xglat(nvxgle)
      else
        gxlmin = xglat(nvxgle)
        gxlmax = xglat(nvxgls)  
      end if
      
      if (yglat(nvygls)< yglat(nvygle)) then
        gylmin = yglat(nvygls)
        gylmax = yglat(nvygle)
      else
        gylmin = yglat(nvygle)
        gylmax = yglat(nvygls)  
      end if
      
      if (zglat(nvzgls)< zglat(nvzgle)) then
        gzlmin = zglat(nvzgls)
        gzlmax = zglat(nvzgle)
      else
        gzlmin = zglat(nvzgle)
        gzlmax = zglat(nvzgls)  
      end if

!c  calculate volumes
!c  Parallelized, OpenMP, DSU

      call cvolume

!c  write spatial discretization parameters to generic output file
      if (b_enable_output .and. b_enable_output_gen) then
          
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)
      
#ifdef PETSC
      write(igen,'(a)')                                               &
        "spatial discretization for local grid without ghost nodes"
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in x-direction        = ',nvx         
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in y-direction        = ',nvy         
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in z-direction        = ',nvz         
      write(igen,'(a,i10)')                                           &
     &'total number of control volumes                 = ',nn
      write(igen,'(/a)') "spatial discretization for global grid" 
     
      write(igen,'(/a)')                                               &
        "spatial discretization for local grid with ghost nodes"
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in x-direction        = ',nvxgl         
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in y-direction        = ',nvygl         
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in z-direction        = ',nvzgl         
      write(igen,'(a,i10)')                                           &
     &'total number of control volumes                 = ',nngl
      write(igen,'(/a)') "spatial discretization for global grid" 
#endif

      write(igen,'(a,i10)')                                           &
     &'number of control volumes in x-direction        = ',nvxgbl         
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in y-direction        = ',nvygbl         
      write(igen,'(a,i10)')                                           &
     &'number of control volumes in z-direction        = ',nvzgbl         
      write(igen,'(a,i10)')                                           &
     &'total number of control volumes                 = ',nngbl
      
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
