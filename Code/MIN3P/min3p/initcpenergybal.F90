!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initcpenergybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcpenergybal
!c -------------------
!c
!c control parameters for energy balance
!c
!c written by:      Sergio Andres bea Jofre 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           deltol_vs          = solver update tolerance             * +
!c           dinc_vs            = increment for numerical             * +
!c                                differentiation
!c           perm_fac(nn)       = scaling factor for permeability     * +
!c                                as a function of porosity changes 
!c           restol_vs          = solver residual tolerance           * +
!c           srelfac_vs         = user specified underrelaxation      * +
!c                                factor
!c           sw_star            = anticipated change in saturation    * +
!c                                per time step
!c           tol_vs             = convergence tolerance               * +
!c                                (variably saturated flow)
!c           uvslim             = max. allowed update                 * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           idetail_vs         = solver information level            * +
!c           level_vs           = incomplete factorization level      * +
!c           maxit_vs           = max. number of newton iterations    * +
!c                                (variably saturated flow)
!c           msolvit_vs         = max. number of solver iterations    * +
!c           nn                 = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           comp_relax         = .true.  -> compute underelaxation   * +
!c                                           factor
!c           hydraulic_head     = .true.  -> initial condition in     * +
!c                                           terms of hydraulic head
!c           mass_balance_vs    = .true.  -> compute mass balance     * +
!c                                           (variably_saturated
!c                                            flow)
!c           pressure_head      = .true.  -> initial condition in     * +
!c                                           terms of pressure head
!c           rcm_ordering_vs    = .true.  -> rcm ordering for         * +
!c                                           1d scalar matrix
!c           under_relax        = .true.  -> underrelaxation          * +
!c           upstream           = .true.  -> upstream weighting       * +
!c           variably_saturated = .true.  -> .not.fully_saturated,    * +
!c                                        -> variably saturated
!c                                           conditions
!c dens.f:
!c           real*8:
!c           -------
!c           courant_target     = target courant number               * +
!c           drho_dc            = density-TDS constant drho / dTDS    * +
!c
!c
!c           integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         + -
!c           inpl               = counter for napl components         * +
!c           iter_target        = target number of Picard iterations  + -
!c           maxit_sia          = maximum number of Picard iterations * +
!c           ndd                = number of components used for       * +  
!c                                fluid density calculation
!c           nnpl               = total number of napl components     * +
!c  
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density         * + 
!c                                           dependent flow
!c           fluid_pressure     = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c           fresh_head         = .true.  -> initial and boundary     * +
!c                                           conditions in terms 
!c                                           of freshwater head 
!c           init_perm          = .true. -> initial media             * +
!c                                           properties in 
!c                                           permeability units
!c           init_cond          = .true. -> initial media             * +
!c                                           properties in hydraulic 
!c                                           conductivity units
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c
!c local:    
!c           real*8:
!c           -------
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures       * +   
!c
!c           integer*4:
!c           ----------
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcpenergybal
 
      use parm
      use gen
      use dens
      use chem
#ifdef PETSC
      use solver_snes_common, only : stencil_width
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: ierr, l_string

      external findstrg, readbloc   

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0

      logical found_section, found_subsection
      character*72 subsection,name
 
!c  define or read control parameters for energy balance
   
      section_header = 'control parameters - energy balance'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  general control parameters

      tolglob = 1.0d-6  
      maxiterglob = 100 
      update_viscosity_temp = .false. 
      drho_dt = -0.34d0   ! [M L-3 oC-1]
      dinc_heat = 1.0d-4 
      tempref_dens=20.0d0 
      nonlindens_heat=.false.
      
      tempcorr_min = -1.0d300
      tempcorr_max = 1.0d300
      
      levelglob = 0
      msolvitglob = 100
      idetailglob = 1
      restolglob = 0.1d0 * tolglob
      deltolglob = 0.1d0 * tolglob      
      ugloblim_log = r1
      
!c density-dependent flow and picard iteration parameters

        subsection = 'energy balance parameters'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) drho_dt
        end if

        subsection = 'update viscosity'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          update_viscosity_temp = .true.
          
          allocate (viscoold(nngl), stat = ierr)
          viscoold=1.0d-3
          call checkerr(ierr,'viscoold',ilog)
        end if
        
!cprovi----------------------------------------------------
!cprovi Read reference temperature for density 
!cprovi----------------------------------------------------
        subsection = 'reference temperature for density'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) tempref_dens
        end if
        
!cdsu----------------------------------------------------
!cdsu Correction temperature for solution update
!cdsu----------------------------------------------------
        subsection = 'temperature correction for solution'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) tempcorr_min, tempcorr_max
        end if
        
!cprovi----------------------------------------------------        
!cprovi Read  
!cprovi----------------------------------------------------
        subsection = 'average density in z'
        !cprovi--------------------------------------------
        !cprovi Assign default reference mass fraction
        !cprovi--------------------------------------------
        av_dens_z=.false.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          av_dens_z = .true. 
        end if        
!cprovi----------------------------------------------------        
!cprovi Read  
!cprovi----------------------------------------------------
        subsection = 'upstream factor for heat equation'
        !cprovi--------------------------------------------
        !cprovi  
        !cprovi--------------------------------------------
        ups_heat=r1 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) ups_heat
          if (ups_heat>r1.or.ups_heat<r0) ups_heat=r1         
        end if        
!cprovi----------------------------------------------------        
!cprovi Read reference tds
!cprovi----------------------------------------------------
        subsection = 'reference tds'
        !cprovi--------------------------------------------
        !cprovi Assign default reference mass fraction
        !cprovi--------------------------------------------
        ref_tds = 1.0d-20 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) ref_tds         
        end if        
!cprovi----------------------------------------------------
!cprovi Mass flux for second boundary condition
!cprovi We assume that the second boundary condition for
!cprovi flow is in kg/s (for default is m3/s)
!cprovi----------------------------------------------------
        subsection = 'mass flux for second boundary condition'
        massflux_second=.false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          massflux_second=.true.
        end if                        
!cprovi----------------------------------------------------
!cprovi  
!cprovi----------------------------------------------------
        subsection = 'logarithm in unknowns'
        islogunk_energybal=.false.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          islogunk_energybal=.true.
        end if                                                             
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'non-linear density'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          nonlindens_heat=.true. 
        end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'non-advection'
        isadvective = .true.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then 
            write(ilog,*) 'Non-advection in energy balance'
          end if
          isadvective = .false.
        end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'non-dispersion'
        isdispersive = .true.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then  
            write(ilog,*) 'Non-dispersion in energy balance'
          end if
          isdispersive = .false.
        end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'non-conduction'
        isconductive = .true.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then  
            write(ilog,*) 'Non-conduction in energy balance'
          end if
          isconductive = .false.
        end if     
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'non-storage term in flow equation'
        isstorflow = .true.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then  
            write(ilog,*) 'Non-storage term is computed in flow equation'
          end if
          isstorflow = .false.
        end if 
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'non-storage term in heat equation'
        isstorheat = .true.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then  
            write(ilog,*) 'Non-storage term is computed in heat equation'
          end if
          isstorheat = .false.
        end if                              
!cprovi----------------------------------------------------
!cprovi Update Lambda thermal conductivity
!cprovi----------------------------------------------------
        subsection = 'update water thermal conductivity'
        update_heatcondw = .false. 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          update_heatcondw = .true. 
        end if        
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi 
!cprovi----------------------------------------------------
        subsection = 'assume boussinesq approximation'
        isboussinesq = .false.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          isboussinesq=.true. 
        end if
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read if evaporation of water is computed
!cprovi----------------------------------------------------
        subsection = 'compute evaporation'
        evaporation = .false. 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
           if (variably_saturated) then
              
              evaporation=.true.
              if (rank == 0 .and. b_enable_output) then
                write(ilog,*) 'Evaporation processes are computed'
              end if
     
           else
              if (rank == 0 .and. b_enable_output) then 
                write(ilog,*) 'Evaporation can not be computed'
                write(ilog,*) 'Please, set the problem to'
                write(ilog,*) 'variable saturated flow'
                write(*,*) 'Evaporation can not be computed'
                write(*,*) 'Please, set the problem to'
                write(*,*) 'variable saturated flow'
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
           end if
        end if                  
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read viscosity model for temperature
!cprovi----------------------------------------------------
        subsection = 'viscosity model'
        iviscomodel=2 ! diersch model
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
           read(itmp,*,err=999,end=999) name
           if (name=='sutra') then
             iviscomodel=1
           else if (name=='diersch') then
             iviscomodel=2
           else
             if (rank == 0) then
               write (*,*) 'Viscosity model not implemented'
               write (ilog,*) 'Viscosity model not implemented'
             end if
#ifdef PETSC
             call petsc_mpi_finalize
#endif
             stop 
           end if
        end if  
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read if energy balance must be computed
!cprovi Default value => false
!cprovi----------------------------------------------------
        subsection = 'energy balance'
        energy_balance=.false. 
        imheat=0
        imheat_first=0
        imheat_last=0
        culabsbalheat = r0
        culrelbalheat = r0
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
           energy_balance=.true.
        end if         
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read thermal conductivity model
!cprovi----------------------------------------------------
       subsection = 'thermal conductivity model'
       heatcond_model = 'model 1'
       nheatcond = r1
       call findstrg(subsection,itmp,found_subsection)

       if (found_subsection) then
           read(itmp,*,err=999,end=999) heatcond_model
           select case (heatcond_model)
           case ('model 1','model 2','model 3','model 4','model 5',   &
     &           'model 6')
              if (heatcond_model=='model 5') then
                read(itmp,*,err=999,end=999) nheatcond
              end if
           case default
             if (rank == 0) then 
               write (*,*) 'Thermal conductivity model not implemented'
               write (ilog,*) 'Thermal conductivity model not implemented'
             end if
#ifdef PETSC
             call petsc_mpi_finalize
#endif
             stop
           end select
       end if        
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read if entalphy change source is considered
!cprovi----------------------------------------------------
       entalphy_change=.false.
       if (reactive_transport) then
          
          subsection = 'entalphy change'
           
          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            entalphy_change=.true.
          end if      
       end if
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi Read the gravity constant
!cprovi----------------------------------------------------
        subsection = 'gravity constant'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
           read(itmp,*,err=999,end=999) gacc           
        end if
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi  
!cprovi----------------------------------------------------
        subsection = 'spatial weighting'
        call findstrg(subsection,itmp,found_subsection)
        sp_weight_heat='upstream' 
        if (found_subsection) then
         
         read(itmp,*,err=999,end=999) sp_weight_heat     
         
         if (sp_weight_heat=='van leer') then
            sp_weight_heat='vanleer'
         elseif (sp_weight_heat=='van leer 2') then
            sp_weight_heat='vanleer2'
         elseif (sp_weight_heat=='centered 2') then   
            sp_weight_heat='centered2'
         end if
         
#ifdef PETSC
         if (sp_weight_heat=='vanleer' .or.       &
             sp_weight_heat=='vanleer2') then
           if (nprcs > 1 .and. stencil_width < 2) then
             if (rank == 0) then
               write(*,'(2a)') "Error van leer spatial weighting ",    &
                               "requires stencil width 2 or larger"
               write(ilog,'(2a)') "Error van leer spatial weighting ", &
                               "requires stencil width 2 or larger"
               close(ilog)
             end if
             call petsc_mpi_finalize
             stop
           end if
         end if
#endif

         if (sp_weight_heat/='upstream'.and.      &
     &       sp_weight_heat/='centered'.and.      &
     &       sp_weight_heat/='centered2'.and.     &
     &       sp_weight_heat/='vanleer'.and.       &
     &       sp_weight_heat/='vanleer2') then
           if (rank == 0) then  
            write(ilog,'(a)')                     &
     &     'error reading subsection "spatial weighting" energy balance'
            write(*,'(a)')                        &
     &     'error reading subsection "spatial weighting" energy balance'
           end if 
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if      
        end if                                                   
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------

        subsection = 'user specified underrelaxation factor'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          under_relax_temp = .true.
          read(itmp,*,err=999,end=999) srelfac_temp
        end if
        
        
        subsection = 'compute underrelaxation factor'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          under_relax_temp = .true.
          comp_relax_temp = .true.
          read(itmp,*,err=999,end=999) utemplim
        end if
        
!cdsu  water freezing parameters
        subsection = 'water freezing temperature'
        water_freezing_temper = 0.0d0
        b_water_freezing = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_water_freezing = .true.
          read(itmp,*,err=999,end=999) water_freezing_temper
        end if
        
        subsection = 'water freezing conductivity'
        water_freezing_cond = 1.0d-20
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          read(itmp,*,err=999,end=999) water_freezing_cond
          if (water_freezing_cond <= 0.0d0) then
            water_freezing_cond = 1.0d-20
          end if
        end if
        
        subsection = 'water freezing reaction rate'
        b_water_freezing_ratemin = .false.
        water_freezing_ratemin = 1.0d-20
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_water_freezing_ratemin = .true.
          read(itmp,*,err=999,end=999) water_freezing_ratemin          
          if (water_freezing_ratemin <= 0.0d0) then
            water_freezing_cond = 1.0d-20
          end if
        end if
        
!cdsu  solver parameters

        subsection = 'newton iteration settings'

        call findstrg(subsection,itmp,found_subsection)
        
        if (found_subsection) then
          read(itmp,*,err=999,end=999) dinc_heat
          read(itmp,*,err=999,end=999) maxiterglob
          read(itmp,*,err=999,end=999) tolglob
          read(itmp,*,err=999,end=999) ugloblim_log
        end if

!c  solver settings

        subsection = 'solver settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          read(itmp,*,err=999,end=999) levelglob 
          read(itmp,*,err=999,end=999) msolvitglob
          read(itmp,*,err=999,end=999) idetailglob
          read(itmp,*,err=999,end=999) restolglob
          read(itmp,*,err=999,end=999) deltolglob          
        end if
        
 
      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
