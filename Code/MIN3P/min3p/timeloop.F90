!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 488 $
!> $Author: cblitz $
!> $Date: 2017-07-17 18:22:05 +0200 (Mon, 17 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/timeloop.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine timeloop
!c -------------------
!c
!c driver subroutine for transient flow and/or reactive transport
!c modified for optional density dependent flow simulation and 
!c picard iterations between solution of flow and transport/reaction
!c equations
!c
!c written by:      Uli Mayer - May 9, 96
!c
!c last modified:   Tom Henderson - March 3, 2004
!c                  Sergi Molins - May 2, 2006
!c                  added skip and nskip
!c                  intialize iupsg
!c                  Sergi Molins - June 7, 2006
!c                  added chemical_water
!c                  Sergi Molins - Jan 30, 2007
!c                  added restart option
!
!c		    Celine Blitz Frayret (CBF) and Frédéric Gérard (FG) - from May 9, 2017 - According to the MIN3P-ArchiSimple
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c bbls.f:      real*8
!c           ------
!c           sanew_b(nn)         = water saturation prior to reactran and gasbub
!c                                   for convergence check of outer bubble loop
!c              cx_b(nx,nn)         = species concentrations prior to gasbub
!c                                   for convergence check of inner bubble loop
!c              c_update(nc,nn)     = component concentration at previous inner
!c                                   bubble iteration. 
!c          
!c           integer*4
!c               ---------
!c              ibub                 = counter for inner bubble iteration loop
!c              ibubflow             = counter for outer bubble iteration loop
!c            maxibub            = maximum number of inner iterations
!c            maxibubflow        = maximum number of outer iterations
!c          
!c           logical
!c               --------
!c              gas_bubbles         =.true. -> gas phase saturation       + -
!c                                            is calculated
!c                                             below the water table
!c            double_bubble           = .true. -> double bubble iterations
!c              bub_not_converged          = .true.-> inner bubble loop not converged
!c            bubflow_not_converged      = .true.-> outer bubble loop not converged
!c
!c gen.f:    real*8:
!c           -------
!c           area(nm,nn)        = mineral reactivity term             + -
!c                                (global system)
!c           cnew(nc,nn)        = concentrations of free species      + *
!c                                - new time level [moles/l water]
!c           cmnew(nm,nn)       = mineral concentrations              + +
!c                                - new time level [moles/l bulk]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cpuint             = cpu-time (intermediate) [seconds]   + +
!c           cx(nx,nn)          = concentrations of secondary aqueous + *
!c                                species [moles/l water]
!c           delt               = time step                           + -
!c           delt_io            = time step (I/O units)               + -
!c           delt_rt            = estimated time step                 * *
!c                                (reactive transport)
!c           delt_vs            = estimated time step                 * * 
!c                                (variably saturated flow)
!c           delt_courant       = estimated time step                 * *                
!c                                (courant target)
!c           deltmax            = maximum time step                   + -
!c           deltmin            = minimum time step                   + -
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients for aqueous   + -
!c                                species
!c           gnew(ng,nn)        = gas concentrations                  + *
!c                                - new time level [moles/l air]
!c           gs_tout(ngs)       = specified output times for          + -
!c                                contour data
!c           hhead(nn)          = hydraulic head                      + -
!c           phi(nm,nn)         = volume fractions of minerals        + *
!c           phiold(nm,nn)      = volume fractions of minerals        + *
!c                                - old time level
!c           pornew(nn)         = porosity                            + -
!c           qwater(nn)         = rate of water production/consumpt.  * +
!c                                due to geochemical reactions 
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                (new time level)
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tfinal             = final solution time                 + -
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           time               = current solution time               * +
!c           time_bcvs          = next read time for flow boundary    + + 
!c                                conditions
!c           time_io            = current solution time (I/O units)   * +
!c           time_factor        = conversion factor from I/O time     + -
!c                                units to internal time units
!c           time_soi           = next read time for soil specific    + +
!c                                parameters
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           tsrc(ntsrc)        = target read times - transient       + -
!c                                source chemistry
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log file               + -
!c           idelt              = unit mumber, magnitude of current   + -
!c                                             time step
!c           idetail_rt         = information level                   + -
!c                                (reactive transport)
!c           idetail_vs         = information level                   + -
!c                                (variably saturated flow)
!c           igbb               = unit number, concentrations of      + -
!c                                sorbed species
!c           igbc               = unit number, free species and       + -
!c                                             secondary aqueous
!c                                             species concentrations
!c                                             - transient data
!c                                               global system
!c           igbd               = unit number, reaction rates for     + -
!c                                             dissolution-
!c                                             precipitation
!c                                             reactions
!c                                             - transient data
!c                                               global system
!c           igbg               = unit number, gas concentrations     + -
!c                                             - transient data
!c                                                global system
!c           igbg               = unit number, degassing rates        + -
!c                                             - transient data
!c                                                global system
!c           igbm               = unit number, master variables       + -
!c                                             - transient data
!c                                               global system
!c           igbi               = unit number, rates of intra-aqueous + -
!c                                             kinetic reactions
!c                                             - transient data
!c                                               global system
!c           igbs               = unit number, saturation indices     + -
!c                                             - transient data
!c                                               global system
!c           igbt               = unit number, total aqueous          + -
!c                                             component
!c                                             concentrations
!c                                             - transient data
!c                                               global system
!c           igbv               = unit number, mineral volume         + -
!c                                             fractions
!c                                             - transient data
!c                                             - global system
!c           igbx               = unit number, saturation indicea     + -
!c                                             (excluded minerals)
!c                                             - transient data
!c                                               global system
!c           igstime            = pointer to next output time for     + +
!c                                contour data
!c           itsolvtot_rt       = total number of solver              * +
!c                                iterations
!c                                (reactive transport)
!c           itsrc              = pointer to target read times for    + -
!c                                transient source chemistry
!c           ittot_rt           = total number of iterations          * +
!c                                (reactive transport)
!c           l_zone_name        = length of zone name                 * *
!c           mtime              = current time step                   * +
!c           mtime_f            = number of failed time steps         * +
!c           ngs                = number of output times for          + -
!c                                contour data
!c           ngb                = number of output locations for      + -
!c                                transient data
!c           ngb_step           = number of time steps between        + -
!c                                output of transient data
!c           ngb_tstep          = number of total time steps in       + -
!c                                output of transient data
!c           ngb_vol(ngb)       = control volume numbers for output   + -
!c                                of transient data
!c           nn                 = total number of control volumes     + -
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        * +
!c           iupsg(njavs)       = upstream node for gas transport     * +
!c
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           gb_output          = .true.  -> output of transient data + -
!c           gs_output          = .true.  -> output of contour data   + -
!c           mass_balance_vs    = .true.  -> compute mass balance     + -
!c                                           variably saturated flow  
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           reduce_timestep    = .true.  -> restart with reduced     + -
!c                                           timestep
!c           root_uptake        = .true.  -> calculate root water     + -
!c                                           uptake
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           transient_source   = .true.  -> transient source         + -
!c                                           chemistry
!c                                .false. -> constant source
!c                                           chemistry
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c           chemical_water     = .true.  -> account for production   + -
!c                                           or consumption of water
!c                                           due to geochemical 
!c                                           reactions in flow eq.
!c
!c           character:
!c           ----------
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c           update_activity_rt = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c           update_bcvs        = .true.  -> transient boundary       + -  
!c                                           condition for variably 
!c                                           saturated flow
!c           zone_name          = name of zone                        * *
!c
!c chem.f:   integer*4:
!c           ----------
!c           nc                 = number of components including h2o  + -
!c
!c           logical:
!c           --------
!c           temp_field         = .true.  -> nodal temperatures       + -
!c
!c dens.f:   real*8:
!c           -------
!c           delt_tds           = lagged time step for tds storage    - + 
!c                                derivative
!c           density(nn)        = fluid density                       + -
!c           densold(nn)        = fluid density from previous         * + 
!c                                iteration/time step
!c           integer*4:
!c           ----------
!c           msia               = total number of sequential          * +           
!c                                iterations
!c           maxit_sia          = maximum number of Picard iterations * -
!c           iter_sia           = iteration counter -Picard iteration * +  
!c           iter_target        = target number of Picard iterations  * -
!c           ts_sia             = picard iterations per time step     * +
!c 
!c           logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c           cpuint_old         = cputime (intermediate) [seconds]
!c           r0                 = constant
!c           r86400             = constant
!c           rhalf              = constant
!c           tiny_time          = tiny time increment
!c           tiny               = tiny increment
!c           c_diff             = change in component concentration before and
!c                                after gasbub
!c           c_tol              = convergence tolerance for inner bubble loop
!c           sa_diff            = change in saturation in before and after gasbub
!c           sa_tol             = convergence tolerance for outer bubble loop
!c
!c           integer*4:
!c           ----------
!c           igb                = counter
!c           igb_step           = counter for output of transient 
!c                                data
!c           ibub_tol           = counter - convergence of inner bubble loop
!c           ibubflow_tol       = counter - convergence of outer bubble loop
!c
!c external: mbalvs   = compute mass balance - variably saturated 
!c                      flow
!c           mbaldd   = compute mass balance - variably saturated 
!c                      density dependent flow
!c           nexttime = prepare for next time step
!c           outputvs = write contour data to output file for
!c                      postprocessing (variably saturated flow)
!c           outputdd = write contour data to output file for
!c                      postprocessing (density dependent flow)
!c           outputrt = write contour data to output file for 
!c                      postprocessing (reactive transport)
!c           reactran = driver subroutine for reactive transport
!c           updtbcvs = update boundary conditions for 
!c                      variably saturated flow
!c           updtbcdd = update boundary conditions for 
!c                      density dependent flow
!c           updtetp  = update etp and canopy dependent variables 	!CBF
!c           tcorr    = temperature correction for debye-huckel,
!c                      equilibrium and rate constants
!c           tprfrtlc = write transient data to output file for
!c                      postprocessing (reactive transport)
!c           tprfdd   = write transient data to output file for
!c                      postprocessing (density dependent 
!c                      flow parameters)
!c           tprfvs   = write transient data to output file for
!c                      postprocessing (flow parameters)
!c           tranflow = driver subroutine for transient flow
!c           trddflow = driver subroutine for transient 
!c                      density dependent flow
!c           tranunit = assign unit numbers for output of transient 
!c                      data
!c ----------------------------------------------------------------------

      subroutine timeloop
      !DEC$ ATTRIBUTES STDCALL, ALIAS:"TIMELOOP" , DLLEXPORT :: timeloop
      
 
      use parm
      use gen
      use chem
      use dens
      use phys
      use bbls
      use biol!FG july 2017 to get update_root_rld
      use writeversion
      use m_ice_sheet, only : max_update_pice, b_check_update_pice
      use file_unit, only : lun_get, lun_free
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: tid, i, i1, igb, iprint, igb_step, info_debug, ivol,  &
                 ipest, istatus, ierrcode, ngb_tstep, iunit
      real*8 :: cputime, cpuint_old, porosity_flow, bubm, time_sirius = 1.0
      
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif  

#ifdef PETSC
      real*8 :: delta_pice_max_gbl
#endif

      external mbalvs, mbaldd, nexttime, outputvs,                    &
               outputdd, outputrt, reactran, porosity_flow,           &
               tprfrtlc, tprfdd, tprfvs, tranflow, trddflow,          &
               tranunit,updtbcvs, updtbcdd, velodd,                   &
               tranbcrt, tranbcrt_read, updtetp			!CBF ADDED updtetp!FG discard updtsoil as redondant by then

                                                                       
      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1 = 1.0d0,      &
     &           r2 = 2.0d0, r86400 = 8.64d4, tiny_time = 1.d-10,      &
     &           tiny = 1.0d-300, bignum = 1.0d+30,                    &
     &           zerokelvin = 273.15d0, r16 = 1.0d-16,                 &
     &           r12 = 1.0d-12, r9 = 1.0d-9,                           &
     &           r365 = 3.65d2, r3 = 3.0d0, r10 = 1.0d-10

#ifdef PETSC
      integer :: ibub_tol_gbl, ibubflow_tol_gbl
#endif
     
      logical :: iserror
      !Flag to indicate if the current time step is reduced
      real(type_r8) :: cputime_start
      
      !Local variables
      integer :: ibub_tol, ibubflow_tol, ic, izn, nbLigne, nbLigneOld = 0, ierr
      real(type_r8) :: c_tol, c_diff, uvs_tol, uvs_diff, delt_temp,    &
                       rdummy     

      real*8 :: delta_pice, delta_pice_max
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
      
        !>interface of tcorr
        subroutine tcorr(tempkel)
          use parm, only : type_r8     
          real(type_r8) :: tempkel   
        end subroutine tcorr
      
      end interface

      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
      
      info_debug = 0
      
!c  initialize time stepping and iteration parameters for 
!c  reactive transport 
    
      
      mtime = 0
      iter_sia = 0
      iter_seep = 0
      iter_vs = 0
      ittot_vs = 0

      msia = 0
      mtime_f = 0
      igb_step = 0
      ngb_tstep = 0
      reduce_timestep = .false.
      
      i_first=.true.!FG sept 2021 - to open *.dmr and *.drm files in output_min only if first time
      
!cprovi----------------------------------------------------------
!cprovi Restart process
!cprovi 9/07/2009 
!cprovi this is based on Richard Amos implementation 
!cprovi----------------------------------------------------------
!cprovi  Parallelized, OpenMP, DSU
    rsrt_cnt=0
    
!c     initialize skip variable
    nskip_time = 0
!cc	skip = 10 ! hardwired

    if (restart_sim) then
      call restart_r
      time=time_io*time_factor
      restart_sim=.false.      
    end if
    
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------

!c time-step limiting parameters set to arbitrary large values for 
!c simulations with constant density fluid or groundwater flow
!c verification problems

      sia_ts_mult = 0.05d0
      delt_sia = bignum   !arbitrary large number
      delt_courant = bignum !arbitrary large number

      if (reactive_transport) then
        ittot_rt = 0
        itsolvtot_rt = 0
        if (update_activity_rt.eq.'no_update') then
          update_activity(tid) = 'no_update'
        elseif (update_activity_rt.eq.'time_lagged') then
          update_activity(tid) = 'time_lagged'
        elseif (update_activity_rt.eq.'double_update') then
          update_activity(tid) = 'double_update'
        endif
      end if

      if(rank == 0) then      !if MPI rank 0
        if (b_enable_output) then  
          write(*,'(/1x,a)')'enter timeloop hehe'
          write(*,'(1x,72a)')('-',i=1,72)
        end if
        if(.not. b_enable_output) then
            write(*,'(/1x,a)')'output is disabled, please wait ...'
        end if
        
        if (b_enable_output) then
          write(ilog,'(a)')'enter timeloop'
          write(ilog,'(72a)')('-',i=1,72)
        end if
        if(.not. b_enable_output) then
            write(ilog,'(/1x,a)')'output is disabled, please wait ...'
        end if
      end if                  !end if MPI rank 0
      
      if (transient_source) then
        call tranbcrt_read 
      end if

!c  time loop
!c  exit time loop based upon final solution time 

!c option look for file pest.stp, which will cause simulation to abort
      ipest = 0 !(0/1) -> 1 = activate PEST termination function
 
      !TR - create the array of RLD coming from SQ
    allocate ( rld_sirius(nn) )
    
      do while (time.lt.tfinal-tiny_time .and. not(sirius_finished))       !start time loop
          !write(*,*) 'timeio',time_io,'timesi',time_sirius, 'time',time
          
          !TR - stay in loop if one day hadn't pass in Min3p 
          if(time_io.ge.time_sirius) then
             min3pDayFinished = .true.
             time_sirius = time_sirius + 1
             siriusDayDone = .false.
          endif
          
          
          !TR - wait that one day had pass in Sirius
         do while(siriusDayDone == .false. .and. not(sirius_finished))
            call sleep(1)
         enddo
         
         min3pDayFinished = .false.
        
         
      !TR
    
        prt_timestep_tot = cputime()
        
        b_mpi_process_flag = .false.
        
        if(ipest .eq.1) then  
          if (rank == 0) then       !if MPI rank 0
            !iunit = 99  
            iunit = lun_get()
            open (iunit,file='../pest.stp',status='old',iostat=istatus)
            if(istatus .eq. 0) then
              write(ilog,'(a)')'execution halted due to pest.stp'
              close(iunit)
              open (iunit,file='pslave.fin',status='unknown') ! terminate slave
              write(iunit,'(a)') 'F'
              close(iunit)
            end if
            call lun_free(iunit)
          end if                    !end if MPI rank 0

#ifdef MPI
          call MPI_BCAST(istatus, 1, MPI_INTEGER4, 0,                  &
                       Petsc_Comm_World, ierrcode)
          CHKERRQ(ierrcode)
#endif
          if(istatus .eq. 0) then
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
          
        end if

        mtime = mtime+1
        ts_sia = 0           !picard iterations per given time step
        
       if ((skip_time.gt.0).and.(nskip_time.lt.skip_time)) then
         nskip_time = nskip_time + 1  
       else
         nskip_time = 0
       end if  

!c  variable time stepping            
        if (mtime.eq.1) then
          if (varsat_flow.and.reactive_transport) then
!c           initialize iupsg variable 
!c           (updated after each N-R iteration, in reactran) 
            do i1 = 1,njavs
              iupsg(i1) = 'a'
            enddo
          
          endif
        end if

        if (mtime.gt.1) then

!c  save previous time step length for tds storage derivative

          delt_tds = delt

!c calculate new time step length using Courant criteria and # of Picard iterations

          if (density_dependence) then  !available for DD flow only

            delt_courant = delt * courant_target / courant_max         

!c  limit time-step lengths when the the number of Picard iterations exceeds
!c the use-defined target.  This limiter deactivated by setting the target to
!c a large integer e.g. 100

            if (iter_sia .gt. iter_target) then
              delt_sia = (r1 - (sia_ts_mult * r2)) * delt 
            elseif (iter_sia .lt. iter_target) then
              delt_sia = bignum  !no time step control
            elseif (iter_sia .eq. iter_target) then
              delt_sia = (r1 + sia_ts_mult) * delt
            end if
          end if !(density_dependence)
        continue

!c  assign new time step for global simulation
!c  flow and reactive transport
!c  Courant criteria added July 14, 2003

          if ((varsat_flow).and.(reactive_transport)) then
            if (transient_flow.and.variably_saturated) then             
              delt = dmin1(delt_vs,delt_rt,delt_courant,delt_sia)
              delt = dmax1(delt,deltmin)
            else
              delt = dmin1(delt_rt,delt_courant,delt_sia)
              delt = dmax1(delt,deltmin) 
            end if

!c  flow only

          elseif (varsat_flow.and.(.not.reactive_transport)) then
            if (transient_flow) then
              delt = delt_vs  
            else
              delt = delt     
            end if

!c  reactive transport only

          elseif ((.not.varsat_flow).and.(reactive_transport)) then
            delt = delt_rt 
          else
            delt = delt_vs
          end if
          
!c  gas bubbles
          if (gas_bubbles) then
            if (ibub.gt.bub_exp.or.ibubflow.gt.bub_exp) then
              bubm=max0(ibub,ibubflow) 
              delt=delt*dmin1(1.0,bub_exp/bubm)
            end if
          end if

!c  save controlling factor for time step length

         if (delt .eq. delt_vs) then
           ts_min = 'varsat'
         elseif (delt .eq. delt_rt) then
           ts_min = 'reactive'
         elseif (delt .eq. delt_courant) then
           ts_min = 'courant'
         elseif (delt .eq. delt_sia) then
           ts_min = 'picard'
         end if

         if (.not.gas_bubbles) then 
!c  adjust time step to target read times for transient boundary conditions
!c  for variably saturated flow

           if (update_bcvs) then
             if (time+delt.gt.time_bcvs*time_factor) then
               delt = time_bcvs*time_factor-time
               delt = dmax1(delt, deltmin)
             end if
           end if
          
!c  adjust time step to target read times for atmospheric parameters           
           if (evaporation.and.read_atm) then
             if (time+delt>time_atm*time_factor) then
               delt = time_atm*time_factor-time
               delt = dmax1(delt, deltmin)
             end if
           end if

!c  adjust time step to target read times for updating soil specific
!c  parameters

           if (root_uptake) then
             if (time+delt.gt.time_soi*time_factor) then
               delt = time_soi*time_factor-time
               delt = dmax1(delt, deltmin)
             end if
           end if
          
         end if
         
        end if          !(mtime.gt.1)
        
        prt_timestep_nonlinear = 0.0

        goto 1000

!c  maximum number of iterations exceeded, time step guess was poor,
!c  reduce time step size 

999     continue
  
        time = time-delt
             
        mtime_f = mtime_f+1

!c automatic (constant) time step reduction for vs flow or reactive transport
!c timestep reduction for failed Picard iterations = total number
!c of coupling iterations / Picard iteration target

!c time step reduction based on non-convergence of flow or
!c transport/reaction solutions

        if (reduce_timestep) then
          
          delt = rhalf*delt            !constant time step reduction
          reduce_timestep = .false.

          ts_sia = 0

        end if


!c  correct total number of sequential iterations

        msia = msia - ts_sia
        
#ifdef DEBUG
        if(rank == 0 .and. b_enable_output) then
          write(*,'(a, 2(1x, i4), 2(1x, e12.4), 1x, l1)')              &
                "rank, mtime_f, time, delt, reduce_timestep ",         &
                 rank, mtime_f, time, delt, reduce_timestep
        end if
#endif
        
!c  emergency exit if time step becomes too small

1000    continue

        b_mpi_process_flag = .false. 
  
        if (delt.lt.deltmin-tiny) then  
            
          if(rank == 0) then
              
            write(*,*)'no further time step reduction possible'
            write(*,*)'Optimal time increment computed by MIN3P',delt
            write(*,*)'Minimum time increment specified by user',deltmin
            write(*,*)'Please, reduce the MINIMUM TIME INCREMENT'
            write(*,*)"stop signal in time step reduction failed"
            
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(a)')'failure in timeloop'

!c  time step reduction for courant criteria
            if (courant_target .lt. courant_max) then
              write(ilog,'(a)')'courant criteria exceeded'
            end if
            
            write(ilog,'(a)')'no further time step reduction possible'
            write(ilog,'(a)')'bye now ...'
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(72a)')('-',i=1,72)
            write(ilog,'(72a)')('-',i=1,72)
          
          end if 
          
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(a)')'failure in timeloop'
            if (courant_target .lt. courant_max) then
                write(igen,'(a)')'courant criteria exceeded'
            end if
            write(igen,'(a)')'no further time step reduction possible'
            write(igen,'(a)')'bye now ...'
          end if
                    
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
          
        end if   

        time = time + delt                !new solution time

!c  make sure solution will be computed at specified output times
!c  check if the restart time is the same as the first output time
        if (b_check_restart_time) then
          if (abs(time-delt-gs_tout(igstime)) < tiny_time) then
            igstime = igstime + 1
          end if
          b_check_restart_time = .false.
        end if

        if (time > gs_tout(igstime)+tiny_time) then
          delt = delt + gs_tout(igstime) - time  
          time = gs_tout(igstime)
        end if

!c  make sure solution time will be consistent with target read times for
!c  source chemistry
        if (transient_source) then
          if (time > tsrc(itsrc)+tiny_time) then  
            delt = delt + tsrc(itsrc) - time
            time = tsrc(itsrc)
          end if         
        end if

!c  make sure the solution will be consistent with the ice loading/unloading
!c  timeline, DSU
        if (compute_ice_sheet_loading) then
          !c find the initial ice loading/unloading stage
          if (mtime == 1 .and. icestage < 0 .and. nicestages < 0) then
            icestage = 0
            nicestages = size(icetimeline,2)
            if (nicestages > 0) then
              !c check if timeline is continuous
              do i = 1, nicestages-1
                if ((icetimeline(1,i+1)-icetimeline(2,i)>tiny_time).or.&
                    (icetimeline(2,i)-icetimeline(1,i)<tiny_time).or.  &
                    (icetimeline(2,nicestages)-                        &
                     icetimeline(1,nicestages)<tiny_time)) then
                  if (rank == 0) then
                    write(*,*) 'SIMULATION TERMINATED'
                    write(*,*) 'ice loading/unloading timeline is not correct'
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'ice loading/unloading timeline is not correct'
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
              end do

              !c convert unit to the same as internal timestep
              do i = 1, nicestages
                icetimeline(1,i) = icetimeline(1,i)*time_factor
                icetimeline(2,i) = icetimeline(2,i)*time_factor
              end do

              !c check the current stage
              if (time < icetimeline(1,1)) then
                icestage = 0
              else if (time > icetimeline(2,nicestages)) then
                icestage = nicestages + 1
              else
                do i = 1, nicestages
                  if (time >= icetimeline(1,i) .and.                   &
                      time < icetimeline(2,i)) then
                    icestage = i
                    exit
                  end if
                end do
              end if
            end if
          end if

          !c check if current time spans two stages
          if (icestage > 0 .and. icestage < nicestages + 1) then
            if (time >= icetimeline(2,icestage)) then
              delt = delt + icetimeline(2,icestage) - time
              time = icetimeline(2,icestage)
              icestage = icestage + 1

              if (idetail_vs > 0 .and. rank == 0 .and. b_enable_output) then
                write(*,*) " Adjust timestep for ice loading/unloading, icestage ",icestage
                write(ilog,*) " Adjust timestep for ice loading/unloading, icestage ",icestage
              end if

            end if
          end if
        end if
     
!cprovi------------------------------------------------------------------------
!cprovi Check the time increment 
!cprovi------------------------------------------------------------------------ 
        b_mpi_process_flag = .false. 

        if (delt<=r0) then
          if (rank == 0) then  
            write(*,*) 'SIMULATION TERMINATED'
            write(*,*) 'computed time increment delt <= 0'
            write(*,*) "stop signal in time increment delt <= 0"          
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'computed time increment delt <= 0'
          end if
                    
#ifdef PETSC
          call petsc_mpi_finalize
#endif  
          stop        
        end if

!cprovi------------------------------------------------------------------------                
!cprovi------------------------------------------------------------------------               
!cprovi------------------------------------------------------------------------        
!c  convert current solution time and time step to I/O units

        time_io = time/time_factor
        delt_io = delt/time_factor
        

!cprovi----------------------------------------------------
!cprovi Ice sheet loading/unloding is computed
!cprovi----------------------------------------------------        
!c  update the boundary conditions 
        if (compute_ice_sheet_loading) then
          if (density_dependence) then
              
              !Parallelized, OpenMP, DSU
              call compute_bc_ice_sheet

              if (reduce_timestep) then
               goto 999
              end if
                                   
              if (compute_permafrost.and.permeability_field) then
                permx=permx0
                permy=permy0
                permz=permz0
                !Parallelized, OpenMP, DSU
                call modify_for_permafrost_ (ice_sheet,permx,       &
                    permy,permz,nngl,time_io,xg,zg,                 &
                    numofthreads_global, numofloops_thred_global,   &
                    iserror)
                if (iserror) then
                  if(rank == 0) then  
                    write(*,*) 'Error when update for permafrost'
                    write(*,*) "stop signal in update for permafrost"
                  end if
                  
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                  
                end if 
              end if 
          end if 
        end if  
        
       
!cprovi------------------------------------------------------------------------ 
!cprovi------------------------------------------------------------------------ 
!cprovi------------------------------------------------------------------------ 
!cprovi------------------------------------------------------------------------
      if (transient_source .or. transient_source_function) then
 
        if (transient_source) then
          if (itsrc.le.ntsrc.and.tsrc(itsrc)-tiny_time.lt.time) then
            itsrc = itsrc + 1
            if (itsrc.gt.ntsrc) then
              tsrc(itsrc) = tfinal+tiny_time
            end if
          end if
        end if
       
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
!c  report to log file
          write(ilog,'(/72a)')('-',i=1,72)
          write(ilog,'(a,1pe12.4,1x,a)')                               &
               'update source chemistry - reactive transport, T = ',   &
                time_io, time_unit
          write(ilog,'(72a/)')('-',i=1,72)
                                                                          
!c  report to screen                                                   
          write(*,'(/72a)')('-',i=1,72)                                
          write(*,'(a,1pe12.4,1x,a)')                                  &
               'update source chemistry - reactive transport, T = ',   &
                time_io, time_unit                                     
          write(*,'(72a/)')('-',i=1,72)
          
        end if
        
        call tranbcrt(time)    
        
        if (update_activity_rt.eq.'no_update') then
         update_activity(tid) = 'no_update'
        elseif (update_activity_rt.eq.'time_lagged') then
          update_activity(tid) = 'time_lagged'
        elseif (update_activity_rt.eq.'double_update') then
          update_activity(tid) = 'double_update'
        endif
        
      end if

!c  sequential iterative coupling between flow and transport/reaction equations
!c  Picard iterative loop begins here
!c  ---------------------------------------------------------------------------

      not_converged_sia = .true.
      iter_sia = 0
      
      b_mpi_process_flag = .false.

      if ((.not.density_dependence).or.(flow_verification)) then
        maxit_sia = 1
      end if
            
      
      if (density_dependence) then 
          
            b_mpi_process_flag = .false.
            
            !c  allocate mask for porosities 
            modify_por=.true.
            if (nbvs>0) then
                 modify_por(iabvs(1:nbvs))=.false.
            end if

            if (compute_ice_sheet_loading) then

              delta_pice = 0.0d0
              delta_pice_max = 0.0d0


#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_timeloop_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, iserror, delta_pice)
    !$omp do schedule(static) lastprivate (delta_pice_max)
#endif 
              do ivol=1,nngl               
               !cprovi--------------------------------------------------------
               !cprovi--------------------------------------------------------
               !cprovi-------------------------------------------------------- 
               if(.not. b_mpi_process_flag) then

                 por_stress_old(ivol) = por_stress(ivol)

                 call compute_dpicedt_ (ice_sheet,por_stress(ivol),     &
                         time_io-delt_io,time_io,xg(ivol),              &
                         stor(ivol),r1,skempton(ivol),'pressure',iserror)

                 if (b_check_update_pice) then
                   delta_pice = (por_stress(ivol)-por_stress_old(ivol))/ &
                                 stor(ivol)/r1/skempton(ivol)
                   if (delta_pice_max < abs(delta_pice)) then
                     delta_pice_max = abs(delta_pice)
                   end if
                 end if

                 if (iserror) then
                    if(rank == 0) then 
                      write(*,*) 'Error when call service compute_dpicedt_'                                          
                      write(*,*) "stop signal in call service compute_dpicedt_"
                      write(ilog,*) 'Error when call service compute_dpicedt_' 
                      close(ilog)
                    end if
                    b_mpi_process_flag = .true.
                 end if                
              
               end if

               if(.not. b_mpi_process_flag) then
                  ! Compute first approximation for porosity
                  ! Only make sense if vertical stress is computed
                  ! because pak+1 = pak
                  if (modify_por(ivol)) then
                      pornew(ivol)=porosity_flow(porold(ivol),uvsnew(ivol),&
                                                 uvsold(ivol),stor(ivol),  &
                                                 por_stress(ivol),         &
                                                 por_init(ivol),facpormin)
                  end if
               end if

              end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
              if (b_check_update_pice) then
                call MPI_Allreduce(delta_pice_max,delta_pice_max_gbl,1,&
                                   MPI_REAL8,MPI_MAX,                  &
                                   Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
                delta_pice_max = delta_pice_max_gbl
              end if
#endif
              if (b_check_update_pice) then
                if (delta_pice_max > max_update_pice) then
                  if (idetail_vs > 0 .and. b_enable_output .and. rank == 0) then
                    write(*,*) "Reduce timestep, maximum ice loading internal pressure update ",delta_pice_max
                    write(ilog,*) "Reduce timestep, maximum ice loading internal pressure update ",delta_pice_max
                  end if
                  reduce_timestep = .true.
                  por_stress = por_stress_old

                  goto 999
                else
                  if (idetail_vs > 0 .and. b_enable_output .and. rank == 0) then
                    write(*,*) "Maximum ice loading internal pressure update ",delta_pice_max
                    write(ilog,*) "Maximum ice loading internal pressure update ",delta_pice_max
                  end if
                end if
              end if

            end if
            
        if(b_mpi_process_flag) then
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
            
      end if

      
      cputime_start = cputime()

#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(*,'(a, 3(1x, i4), 1x, l1)')                            &
                "rank, iter_sia, maxit_sia, not_converged_sia ",       &
                rank, iter_sia, maxit_sia, not_converged_sia
        end if
      end if
#endif
       
      do while ((iter_sia .lt. maxit_sia) .and. (not_converged_sia))
          
        prt_nonlinear_tot = cputime()

!c ts_sia = number of Picard iterations since last successful time step 

!c iter_sia = number of Picard iterations in current time step

!c msia = cumulative number of coupling iterations for all successful
!c time steps 

        iter_sia = iter_sia + 1
        ts_sia = ts_sia + 1
        msia = msia + 1

!c  write run specific information to log file
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then

          if (idetail_vs.gt.0 .and. transient_flow .or.               &
            idetail_rt.gt.0) then
                                                                       
            write(ilog,'(/72a)')('-',i=1,72)                           
            write(ilog,'(a,i8,1x,a,1pe10.3,1x,a7,1x,a,1pe10.3,        &
      &                  1x,a7,1x,a,i3)')                             &
                  'timestep:',mtime,'time:',time_io,time_unit,        &
                                    'delt:',delt_io,time_unit,        &
                                    'iter:',iter_sia                   
            write(ilog,'(72a/)')('-',i=1,72)
                                                                       
          elseif (idetail_vs.eq.0 .and. transient_flow .or.           &
                  idetail_rt.eq.0) then
                                                                       
            write(ilog,'(1x,a,i8,1x,a,1pe10.3,1x,a7,1x,a,1pe10.3,     &
      &             1x,a7,1x,a5,i3,1x,a8,1pe10.3,1x,a8,1pe10.3)')     &
                'timestep:',mtime,'time:',time_io,time_unit,          &
                                  'delt:',delt_io,time_unit,          &
                                    'iter:',iter_sia,                 &
                                  'max.sia:',sia_max,                 &
                                  'tol.sia:',tol_sia
          end if

!c  write run specific information to screen

!CBF
	!if(mtime.eq.4)then
	!write(*,*) 'STOP TIMELOOP'
	!stop
	!endif


          write(*,'(1x,a,i8,1x,a,1pe10.3,1x,a7,1x,a,1pe10.3,          &
       &            1x,a7,1x,a5,i3,1x,a8,1pe10.3,1x,a8,1pe10.3)')     &
                'timestep:',mtime,'time:',time_io,time_unit,          &
                                  'delt:',delt_io,time_unit,          &
                                    'iter:',iter_sia,                 &
                                  'max.sia:',sia_max,                 &
                                  'tol.sia:',tol_sia
 
        end if                  !end if MPI rank 0
        
        prt_nonlinear_flow = cputime()
        
        

!c  store current densities and compute change in porosity by vertical stress 
        if (density_dependence) then 
           densold1 = density             
        end if   
        
!c_bubbles if not gas_bubbles then go to tranflow and reactran only
!c  transient flow
        if (.not.gas_bubbles) then
            
          ibub=1
          ibubflow=1
           
          if (varsat_flow.and.transient_flow) then              
              
            if (density_dependence) then
               if (heat_transport) then      
!cprovi---------------------------------------------------------------
!cprovi Compute the influence coefficient for dispersive fluxes
!cprovi It is updated for the velocities
!cprovi---------------------------------------------------------------
                     !infheat_d is parallelized, OpenMP, DSU
                     call infheat_d(nvxgl,nvygl,nvzgl,iavs,javs,isymvs,&
                       cinfheat_d,cinfvs,dimcv,                        &
                       disheatx,disheaty,disheatz,                     &
                       pornew, sanew, uvsnew,                          &
                       density, zg,viscosity,relperm,                  &
                       idbg, ilog, njavs, nngl, half_cells,            &
                       cinfrad,heatcapw,radial_coord,                  &
                       ups_heat,av_dens_z,gacc)
!cprovi---------------------------------------------------------------
!cprovi If thermal heat conductity of water is updated or for the 
!cprovi case of variable saturated flow, then thermal conductivity 
!cprovi tensor is updated 
!cprovi---------------------------------------------------------------     
                     if (update_heatcondw.or.variably_saturated) then
                        !infheat_c is parallelized, OpenMP, DSU 
                        call infheat_c (nvxgl,nvygl,nvzgl,iavs,javs,  &
                                        isymvs,                       &
                                        cinfheat_c,dimcv,heatcondw,   &
                                        heatconds,heatcondg,pornew,   &
                                        sanew,                        &
                                        zg,idbg,ilog,njavs,nngl,      &
                                        half_cells,cinfrad,           &
                                        radial_coord,heatcond_model,  &
                                        nheatcond)
                     end if                      
!cprovi--------------------------------------------------------------------
!cproovi Compute the maximum velocities for van leer spatial interpolation          
!cprovi--------------------------------------------------------------------         
                     if (sp_weight_heat=='vanleer'.or.                &
                         sp_weight_heat=='vanleer2') then 
                         !i2upfind_heat is parallelized, OpenMP, DSU 
                         call i2upfind_heat
                     end if 
!cprovi--------------------------------------------------------------------
!cprovi If evaporation is computed, compute the corresponding influence
!cprovi coefficients
!cprovi--------------------------------------------------------------------                     
                     if (evaporation) then
                       !infevap is parallelized, OpenMP, DSU 
                       call infevap(nvxgl,nvygl,nvzgl,iavs,javs,isymvs,&
                             cinfevap_pa,cinfevap_t,cinfvs_t,          &
                             cinfvs,density,                           &
                             ddensvdpa,ddensvdt,dimcv,tempnew,         &
                             mpropvs,nzn,diffv0,                       &
                             pornew,sanew,idbg,ilog,njavs,nngl,        &
                             tortuosity_corr,half_cells,assigned_tau,  &
                             tau,type_tortuosity,marchies,cinfrad,     &
                             radial_coord,isenhfactor,fclay_nabla,     &
                             cte_nabla,ref_dens,nabla_qhv,             &
                             split_divdensv,gacc,gainwt,dsurftensdt,   &
                             gammaw0, tau_fac)
                     end if
               end if
               
               !Parallelized, OpenMP, DSU
               call trddflow
               
            else 
              !Parallelized, OpenMP, DSU
              call tranflow

            end if
            
!FG July 2017 : update root density, moved after time step reduction process due to tranflow. Was put here since Feb 2015.
!               Remind this for testing with other version as there should little differences in simulations where time step cuts due to flow occur and/or RT calculations below...
!       if (update_root_rld) then
!
!           call updtrootdensity
!                              
!	   end if          
          
!c  convergence failure - restart newton iteration with reduced timestep
         
            if (reduce_timestep) then
              prt_timestep_nonlinear =  prt_timestep_nonlinear +       &
                                        cputime() - cputime_start

              if(rank == 0 .and. b_enable_output .and. .not.           &
                 ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                if (mass_balance_vs .and. idetail_vs.gt.2) then
                  write(*,'(2(a,1x,e16.8,1x))')                        &
                        'Relative mass balance error', relbalance_vs,  &
                        'tolerance',rtol_relbalance_vs
                  write(ilog,'(2(a,1x,e16.8,1x))')                     &
                        'Relative mass balance error', relbalance_vs,  &
                        'tolerance',rtol_relbalance_vs
                end if

                if (mass_balance_vs .and. idetail_vs.gt.2) then
                  write(*,'(2(a,1x,e16.8,1x))')                        &
                        'Absolute mass balance error',absbalance_vs,   &
                        'tolerance',rtol_absbalance_vs
                  write(ilog,'(2(a,1x,e16.8,1x))')                     &
                        'Absolute mass balance error',absbalance_vs,   &
                        'tolerance',rtol_absbalance_vs
                end if

                write(*,*) 'Reduce time step for flow'
                write(ilog,*) 'Reduce time step for flow'

              end if                  !end if MPI rank 0  
           
              goto 999
            end if

          end if
                    
          prt_nonlinear_flow = cputime() - prt_nonlinear_flow
          
         
!c  reactive transport
            
          prt_nonlinear_react = cputime()


          if (reactive_transport) then
         
!cprovi-----------------------------------------------------------------
!cprovi Update the temperature vector for reactive transport 
!cprovi-----------------------------------------------------------------          
            if (heat_transport) then
#ifdef OPENMP
    !$omp parallel                                                    &                                                              
    !$omp if (nngl > numofloops_thred_global)                         & 
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)                                              
    !$omp do schedule(static)
#endif 
               do ivol=1,nngl
                  tkel(ivol) = tempnew(ivol) + zerokelvin                  
               end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            end if
          
!cprovi-----------------------------------------------------------------
!cprovi Compute reactive transport 
!cprovi Parallelized, OpenMP, DSU
!cprovi-----------------------------------------------------------------
            call reactran

!c  convergence failure - restart newton iteration with reduced timestep

            if (reduce_timestep) then
                
             prt_timestep_nonlinear =  prt_timestep_nonlinear + cputime() - cputime_start  
             
             if(rank == 0 .and. b_enable_output .and.                         &
              .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
               write(*,*) 'Reduce time step for reactive transport'
               write(ilog,*) 'Reduce time step for reactive transport'
             end if                  !end if MPI rank 0
             
             !c  reset primary and secondary flow equation unknowns
             !c  Geochemical variables are reseted in reactran

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (varsat_flow) then
               uvsnew = uvsold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (varsat_flow) then
               pornew = porold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (varsat_flow) then
               sanew = saold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (variably_saturated) then
               sgnew = sgold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (density_dependence) then 
                 density = densold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (density_dependence) then 
                 densold1 = densold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (density_dependence) then 
                 tds_new = tds_old
             end if  
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
             if (heat_transport) then
                 tempnew = tempold
             end if 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (heat_transport .and. update_viscosity_temp) then  
                viscosity = viscoold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (heat_transport .and. ispitzerdens) then
                density_pitzer = densold_pitzer
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (heat_transport .and. evaporation) then
                densvnew = densvold
             end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (heat_transport .and. evaporation) then
                latvapnew = latvapold
             end if  

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (reactive_transport) then
               sionnew = sionold
             end if

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
             if (reactive_transport) then
               cnew(1:n,:) = c(1:n,:)
             end if

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif
             goto 999
            
            end if
          
          else  
            
            not_converged_sia=.false.

          end if


          prt_nonlinear_react = cputime() - prt_nonlinear_react
        
          prt_nonlinear_tot = cputime() - prt_nonlinear_tot
          

!c  write runtime to file
          if(rank == 0 .and. b_prtfile) then      !if MPI rank 0
            write(iprt_nonlinear, "(3(i8, 1x),4(e12.4,2x))") mtime, iter_sia, msia, prt_nonlinear_flow, prt_nonlinear_react,  &
                  (prt_nonlinear_tot - prt_nonlinear_flow - prt_nonlinear_react), prt_nonlinear_tot
          end if                  !end if MPI rank 0  
        
        else
            
	


          if (double_bubble) then
              
            if (rank == 0 .and. b_enable_output .and. .not.            &
                ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
              write(ilog,'(a)') "enter gas bubble: double_bubble"
            end if
                    
            solvegb=.false.
            bubflow_not_converged=.true.
            ibubflow=0            
            updatefactor = r1


            do while (bubflow_not_converged)
            
              ibubflow=ibubflow+1
              ibubflow_tol=0
              
              if (rank == 0 .and. b_enable_output .and. .not.          &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                write(ilog,'(a,1x,i6,1x)') "ibubflow",ibubflow
              end if
              
              do ivol=1,nngl
                uvsnew_b(ivol) = uvsnew(ivol)
                sanew_b(ivol)  = sanew(ivol)
              end do
              
              call tranflow
		


!c  convergence failure - restart newton iteration with reduced timestep

              if (reduce_timestep) goto 999


!c  set variables for convergence check

              bub_not_converged=.true.
              ibub=0

              do while (bub_not_converged)

                ibub=ibub+1
                ibub_tol=0
                
                if (rank == 0 .and. b_enable_output .and. .not.        &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                  write(ilog,'(a,1x,i6,1x)') "ibub",ibub
                end if


                call reactran

!c  convergence failure - restart newton iteration with reduced timestep

                if (reduce_timestep) goto 999

!c set variables to update non-gas components and for convergence check

                do ivol=1,nngl
                  do ic=1,nc-1
                    c_update(ic,ivol)=cnew(ic,ivol)
                  end do
                  sanew_c(ivol)=sanew(ivol)
                end do   

!c  calculate gas phase saturation due to bubbles
#ifdef DEBUG
                call gasbub(.true., .false.)
#else
                call gasbub(.false., .false.)
#endif

                if (reduce_timestep) goto 999

!c  check for convergence
                if (sgsolved) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, ic, c_diff, c_tol)                            &
    !$omp reduction(+:ibub_tol)
    !$omp do schedule(static)
#endif
                  do ivol=1,nngl
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif
                    do ic=1,nc-1
                       c_diff=c_update(ic,ivol)-cnew(ic,ivol)
                       c_tol=c_update(ic,ivol)*bub_tol
                       if (dabs(c_diff).gt.dmax1(r9,dabs(c_tol)))then    
                          ibub_tol=ibub_tol+1
                      end if
                    end do 
                  end do 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
                  call MPI_Allreduce(ibub_tol, ibub_tol_gbl,1,         &
                                     MPI_INTEGER4,MPI_SUM,             &
                                     Petsc_Comm_World,ierrcode)
                  CHKERRQ(ierrcode)
                  ibub_tol = ibub_tol_gbl
#endif
                end if
            
                if (ibub_tol.eq.0)then
                  bub_not_converged=.false.
                end if        

                if (ibub>maxibub) then
                  if(rank == 0) then  
                    write(ilog,'(72a)')('-',i=1,72)                    
                    write(ilog,'(a)')'bubble model fails to converge'
                    write(ilog,'(a)')'maximum number of bubble iterations exceeded'
                    write(ilog,'(a)')'reduce timestep'
                    
                    write(*,'(72a)')('-',i=1,72)                    
                    write(*,'(a)')'bubble model fails to converge'
                    write(*,'(a)')'maximum number of bubble iterations exceeded'
                    write(*,'(a)')'reduce timestep'
                  end if
                  reduce_timestep = .true.
                  goto 999
                end if

              end do        !bub_not_converged

!c_bubbles check for convergence, outer bubble loop
              if (sgsolved) then
                if (ibubflow.eq.r1) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, uvs_diff, uvs_tol)                       &
    !$omp reduction(+:ibubflow_tol)
    !$omp do schedule(static)
#endif
                  do ivol=1,nngl 
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif
                    izn = mpropvs(ivol)                   !material property zone
                    if (uvsnew(ivol).ge.aentry(izn)) then    ! if saturated
                      uvs_diff=sanew_b(ivol)-sanew(ivol)
                      uvs_tol=sanew_b(ivol)*bubflow_tol
                      if (dabs(uvs_diff).gt.dmax1(r16,dabs(uvs_tol)))then
                         ibubflow_tol=ibubflow_tol+1
                      end if 
                    end if
                  end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                else
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, uvs_diff, uvs_tol)                       &
    !$omp reduction(+:ibubflow_tol)
    !$omp do schedule(static)
#endif 
                  do ivol=1,nngl 
#ifdef PETSC
                    if(node_idx_lg2l(ivol) < 0) then
                      cycle
                    end if
#endif
                    izn = mpropvs(ivol)                   !material property zone
                    if (uvsnew(ivol).ge.aentry(izn)) then    ! if saturated
                      uvs_diff=uvsnew_b(ivol)-uvsnew(ivol)
                      uvs_tol=uvsnew_b(ivol)*bubflow_tol
                      if (dabs(uvs_diff).gt.dmax1(r16,dabs(uvs_tol)))then
                         ibubflow_tol=ibubflow_tol+1
                      end if 
                    end if
                  end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
                end if
#ifdef PETSC
                  call MPI_Allreduce(ibubflow_tol, ibubflow_tol_gbl,1, &
                                     MPI_INTEGER4,MPI_SUM,             &
                                     Petsc_Comm_World,ierrcode)
                  CHKERRQ(ierrcode)
                  ibubflow_tol = ibubflow_tol_gbl
#endif
              end if

              if (ibubflow_tol.eq.0)then
                 bubflow_not_converged=.false.
              else if (rank == 0 .and. b_enable_output .and. .not.     &
                ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                if (ibubflow_tol.gt.0) then
                  write (ilog,'(a,1x,i6)') 'flow-bub', ibub
                end if
              end if
              
            
              if (ibubflow>maxibubflow) then
                if (rank == 0) then 
                   write(ilog,'(72a)')('-',i=1,72)                    
                   write(ilog,'(a)')'bubble model fails to converge'
                   write(ilog,'(a)')'maximum number of bubble iterations exceeded'
                   write(ilog,'(a)')'reduce timestep'
                   
                   write(*,'(72a)')('-',i=1,72)                    
                   write(*,'(a)')'bubble model fails to converge'
                   write(*,'(a)')'maximum number of bubble iterations exceeded'
                   write(*,'(a)')'reduce timestep'
                end if
                reduce_timestep = .true.
                goto 999
              end if

            end do !bubflow_not_converged

!c_bubbles call second half of reactran

            call reactran_2

!c_bubbles  if not double bubble then loop over tranflow,reactan and gasbub

          else
              
            if (rank == 0 .and. b_enable_output .and. .not.            &
                ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
              write(ilog,'(a)') "enter gas bubble: no double_bubble"
            end if
        
            bubflow_not_converged=.true.
            ibubflow=0
            bub_not_converged=.true.
            ibub=0
            updatefactor = r1
            solvegb = .false.    
        
            do ivol=1,nngl
              sanew_b(ivol)=sanew(ivol)
            end do    

            do while (bubflow_not_converged.or.bub_not_converged)
            
              ibubflow=ibubflow+1
              ibubflow_tol=0
              ibub=ibub+1
              ibub_tol=0
              
              if (rank == 0 .and. b_enable_output .and. .not.          &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                write(ilog,'(2(a,1x,i6,1x))') "ibubflow",ibubflow,"ibub",ibub
              end if

              do ivol=1,nngl
                uvsnew_b(ivol)=uvsnew(ivol)
              end do

              call tranflow

!c  convergence failure - restart newton iteration with reduced timestep

              if (reduce_timestep) goto 999

!c  set variables for convergence check

              call reactran

!c  convergence failure - restart newton iteration with reduced timestep

              if (reduce_timestep) goto 999

!c set variables to update non-gas components

              do ivol=1,nngl
                do ic=1,nc-1
                  c_update(ic,ivol)=cnew(ic,ivol)
                end do
                sanew_c(ivol)=sanew(ivol)
              end do

!c  calculate gas phase saturation due to bubbles
#ifdef DEBUG
              call gasbub(.true., .false.)
#else
              call gasbub(.false., .false.)
#endif
              if (reduce_timestep) goto 999
              
!c  if new gas saturation was solved for then check for convergence
              if (sgsolved) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, ic, c_diff, c_tol, uvs_diff, uvs_tol)         &
    !$omp reduction(+:ibub_tol,ibubflow_tol)
    !$omp do schedule(static)
#endif
                do ivol=1,nngl
#ifdef PETSC
                  if(node_idx_lg2l(ivol) < 0) then
                    cycle
                  end if
#endif
                  do ic=1,nc-1
                    c_diff=c_update(ic,ivol)-cnew(ic,ivol)
                    c_tol=c_update(ic,ivol)*bub_tol
                    if (dabs(c_diff).gt.dmax1(r10,dabs(c_tol)))then
                        ibub_tol=ibub_tol+1
              
!c    if (ibub.gt.10) then
!c      write(ilog,'(a,i6,a14,4e16.8)') 'bub',ivol,namec(ic),          &
!c            c_update(ic,ivol),cnew(ic,ivol),c_diff,c_tol
!c      write(ilog,'(a,1x,l2)')'unsaturated', unsaturated(ivol)
!c    end if
                    end if
                  end do 
                  uvs_diff=uvsnew_b(ivol)-uvsnew(ivol)
                  uvs_tol=uvsnew_b(ivol)*bubflow_tol
                  if (dabs(uvs_diff).gt.dmax1(r9,dabs(uvs_tol)))then
                     ibubflow_tol=ibubflow_tol+1
!c    if (ibub.gt.10) then
!c      write(ilog,'(a,i6,4e16.8)')'flow',ivol, uvsnew_b(ivol),        &
!c            uvsnew(ivol),uvs_diff,uvs_tol
!c      write(ilog,'(a,1x,l2)')'unsaturated', unsaturated(ivol)
!c    end if
                  end if
                end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
                call MPI_Allreduce(ibub_tol, ibub_tol_gbl,1,           &
                                   MPI_INTEGER4,MPI_SUM,               &
                                   Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
                ibub_tol = ibub_tol_gbl
                
                call MPI_Allreduce(ibubflow_tol, ibubflow_tol_gbl,1,   &
                                   MPI_INTEGER4,MPI_SUM,               &
                                   Petsc_Comm_World,ierrcode)
                CHKERRQ(ierrcode)
                ibubflow_tol = ibubflow_tol_gbl
#endif
              end if

              if ((ibub_tol.eq.0).and.(ibubflow_tol.eq.0))then
                 bub_not_converged=.false.
                 bubflow_not_converged=.false.
              else if (rank == 0 .and. b_enable_output .and. .not.     &
                  ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
                if(ibub_tol.gt.0)then
                  write (ilog,'(a,1x,i6)') 'reactran-bub', ibub
                end if
                if (ibubflow_tol.gt.0) then
                  write (ilog,'(a,1x,i6)') 'flow-bub', ibub
                end if
              end if

              if ((ibubflow>maxibubflow).or.(ibub>maxibub)) then
                if (rank == 0) then  
                  write(ilog,'(72a)')('-',i=1,72)                    
                  write(ilog,'(a)')'bubble model fails to converge'
                  write(ilog,'(a)')'maximum number of bubble iterations exceeded'
                  write(ilog,'(a)')'reduce timestep'

                  write(*,'(72a)')('-',i=1,72)                    
                  write(*,'(a)')'bubble model fails to converge'
                  write(*,'(a)')'maximum number of bubble iterations exceeded'
                  write(*,'(a)')'reduce timestep'
                end if
                reduce_timestep = .true.
                goto 999
              end if

            end do !bubflow_not_converged

!c_bubbles call second half of reactran
     
            call reactran_2

          end if    !double bubbles
          
        end if       !gas bubbles

#ifdef DEBUG
        if(rank == 0 .and. b_enable_output) then
          if(info_debug > 10) then
            write(*,'(a, 3(1x, i4), 1x, l1)') "rank, iter_sia, maxit_sia, not_converged_sia ", &
                  rank, iter_sia, maxit_sia, not_converged_sia
          end if
        end if
#endif
         
!c skip ahead for flow verification problems and 

!c call ddtds moved to reactran

      end do  !while ((iter_sia .lt. maxit_sia) .and. (not_converged_sia))

      prt_timestep_nonlinear =  prt_timestep_nonlinear + cputime() - cputime_start

      if (abs(relbalance_vs) .le. rtol_relbalance_vs .or.              &
          abs(absbalance_vs) .le. rtol_absbalance_vs) then

        if (flow_verification) go to 1001

        if (.not.density_dependence) go to 1001
      
      end if
      
    



!c  non-convergence of coupling iterations

        if (((iter_sia.eq.maxit_sia).and.(not_converged_sia)) .or.    &
            ((abs(relbalance_vs) .gt. rtol_relbalance_vs ) .and.      &
            (abs(absbalance_vs) .gt. rtol_absbalance_vs ))) then

          reduce_timestep = .true.

          if(rank == 0 .and. b_enable_output .and. .not.               &
             ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then

            if (abs(relbalance_vs) .le. rtol_relbalance_vs .or. &
                abs(absbalance_vs) .le. rtol_absbalance_vs) then

              write(*,*) 'Time step is reduced for sia'

              write(ilog,*)                                            &
               '----------------------------------------------------'
              write(ilog,*)                                            &
               '   maximum number of coupling iterations exceeded   '
              write(ilog,*)                                            &
               '             reducing time step                     '
              write(ilog,*)                                            &
               '----------------------------------------------------'
            end if

            if (abs(relbalance_vs) .gt. rtol_relbalance_vs .and.       &
                idetail_vs.gt.2) then
              write(*,'(2(a,1x,e16.8,1x))')                                 &
               'Relative mass balance error', relbalance_vs,                &
               'tolerance of relative mass balance error',rtol_relbalance_vs
              write(ilog,'(2(a,1x,e16.8,1x))')                              &
               'Relative mass balance error', relbalance_vs,                &
               'tolerance of relative mass balance error',rtol_relbalance_vs
              write(ilog,*)                                                 &
               '----------------------------------------------------'
            end if

            if (abs(absbalance_vs) .gt. rtol_absbalance_vs .and.       &
                idetail_vs.gt.2) then
              write(*,'(2(a,1x,e16.8,1x))')                                 &
               'Absolute mass balance error',absbalance_vs,                 &
               'tolerance of absolute mass balance error',rtol_absbalance_vs
              write(ilog,'(2(a,1x,e16.8,1x))')                              &
               'Absolute mass balance error',absbalance_vs,                 &
               'tolerance of absolute mass balance error',rtol_absbalance_vs
              write(ilog,*)                                                 &
               '----------------------------------------------------'
            end if
!c  write sequential iteration non-convergence history to log file

            if (density_dependence .and. idetail_vs.gt.0) then
              write(ilog,'(/72a)')('-',i=1,72)
              write(ilog,'(/2a)') ' Sequential Iteration Convergence',  &
                      ' Summary:'                                        
              write(ilog,'(a)') ' Sequential   maximum'                  
              write(ilog,'(2a)')' iteration    update      ',           &
                              ' maxvol       nexvol'
                                                                         
              do i1 = 1,iter_sia                                         
                write(ilog,'(i6,7x,1pe11.4,3x,i6,7x,i6)')               &
                      i1,sia_dens(i1),sia_maxvol(i1), sia_nexvol(i1)
              end do
            
            end if
  
          end if                  !end if MPI rank 0

          
!c  reset primary and secondary flow equation unknowns
!c  and geochemical system for reduced time step

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (varsat_flow) then
            uvsnew = uvsold
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (varsat_flow) then
            pornew = porold
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (varsat_flow) then
            sanew = saold
          end if

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (variably_saturated) then
             sgnew = sgold
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (density_dependence) then
              density = densold
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (density_dependence) then
              densold1 = densold
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (density_dependence) then
              tds_new = tds_old
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif          
          if (heat_transport) then
              tempnew = tempold 
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif          
          if (heat_transport .and. update_viscosity_temp) then
              viscosity = viscoold
          end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (heat_transport .and. ispitzerdens) then
              density_pitzer = densold_pitzer
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (heat_transport .and. evaporation) then
              densvnew = densvold
          end if

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (heat_transport .and. evaporation) then
              latvapnew = latvapold
          end if

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (reactive_transport) then
            sionnew = sionold
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
          if (reactive_transport) then
            cnew(1:n,:) = c(1:n,:)
          end if
          
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif

          goto 999

        end if !(iter_sia.eq.maxit_sia).and.(not_converged_sia)
             
        if(b_enable_output) then      !if enable output

!c error in sequential iterations or input parameter

        if (msia .eq. 0 .and. rank == 0) then 
          write(ilog,'(72a)')('-',i=1,72)
          write(ilog,'(a)')'failure in timeloop'
          write(ilog,'(a)')'error in sequential iterative coupling'
          write(ilog,'(a)')'bye now ...'
          write(ilog,'(72a)')('-',i=1,72)
          write(ilog,'(72a)')('-',i=1,72)
          write(ilog,'(72a)')('-',i=1,72)
          if (b_enable_output_gen) then
            write(igen,'(a)')'failure in timeloop'
            write(igen,'(a)')'error in sequential iterative coupling'
            write(igen,'(a)')'bye now ...'
          end if
        end if

!c  write sequential iteration convergence history to log file

        if (density_dependence .and. idetail_vs.gt.0 .and. rank == 0   &
            .and..not.((skip_time.gt.0).and.                           &
            (nskip_time.lt.skip_time))) then
          write(ilog,'(/72a)')('-',i=1,72)
          write(ilog,'(/2a)') ' Sequential Iteration Convergence',    &
                    ' Summary:'                                        
          write(ilog,'(a)') ' Sequential   maximum'                    
          write(ilog,'(2a)')' iteration    update      ',             &
                            ' maxvol       nexvol'
                                                                       
          do i1 = 1,iter_sia                                           
            write(ilog,'(i6,7x,1pe11.4,3x,i6,7x,i6)')                 &
                  i1,sia_dens(i1),sia_maxvol(i1), sia_nexvol(i1)
          end do

        end if

        end if                  !end if enable output


!c  mass balance for density dependent and variably saturated flow
!c  Parallelized, OpenMP, DSU

1001    continue

        if (varsat_flow.and.mass_balance_vs) then
          if (density_dependence) then
            call mbaldd
          else  
            call mbalvs
          end if
        end if
        
!cprovi-------------------------------------------------------------------
!cprovi  Compute energy balance 
!cprovi  Parallelized, OpenMP, DSU
!cprovi-------------------------------------------------------------------
        if (heat_transport.and.energy_balance) then
          call energy_bal
        end if
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi------------------------------------------------------------------- 
!c  write magnitude of current time step,number of 
!c  coupling iterations, and time step size controller to file

        if(rank == 0 .and. b_enable_output .and.                      &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        if (idetail_vs.gt.0 .and. transient_flow .or.                 &
     &      idetail_rt.gt.0) then
 
          if (mtime.eq.1) then
!c  magnitude of current time step
            !idelt = 24
            idelt = lun_get()
            open(idelt,file=prefix(:l_prfx)//'_o.dt',status='unknown',&
                 form='formatted')
              
!c  version information
            if (b_writeversion_tecplot ) then
                call writeversion2file(idelt, "#")
            end if
            
!c  title and variables        
            write(idelt,'(3a)') 'title = "dataset ',prefix(:l_prfx),'"'
            write(idelt,'(4a)') 'variables = "time", "delta t", ',    &
     &                          '"courant_max", "courant_num", ',     &
     &                          '"iter_ts","iter_vs","iter_rt", ',    &
     &                          '"ts_min"'
            write(idelt,'(2a)') 'zone t = "time step data", f=point'

!c  no limiter on initial time step length

          ts_min = 'none'

        end if
          
        write(idelt,'(3es13.5,4i4,a12)') time_io,delt_io,           &
     &                                  courant_max, courant_num,     &
     &                                  ts_sia,iter_vs,iter_rt,ts_min   
  
       end if
     
           end if
           
           !FG sept 2021 - calculate and write domain-scale mineral rates and reacted masses
           
           if (reactive_transport) then
                if (nm.gt.0) then
                  call output_min
                endif
            endif

!c  write contour data to output file at specified output times
   
        if (gs_output) then
        
          if (time.ge.(gs_tout(igstime)-tiny_time)) then

            if (b_enable_output) then  
              
              if(rank == 0) then  
!c  report to log file

                write(ilog,'(/a,1pe12.4,1x,a)')                        &
                     'write contour data, T = ', time_io, time_unit
                write(ilog,'(72a/)')('-',i=1,72)
                
!c  report to screen

                write(*,'(/1x,a,1pe12.4,1x,a)')                        &
                     'write contour data, T = ', time_io, time_unit
                write(*,'(1x,72a/)')('-',i=1,72)
              
              end if

              if (varsat_flow.and.transient_flow) then
                if (density_dependence) then
                  call outputdd
                else
                  call outputvs
                end if
              end if
            
              if (reactive_transport) then
                call outputrt                
                if (gas_bubbles.and.bubble_out) then                  
                  call gasbub(.false., .true.) 
                  if (reduce_timestep) goto 999
                end if
              end if
              
            end if
            
            igstime = igstime + 1
          end if
        end if               !(gs_output)
 
!c  write transient data to output file
!c  every ngb_step time step and after completion of solution
 
        if (gb_output .and. b_enable_output) then         !**Note: Output is not parallelized yet, DSU
          igb_step = igb_step + 1
          if (igb_step.eq.ngb_step.or.time.gt.tfinal-tiny_time) then
            ngb_tstep = ngb_tstep + 1  
            if (transient_flow.or.reactive_transport) then
              do igb = 1,ngb

                ivol = ngb_vol(igb)
                
                if(ivol < 0) then
                    cycle
                end if
                  
!c  assign unit numbers for output of transient data

                call tranunit(igb)

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

                if (temp_field.or.heat_transport) then
                  call tcorr(tkel(ivol))
                end if

!c  write transient data to output file

                if (transient_flow) then
                  if (density_dependence) then
                    call tprfdd(ivol,igb,ngb_tstep)      
                  else
                    call tprfvs(ivol,igb,ngb_tstep)
                  end if
                end if

                if (reactive_transport) then
                    
                  if (b_output_binary) then                    
                    igbt  = igbt_mpi(igb)
                    igbc  = igbc_mpi(igb)
                    igbm  = igbm_mpi(igb)
                    igbgr = igbgr_mpi(igb)
                    igbg  = igbg_mpi(igb)
                    igbi  = igbi_mpi(igb)
                    igbb  = igbb_mpi(igb)
                    igbs  = igbs_mpi(igb)
                    igbv  = igbv_mpi(igb)
                    igbd  = igbd_mpi(igb)
                    igbx  = igbx_mpi(igb)
                    igbis = igbis_mpi(igb)
                  end if
                    
                  if (density_dependence) then
                    call tprfrtlc(totcnew(1,ivol),cnew(1,ivol),        &
                           cx(1,ivol),gamma(1,ivol),                   &
                           gamma(nc+1,ivol),cmnew(1,ivol),             &
                           gnew(1,ivol),cec_g(ivol),                   &
                           distcoff_rt(1,ivol),area(1,ivol),           &
                           phi(1,ivol),phiold(1,ivol),                 &
                           sionnew(ivol),tkel(ivol),                   &
                           uvsnew(ivol),zg(ivol),time_io,delt,         &
                           sanew(ivol),pornew(ivol),igbt,igbc,         &
                           igbm,igbg,igbgr,igbi,igbb,igbs,igbv,        &
                           igbd,igbx,igbis,offset_igbt(igb),           &
                           offset_igbc(igb),offset_igbm(igb),          &
                           offset_igbg(igb),offset_igbgr(igb),         &
                           offset_igbi(igb),offset_igbb(igb),          &
                           offset_igbs(igb),offset_igbv(igb),          &
                           offset_igbd(igb),offset_igbx(igb),          &
                           offset_igbis(igb),                          &
                           offset_igbt_ijk(igb),                       &
                           offset_igbc_ijk(igb),offset_igbm_ijk(igb),  &
                           offset_igbg_ijk(igb),offset_igbgr_ijk(igb), &
                           offset_igbi_ijk(igb),offset_igbb_ijk(igb),  &
                           offset_igbs_ijk(igb),offset_igbv_ijk(igb),  &
                           offset_igbd_ijk(igb),offset_igbx_ijk(igb),  &
                           offset_igbis_ijk(igb),                      &
                           prefix,l_prfx,tec_header,                   &
                           ivol,mtime,ngb_tstep+1,zone_name,           &
                           l_zone_name,update_porosity)
                  else                                                 
                    call tprfrtlc(totcnew(1,ivol),cnew(1,ivol),        &
                           cx(1,ivol),gamma(1,ivol),                   &
                           gamma(nc+1,ivol),cmnew(1,ivol),             &
                           gnew(1,ivol),cec_g(ivol),                   &
                           distcoff_rt(1,ivol),area(1,ivol),           &
                           phi(1,ivol),phiold(1,ivol),                 &
                           sionnew(ivol),tkel(ivol),                   &
                           hhead(ivol),zg(ivol),time_io,delt,          &
                           sanew(ivol),pornew(ivol),igbt,igbc,         &
                           igbm,igbg,igbgr,igbi,igbb,igbs,igbv,        &
                           igbd,igbx,igbis,offset_igbt(igb),           &
                           offset_igbc(igb),offset_igbm(igb),          &
                           offset_igbg(igb),offset_igbgr(igb),         &
                           offset_igbi(igb),offset_igbb(igb),          &
                           offset_igbs(igb),offset_igbv(igb),          &
                           offset_igbd(igb),offset_igbx(igb),          &
                           offset_igbis(igb),                          &
                           offset_igbt_ijk(igb),                       &
                           offset_igbc_ijk(igb),offset_igbm_ijk(igb),  &
                           offset_igbg_ijk(igb),offset_igbgr_ijk(igb), &
                           offset_igbi_ijk(igb),offset_igbb_ijk(igb),  &
                           offset_igbs_ijk(igb),offset_igbv_ijk(igb),  &
                           offset_igbd_ijk(igb),offset_igbx_ijk(igb),  &
                           offset_igbis_ijk(igb),                      &
                           prefix,l_prfx,tec_header,                   &
                           ivol,mtime,ngb_tstep+1,zone_name,           &
                           l_zone_name,update_porosity)
                  end if !density dependence
                end if ! reactive_transport
            end do
            
            !cprovi----------------------------------------------------    
            !cprovi  Write transient evaporation info
            !cprovi----------------------------------------------------    
            if(rank == 0 .and. b_enable_output) then
              if (evaporation.and.write_evap_info) then  
                 call trans_evap_info (.false.,ngb_tstep)
              end if
            end if
            
            end if
            igb_step = 0
          end if
        end if                !(gb_output)

!c calculate maximum courant number for groundwater flow

        iprint = 0

        if ((density_dependence).and.(.not.flow_verification)) then
          !velodd is parallelized, OpenMP, DSU
          call velodd (nvxgl,nvygl,nvzgl,iavs,javs,cinfvs_a,dimcv, xg, &
     &                 yg, zg, uvsnew, density, viscosity,             &
     &                 relperm, idbg, ilog,ivel, fully_saturated,      &
     &                 njavs, nngl, nn, half_cells, pornew, sanew,     &
     &                 delt, courant_max, courant_num, iprint,time_io, &
     &                 cinfrad,radial_coord,0)
        else
          delt_courant = bignum  !arbitrary large number
        end if

	

!cprovi----------------------------------------------------    
!cprovi  Prepare for next time step
!cprovi  Parallelized, OpenMP, DSU
!cprovi----------------------------------------------------
        call nexttime
	
!cprovi----------------------------------------------------
!cprovi Update atmospheric parameters  
!cprovi----------------------------------------------------       
        if (evaporation.and.variably_saturated) then
           call updtbcatm
        end if      

 
!cprovi----------------------------------------------------
!cprovi Write the backup files for the restart process 
!cprovi Sergio Andres Bea Jofre 
!cprovi----------------------------------------------------
       if(b_enable_output)  then
        ! call restart_w
       end if

!cprovi----------------------------------------------------
!cprovi update boundary conditions for variably 
!cprovi saturated flow
!cprovi----------------------------------------------------        
       if (update_bcvs) then
          if (density_dependence) then
             call updtbcdd
          else 
             call updtbcvs
          end if
       end if
       
!FG July 2017 - root density update (see previous commment on an alternative position for this call, set from Feb 2015).
       if (update_root_rld) then 
           
           call updtrootdensity
                              
       end if

!  update etp and canopy dependent parameters	!CBF
      if ((root_uptake).or.(pure_evap)) then	!CBF
            
	    call updtetp	!CBF

	  end if	!CBF

!c  update temperature field

        if (temp_field) then
  
          call readtemp

          if (update_temp) then
            call intpolt
          end if

        end if

!c  update cputime

        cpuint_old = cpuint
        cpuint = cputime()
        if (cpuint.lt.cpuint_old) then
          csec = csec + cpuint - cpuint_old + r86400
        else
          csec = csec + cpuint - cpuint_old
        end if
        
        prt_timestep_tot = cputime() - prt_timestep_tot
!c  write runtime to file
        if(rank == 0 .and. b_prtfile) then
          write(iprt_timestep, "(i8, 2x, 3(e12.4,2x))") mtime, prt_timestep_nonlinear,    &
               (prt_timestep_tot - prt_timestep_nonlinear),  prt_timestep_tot
        end if

      end do                  !end time loop
 write(*,*) 'timeloop fini dans timeloop'
		

!cprovi----------------------------------------------------
!cprovi Write backup file for the last time 
!cprovi It was added by Sergio Andres Bea Jofre
!cprovi It was based on Richard Amos implementation and 
!cprovi Sergi Molins Implementation 
!cprovi----------------------------------------------------
      igstime = igstime - 1
      rsrt_cnt = backup_frequency*2 - 1
      if(b_enable_output)  then
        !call restart_w
      end if

!cprovi----------------------------------------------------
!cprovi----------------------------------------------------
!cprovi----------------------------------------------------

      return
      end
