!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initbcvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

! ----------------------------------------------------------------------
! subroutine initbcvs                                                   
! -------------------                                                   
!                                                                       
! boundary conditions (variably saturated flow)                         
!                                                                       
! first type boundary conditions:                                       
! -> define zone by delineating nodes located within zone               
!                                                                       
! second type boundary condition:                                       
! -> define area (only on surface of solution domain)                   
!                                                                       
! seepage face boundary condition:                                      
! -> define area (only on surface of solution domain)                   
!                                                                       
! written by:      Uli Mayer - May 17, 96                               
!                                                                       
! last modified:   Tom Henderson - March 24, 2003                       
!                  - added point source                                 
!                                                                       
! definition of variables:                                              
!                                                                       
! I --> on input   * arbitrary  - initialized  + entries expected       
! O --> on output  * arbitrary  - unaltered    + altered                
!                                                                       
!                                                                    I O
! passed:   -                                                           
!                                                                       
! common:                                                               
! gen.f:    real*8:                                                     
!           -------                                                     
!           bcondvs(nbvs)      = boundary condition                  * +
!                                (pressure head or flux) or             
!                                identification of seepage face         
!                                boundary type                          
!           dimcv(3,nn)        = spatial dimensions of control       + -
!                                volumes                                
!           hhead(nn)          = hydraulic head                      + +
!           rwork(:,:)         = real*8 work array                   * *
!           time_bcvs          = next read time for flow boundary    * +
!                                conditions                             
!           uvsold(nn)         = solution vector (old time level)    + +
!           uvsnew(nn)         = solution vector (new time level)    + +
!           sec_per_days       = conversion factor from SI input     + -
!                                units for physico-chemical             
!                                parameters internal time units         
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibcvs              = unit number, transient boundary     * +
!                                             conditions, variably      
!                                             saturated flow            
!           idat               = unit number, run specific input     + -
!                                             file                      
!           igen               = unit number, generic output file    + -
!           ilog               = unit number, log book               + -
!           itmp               = unit number, temporary storage      + -
!           iabvs(nbvs)        = pointer to boundary control volumes * +
!                                for variably saturated flow            
!           iwork(:)           = integer work array                  * *
!           l_prfx             = length of prefix of I/O files       + -
!           l_zone_name        = length of zone name                 * +
!           nn                 = total number of control volumes     + -
!           nbvs               = number of specified boundary        * +
!                                control volumes                        
!                                (variably saturated flow)              
!           nseep_first        = number of seepage face nodes        * +
!                                                                       
!           logical:                                                    
!           --------                                                    
!           fully_saturated    = .true.  -> saturated conditions     + -
!           update_bcvs        = .true.  -> transient boundary       * +
!                                           condition for variably      
!                                           saturated flow              
!           variably_saturated = .true.  -> .not.fully_saturated,    + -
!                                        -> variably saturated          
!                                           conditions                  
!           hydraulic_head     = .true.  -> initial condition in     + -
!                                           terms of hydraulic head     
!           pressure_head      = .true.  -> initial condition in     + -
!                                           terms of pressure heada     
!           seepage_face       = .true.  -> seepage face boundary    * +
!                                           specified                   
!                                                                       
!           character:                                                  
!           ----------                                                  
!           prefix             = prefix name for all I/O files       + -
!           zone_name          = name of zone                        * +
!           btypevs(nbvs)      = boundary type array                 * +
!                                (variably saturated flow)              
!                                'first'   = Dirichlet                  
!                                'second'  = Neumann                    
!                                'seepage' = seepage face               
!           section_header     = section header                      * +
!                                                                       
! local:    real*8:                                                     
!           -------                                                     
!           r0                 = constant                               
!           r1                 = constant                               
!           tiny               = small increment                        
!           xbmin              = min. x-coordinate of boundary          
!                                zone                                   
!           xbmax              = max. x-coordinate of boundary          
!                                zone                                   
!           ybmin              = min. y-coordinate of boundary          
!                                zone                                   
!           ybmax              = max. y-coordinate of boundary          
!                                zone                                   
!           zbmin              = min. z-coordinate of boundary          
!                                zone                                   
!           zbmax              = max. z-coordinate of boundary          
!                                zone                                   
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibvs               = counter (boundary control volumes)     
!           ibz                = counter (zones)                        
!           ierr               = 0 -> memory allocation successful      
!           ivol               = counter (control volumes)              
!           istart             = pointer (control volume)               
!           iend               = pointer (control volume)               
!           l_string           = length of text string                  
!           nbvsp              = start of boundary zone                 
!                                (temporary)                            
!           nbz                = number of boundary zones               
!                                                                       
!           logical:                                                    
!           --------                                                    
!           found              = logical variable to exit search        
!           found_section      = .true.  -> section header was          
!                                           found in input file         
!           found_subsection   = .true.  -> subsection header was       
!                                           found in input file         
!           xy_plane           = boundary zone parallel tp xy-plane     
!           xz_plane           = boundary zone parallel to xz-plane     
!           yz_plane           = boundary zone parallel to yz-plane     
!                                                                       
!           character:                                                  
!           ----------                                                  
!           bcond              = btypevs = 'first'                      
!                                -> hydraulic head                      
!                                btypevs = 'second'                     
!                                -> specified flux                      
!                                btypevs = 'seepage'                    
!                                -> initial seepage face heigth         
!           btypezn            = boundary type of zone                  
!           subsection         = name of subsection in input file       
!                                                                       
! external: checkerr  = check for error during memory allocation        
!           findstrg  = find text string in file                        
!           findzone  = find zone in input section                      
!           readbloc  = read section of input file and write to         
!                       temporary file                                  
!           readzone  = read zone in section of input file and          
!                       write to temporary file                         
! ----------------------------------------------------------------------
                                                                        
      subroutine initbcvs 
                                                                        
      use parm 
      use gen 
      use file_unit, only : lun_get, lun_free
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif                                                                        
      implicit none
      
      integer :: i, ibz, ibvs, ivol, ierr, nbz, nbvsp, l_string
      
      real*8 :: areaf, bcond, xbmin, xbmax, ybmin, ybmax, zbmin, zbmax
                                                                        
      external checkerr, findstrg, findzone, readbloc, readzone 
                                                                        
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, tiny = 1.0d-8 
                                                                        
      logical xy_plane,xz_plane,yz_plane,found,found_section,          &
     &        found_subsection                                          
      character*12 btypezn 
      character*72 subsection 
      real*8  factiny 

      areaf = r0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
                                                                        
!  define defaults                                                      
      if(rank == 0 .and. b_enable_output) then                                                                  
        write(*,*) 'boundary conditions - ',                           &
     &             'variably saturated flow'                              
        write(*,*) ('-',i=1,72) 
                                                                        
        write(ilog,'(2a)') 'boundary conditions - ',                     &
     &                     'variably saturated flow'                      
        write(ilog,'(72a/)')('-',i=1,72) 
      end if  
                                                                        
!  read section header for boundary conditions of variably saturated    
!  flow simulation                                                      
                                                                        
      section_header = 'boundary conditions - variably saturated flow' 
      call readbloc (idat,itmp,section_header,found_section,.true.) 
                                                                        
!  define length of section header                                      
                                                                        
      l_string = index(section_header,'  ')-1 
      if (l_string.eq.-1.or.l_string.gt.72) then 
         l_string=72 
      end if 
                                                                        
!  terminate program if section header not found                        
                                                                        
      if (.not.found_section) then 
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file' 
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop 
      end if 
                                                                        
!  write section header to generic output file                          
      if (b_enable_output .and. b_enable_output_gen) then                                                                  
        write(igen,'(/72a)')('-',i=1,72) 
        write(igen,'(a)') section_header(:l_string) 
        write(igen,'(72a/)')('-',i=1,72) 
      end if
                                                                        
!  initialize variables for seepage face iteration                      
                                                                        
      seepage_face = .false. 
      seep_iter = .false.
      nseep_first = 0 
                                                                        
!  preliminary allocation of memory for boundary conditions             
                                                                        
      allocate (bcondvs(nngl), stat = ierr) 
      bcondvs=0 
      call checkerr(ierr,'bcondvs',ilog) 
                                                                        
      allocate (iabvs(nngl), stat = ierr) 
      iabvs=0 
      call checkerr(ierr,'iabvs',ilog) 
                                                                        
      allocate (btypevs(nngl), stat = ierr) 
      btypevs=' ' 
      call checkerr(ierr,'btypevs',ilog) 
      
      allocate (ivol2bvs(nngl), stat = ierr)
      ivol2bvs=0 
      call checkerr(ierr,'ivol2bvs',ilog)
                                                                        
!  read number of boundary zones                                        
                                                                        
      read(itmp,*,err=999,end=999) nbz
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
     &  'number of boundary zones                        = ',nbz    
      end if
                                                                        
!  initialize pointer array for storage of boundary conditions          
                                                                        
      nbvs = 0 
      iabvs(1) = 1 
      ivol2bvs(:) = 0
                                                                        
!  read name of zone                                                    
                                                                        
                                  !loop over number of zones            
      do ibz=1,nbz 
                                                                        
                                  !temporary pointer for output         
        nbvsp = nbvs+1 
                                                                        
!  find current zone in input file and write to temporary file          
                                                                        
        subsection = 'number and name of zone' 
                                                                        
        call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                        
        if (found_subsection) then 
                                                                        
          call readzone(itmp,icnv,ilog,zone_name,found_subsection) 
                                                                        
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error in input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define length of zone name                                           
                                                                        
        l_zone_name = index(zone_name,'  ')-1 
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
          l_zone_name = 72 
        end if 
                                                                        
                                                                        
!  define type and value of boundary condition                          
                                                                        
        subsection = 'boundary type' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 
                                                                        
        if (found_subsection) then 
                                                                        
          read(icnv,*,err=999,end=999) btypezn, bcond 
                                                                        
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
            l_string = index(subsection,'  ')-1 
            if (l_string.eq.-1.or.l_string.gt.72) then 
               l_string=72 
            end if 
            write(ilog,*) 'subsection "',subsection(:l_string),           &
     &                    '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  read coordiantes defining boundary zone,                             
                                                                        
        subsection = 'extent of zone' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 
                                                                        
        if (found_subsection) then 
                                                                        
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
     &                                 zbmin,zbmax                      
                                                                        
        elseif (.not.found_subsection) then 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "', section_header(:l_string),'"' 
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
            l_string = index(subsection,'  ')-1 
            if (l_string.eq.-1.or.l_string.gt.72) then 
               l_string=72 
            end if 
            write(ilog,*) 'subsection "',subsection(:l_string),        &
     &                 '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define boundary face to be considered (only needed for calculation   
!  of boundary face area for second type boundary conditions)           
                                                                        
        if (btypezn.eq.'second') then 
                                                                        
          found = .false. 
          xy_plane = .false. 
          xz_plane = .false. 
          yz_plane = .false. 
                                                                        
                                                  !xy_plane             
          if (dabs(zbmax-zbmin).lt.tiny) then 
            if ((dabs(xbmax-xbmin).lt.tiny).or.                         &
     &          (dabs(ybmax-ybmin).lt.tiny)) then  
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED' 
                write(ilog,*) 'error in input file' 
                write(ilog,*) 'section "', section_header(:l_string),'"' 
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            else 
              xy_plane = .true. 
              found = .true. 
            end if 
          end if 
                                                                        
                                                   !xz_plane            
          if (.not.found) then 
            if (dabs(ybmax-ybmin).lt.tiny) then 
              if ((dabs(xbmax-xbmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "', section_header(:l_string),'"' 
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face' 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                xz_plane = .true. 
                if (xy_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                            &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
                                                   !yz_plane            
          if (.not.found) then 
            if (dabs(xbmax-xbmin).lt.tiny) then 
              if ((dabs(ybmax-ybmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then 
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "',section_header(:l_string),'"' 
                  write(ilog,*) 'zone "',zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                yz_plane = .true. 
                if (xy_plane.or.xz_plane) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                            &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
!  exit if boundary face was not found                                  
                                                                        
          if (.not.found) then
            if (rank == 0) then  
              write(ilog,*) 'SIMULATION TERMINATED' 
              write(ilog,*) 'error in input file' 
              write(ilog,*) 'section "', section_header(:l_string),'"' 
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
              write(ilog,*) 'unable to specify boundary face'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
          end if 
                                                                        
                                  !(btypezn.eq.'second')                
        end if 
                                                                        
!  increment boundary coordinates                                       
                                                                        
        factiny=dabs(xbmax-xbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        xbmin = xbmin-factiny 
        xbmax = xbmax+factiny 
        factiny=dabs(ybmax-ybmin)*tiny 
        if (factiny==r0) factiny=tiny 
        ybmin = ybmin-factiny 
        ybmax = ybmax+factiny 
        factiny=dabs(zbmax-zbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        zbmin = zbmin-factiny 
        zbmax = zbmax+factiny 
                                                                        
!  store type of boundary condition and boundary condition              
!  for global system in compressed storage                              
                                                                        
        do ivol = 1,nngl 
                                                                        
!  check limits of boundary zone                                        
                                                                        
          if ((xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)) then 
            if ((yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)) then 
              if ((zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) then 
                                                                        
!  assign boundary type and boundary condition                          
                                                                        
                nbvs = nbvs+1 
                                                                        
!  exit if nbvs > nn                                                    
                                                                        
                if (nbvs.gt.nngl) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'nbvs > nn ...' 
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                                                                        
!  assign pointer and                                                   
                                                                        
                iabvs(nbvs) = ivol 
                btypevs(nbvs) = btypezn 
                
                ivol2bvs(ivol) = nbvs
                                                                        
!  first type boundary condition - constant pressure head               
                                                                        
                if (btypevs(nbvs).eq.'first') then 
                                                                        
                  if (pressure_head) then 
                    hhead(ivol) = bcond + zg(ivol) 
                    bcondvs(nbvs) = bcond 
                  elseif (hydraulic_head) then 
                    hhead(ivol) = bcond 
                    bcondvs(nbvs) = bcond - zg(ivol) 
                  end if 
                  
!#ifdef DEBUG
!                  if(ivol == 14) then
!                      write(idbg,*) "-->initbcvs A hhead(ivol)", hhead(ivol)
!                  end if
!#endif
                                                                        
                  if (fully_saturated) then 
                    uvsnew(ivol) = hhead(ivol) 
                    uvsold(ivol) = hhead(ivol) 
                  elseif (variably_saturated) then 
                    uvsnew(ivol) = hhead(ivol)-zg(ivol) 
                    uvsold(ivol) = hhead(ivol)-zg(ivol) 
                  end if 
                                                                        
!  second type boundary condition - specified flux                      
                                                                        
                elseif (btypezn.eq.'second') then 
                                                                        
!  calculate flux area                                                  
                                                                        
                  if (xy_plane) then 
                    areaf = dimcv(1,ivol) * dimcv(2,ivol) 
                  elseif (xz_plane) then 
                    areaf = dimcv(1,ivol) * dimcv(3,ivol) 
                  elseif (yz_plane) then 
                    areaf = dimcv(2,ivol) * dimcv(3,ivol) 
                  end if 
                                                                        
!  assign second type boundary condition                                
                                                                        
                  bcondvs(nbvs) = areaf*bcond 
                                                                        
                                                                        
                elseif (btypezn.eq.'point') then 
                  bcondvs(nbvs) = bcond 
                                                                        
!  seepage boundary condition - zero pressure or zero flux              
                                                                        
                elseif (btypezn.eq.'seepage') then 
                                                                        
                                                !initialize seepage face
                  seepage_face = .true. 
                                                                        
                                                !assign first type b.c  
                  if (zg(ivol).lt.bcond) then 
                    uvsnew(ivol) = r0 
                    uvsold(ivol) = r0 
                    hhead(ivol) = r0 + zg(ivol) 
                                                !identify zero pressure 
                    bcondvs(nbvs) = -r1 
                  else 
                                                !identify zero-flux     
                    bcondvs(nbvs) = r1 
                  end if 
                  
!#ifdef DEBUG
!                  if(ivol == 14) then
!                      write(idbg,*) "-->initbcvs B hhead(ivol)", hhead(ivol)
!                  end if
!#endif
                                                                        
                       !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.  
                end if 
                       ! btypezn.eq.'seepage')                          
                       !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)     
              end if 
                       !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)     
            end if 
                       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)     
          end if 
                       !loop over control volumes                       
        end do 
                                                                        
!  write header for boundary zone to generic output file                
        if (b_enable_output .and. b_enable_output_gen) then   
            
        write(igen,'(/a,i1,a,1x,a)') 'zone ',ibz,':',zone_name 
        write(igen,'(72a)')('-',i=1,72)
                                      
#ifdef PETSC
        if (btypezn.eq.'first') then 
          if (pressure_head) then 
            write(igen,'(3(a,3x),a/)') 'local volume',                 &
                  'global volume', 'boundary type','pressure head'                
          elseif (hydraulic_head) then 
            write(igen,'(3(a,3x),a/)') 'local volume',                 &
                  'global volume', 'boundary type','hydraulic head'               
          end if 
        elseif (btypezn.eq.'second') then 
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','specified flux'                 
        elseif (btypezn.eq.'seepage') then 
          write(igen,'(3(a,3x),a/)') 'local volume',                   &
                  'global volume', 'boundary type','initial guess'                  
        end if 
#else
        if (btypezn.eq.'first') then 
          if (pressure_head) then 
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',      &
     &                                   'pressure head'                
          elseif (hydraulic_head) then 
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',      &
     &                                   'hydraulic head'               
          end if 
        elseif (btypezn.eq.'second') then 
          write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',        &
     &                                 'specified flux'                 
        elseif (btypezn.eq.'seepage') then 
          write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',        &
     &                                 'initial guess'                  
        end if 
#endif
        end if
                                                                        
!  write boundary condition for zone to generic output file             
                                                                        
                                               !first and second type   
        if (btypezn.ne.'seepage') then
          if (b_enable_output .and. b_enable_output_gen) then       
          do ibvs=nbvsp,nbvs 
            ivol = iabvs(ibvs) 
#ifdef PETSC
            write(igen,'(i10,5x,i10,6x,a12,1pe13.3)') ivol,            &
                  node_idx_lg2g(ivol),btypevs(ibvs),bcondvs(ibvs)
#else
            write(igen,'(i6,3x,a12,1pe13.3)') ivol,btypevs(ibvs),      &
     &                                             bcondvs(ibvs)
#endif
          end do 
          end if
                                               !seepage face            
        else 
          do ibvs=nbvsp,nbvs 
            ivol = iabvs(ibvs) 
            if (bcondvs(ibvs).lt.r0) then 
              if (b_enable_output .and. b_enable_output_gen) then  
#ifdef PETSC
              write(igen,'(i10,5x,i10,6x,a12,4x,a)') ivol,             &
                    node_idx_lg2g(ivol),btypevs(ibvs),'zero pressure'
#else
              write(igen,'(i6,3x,a12,4x,a)') ivol,btypevs(ibvs),       &
     &                                       'zero pressure'  
#endif
              end if
              nseep_first = nseep_first + 1 
                                                                        
            else
              if (b_enable_output .and. b_enable_output_gen) then  
#ifdef PETSC
              write(igen,'(i10,5x,i10,6x,a12,4x,a)') ivol,             &
                    node_idx_lg2g(ivol),btypevs(ibvs),'zero flux'
#else
              write(igen,'(i6,3x,a12,4x,a)') ivol,btypevs(ibvs),        &
     &                                       'zero flux' 
#endif
              end if  
            end if 
          end do 
        end if 
                                                                        
!  conversion of time units for computation in days                     
!  if second type boundary condition is specified                       
                                                                        
        if ((btypezn.eq.'second') .or.                                  &
     &      (btypezn.eq.'point')) then                                     
          do ibvs=nbvsp,nbvs 
            bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days 
          end do 
        end if 
                                                                        
                        !end loop over zones                            
      end do 
                                                                        
!  define if boundary conditions are to updated

      section_header = 'transient boundary conditions'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (found_section) then
        update_bcvs = .true.
      end if

!c  open file containing boundary conditions for variably saturated flow
!c  and read first read time

      if (update_bcvs) then

        !ibcvs = 15
        ibcvs = lun_get()
        open(ibcvs,file=prefix(:l_prfx)//'.bcvs',err=997, status='old')
        read(ibcvs,*,err=998,end=998) time_bcvs
             
      end if
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
      update_ext_type_bcvs=.false. 
      section_header = 'update extension and type boundary conditions'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (found_section) then
        update_ext_type_bcvs = .true.
      end if



      if (update_ext_type_bcvs) then
       
       !ibcvs1 = 17
       ibcvs1 = lun_get()

       open(ibcvs1,file=prefix(:l_prfx)//'.bcvs1',err=997, status='old')
             
      end if
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
       
!c  minimize memory requirement for boundary arrays

!c  array bcondvs

      allocate (rwork(nbvs,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ibvs = 1,nbvs
        rwork(ibvs,1) = bcondvs(ibvs)
      end do

      deallocate (bcondvs, stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)

      allocate (bcondvs(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)

      do ibvs = 1,nbvs
        bcondvs(ibvs) = rwork(ibvs,1)
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array iabvs

      allocate (iwork(nbvs), stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      do ibvs = 1,nbvs
        iwork(ibvs) = iabvs(ibvs)
      end do

      deallocate (iabvs, stat = ierr)
      call checkerr(ierr,'iabvs',ilog)

      allocate (iabvs(nbvs), stat = ierr)
      call checkerr(ierr,'iabvs',ilog)

      do ibvs = 1,nbvs
        iabvs(ibvs) = iwork(ibvs)
      end do

      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      
      !Check if the boundary condition is valid
      !allocate(bvalid_iabvs(nbvs), stat = ierr)
      !call checkerr(ierr,'bvalid_iabvs',ilog)
      !bvalid_iabvs = .true.
      !do ibvs = 1,nbvs
      !    do ibvs2 = ibvs +1, nbvs
      !        if(iabvs(ibvs) == iabvs(ibvs2)) then
      !            bvalid_iabvs(ibvs) = .false.
      !            exit
      !        end if
      !    end do
      !end do

      goto 1000

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'file ', prefix(:l_prfx)//'.bcvs missing'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
