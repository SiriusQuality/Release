!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initbcdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initbcdd
!c -------------------
!c
!c boundary conditions (variably saturated density dependent flow) 
!c
!c first type boundary conditions: 
!c -> define zone by delineating nodes located within zone
!c
!c second type boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c seepage face boundary condition:
!c -> define area (only on surface of solution domain)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - August 21, 2002
!c
!c last modified:   Tom Henderson - March 24, 2004
!c 
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           bcondvs(nbvs)      = boundary condition                  * +
!c                                (pressure head or flux) or
!c                                identification of seepage face
!c                                boundary type
!c           dimcv(3,nn)        = spatial dimensions of control       + -
!c                                volumes
!c           rwork(:,:)         = real*8 work array                   * *
!c           time_bcvs          = next read time for flow boundary    * +
!c                                conditions
!c           uvsold(nn)         = solution vector (old time level)    + +
!c           uvsnew(nn)         = solution vector (new time level)    + +
!c           sec_per_days       = conversion factor from SI input     + -
!c                                units for physico-chemical 
!c                                parameters internal time units
!c
!c           integer*4:
!c           ----------
!c           ibcvs              = unit number, transient boundary     * +
!c                                             conditions, variably
!c                                             saturated flow
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           iabvs(nbvs)        = pointer to boundary control volumes * +
!c                                for variably saturated flow
!c           iwork(:)           = integer work array                  * *
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 * +
!c           nn                 = total number of control volumes     + -
!c           nbvs               = number of specified boundary        * +
!c                                control volumes
!c                                (variably saturated flow)
!c           nseep_first        = number of seepage face nodes        * +
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           update_bcvs        = .true.  -> transient boundary       * +
!c                                           condition for variably 
!c                                           saturated flow
!c           variably_saturated = .true.  -> .not.fully_saturated,    + -
!c                                        -> variably saturated
!c                                           conditions 
!c           hydraulic_head     = .true.  -> initial condition in     + -
!c                                           terms of hydraulic head
!c           pressure_head      = .true.  -> initial condition in     + -
!c                                           terms of pressure heada
!c           seepage_face       = .true.  -> seepage face boundary    * +
!c                                           specified
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files       + -
!c           zone_name          = name of zone                        * +
!c           btypevs(nbvs)      = boundary type array                 * +
!c                                (variably saturated flow)
!c                                'first'   = Dirichlet
!c                                'second'  = Neumann
!c                                'seepage' = seepage face
!c           section_header     = section header                      * +
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure
!c           density(nn)        = fluid density 
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures
!c           logical:
!c           --------
!c           fluid_pressure     = .true.  -> initial and boundary
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           flow_verification  = .true.  -> verify pressure formulation
!c                                           for constant density 
!c                                           test problem
!c           fresh_head         = .true.  -> initial and boundary
!c                                           conditions in terms 
!c                                           of freshwater head 
!c local:    real*8:
!c           -------
!c           r0                 = constant
!c           r1                 = constant
!c           tiny               = small increment
!c           xbmin              = min. x-coordinate of boundary
!c                                zone
!c           xbmax              = max. x-coordinate of boundary
!c                                zone
!c           ybmin              = min. y-coordinate of boundary
!c                                zone
!c           ybmax              = max. y-coordinate of boundary
!c                                zone
!c           zbmin              = min. z-coordinate of boundary
!c                                zone
!c           zbmax              = max. z-coordinate of boundary
!c                                zone
!c
!c           integer*4:
!c           ----------
!c           ibvs               = counter (boundary control volumes)
!c           ibz                = counter (zones)
!c           ierr               = 0 -> memory allocation successful
!c           ivol               = counter (control volumes)
!c           istart             = pointer (control volume)
!c           iend               = pointer (control volume)
!c           l_string           = length of text string
!c           nbvsp              = start of boundary zone 
!c                                (temporary)
!c           nbz                = number of boundary zones
!c
!c           logical:
!c           --------
!c           found              = logical variable to exit search 
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c           xy_plane           = boundary zone parallel tp xy-plane
!c           xz_plane           = boundary zone parallel to xz-plane
!c           yz_plane           = boundary zone parallel to yz-plane
!c
!c           character:
!c           ----------
!c           bcond              = btypevs = 'first' 
!c                                -> hydraulic head
!c                                btypevs = 'second' 
!c                                -> specified flux
!c                                btypevs = 'seepage' 
!c                                -> initial seepage face heigth
!c           btypezn            = boundary type of zone        
!c           subsection         = name of subsection in input file
!c
!c external: checkerr  = check for error during memory allocation
!c           findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine initbcdd
 
      use parm
      use gen
      use dens
      use file_unit, only : lun_get
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, ibz, ibvs, ibrt, ierr, ivol, l_string, nbz, nbvsp
      real*8 :: h0_grad, slope_grad, bcond, xbmin, xbmax,              &
                ybmin, ybmax, zbmin, zbmax, pos_grad, areaf

      external checkerr, findstrg, findzone, readbloc, readzone

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, tiny = 1.d-5

      logical xy_plane,xz_plane,yz_plane,found,found_section,     &
     &        found_subsection 
      character*12 btypezn
      character*72 subsection,dir_grad
      
      integer :: ntemp

      pos_grad = r0
      areaf = r0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
      
!cprovi-------------------------------------------------------------------
!cprovi Set initial values for density-driven gradient 
!cprovi-------------------------------------------------------------------
      h0_grad=r0
      slope_grad=r1
      dir_grad='z'      

!c  define defaults

      if(rank == 0 .and. b_enable_output) then
        write(*,*) 'boundary conditions - ',                           &
     &             'variably saturated density dependent flow'
        write(*,*) ('-',i=1,72)

        write(ilog,'(2a)') 'boundary conditions - ',                   &
     &                     'variably saturated density dependent flow'
        write(ilog,'(72a/)')('-',i=1,72)
      end if

!c  read section header for boundary conditions of density dependent
!c  flow simulation
   
      section_header = 'boundary conditions - variably saturated flow'
      call readbloc (idat,itmp,section_header,found_section,.true.)
 
!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  write section header to generic output file  
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
      end if

!c  initialize variables for seepage face iteration

      seepage_face = .false.
      nseep_first = 0

!c  preliminary allocation of memory for boundary conditions

      allocate (bcondvs(nngl), stat = ierr)
      bcondvs=0.0d0 
      call checkerr(ierr,'bcondvs',ilog)

      allocate (iabvs(nngl), stat = ierr)
      iabvs=0 
      call checkerr(ierr,'iabvs',ilog)

      allocate (btypevs(nngl), stat = ierr)
      btypevs=' '
      call checkerr(ierr,'btypevs',ilog)      
      
      allocate (ivol2bvs(nngl), stat = ierr)
      ivol2bvs=0 
      call checkerr(ierr,'ivol2bvs',ilog)

!c  read number of boundary zones
 
      read(itmp,*,err=999,end=999) nbz
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                       &
     &  'number of boundary zones                        = ',nbz
      end if

!c  initialize pointer array for storage of boundary conditions

      nbvs = 0
      iabvs(1) = 1
      
      ivol2bvs(:) = 0

!c  read name of zone

      do ibz=1,nbz                !loop over number of zones

        nbvsp = nbvs+1            !temporary pointer for output

!c  find current zone in input file and write to temporary file

        subsection = 'number and name of zone'

        call findzone(subsection,itmp,found_subsection,ibz,zone_name)

        if (found_subsection) then

          call readzone(itmp,icnv,ilog,zone_name,found_subsection)

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error in input file'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define length of zone name

        l_zone_name = index(zone_name,'  ')-1
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
          l_zone_name = 72
        end if
 
 
!c  define type and value of boundary condition

        subsection = 'boundary type'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          read(icnv,*,err=999,end=999) btypezn, bcond
          if (btypezn=='gradient') then
             read(icnv,*,err=999,end=999) dir_grad
             read(icnv,*,err=999,end=999) h0_grad
             read(icnv,*,err=999,end=999) slope_grad
             if (dir_grad/='x'.and.   &
     &           dir_grad/='y'.and.   &
     &           dir_grad/='z') then 
               if (rank == 0) then  
                 write(ilog,*) 'SIMULATION TERMINATED'
                 write(ilog,*) 'error in input file'
                 write(ilog,*) 'section "',section_header(:l_string),'"'
                 write(ilog,*) 'Error in gradient direction'
                 close(ilog)
               end if
#ifdef PETSC
               call petsc_mpi_finalize
#endif
               stop
             end if
          end if

        else
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',section_header(:l_string),'"'
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
            l_string = index(subsection,'  ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
               l_string=72
            end if
            write(ilog,*) 'subsection "',subsection(:l_string), &
     &                    '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  read coordiantes defining boundary zone, 

        subsection = 'extent of zone'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,   &
     &                                 zbmin,zbmax

        elseif (.not.found_subsection) then

          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "', section_header(:l_string),'"'
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
            l_string = index(subsection,'  ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
               l_string=72
            end if
            write(ilog,*) 'subsection "',subsection(:l_string),     &
     &                 '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define boundary face to be considered (only needed for calculation
!c  of boundary face area for second type boundary conditions) 

        if (btypezn.eq.'second'.or.                               &
     &     (btypezn.eq.'atmospheric'.and.evaporation)) then
   
          found = .false.
          xy_plane = .false.
          xz_plane = .false.
          yz_plane = .false.

          if (dabs(zbmax-zbmin).lt.tiny) then     !xy_plane
            if ((dabs(xbmax-xbmin).lt.tiny).or.                   &
     &          (dabs(ybmax-ybmin).lt.tiny)) then
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error in input file'
                write(ilog,*) 'section "', section_header(:l_string),'"'
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                write(ilog,*) 'unable to specify boundary face'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            else
              xy_plane = .true.
              found = .true.
            end if
          end if

          if (.not.found) then                     !xz_plane
            if (dabs(ybmax-ybmin).lt.tiny) then
              if ((dabs(xbmax-xbmin).lt.tiny).or.                 &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "', section_header(:l_string),'"'
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                xz_plane = .true.
                if (xy_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                      &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

          if (.not.found) then                     !yz_plane
            if (dabs(xbmax-xbmin).lt.tiny) then
              if ((dabs(ybmax-ybmin).lt.tiny).or.                 &
     &            (dabs(zbmax-zbmin).lt.tiny)) then
                if (rank == 0) then
                  write(ilog,*) 'SIMULATION TERMINATED'
                  write(ilog,*) 'error in input file'
                  write(ilog,*) 'section "',section_header(:l_string),'"'
                  write(ilog,*) 'zone "',zone_name(:l_zone_name),'"'
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              else
                yz_plane = .true.
                if (xy_plane.or.xz_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'error in input file'
                    write(ilog,*) 'section "',                      &
     &                             section_header(:l_string),'"'
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
                found = .true.
              end if
            end if
          end if

!c  exit if boundary face was not found 

          if (.not.found) then
            if (rank == 0) then  
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in input file'
              write(ilog,*) 'section "', section_header(:l_string),'"'
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
              write(ilog,*) 'unable to specify boundary face'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if

        end if                    !(btypezn.eq.'second')

!c  increment boundary coordinates

        xbmin = xbmin-tiny
        xbmax = xbmax+tiny
        ybmin = ybmin-tiny
        ybmax = ybmax+tiny
        zbmin = zbmin-tiny
        zbmax = zbmax+tiny

!c  store type of boundary condition and boundary condition
!c  for global system in compressed storage

        do ivol = 1,nngl

!c  check limits of boundary zone

          if ((xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)) then
            if ((yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)) then
              if ((zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) then

!c  assign boundary type and boundary condition

                nbvs = nbvs+1

!c  exit if nbvs > nn

                if (nbvs.gt.nngl) then
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED'
                    write(ilog,*) 'nbvs > nn ...'
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if

!c  assign pointer and 
!c
                iabvs(nbvs) = ivol
                btypevs(nbvs) = btypezn
                
                ivol2bvs(ivol) = nbvs

!c  first type boundary condition - constant head or fluid pressure 

                if (btypevs(nbvs).eq.'first') then
                  if (fluid_pressure) then
                  uvsnew(ivol) = bcond
                  
                  elseif (pressure_head) then                         
                    uvsnew(ivol) = bcond*density(ivol)*gacc

                  elseif (fresh_head) then
                  uvsnew(ivol) = (bcond - zg(ivol)) *   &
     &                                 gacc * ref_dens

                  elseif (hydraulic_head) then
                    uvsnew(ivol) = (bcond- zg(ivol)) *    &
     &                              gacc * density(ivol)

                  end if !fluid pressure

                  bcondvs(nbvs) = uvsnew(ivol)
                  uvsold(ivol) = uvsnew(ivol)


                  elseif (btypevs(nbvs).eq.'gradient')then
                    
                    select case(dir_grad)
                    case ('x')
                      pos_grad=xg(ivol) 
                    case ('y')
                      pos_grad=yg(ivol) 
                    case ('z')
                      pos_grad=zg(ivol) 
                    end select
                    
                    bcond=h0_grad + slope_grad*pos_grad
                    
                    if (fluid_pressure) then
                      uvsnew(ivol) = bcond
                    elseif (pressure_head) then                         
                        uvsnew(ivol) = bcond*density(ivol)*gacc
                    elseif (fresh_head) then
                      uvsnew(ivol) = (bcond - zg(ivol)) *   &
     &                                 gacc * ref_dens

                    elseif (hydraulic_head) then
                        uvsnew(ivol) = (bcond- zg(ivol)) *    &
     &                                  gacc * density(ivol)

                    end if !fluid pressure
                    bcondvs(nbvs) = uvsnew(ivol)
                    uvsold(ivol) = uvsnew(ivol)
                    btypevs(nbvs) = 'first' 

!c  second type boundary condition - specified flux
                  elseif (btypezn.eq.'second') then

!c  calculate flux area

                  if (xy_plane) then
                    areaf = dimcv(1,ivol) * dimcv(2,ivol)
                  elseif (xz_plane) then
                    areaf = dimcv(1,ivol) * dimcv(3,ivol)
                  elseif (yz_plane) then
                    areaf = dimcv(2,ivol) * dimcv(3,ivol)
                  end if

!c  assign second type boundary condition
!c  flux volume only - density stored in ssdens array calculated in 
!c  subroutine initbcrt.  Volume flux converted to mass flux in 
!c  jacbvs and jacbrt
!c

                  bcondvs(nbvs) = areaf * bcond

!c flow verification problem toggle
!c multiply flux volume by reference density

                  if (flow_verification) then
                  bcondvs(nbvs) = bcondvs(nbvs) * ref_dens
                end if
             
             elseif (btypezn.eq.'atmospheric') then

                  if (.not.evaporation) goto 999
!c  calculate flux area

                  if (xy_plane) then
                    areaf = dimcv(1,ivol) * dimcv(2,ivol)
                  elseif (xz_plane) then
                    areaf = dimcv(1,ivol) * dimcv(3,ivol)
                  elseif (yz_plane) then
                    areaf = dimcv(2,ivol) * dimcv(3,ivol)
                  end if

!c  assign second type boundary condition
!c  flux volume only - density stored in ssdens array calculated in 
!c  subroutine initbcrt.  Volume flux converted to mass flux in 
!c  jacbvs and jacbrt
!c

                  bcondvs(nbvs) = areaf    

!c injection point: input units are cubic meters per second

                elseif (btypezn.eq.'point') then
                  
                  bcondvs(nbvs) = bcond                     

!c  seepage boundary condition - zero pressure or zero flux
!c  not converted yet to pressure pdv formulation!!
                

                elseif (btypezn.eq.'seepage') then

                  seepage_face = .true.         !initialize seepage face

                  if (zg(ivol).lt.bcond) then   !assign first type b.c
                    uvsnew(ivol) = r0
                    uvsold(ivol) = r0

                    bcondvs(nbvs) = -r1         !identify zero pressure
                  else
                    bcondvs(nbvs) = r1          !identify zero-flux
                  end if
                
                else if (btypezn.eq.'initial') then  
                  
                  btypevs(nbvs) = 'first'
                  
                  bcondvs(nbvs) = uvsnew(ivol)      
                
                end if !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.
                       ! btypezn.eq.'seepage')
              end if   !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
            end if     !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
          end if       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes

!c  write header for boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
            
        write(igen,'(/a,i1,a,1x,a)') 'zone ',ibz,':',zone_name
        write(igen,'(72a)')('-',i=1,72)

        if (btypezn.eq.'first') then
          if (fluid_pressure) then
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',    &
     &                                   'pressure'
          elseif (pressure_head) then
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',    &
     &                                   'pressure head'
          elseif (fresh_head) then
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',    &
     &                                   'freshwater head'
          elseif (hydraulic_head) then
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',    &
     &                                   'hydraulic head'
          end if
        elseif (btypezn.eq.'second') then
          write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',      &
     &                                 'specified mass flux'
        elseif (btypezn.eq.'seepage') then
          write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',      &
     &                                 'initial guess'
        end if
        
        end if

!c  write boundary condition for zone to generic output file

        if (btypezn.ne.'seepage') then         !first and second type
          if (b_enable_output .and. b_enable_output_gen) then   
          do ibvs=nbvsp,nbvs
            ivol = iabvs(ibvs)
            write(igen,'(i6,3x,a12,1pe13.3)') ivol,btypevs(ibvs),     &
     &                                             bcondvs(ibvs)
          end do
          end if 
        else                                   !seepage face
          do ibvs=nbvsp,nbvs
            ivol = iabvs(ibvs)
            if (bcondvs(ibvs).lt.r0) then
              if (b_enable_output .and. b_enable_output_gen) then   
              write(igen,'(i6,3x,a12,4x,a)') ivol,btypevs(ibvs),      &
     &                                       'zero pressure'
              end if 
              nseep_first = nseep_first + 1  
                                             
            else
              if (b_enable_output .and. b_enable_output_gen) then  
              write(igen,'(i6,3x,a12,4x,a)') ivol,btypevs(ibvs),      &
     &                                       'zero flux'
              end if
            end if
          end do
        end if

!c  conversion of time units for computation in days
!c  if second type boundary condition is specified

        if ((btypezn.eq.'second') .or.        &
     &      (btypezn.eq.'point')) then
          do ibvs=nbvsp,nbvs
            bcondvs(ibvs) = bcondvs(ibvs)*sec_per_days
          end do
        end if

      end do            !end loop over zones

!c  define if boundary conditions are to updated
      update_bcvs=.false. 
      section_header = 'transient boundary conditions'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (found_section) then
        update_bcvs = .true.
      end if

!c  open file containing boundary conditions for variably saturated flow
!c  and read first read time

      if (update_bcvs) then

        !ibcvs = 15
        ibcvs = lun_get()
        open(ibcvs,file=prefix(:l_prfx)//'.bcvs',err=997, status='old')
        read(ibcvs,*,err=998,end=998) time_bcvs
             
      end if
      
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
      update_ext_type_bcvs=.false. 
      section_header = 'update extension and type boundary conditions'
      call readbloc (idat,itmp,section_header,found_section,.true.)

      if (found_section) then
        update_ext_type_bcvs = .true.
      end if



      if (update_ext_type_bcvs) then
       
       !ibcvs1 = 17
       ibcvs1 = lun_get()

       open(ibcvs1,file=prefix(:l_prfx)//'.bcvs1',err=997, status='old')
             
      end if
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
!cprovi--------------------------------------------------------------------      
       
!c  minimize memory requirement for boundary arrays

!c  array bcondvs

      allocate (rwork(nbvs,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ibvs = 1,nbvs
        rwork(ibvs,1) = bcondvs(ibvs)
      end do

      deallocate (bcondvs, stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)

      allocate (bcondvs(nbvs), stat = ierr)
      call checkerr(ierr,'bcondvs',ilog)

      do ibvs = 1,nbvs
        bcondvs(ibvs) = rwork(ibvs,1)
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array iabvs

      allocate (iwork(nbvs), stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      do ibvs = 1,nbvs
        iwork(ibvs) = iabvs(ibvs)
      end do

      deallocate (iabvs, stat = ierr)
      call checkerr(ierr,'iabvs',ilog)

      allocate (iabvs(nbvs), stat = ierr)
      call checkerr(ierr,'iabvs',ilog)

      do ibvs = 1,nbvs
        iabvs(ibvs) = iwork(ibvs)
      end do

      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      
      !Check if the boundary condition is valid
      !allocate(bvalid_iabvs(nbvs), stat = ierr)
      !call checkerr(ierr,'bvalid_iabvs',ilog)
      !bvalid_iabvs = .true.
      !do ibvs = 1,nbvs
      !    do ibvs2 = ibvs +1, nbvs
      !        if(iabvs(ibvs) == iabvs(ibvs2)) then
      !            bvalid_iabvs(ibvs) = .false.
      !            exit
      !        end if
      !    end do
      !end do
      
!cprovi-----------------------------------------------------------------------
!cprovi Store the initial boundary conditions values
!cprovi When ice sheet loading is computed, boundary
!cprovi conditions for flow are transient. However, we
!cprovi restart the initial values startyin the new
!cprovi time step 
!cprovi Idem for transport boundary conditions 
!cprovi-----------------------------------------------------------------------      
      if (compute_ice_sheet_loading) then 
         nbvs0=nbvs
         nbrt0=nbrt
         allocate (bcondvs0(nbvs0), stat = ierr)
         call checkerr(ierr,'bcondvs0',ilog)
         
         allocate (iabvs0(nbvs0), stat = ierr)
         call checkerr(ierr,'iabvs0',ilog)
         
         allocate (jabrt0(nbrt0), stat = ierr)
         call checkerr(ierr,'jabrt0',ilog)
         
         do ibvs = 1,nbvs0
           iabvs0(ibvs) = iabvs(ibvs)
           bcondvs0(ibvs) = bcondvs(ibvs)
         end do
         do ibrt = 1,nbrt0
           jabrt0(ibrt) = jabrt(ibrt)
         end do
         
         ntemp = max(nbvs, nbrt)
         allocate (valuebc(ntemp), stat = ierr)
         valuebc = 0.0d0
         call checkerr(ierr,'valuebc',ilog)
         
         allocate (iwork_bc(ntemp), stat = ierr)
         iwork_bc = 0
         call checkerr(ierr,'iwork_bc',ilog)
         
         allocate (rwork_bc(ntemp), stat = ierr)
         rwork_bc = 0.0d0
         call checkerr(ierr,'rwork_bc',ilog)
         
      end if
!cprovi-----------------------------------------------------------------------
!cprovi Store the 
!cprovi-----------------------------------------------------------------------      
      goto 1000

997   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'file ', prefix(:l_prfx)//'.bcvs missing'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

998   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
