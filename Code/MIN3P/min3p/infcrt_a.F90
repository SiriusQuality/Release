!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/infcrt_a.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine infcrt_a
!c -------------------
!c
!c compute influence coefficients for advective and dispersive flux 
!c terms for rectangular, cartesian finite volume discretization 
!c (reactive transport) for aqueous phase
!c
!c written by:      Uli Mayer - August 15, 96
!c
!c last modified:   Uli Mayer - November 20, 96
!c                  Sergi Molins - Feb 18, 2007
!c                  added correction for tortuosity when oil present
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c     input:
!c
!c passed:   real*8:
!c           -------
!c           d(3, ibk)          = dimension of cells in x,y,z         + -
!c                                direction
!c           diffu              = phase molecular diffusion (m2/day)
!c           disx(nzn)          = dispersion, x direction (m)
!c           disy(nzn)          =    "      , y    "      (m)
!c           disz(nzn)          =    "      , z    "      (m)
!c           cinfrt_va()        = influence coefficients 
!c                                J^w_ij/A_ij
!c                                (advective flux terms)
!c           cinfrt_da()        = influence coefficients
!c                                D_ij * A_ij / d_ij  
!c                                (dispersvie flux terms)
!c
!c           integer*4:
!c           ----------
!c           ibk                = block i
!c           id                 = connected block j
!c           idbg               = output for debugging information
!c           ilog               = unit number, logbook
!c           nmax               = max cells for dim purposes
!c           nphas              = max number of phases
!c           njamxc             = max dim ja array (ncomp.com)
!c           nvx                = number of control volumes 
!c                                in x direction
!c           nvy                = number of control volumes 
!c                                in y direction
!c           nvz                = number of control volumes 
!c                                in z direction
!c           pornew(ibk)        = porosity
!c           sanew(nmax)        = aqueous phase saturation
!c                                - new time level
!c           hhead(nmax)        = hydraulic head
!c           uvsnew(nmax)       = hydraulic pressure
!c           relperm(nmax)      = rel permeability
!c           cinfvs(nmax)       = influence coefficient 
!c                                (variably saturated flow) 
!c           ia(), ja()         = ysmp pointers
!c           isymm(ii)          = symmetry pointer for cell ibk
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions
!c           variably_saturated = .true.  -> .not.fully_saturated,
!c                                        -> variably saturated
!c                                           conditions
!c           half_cells         = .true.  -> half cells on boundary
!c           tortuosity_corr    = .true.  -> Millington-Quirk 
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c multidiff.f90
!c           logical:
!c           --------
!c         multi_diff = .true. -> multicomponent diffusion (MCD)
!c local:
!c
!c external: diffcoff  = compute effective diffusion coefficient
!c           fluxfs    = flux function for fully saturated flow 
!c           fluxvs    = flux function for variably saturated flow
!c --------------------------------------------------------------------------

      subroutine infcrt_a (nvxgls, nvxgle, nvxgbl,                &
                         nvygls, nvygle, nvygbl,                  &
                         nvzgls, nvzgle, nvzgbl,                  &
                         nvx, nvy, nvz, ia, ja, isymm,            &
                         cinfvs, cinfrt_va, cinfrt_da, d,         &
                         mprop, nzn, diffu, disx, disy, disz,     &
                         pornew, sanew, uvsnew, hhead, relperm,   & 
                         idbg, ilog, upstream, fully_saturated,   &
                         variably_saturated, njamxc, nmax,        &
                         tortuosity_corr,half_cells,cinfrt_da_ic, &
                         diff_coff, nc, diff_ic,assigned_tau,     &
                         tau,type_tortuosity,marchies,cinfrad,    &
                         radial_coord, multi_diff, tau_fac,       &
                         harmonic_porosity, delx,dely,delz,       &
                         type_averaging_De, xg,                   &
                         sonew,oil_saturation)
#ifdef OPENMP      
      use omp_lib 
      use gen, only : rank, b_enable_output,                      &
                      numofthreads_global,                        &
                      numofloops_thred_global,                    &
                      numofloops_thred_infcrt_a_1,                &
                      numofloops_thred_infcrt_a_2,                &
                      numofloops_thred_infcrt_a_3
#else
     use gen, only : rank, b_enable_output
#endif   
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: ic, ivol, ivxp, ivxn, ivyp, ivyn, ivzp, ivzn, jvol,   &
                 jzn, jtemp, nmax, njamxc, info_debug
      real*8 :: diff_eff1, diff_eff2

      external diffcoff, fluxfs, fluxvs

      integer nvxgls, nvxgle, nvxgbl, nvygls, nvygle, nvygbl,       &
              nvzgls, nvzgle, nvzgbl, ivxgbl, ivygbl, ivzgbl,       &
              ivxpgbl, ivypgbl, ivzpgbl, ivxngbl, ivyngbl, ivzngbl, & 
              nvx, nvy, nvz, ia(nmax+1), ja(njamxc),                &
              isymm(njamxc), idbg, ilog, nzn, mprop(*), nc

      logical half_cells, fully_saturated, variably_saturated,    &
             upstream, tortuosity_corr,diff_coff,assigned_tau,    &
             radial_coord, multi_diff, harmonic_porosity,         &
             oil_saturation
      
      character(len=30)       type_averaging_De

      real*8  diffu, disx(nzn), disy(nzn), disz(nzn),             &
             pornew(nmax), uvsnew(nmax), hhead(nmax),             &
             relperm(nmax),sanew(nmax), d(3,nmax),                &
             cinfvs(njamxc), cinfrt_va(njamxc),                   &
             cinfrt_da(njamxc),cinfrt_da_ic(njamxc,nc),           &
             diff_ic(nc),tau(nmax),cinfrad(njamxc),               &
             tau_fac(nmax), marchies(nmax), sonew(nmax)

      real*8 diffcoff,fluxfs,fluxvs
      real*8  delx(nvx),dely(nvy),delz(nvz), xg(nvx)
      
      character(len=*) type_tortuosity

!c     local variables

      real*8 r0, rhalf, r1, r2, eps, pi
      parameter (eps = 1.0d-300, r0 = 0.0d0, rhalf = 0.5d0,       & 
                r1 = 1.0d0, r2 = 2.0d0,pi = 3.141592653589790E+00)

      real*8 aread(3,12),areax(3,12),vel(3),dist(3,12),           &
            porav, satav, vx2, vy2, vz2, vmag,                    &
            tend(3), areai,                                       &
            diffav, diff_eff,disx_avg, disy_avg,                  &
            disz_avg, dflux,tauav, marchieav, so_av

!cmx    changed: Mar. 13, added for harmonic averaging
      real*8 diff_i,diff_j,diff_ij,areaf,                             &
           por_i,por_j,delx_i,dely_i,delz_i,delx_j,dely_j,delz_j,     &
           tau_i, tau_j
      integer ibk, ivz, ivy, ivx, ibkz, ibky,                     &
             ii, id, ixx, iyy, izz, iisav,                        &
             idim, npair(3), iface(3,12), ndim,                   &
             fvpair(3,12,2), ipair, idim2, idim3, irk_ibk, irk_id

      character*1 iups
      real*8 por1, por2
#ifdef OPENMP      
      integer :: nvols
#endif

      delx_i = r0
      delx_j = r0
      dely_i = r0
      dely_j = r0
      delz_i = r0
      delz_j = r0
      dflux = r0
      iisav = 0

!c  compute influence coefficients for advective flux terms
!c  (influence coefficients are equal Darcy flux = J_ij/A_ij)

!c  loop over control volumes
      ivol=0
      tau_i = r1
      tau_j = r1
#ifdef OPENMP      
      nvols = nvx * nvy * nvz
#endif
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrt_a_1)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ibky, ibkz, id, idim, idim2, idim3, ii,       &
    !$omp iisav, ivx, iups, ivy, ivz, ixx, iyy, izz)                  
    !$omp do schedule(static)
#endif
      do ivz = 1,nvz                !increments in z-direction
        ibkz = (ivz-1)*nvx*nvy

        do ivy = 1,nvy              !increments in y-direction
          ibky = (ivy-1)*nvx

          do ivx = 1,nvx            !increments in x-direction 
            ibk = ibkz+ibky+ivx

!c  loop over three -ve faces

            do idim = 1,3           !loop over dimensions
              ixx = ivx
              iyy = ivy
              izz = ivz

!c  compute in -tive face direction only

              if (idim.eq.1) then           !in x-direction
                ixx = ixx-1
                id = ibk-1
                idim2 = 2
                idim3 = 3
              elseif (idim.eq.2) then       !in y-direction
                iyy = iyy-1
                id = ibk-nvx
                idim2 = 3
                idim3 = 1
              elseif (idim.eq.3) then       !in z-direction
                izz = izz-1
                id = ibk-nvx*nvy
                idim2 = 1
                idim3 = 2
              endif

!c  skip if edge

              if (ixx.le.0 .or. iyy.le.0 .or. izz.le.0) cycle

!c  find -ve face in row of connected cells to ibk

              do ii = ia(ibk),ia(ibk+1)-1
                if (ja(ii).eq.id) then
                  iisav = ii
                  go to 211
                endif
              end do
              
              if (rank == 0 .and. b_enable_output) then
                write(ilog,*) ' error-cannot find id in list-infcrt_a 1'
                write(ilog,*) ' ibk, id ', ibk, id
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
211           continue


!c  find darcy flux between node pair
#ifdef OPENMP
    !$omp critical
#endif 
              if (variably_saturated) then
                if (upstream) then
                  iups = 'i'                          !h_i >= h_j
                  if (hhead(id).gt.hhead(ibk)) then   !h_j > h_i
                    iups = 'j'
                  end if
!#ifdef DEBUG
!                if(iisav == 38 .or. isymm(iisav) == 38) then
!                    write(idbg,'(2(a,1x,e,1x),a,1x,l1)')               &
!                        "hhead(id)",hhead(id),"hhead(ibk)",hhead(ibk), &
!                        "(hhead(id).gt.hhead(ibk))",                   &
!                        (hhead(id).gt.hhead(ibk))
!                end if
!#endif
                end if

                cinfrt_va(iisav) = - fluxvs(upstream,hhead(ibk),      &
                                           hhead(id),relperm(ibk),    &
                                           relperm(id),iups,          &
                                           cinfvs(ii))
!#ifdef DEBUG
!                if(iisav == 38 .or. isymm(iisav) == 38) then
!                    write(idbg,'(4(a,1x,i,1x),2(a,1x),a,1x,l1,1x,5(a,1x,e20.12,1x))') &
!                    "iisav",iisav,"ibk",ibk,"id",id,"ii",ii,"iups",iups,              &
!                    "upstream",upstream,"hhead(ibk)",hhead(ibk),"hhead(id)",hhead(id),&
!                    "relperm(ibk)",relperm(ibk),"cinfvs(ii)",cinfvs(ii),              &
!                    "cinfrt_va(iisav)",cinfrt_va(iisav)
!                end if
!#endif

              elseif (fully_saturated) then

                cinfrt_va(iisav) = - fluxfs(uvsnew(ibk),uvsnew(id),   &
                                           cinfvs(ii))
!#ifdef DEBUG
!                if(iisav == 38 .or. isymm(iisav) == 38) then
!                    write(idbg,'(4(a,1x,i,1x),4(a,1x,e20.12,1x))')     &
!                    "iisav",iisav,"ibk",ibk,"id",id,"ii",ii,           &
!                    "uvsnew(ibk)",uvsnew(ibk),"uvsnew(id)",uvsnew(id), &
!                    "cinfvs(ii)",cinfvs(ii),"cinfrt_va(iisav)",        &
!                    cinfrt_va(iisav)
!                end if
!#endif
              end if

!c  matrix is symmetric n a symbolic sense, since cinfrt_va between 
!c  cell ibk and id is equal to - cinfrt_va between cells id and ibk
              cinfrt_va(isymm(iisav)) = - cinfrt_va(iisav)
#ifdef OPENMP
    !$omp end critical
#endif
            end do
          end do
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  compute the influence coefficients for dispersive flux terms
!c  loop over the number of "pseudo dispersion elements"

!c  zero the influence coefficient for dispersive flux term
!#ifdef OPENMP
!    !$omp parallel                                                    &
!    !$omp if (nvols > numofloops_thred_infcrt_a_2)                    &
!    !$omp num_threads(numofthreads_global)                            &
!    !$omp default(shared)                                             &
!    !$omp private (ibk, ii)                  
!    !$omp do schedule(static)
!#endif
!      do ibk = 1, nmax
!        do ii = ia(ibk),ia(ibk+1)-1
!          cinfrt_da(ii) = r0
!        end do
!      end do
!#ifdef OPENMP
!    !$omp end do
!    !$omp end parallel
!#endif 
      cinfrt_da(:) = r0
      cinfrt_da_ic(:,:) = r0

!c  loop over control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrt_a_3)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ic, id, idim, idim2, idim3, iface, ii,        &
    !$omp iisav, ipair, irk_ibk, irk_id, iups, ivol,                  &
    !$omp ivx, ivy, ivz, ivxp, ivxn, ivyp, ivyn, ivzp, ivzn,          &
    !$omp ivxgbl, ivygbl, ivzgbl, ivxpgbl, ivypgbl, ivzpgbl,          &
    !$omp ivxngbl, ivyngbl, ivzngbl,                                  &
    !$omp jtemp, jvol, jzn, ndim, npair,                              &
    !$omp areax, aread, areaf, areai, delx_i, delx_j, dely_i,         &
    !$omp dely_j, delz_i, delz_j, diffav, diff_eff,                   &
    !$omp diff_eff1, diff_eff2, diff_i, diff_ij, diff_j,              &
    !$omp dist, disx_avg, disy_avg, disz_avg, dflux, fvpair,          &
    !$omp marchieav, satav, tauav, por_i, por_j, por1, por2,          &
    !$omp porav, tau_i, tau_j, tend, vel, vmag, vx2, vy2, vz2,        &
    !$omp so_av)                                                      
    !$omp do schedule(static)
#endif
      do ivz = 1, nvz          !increments in z-direction
         ivzgbl = ivz+nvzgls-1 
         do ivy = 1, nvy       !increments in y-direction
            ivygbl = ivy+nvygls-1 
            do ivx = 1, nvx    !increments in x-direction                
              ivxgbl = ivx+nvxgls-1  
              
              so_av = r0

!c  find node pairs for elemental velocities as well
!c  as influence coefficient for node pairs within dipersion element

!               call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,
!     &                        fvpair, npair, aread, d, half_cells,
!     &                        nmax,idbg)
               call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,           &
                         fvpair, npair,aread,areax,dist,d, half_cells,&
                         ia, ja, njamxc,                              &
                         nmax,idbg,cinfrad,radial_coord)     

!c  check if fully connected "pseudo dispersion element"
!c  was found for dimensionality of problem

!CMX               if ((nvx .gt. 1 .and. npair(1) .eq. 0) .or.            &
!CMX                   (nvy .gt. 1 .and. npair(2) .eq. 0) .or.            &
!CMX                   (nvz .gt. 1 .and. npair(3) .eq. 0)) cycle

               if (((nvx .gt. 1 .and. npair(1) .eq. 0) .or.           &
                   (nvy .gt. 1 .and. npair(2) .eq. 0) .or.            &
                   (nvz .gt. 1 .and. npair(3) .eq. 0)) .and.          &
                   (type_averaging_De.ne.'harmonic' .or.              &
                   (.not.harmonic_porosity)) .and.                    &
                   ((type_averaging_De.eq.'arithmetic' .and.          &
                   (harmonic_porosity)) .or.                         &
                    type_averaging_De.eq.'  ')) cycle

 !c  pointers to previous colums in x,y and z

            ivxp = ivx-1
            ivxn = ivx+1
            ivyp = ivy-1
            ivyn = ivy+1
            ivzp = ivz-1
            ivzn = ivz+1
            
            ivxpgbl = ivxgbl-1
            ivxngbl = ivxgbl+1
            ivypgbl = ivygbl-1
            ivyngbl = ivygbl+1
            ivzpgbl = ivzgbl-1
            ivzngbl = ivzgbl+1            

!c              loop over the dimensions x,y,z

               do idim = 1, 3

                  idim2 = idim + 1
                  idim3 = idim + 2
                  if (idim2 .gt. 3) idim2 = idim2 - 3
                  if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero advective velocity

                  vel(idim) = r0

!c  loop over the number of node pairs in the dimension

                  do ipair = 1, npair(idim)

                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)

!c  calculate average interfacial area between nodes
!cprovi------------------------------------------------
!cprovi Assign the interfacial area
!cprovi------------------------------------------------                
                    areai = areax(idim, ipair)

                     do ii = ia(ibk), ia(ibk+1)-1
                        if (ja(ii) .eq. id) then
                           iisav = ii
                           go to 431
                        endif
                     end do
                     if (rank == 0 .and. b_enable_output) then
                       write(ilog,*) ' error-cannot find id in list-infcrt_a 2'
                       write(ilog,*) ' ibk, id ', ibk, id
                       close(ilog)
                     end if
#ifdef PETSC
                     call petsc_mpi_finalize
#endif
                     stop
431                  continue
                     iface(idim, ipair) = iisav

!c  find darcy flux between node pair

                     if (variably_saturated) then
                       if (upstream) then
                         iups = 'i'                            !h_i >= h_j
                         if (hhead(id).gt.hhead(ibk)) then     !h_j > h_i
                           iups = 'j'
                         end if
                       end if

                       dflux = - fluxvs(upstream,hhead(ibk),      &
                                       hhead(id),relperm(ibk),    &
                                       relperm(id),iups,          &
                                       cinfvs(iisav))
  
                     elseif (fully_saturated) then 

                       dflux = - fluxfs(uvsnew(ibk),uvsnew(id),   &
                                       cinfvs(iisav))
                     end if


!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two nodes

                     vel(idim) = vel(idim) + dflux / areai
                  end do

!c  find the average elemental velocity in the
!c  x,y,z directions

                  vel(idim) = vel(idim)/(float( npair(idim) ) + eps)
               end do

!cmx-------------------------------------------------------------------
!cmx-------------------------------------------------------------------
!cmx     Not harmonic average in porosity and/or De
!cmx-------------------------------------------------------------------
!cmx-------------------------------------------------------------------
        if (.not.harmonic_porosity .and.                          &
            (type_averaging_De.ne.'harmonic') .or.              &
            (type_averaging_De.eq.'arithmetic' .and.            &
            (harmonic_porosity)) .or.                           &
            type_averaging_De.eq.'  ') then  

!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element

               porav = r0
               do idim = 1, 3
                  do ipair = 1, npair(idim)
                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)
                     porav = porav                    &
                          + dmin1( r1, pornew(ibk) )  &
                          + dmin1( r1, pornew(id) )
                  end do
               end do 

               ndim = 0
               if (nvx .gt. 1) ndim = ndim + 1
               if (nvy .gt. 1) ndim = ndim + 1
               if (nvz .gt. 1) ndim = ndim + 1
               porav = porav / float(ndim) / r2**ndim
               
!c  average tortuosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
             if (assigned_tau) then
               tauav = r0
               do idim = 1, 3
                  do ipair = 1, npair(idim)
                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)
 !c                    tauav = tauav                              &
 !c                         + dmin1(r1, tau(ibk) * tau_fac(ibk))  &
 !c                         + dmin1(r1, tau(id) * tau_fac(id))
                       tauav = tauav                              &
                            + tau(ibk) * tau_fac(ibk)             &
                            + tau(id) * tau_fac(id)
                  end do
               end do 

               ndim = 0
               if (nvx .gt. 1) ndim = ndim + 1
               if (nvy .gt. 1) ndim = ndim + 1
               if (nvz .gt. 1) ndim = ndim + 1
               tauav = tauav / float(ndim) / r2**ndim             
            end if   

!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

               diffav = r0
               disx_avg = r0
               disy_avg = r0
               disz_avg = r0

               do idim = 1, 3                      !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                     irk_ibk = mprop(ibk)
                     irk_id = mprop(id)

                     diffav = diffav          &
                           + diffu            &
                           + diffu

                     disx_avg = disx_avg      &
                             + disx(irk_ibk)  &
                             + disx(irk_id)

                     disy_avg = disy_avg      &
                             + disy(irk_ibk)  &
                             + disy(irk_id)

                     disz_avg = disz_avg      &
                             + disz(irk_ibk)  &
                             + disz(irk_id)

                  end do                           !node pairs
               end do                              !dimensions 

               diffav = diffav / float(ndim) / r2**ndim
               disx_avg = disx_avg / float(ndim) / r2**ndim
               disy_avg = disy_avg / float(ndim) / r2**ndim
               disz_avg = disz_avg / float(ndim) / r2**ndim

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element

               satav = r0
               so_av = r0
               do idim = 1, 3
                  do ipair = 1, npair(idim)
                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)
                     satav = satav                    &
                          + dmin1( r1, sanew(ibk) )   &
                          + dmin1( r1, sanew(id) )
		             so_av = so_av                    &
                           + dmin1( r1, sonew(ibk) )  &
                           + dmin1( r1, sonew(id) )                     
                  end do
               end do
               satav = satav / float(ndim) / r2**ndim
               so_av = so_av / float(ndim) / r2**ndim

               vx2 = vel(1)**2
               vy2 = vel(2)**2
               vz2 = vel(3)**2
               vmag = dsqrt(vx2 + vy2 + vz2)
               vx2 = vx2 / (vmag + eps)
               vy2 = vy2 / (vmag + eps)
               vz2 = vz2 / (vmag + eps)
               
!c  calculate the average marchie factor

               marchieav = r0
               do idim = 1, 3
                  do ipair = 1, npair(idim)
                     ibk = fvpair(idim, ipair, 1)
                     id = fvpair(idim, ipair, 2)
                     marchieav = marchieav + marchies(ibk) + marchies(id)
                  end do
               end do
               marchieav = marchieav / float(ndim) / r2**ndim

!c  calculate effective diffusion coefficient
!c_bubbles use averaged diffusion coefficient
              if (.not.diff_coff) then
                 if (type_averaging_De .ne. 'arithmetic De' ) then      ! if first calculating porav, then diff_eff
                   diff_eff = diffcoff(diffav,satav,porav,             &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av)
                 else   ! if first calculating diff_eff1 and diff_eff2, then diff_eff, CMX
!CMX Mar. 2013
                    por1 = 0.0d0
                    por2 = 0.0d0
                    
                    por1 = dmin1( r1, pornew(ibk) )
                    por2 = dmin1( r1, pornew(id) )

                    diff_eff1 = diffcoff(diffav,satav,por1,            &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av)
                    diff_eff2 = diffcoff(diffav,satav,por2,            &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av)
                    diff_eff = (diff_eff1 + diff_eff2)/2
                 end if      ! if diff_ave
! prc -------------------------------------------------------------------
! prc Modified for Multicomponent diffusion
! prc diff_eff = r0 the diffusion coefficient will be taken out from 
! prc dispersion coefficient.
! prc -------------------------------------------------------------------

                 if (multi_diff) then
                   diff_eff = r0
                 end if    
         
! prc -------------------------------------------------------------------
! prc -------------------------------------------------------------------
                 tend(1) = disx_avg * vx2     &
                      + disy_avg * vy2        &
                      + disz_avg * vz2        &
                      + diff_eff

                 tend(2) = disy_avg * vx2     &
                      + disx_avg * vy2        &
                      + disz_avg * vz2        &
                      + diff_eff

                 tend(3) = disz_avg * vx2     &
                      + disz_avg * vy2        &
                      + disx_avg * vz2        &
                      + diff_eff

!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif
               do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization


                    do ipair = 1, npair(idim)             !node pairs
  
                       iisav = iface(idim, ipair)

                       cinfrt_da(iisav) = cinfrt_da(iisav)    &
                                       + tend(idim)           &
                                       * aread(idim, ipair)

                       cinfrt_da(isymm(iisav)) =                      &
                                              cinfrt_da(isymm(iisav)) &
                                              + tend(idim)            &
                                              * aread(idim, ipair)

                    end do                                !node pairs
               end do                           !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif
               
              else 
               
               do ic = 1,nc

                 diff_eff = diffcoff(diff_ic(ic),satav,porav,          &
                                 tortuosity_corr,assigned_tau,         &
                                 tauav,type_tortuosity,marchieav,      &
                                 so_av)

                   tend(1) = disx_avg * vx2       &
                      + disy_avg * vy2            &
                      + disz_avg * vz2            &
                      + diff_eff

                   tend(2) = disy_avg * vx2       &
                      + disx_avg * vy2            &
                      + disz_avg * vz2            &
                      + diff_eff

                   tend(3) = disz_avg * vx2       &
                      + disz_avg * vy2            &
                      + disx_avg * vz2            &
                      + diff_eff

!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif 
                   do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization


                      do ipair = 1, npair(idim)             !node pairs
  
                         iisav = iface(idim, ipair)

                         cinfrt_da_ic(iisav,ic) =                 &
                                       cinfrt_da_ic(iisav,ic)     &
                                       + tend(idim)               &
                                       * aread(idim, ipair)

                         cinfrt_da_ic(isymm(iisav),ic) =              &
                                        cinfrt_da_ic(isymm(iisav),ic) &
                                        + tend(idim)                  & 
                                        * aread(idim, ipair)

                      end do                                !node pairs
                   end do                             !loop over dimensions 
#ifdef OPENMP
    !$omp end critical
#endif                   
             end do      
               
               
               
           end if  
!cmx-----------------------------------------------------------------------
!cmx-----------------------------------------------------------------------
!cmx-----------------------------------------------------------------------
!cmx-----Harmonic averaging of effective diffusion-------------------------
!cmx-------It is only valid when harmonic ---
!cmx-----------------------------------------------------------------------           
           else ! Harmonic averaging of effective diffusion 
!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
!c    changed Nov.09
              ndim = 0
              if (nvx .gt. 1) ndim = ndim + 1
              if (nvy .gt. 1) ndim = ndim + 1
              if (nvz .gt. 1) ndim = ndim + 1
!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

              diffav = r0
              disx_avg = r0
              disy_avg = r0
              disz_avg = r0

              do idim = 1, 3                      !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                    irk_ibk = mprop(ibk)
                    irk_id = mprop(id)

                    disx_avg = disx_avg       &
                             + disx(irk_ibk)  &
                             + disx(irk_id)

                    disy_avg = disy_avg       &
                             + disy(irk_ibk)  &
                             + disy(irk_id)

                    disz_avg = disz_avg       &
                             + disz(irk_ibk)  &
                             + disz(irk_id)

                  end do                          !node pairs
              end do                              !dimensions


              disx_avg = disx_avg / float(ndim) / r2**ndim
              disy_avg = disy_avg / float(ndim) / r2**ndim
              disz_avg = disz_avg / float(ndim) / r2**ndim

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element
!c    changed: Nov. 09
              vx2 = vel(1)**2
              vy2 = vel(2)**2
              vz2 = vel(3)**2
              vmag = dsqrt(vx2 + vy2 + vz2)
              vx2 = vx2 / (vmag + eps)
              vy2 = vy2 / (vmag + eps)
              vz2 = vz2 / (vmag + eps)

!c  calculate effective diffusion coefficient
               

              tend(1) = disx_avg * vx2    &
                      + disy_avg * vy2    &
                      + disz_avg * vz2


              tend(2) = disy_avg * vx2    &
                      + disx_avg * vy2    &
                      + disz_avg * vz2

              tend(3) = disz_avg * vx2    &
                      + disz_avg * vy2    &
                      + disx_avg * vz2


!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif
              do idim = 1, 3                  !loop over dimensions

!c  adjust for 1d-, 2d, 3d - discretization


                    do ipair = 1, npair(idim)            !node pairs
 
                      iisav = iface(idim, ipair)

                      cinfrt_da(iisav) = cinfrt_da(iisav)     &
                                       + tend(idim)           &
                                       * aread(idim, ipair)

                      cinfrt_da(isymm(iisav)) =               &
                                      cinfrt_da(isymm(iisav)) &
                                      + tend(idim)            &
                                      * aread(idim, ipair)

                    end do                                !node pairs
              end do                          !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif

!c  pointer to current control volume

#ifdef OPENMP
            ivol = ((ivz-1)*nvy + ivy-1) * nvx + ivx
#else
            ivol = ivol+1
#endif
!CMX March 2013  300        ivol = ibk
            jtemp = ia(ivol)

!c  assign conductivities for current control volume
!c    changed: Nov. 09, not used for the time being

           
            por_i = pornew(ivol) !assign porosity
            if (assigned_tau) then
             tau_i = tau(ivol)*tau_fac(ivol)    !
            end if 
            diffav=diffu
            satav=dmin1(r1, sanew(ivol))
            so_av=dmin1(r1, sonew(ivol))
            marchieav = marchies(ivol)

            diff_i = diffcoff(diffav,satav,por_i,tortuosity_corr, & 
                             assigned_tau,tau_i,type_tortuosity,  &
                             marchieav,so_av)           



            jtemp = jtemp+1          ! skip diagonal

!c  assign interfacial distances of current control volume

            if (half_cells) then            !half_cells on boundary

              if (nvx.gt.1) then                        !in x-direction
                if (ivxgbl.eq.1.or.ivxgbl.eq.nvxgbl) then        !boundary
                  delx_i = delx(ivxgbl)
                elseif (ivxgbl.gt.0.and.ivxgbl.lt.nvxgbl) then  !interior
                  delx_i = rhalf*delx(ivxgbl) 
                end if
              end if

              if (nvy.gt.1) then                        !in y-direction
                if (ivygbl.eq.1.or.ivygbl.eq.nvygbl) then        !boundary
                  dely_i = dely(ivygbl)
                elseif (ivygbl.gt.0.and.ivygbl.lt.nvygbl) then  !interior
                  dely_i = rhalf*dely(ivygbl) 
                end if
              end if

              if (nvz.gt.1) then                        !in z-direction
                if (ivzgbl.eq.1.or.ivzgbl.eq.nvzgbl) then        !boundary
                  delz_i = delz(ivzgbl)
                elseif (ivzgbl.gt.0.and.ivzgbl.lt.nvzgbl) then  !interior
                  delz_i = rhalf*delz(ivzgbl) 
                end if
              end if

            else                            !full cells on boundary

              if (nvx.gt.1) then                        !in x-direction
                delx_i = rhalf*delx(ivxgbl) 
              end if

              if (nvy.gt.1) then                        !in y-direction
                dely_i = rhalf*dely(ivygbl) 
              end if

              if (nvz.gt.1) then                        !in z-direction
                delz_i = rhalf*delz(ivzgbl) 
              end if

            end if                          !(half_cells)

!c  calculate influence coefficients in x-direction

            if (nvx.gt.1) then              !connections in x-direction

              if (ivxp.gt.0) then          !left connection  (2)
                areaf = dely(ivygbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivxpgbl.eq.1) then
                    delx_j = delx(ivxpgbl)
                  elseif (ivxpgbl.gt.1) then
                    delx_j = rhalf*delx(ivxpgbl)       
                  end if
                else                        !full cells on boundary
                  delx_j = rhalf*delx(ivxpgbl)       
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if 

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)
               
                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, &
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

 !c correct for radial coord

              if (radial_coord) then
              
                  areaf = r2*pi*delz(ivzgbl)*(xg(ivol) - delx_i)
                   cinfrad(jtemp) = areaf
                
              end if
                

!c  permeability update due to porosity changes

                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
!CMX Mar.13                  cinfrt_da(iisav) =  cinfrt_da(iisav)+               &
                        diff_ij*areaf/(diff_i*delx_j+ diff_j*delx_i)
                endif

                jtemp = jtemp+1
              end if

              if (ivxn.le.nvx) then        !right connection  (3)
                areaf = dely(ivygbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivxngbl.eq.nvxgbl) then
                    delx_j = delx(ivxngbl)
                  elseif (ivxngbl.lt.nvxgbl) then
                    delx_j = rhalf*delx(ivxngbl)       
                  end if
                else                        !full cells on boundary
                  delx_j = rhalf*delx(ivxngbl)
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, &
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c correct for radial coord

              if (radial_coord) then
              
                  areaf = r2*pi*delz(ivzgbl)*(xg(ivol) + delx_i)
                   cinfrad(jtemp) = areaf
                
              end if
!c  De update due to porosity changes


                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then 
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
!CMX Mar. 13                  cinfrt_da(isymm(iisav)) =  cinfrt_da(isymm(iisav))+               &
                  diff_ij*areaf/(diff_i*delx_j+diff_j*delx_i)
                endif

                jtemp = jtemp+1
              !The following cinfrt_da is not needed, DSU 
              !else
              !    cinfrt_da(isymm(iisav)) =  cinfrt_da(iisav)           !cmx Mar. 13
              end if

            end if                          !connections in x-direction

!c  calculate influence coefficients in y-direction

            if (nvy.gt.1) then              !connections in y-direction

              if (ivypgbl.gt.0) then          !front connection (4)
                areaf = delx(ivxgbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivypgbl.eq.1) then
                    dely_j = dely(ivypgbl)
                  elseif (ivypgbl.gt.1) then
                    dely_j = rhalf*dely(ivypgbl)       
                  end if
                else                        !full cells on boundary
                  dely_j = rhalf*dely(ivypgbl)       
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
               
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)

!c no correct for radial coord in y direction


                
!c  permeability update due to porosity changes

                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                endif
                jtemp = jtemp+1
              end if

              if (ivyn.le.nvy) then        !back connection (5)
                areaf = delx(ivxgbl)*delz(ivzgbl)
                if (half_cells) then        !half cells on boundary
                  if (ivyngbl.eq.nvygbl) then
                    dely_j = dely(ivyngbl)
                  elseif (ivyngbl.lt.nvygbl) then
                    dely_j = rhalf*dely(ivyngbl)
                  end if
                else                        !full cells on boundary
                  dely_j = rhalf*dely(ivyngbl)
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)
                
!c no correct for radial coord in y direction


                
!c  permeability update due to porosity changes

 

                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                endif

                jtemp = jtemp+1
                
              end if

            endif                          !connections in y-direction

!c  calculate influence coefficients in z-direction

            if (nvz.gt.1) then              !connections in z-direction

              if (ivzpgbl.gt.0) then          !bottom connection (6)
                areaf = delx(ivxgbl)*dely(ivygbl)
                if (half_cells) then        !half cells on boundary
                  if (ivzpgbl.eq.1) then
                    delz_j = delz(ivzpgbl)
                  elseif (ivzpgbl.gt.1) then
                    delz_j = rhalf*delz(ivzpgbl)       
                  end if
                else                        !full cells on boundary
                  delz_j = rhalf*delz(ivzpgbl)       
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)
                
!c correct for radial coord
                if (radial_coord) then
                  if (half_cells) then
                    if (ivxgbl .eq. 1) then
                      areaf = pi*delx(ivxgbl)*delx(ivxgbl)
                    elseif (ivxgbl .eq. nvxgbl) then
                      areaf = r2*pi*(xg(ivol)-0.5*delx(ivxgbl))*delx(ivxgbl)
                    else ! full cell in xx direction
                      areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                    end if
                  else ! full cells
                    areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                end if
                
                cinfrad(jtemp)=areaf
               
              end if
                
!c  permeability update due to porosity changes

 
                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                endif

                jtemp = jtemp+1
              end if

              if (ivzn.le.nvz) then        !top connection (7)
                areaf = delx(ivxgbl)*dely(ivygbl)
                if (half_cells) then        !half cells on boundary
                  if (ivzngbl.eq.nvzgbl) then
                    delz_j = delz(ivzngbl)
                  elseif (ivzngbl.lt.nvzgbl) then
                    delz_j = rhalf*delz(ivzngbl)
                  end if
                else                        !full cells on boundary
                  delz_j = rhalf*delz(ivzngbl)
                end if                      !(half_cells)
                jvol = ja(jtemp)             
                jzn = mprop(jvol)
             
                por_j = pornew(jvol)
                if (assigned_tau) then
                 tau_j = tau(jvol)*tau_fac(jvol)    !
                end if

                diffav=diffu
                satav=dmin1(r1, sanew(jvol))        !satav=dmin1(r1, sanew(ivol)), bug? DSU 2013-2-28
                so_av=dmin1(r1, sonew(jvol))
                marchieav = marchies(jvol)

                diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr, & 
                                 assigned_tau,tau_j,type_tortuosity,  &
                                 marchieav,so_av)
!c correct for radial coord
                if (radial_coord) then
                if (half_cells) then
                  if (ivxgbl .eq. 1) then
                    areaf = pi*delx(ivxgbl)*delx(ivxgbl)
                  elseif (ivxgbl .eq. nvxgbl) then
                     areaf = r2*pi*(xg(ivol)-0.5*delx(ivxgbl))*delx(ivxgbl)
                  else ! full cell in xx direction
                     areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                  end if
                  else ! full cells
                    areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                end if
                
                cinfrad(jtemp)=areaf
                 
              end if


!c  permeability update due to porosity changes

 
                diff_ij = diff_i*diff_j

                if(diff_ij.gt.0.0) then
                  cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                       diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                endif

                jtemp = jtemp+1
                
              end if

            end if                          !connections in z-direction
           
           
           end if 
           
            end do
         end do  
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then
      
      do ibk = 1,nmax
       do ii = ia(ibk),ia(ibk+1)-1
         write(idbg,*) 'cinfrt_va(',ii,') = ',cinfrt_va(ii)
       end do
      end do
      do ibk = 1,nmax
       do ii = ia(ibk),ia(ibk+1)-1
         write(idbg,*) 'cinfrt_va(',ii,') = ',cinfrt_va(ii)
         write(idbg,*) 'cinfrt_da(',ii,') = ',cinfrt_da(ii)
       end do
      end do
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
      
      end if    ! (info_debug.gt.0)
#endif
!cdbg

      return
      end

