!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/datstr_n.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine datstr_n
!c -------------------
!c
!c set up data-structure, generate ordering vectors
!c and perform symbolic factorization for nd-scalar matrix
!c
!c written by:      Uli Mayer - Aug 6, 96
!c
!c last modified:   Uli Mayer - Jan 7, 2000
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed: -
!c
!c common:   
!c parm.f:   integer*4:
!c           ----------
!c           mnjafrt            = max. number of factored connections + -
!c
!c gen.f:    integer*4:
!c           ----------  
!c           ilog               = unit number, log file               + -
!c           nn                 = total number of control volumes     + -
!c           n                  = number of primary unknowns          + -
!c           njart              = number of global connections        * +
!c           njafrt             = number of factored connections      * +
!c           iart(nn*n+1)       = row pointer array for art           * +
!c           jart(njart)        = connectivity list                   * +
!c           iafrt(nn*n+1)      = row pointer array for afrt          * +
!c           jafrt(njafrt)      = column pointer array for afrt       * +
!c           iafdrt(nn*n)       = diagonal pointer array for afrt     * +
!c           lorderrt(nn*n)     = array containing ordering           * +
!c           invordrt(nn*n)     = array containing inverse ordering   * +
!c           iwork(*)           = integer work array                  * +
!c           idbg               = unit number, debugging file         + -
!c           level_rt           = incomplete factoriztaion level      + -
!c
!c           logical:
!c           --------
!c           lwork(*)           = logical work array                  * +
!c           redox_equil_rt     = .true.  -> equilibrium redox        + -
!c                                           reactions
!c           rcm_ordering_rt    = .true.  -> rcm ordering for         * +
!c                                           n-d scalar matrix
!c
!c local:    integer*4:
!c           ----------
!c           i1                 = pointer
!c           ierr               = 0 -> memory allocation successful
!c           ilist              = pointer for work array list
!c           irow               = pointer for work array irow
!c           ilevptr            = pointer for work array levptr
!c         
!c external: checkerr  = check for error during memory allocation 
!c           iajabl    = set up ia-ja data-structure for diagonal 
!c                       and off-diagonal block matrices for 
!c                       reactive transport problem
!c           iajart    = set up ia-ja data-structure for
!c                       nd-scalar matrix
!c           mem_njart = allocate memory for one-dimensional arrays
!c                       of size njart
!c           naturalorderin = assigngs ordering vectors for natural
!c                             ordering
!c           rcmordering =  assigns ordering vectors for reverse
!c                          Cuthill-McKee ordering
!c           setsize   = set number of primary unknowns
!c           symbolicfactorization = incomplete symbolic lower/
!c                                   upper factorization
!c                                   - brute force factor
!c ----------------------------------------------------------------------
 
      subroutine datstr_n
 
      use parm
      use gen
      use matrix_utility, only : remap_matrix_ja
#ifdef PARDISO
      use solver_pardiso, only : ptrt
#endif   
      implicit none
      
      integer :: i1, ierr, ilist, irow, ilevptr

      external checkerr, iajabl, iajart, mem_njart,   &
              rcmordering, naturalordering, setsize,  &
              symbolicfactorization

!c  preliminary memory allocation for pointer arrays jart and kart

      mnjart = 3*ncon*nngl*n*n

      allocate(jart(mnjart), stat = ierr)
      jart=0
      call checkerr(ierr,'jart',ilog)
      
#ifdef PETSC
      allocate(col_idx_l2pg_rt(mnjart), stat = ierr)
      col_idx_l2pg_rt=0
      call checkerr(ierr,'col_idx_l2pg_rt',ilog)      
#endif

      allocate(kart(mnjart), stat = ierr)
      kart=0 
      call checkerr(ierr,'kart',ilog)

!c  set number of primary unknowns for reaction-transport problem

      call setsize(redox_equil_rt)

!c  data structure (diagonal and off-diagonal block matrices)

      call iajabl

!c  data structure (n-d scalar matrix)

      call iajart

!c  final memory allocation for one-dimensional arrays of size njart

      call mem_njart
      
    ! use ws209 solver
      if (i_solver_type_react == 0) then
        
      mnjafrt = 3*(level_rt+1)*njart
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif 
!c  allocate memory for temporary work-arrays
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (lwork(nngl*n), stat = ierr)
      lwork=.false.  
      call checkerr(ierr,'lwork',ilog)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (jafrt(mnjafrt), stat = ierr)
      jafrt=0
      call checkerr(ierr,'jafrt',ilog)
      
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif
      allocate (iwork(2*nngl*n+mnjafrt), stat = ierr)
      iwork=0 
      call checkerr(ierr,'iwork',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

!c  ordering vectors

      if (rcm_ordering_rt) then    !rcm ordering    

        call rcmordering (nngl*n,njart,iart,jart,lorderrt,invordrt,    &
                         lwork,iwork)

      else                         !natural ordering

        call naturalordering (nngl*n,lorderrt,invordrt)

      endif

!c  write memory-requirements to log file
        if(rank == 0 .and. b_enable_output)  then

        write(ilog,'(/a/)')                                           &
       'memory requirements for reactive transport flow simulation:'
        write(ilog,'(2(a,i10/),a,i10)')                               &
       'estimated number of connections:          ',mnjart,           &
       'actual number of connections:             ',njart,            &
       'estimated number of factored connections: ',mnjafrt
        
        end if
 
!c  symbolic factorization

      njafrt = 0
      ilist = 1                  !pointer for work array list
      irow = n*nngl+1              !pointer for work array irow
      ilevptr = 2*(n*nngl)+1       !pointer for work array levptr

      call symbolicfactorization (ilog,n*nngl,njart,njafrt,mnjafrt,   &
                                 level_rt,iwork(ilist),iart,jart,     &
                                 iwork(irow),iwork(ilevptr),iafrt,    &
                                 iafdrt,jafrt,lorderrt,invordrt,      &
                                 b_enable_output)

!c  write actual number of factored connections to log file
        if(rank == 0 .and. b_enable_output)  then

        write(ilog,'(a,i10/)') &
       'actual number of factored connections:    ',njafrt
        
        end if
 
!c  deallocate memory from work arrays

      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      deallocate (lwork, stat = ierr)
      call checkerr(ierr,'lwork',ilog)

!c  minimize memory requirements for array jafrt

      allocate (iwork(njafrt), stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      do i1 = 1,njafrt
        iwork(i1) = jafrt(i1)
      end do

      deallocate (jafrt, stat = ierr)
      call checkerr(ierr,'jafrt',ilog)

      allocate (jafrt(njafrt), stat = ierr)
      call checkerr(ierr,'jafrt',ilog)

      do i1 = 1,njafrt
        jafrt(i1) = iwork(i1)
      end do

      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)
    
      end if
    
    ! use pardiso solver
#ifdef PARDISO
      if (i_solver_type_react == 1 .or. (i_solver_type_react == 0 .and. b_solver_test_pardiso .eqv. .true.)) then
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
        if (allocated(jart_std)) then
            deallocate(jart_std, stat = ierr)
            call checkerr(ierr,'jart_std',ilog) 
        end if
        allocate(jart_std(njart), stat = ierr)
        jart_std = 0
        call checkerr(ierr,'jart_std',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif        
        if (allocated(imaprt_std)) then
            deallocate(imaprt_std, stat = ierr)
            call checkerr(ierr,'imaprt_std',ilog) 
        end if
        allocate(imaprt_std(njart), stat = ierr)
        imaprt_std = 0
        call checkerr(ierr,'imaprt_std',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
        if (allocated(art_std)) then
            deallocate(art_std, stat = ierr)
            call checkerr(ierr,'art_std',ilog) 
        end if
        allocate(art_std(njart), stat = ierr)
        art_std = 0.0d0
        call checkerr(ierr,'art_std',ilog)
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif  
        if (b_solver_test_pardiso) then
            if (allocated(urt_std)) then
                deallocate(urt_std, stat = ierr)
                call checkerr(ierr,'urt_std',ilog) 
            end if
            allocate(urt_std(nngl*n), stat = ierr)
            urt_std = 0.0d0
            call checkerr(ierr,'urt_std',ilog)
        end if
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 

        !map ja array to standard sparse matrix structure, increasing column number for each row
        jart_std = jart
        do i1 = 1, njart
            imaprt_std (i1) = i1
        end do
        call remap_matrix_ja(nngl*n, iart, njart, jart_std, imaprt_std) 
               
      end if
#endif
     
    ! use PETSC solver
#ifdef PETSC
#ifdef CYGWIN
      if(b_enable_output)  then
        write(*,'(2(a,1x,i4,1x),a,1x,l1)') "rank",rank,                &
              "solver_type_react",i_solver_type_react,                 &
              "b_solver_test_petsc",b_solver_test_petsc
      end if
#endif
      if (i_solver_type_react == 0 .and. b_solver_test_petsc .eqv. .true.) then

        if (allocated(urt_std)) then
            deallocate(urt_std, stat = ierr)
            call checkerr(ierr,'urt_std',ilog) 
        end if
        allocate(urt_std(nngl*n), stat = ierr)
        urt_std = 0.0d0
        call checkerr(ierr,'urt_std',ilog)
               
      end if
#endif



!cdbg
!c
!c  ia-ja pointers
!c
!c     do irow=1,nn*n+1
!c       write(igen,*) 'ia(',irow,') = ',iart(irow)
!c     end do
!c     do irow=1,nn*n
!c       istart = iart(irow)
!c       iend = iart(irow+1)-1
!c       write(igen,*) ('ja(',i1,') = ',jart(i1),i1=istart,iend)
!c     end do
!c
!c  ordering vectors
!c
!c     do irow=1,nn*n
!c       write(igen,'(a,1x,i6,1x,a,1x,i6)')
!c    &        'lorderrt(',irow,') = ',lorderrt(irow)
!c     end do
!c     write(igen,*)
!c     do irow=1,nn*n
!c       write(igen,'(a,1x,i6,1x,a,1x,i6)')
!c    &        'invordrt(',irow,') = ',invordrt(irow)
!c     end do
!c
!c  iaf-jaf pointers
!c
!c     do irow=1,nn*n+1
!c       write(igen,*) 'iaf(',irow,') = ',iafrt(irow)
!c     end do
!c     do irow=1,nn*n
!c       write(igen,*) 'iafd(',irow,') = ',iafdrt(irow)
!c     end do
!c     do irow=1,nn*n
!c       istart = iafrt(irow)
!c       iend = iafrt(irow+1)-1
!c       write(igen,*) ('jaf(',i1,') = ',jafrt(i1),i1=istart,iend)
!c     end do
!c     stop
!cdbg

      return
      end
