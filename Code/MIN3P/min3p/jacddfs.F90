!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacddfs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacddfs
!c ----------------
!c
!c pressure formulation
!c accounts for presence of DNAPL phase
!c 
!c
!c construct Jacobian matrix and rhs-vector (density-dependent flow)
!c
!c modified from Uli Mayer template
!c
!c written by:      Tom Henderson - August 16, 2002
!c
!c last modified:   Tom Henderson - December 16, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     - +
!c           bvs(nn)            = rhs vector                          - +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation
!c           pornew(nn)         = porosity (new time level)           + -
!c           relperm(nn)        = relative permeability               * +
!c           relpinc(nn)        = relative permeability (incremented) * *
!c           sainc(nn)          = aqueous phase saturation            * *
!c                                - incremented
!c           sanew(nn)          = aqueous phase saturation            * +
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           uvsinc(nn)         = solution vector (incremented)       * *
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        + -
!c
!c           logical:
!c           --------
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c
!c dens.f:   real*8:
!c           -------
!c           del_p(ncon-1)      = difference in total                 + -       
!c                                pressure potential
!c           del_z(ncon-1)      = difference in                       + -                   
!c                                elevation potential
!c           pressure(nn)       = fluid pressure                      + - 
!c           density(nn)        = fluid density                       + -  
!c           viscosity(nn)      = fluid viscosity                     + -
!c           dcoef(ncon-1)      = coefficient including density       + -
!c                                and viscosity 
!c           rho_av             = average density between ivol        + -
!c                                and jvol
!c
!c           integer*4
!c           ---------
!c           iter_sia           = iteration counter -Picard iteration * - 
!c
!c local:    real*8:
!c           -------
!c           dqroot             = derivative of root water uptake
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsstor            = derivative of storage term
!c           dvsflux            = derivative of flux term
!c           hhinc              = hydraulic head (incremented)
!c           qroot              = root water uptake for current
!c                                control volume
!c           qrootinc           = root water uptake for current 
!c                                control volume (incremented)
!c           totvsflux          = total flux into current control 
!c                                volume
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           r0                 = constant
!c           r1                 = constant
!c           rhalf              = constant
!c           gacc               = gravitational acceleration [m s^-2]
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ivol               = counter (control volumes)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           isym               = symmetry pointer
!c           jvol               = row-column pointer
!c
!c external: rhsvs     = assembly of rhs vector
!c           rootwat   = function for computing root water uptake
!c           storddfs  = storage function for fully saturated 
!c                       density dependent flow 
!c           fluxdd    = flux function for fully saturated 
!c                       density dependent flow
!c           soilparm  = soil hydraulic parameters
!c ----------------------------------------------------------------------
 
      subroutine jacddfs
 
      use parm
      use gen
      use phys
      use dens
#ifdef OPENMP
      use omp_lib 
#endif 
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
      implicit none
      
      integer :: i1, icon, idiag, istart, iend, isym, ivol, izn, jvol, &
                 info_debug
      
      real*8 :: delt_loc, relpfsat, totvsflux, densnew_ivol,           &
                densold_ivol, sanew_ivol, saold_ivol, relperm_av,      &
                visco_av, fluxdd, vsstor, storddfs, dinc_vs_loc,       &
                porinc_ivol, porosity_flow, dtotvsflux, del_pinc,      &
                vsfluxinc, dvsflux, vsstorinc, dvsstor, ph_ivol,       &
                stor_ivol, permx_ivol, permz_ivol

     
      integer :: chunk

      external relpfsat, storddfs, fluxdd, rhsvs, porosity_flow, zero_r8

      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0, r1 = 1.0d0,      &
                           r4 = 4.0d0, r86400 = 86400.0d0
      
      logical                :: updatepor 

      vsstorinc = r0
      
#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow
      if(mod(nngl, numofthreads_matrix_flow) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_flow > 1) then
            if(mod(chunk, i_chunksize_factor_flow) > 0) then
                chunk = chunk/i_chunksize_factor_flow + 1
            else
                chunk = chunk/i_chunksize_factor_flow
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif
      
!c  debug toggle
 
      info_debug = 0
      
      if (iter_sia==1) then
        delt_loc=delt_tds
      else
        delt_loc=delt
      end if
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (i1, icon, idiag, iend, istart, isym, ivol, izn,    &
    !$omp jvol, dcoef, del_p, del_pinc, del_z,                        &
    !$omp densnew_ivol, densold_ivol, dinc_vs_loc,                    &
    !$omp dtotvsflux, dvsflux, dvsstor, porinc_ivol, relperm_av,      &
    !$omp rho_av, sanew_ivol, saold_ivol, totvsflux, visco_av,        &
    !$omp vsflux, vsfluxinc)                                          &
    !$omp firstprivate(vsstor, vsstorinc)
#endif

!c calculate relative permeability to account for the presence
!c of a napl phase

      if (napl_permeability) then
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
        do ivol = 1,nngl             !loop over control volumes
          izn = mpropvs(ivol)
          if (napl_kfunction .eq. 'vangenuchten') then

            relperm(ivol) = relpfsat(sanew(ivol),swr(izn),        &
     &                             expn(izn),spgamma(izn))
          else if (napl_kfunction .eq. 'corey') then      
            relperm(ivol) = ((sanew(ivol) - swr(izn))/            &
     &                               (r1 - swr(izn)))**r4
          end if 
        end do
#ifdef OPENMP
    !$omp end do
#endif
      end if      


!c  build jacobian matrix
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif
      do ivol = 1,nngl             !loop over control volumes

        idiag = iavs(ivol)       !pointer - diagonal 
        istart = iavs(ivol)+1    !pointer - start (off-diagonal entries)
        iend = iavs(ivol+1)-1    !pointer - end (off-diagonal entries)

!c  calculate storage and flux terms for current control volume

        totvsflux = r0           !initialize total influx
        icon = 0                 !counter (connections)
        
        
        
        if (iter_sia==1) then
          densnew_ivol = densold(ivol)
          densold_ivol = densold2(ivol)
          sanew_ivol = saold(ivol)
          saold_ivol = saold2(ivol)
        else
          sanew_ivol = sanew(ivol)
          saold_ivol = saold(ivol)
          densnew_ivol = density(ivol)
          densold_ivol = densold(ivol)
        end if
        

      do i1=istart,iend        !loop over connected control volumes 

          jvol = javs(i1)        !column pointer

!c  compute difference in total presure potential between  
!c  current and adjacent control volumes Pjvol - Pivol
  
          icon = icon+1          !counter (row entries)hen
          del_p(icon) = uvsnew(jvol) - uvsnew(ivol)
          del_z(icon) = zg(jvol) - zg(ivol)

          if (del_z(icon)/=r0) then
            rho_av = rhalf * (density(ivol) + density(jvol))

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
 
            del_z(icon) = del_z(icon) * rho_av * gacc
            del_p(icon) = del_p(icon) + del_z(icon) 
          end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
          if (del_p(icon) > r0) then               
            relperm_av = ups_flow*relperm(jvol)+(r1-ups_flow)*relperm(ivol)
            visco_av = ups_flow*viscosity(jvol)+(r1-ups_flow)*viscosity(ivol)
            rho_av = ups_flow*density(jvol)+(r1-ups_flow)*density(ivol)         
          else                   
            relperm_av = ups_flow*relperm(ivol)+(r1-ups_flow)*relperm(jvol)
            visco_av = ups_flow*viscosity(ivol)+(r1-ups_flow)*viscosity(jvol)
            rho_av = ups_flow*density(ivol)+(r1-ups_flow)*density(jvol)           
          end if
          
           dcoef(icon) = relperm_av * rho_av / visco_av 
    
!c  compute fluxes between current control volume and adjacent 
!c  control volumes

            vsflux(icon) = - fluxdd(del_p(icon),                      &
     &                     cinfvs_a(i1), dcoef(icon))
   
            totvsflux = totvsflux + vsflux(icon)
          continue


        end do                   !loop over connected control volumes


!c for the first picard iteration, TDS and saturations used for storage
!c calculations are taken from time levels N and N-1.  Saturations are a function 
!c of computed NAPL saturations
        
        if (transient_flow) then
           
            vsstor = cvol(ivol)* storddfs(delt,delt_loc,              &
     &               pornew(ivol),                                    &
     &               porold(ivol),sanew_ivol,saold_ivol,              &
     &               densnew_ivol,densold_ivol,densnew_ivol,          &
     &               densold_ivol,r0,r0,                              &
     &               r0,r0,r0,r0,.true.,.false.,                      &
     &               r0,r0,r0,r0)               
     
                         
        end if                   !(transient_flow)

!c  assembly of storage and flux terms in rhs vector
!c Anna Harrison added qh2o term Jan 24 2014
        if(water_removal) then
          totvsflux = totvsflux+qh2o(ivol)/delt  
        end if

        call rhsvs(vsstor,totvsflux,bvs(ivol))

!cprovi--------------------------------------------------------------------
!cprovi increment primary unknown (fluid pressure)
!cprovi If the process is iterative, the increment is a factor of the 
!cprovi fluid pressure 
!cprovi--------------------------------------------------------------------
        if (iterative_solver_flow.and.uvsnew(ivol)/=r0) then
          dinc_vs_loc = uvsnew(ivol)*dinc_vs
        else
          dinc_vs_loc = dinc_vs
        end if 
        
        
        uvsinc(ivol) = uvsnew(ivol) + dinc_vs_loc
        
        
        
       if (modify_por(ivol)) then
            porinc_ivol = porosity_flow(porold(ivol),uvsinc(ivol),    & 
     &                    uvsold(ivol),stor(ivol),                    &
     &                    por_stress(ivol),por_init(ivol),facpormin)  
       else                  
            porinc_ivol = pornew(ivol)               
       end if 
        
        

!c  calculate derivatives of storage and flux terms for current 
!c  control volume (assembly columnwise)

        dtotvsflux = r0          !initialize derivative of total influx
        icon = 0                 !counter (connections)

        do i1=istart,iend        !loop over connected control volumes

          jvol = javs(i1)        !column pointer
          isym = isymvs(i1)      !symmetry pointer
          icon = icon+1

          del_pinc = uvsnew(jvol) - uvsinc(ivol)
          del_pinc = del_pinc + del_z(icon)

!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions
!c  flux with incremented variables and derivative of flux


          vsfluxinc = - fluxdd(del_pinc,                              &
     &                   cinfvs_a(i1),dcoef(icon))
                        
          dvsflux = (vsfluxinc - vsflux(icon))/dinc_vs_loc
          dtotvsflux = dtotvsflux + vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
 
          avs(isym) = avs(isym) - dvsflux    !off-diagonal entries 

        end do                  !loop over connected control volumes

!c  compute storage term with incremented variables (lumped) 
!c  for current control volume, only for transient conditions

        if (transient_flow) then
          
           vsstorinc = cvol(ivol)* storddfs(delt,delt_loc,porinc_ivol,&
     &                 porold(ivol),sanew_ivol,saold_ivol,            &
     &                 densnew_ivol,densold_ivol,densnew_ivol,        &
     &                 densold_ivol,r0,r0,                            &
     &                 r0,r0,r0,r0,.true.,.false.,                    &
     &                 r0,r0,r0,r0)        
          
          
        end if                   !(transient_flow)
       
!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs_loc             
        
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs_loc

        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  

#ifdef DEBUG
    if (info_debug.eq.1) then
        write(idbg,'(5(g12.4,2x))') ivol,                             &
     &                              idiag,                            &
     &                              avs(idiag),                       &
     &                              dvsstor,                          &
     &                              dtotvsflux
    end if
    
    if (info_debug==2.and.uvsnew(ivol)<r0) then
        write(idbg,*) '----------------------------------------------'
        write(idbg,*) '             NEGATIVE PRESSURES               '
        write(idbg,*) '----------------------------------------------'
        write(idbg,*) '    ivol        Paivol         dens         '//&
     &                '    por           kzz        x      y      z'
        write(idbg,'(i8,7e15.4)') ivol,uvsnew(ivol),density(ivol),    &
     &                            pornew(ivol),permz(ivol),xg(ivol),  & 
     &                            yg(ivol),zg(ivol)
        icon=0    
        write(idbg,*) '----------------------------------------------'
        do i1=istart,iend 
           icon=icon+1
           jvol=javs(i1)
           write(idbg,*) 'connection with:',jvol
           write(idbg,*) 'x jvol:', xg(jvol)
           write(idbg,*) 'y jvol:', yg(jvol)
           write(idbg,*) 'z jvol:', zg(jvol)
           write(idbg,*) 'Pa jvol:', uvsnew(jvol)
           write(idbg,*) 'Dens jvol:', density(jvol)
           write(idbg,*) 'Por jvol:', pornew(jvol)
           write(idbg,*) 'Kzz jvol:', permz(jvol)
           write(idbg,*) '-------------------------------------------'
           write(idbg,*) '         vel            dPa            dz'//&
     &                   '         (A/D)kzz'
           write(idbg,*) '-------------------------------------------'
           write(idbg,'(4e15.4)') vsflux(icon), del_p(icon),          &
     &                            del_z(icon),cinfvs_a(i1)
        end do
        write(idbg,*) '----------------------------------------------'
        write(idbg,*) '----------------------------------------------'
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop 
      elseif (info_debug==3.and.uvsnew(ivol)<r0) then 
          ph_ivol=uvsnew(ivol)/(density(ivol)*gacc)    
          stor_ivol=stor(ivol)*(ref_dens*gacc)
          permx_ivol=permx(ivol)/r86400
          permz_ivol=permz(ivol)/r86400
          write(*,'(a27,i8)') 'Negative pressure in ivol:',ivol
          write(*,'(a9,e15.4)') 'x(ivol):',xg(ivol)
          write(*,'(a9,e15.4)') 'y(ivol):',yg(ivol)
          write(*,'(a9,e15.4)') 'z(ivol):',zg(ivol)
          write(*,'(a9,e15.4)') 'Pa [m]:',ph_ivol 
          write(*,'(a16,f7.3)') 'por(ivol) [-]:',pornew(ivol)
          write(*,'(a21,e15.4)') 'dens(ivol) [kg m-3]:',density(ivol)
          write(*,'(a26,e15.4)') 'visco(ivol) [kg m-1 s-1]:',         &
     &                            viscosity(ivol)
          write(*,'(a18,e15.4)') 'stor(ivol) [m-1]:',stor_ivol
          write(*,'(a18,e15.4)') 'kxx(ivol) [m2]:',permx_ivol
          write(*,'(a18,e15.4)') 'kzz(ivol) [m2]:',permz_ivol
      end if
#endif

      end do                          !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp end parallel
#endif

!cdbg
#ifdef DEBUG
    if (info_debug.eq.1) then
        write(idbg,'(4x,5a12)') 'ivol        ',                       &
     &                          'idiag       ',                       &
     &                          'avs(idiag)  ',                       &
     &                          'dvsstor     ',                       &
     &                          'dtotvsflux  '
      end if
#endif      
       
      
      
!   10 continue   
  

      return
      end
