!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/initbcenergybal.F90 $
!---------------------------------------------------------------------
!********************************************************************!

! ----------------------------------------------------------------------
! subroutine initbcenergybal                                            
! -------------------                                                   
!                                                                       
! boundary conditions (variably saturated flow)                         
!                                                                       
! first type boundary conditions:                                       
! -> define zone by delineating nodes located within zone               
!                                                                       
! second type boundary condition:                                       
! -> define area (only on surface of solution domain)                   
!                                                                       
! seepage face boundary condition:                                      
! -> define area (only on surface of solution domain)                   
!                                                                       
! written by:                               I O                         
! passed:   -                                                           
!                                                                       
! common:                                                               
! gen.f:    real*8:                                                     
!           -------                                                     
!           bcondvs(nbvs)      = boundary condition                  * +
!                                (pressure head or flux) or             
!                                identification of seepage face         
!                                boundary type                          
!           dimcv(3,nn)        = spatial dimensions of control       + -
!                                volumes                                
!           hhead(nn)          = hydraulic head                      + +
!           rwork(:,:)         = real*8 work array                   * *
!           time_bcvs          = next read time for flow boundary    * +
!                                conditions                             
!           uvsold(nn)         = solution vector (old time level)    + +
!           uvsnew(nn)         = solution vector (new time level)    + +
!           sec_per_days       = conversion factor from SI input     + -
!                                units for physico-chemical             
!                                parameters internal time units         
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibcvs              = unit number, transient boundary     * +
!                                             conditions, variably      
!                                             saturated flow            
!           idat               = unit number, run specific input     + -
!                                             file                      
!           igen               = unit number, generic output file    + -
!           ilog               = unit number, log book               + -
!           itmp               = unit number, temporary storage      + -
!           iabvs(nbvs)        = pointer to boundary control volumes * +
!                                for variably saturated flow            
!           iwork(:)           = integer work array                  * *
!           l_prfx             = length of prefix of I/O files       + -
!           l_zone_name        = length of zone name                 * +
!           nn                 = total number of control volumes     + -
!           nbvs               = number of specified boundary        * +
!                                control volumes                        
!                                (variably saturated flow)              
!           nseep_first        = number of seepage face nodes        * +
!                                                                       
!           logical:                                                    
!           --------                                                    
!           fully_saturated    = .true.  -> saturated conditions     + -
!           update_bcvs        = .true.  -> transient boundary       * +
!                                           condition for variably      
!                                           saturated flow              
!           variably_saturated = .true.  -> .not.fully_saturated,    + -
!                                        -> variably saturated          
!                                           conditions                  
!           hydraulic_head     = .true.  -> initial condition in     + -
!                                           terms of hydraulic head     
!           pressure_head      = .true.  -> initial condition in     + -
!                                           terms of pressure heada     
!           seepage_face       = .true.  -> seepage face boundary    * +
!                                           specified                   
!                                                                       
!           character:                                                  
!           ----------                                                  
!           prefix             = prefix name for all I/O files       + -
!           zone_name          = name of zone                        * +
!           btypevs(nbvs)      = boundary type array                 * +
!                                (variably saturated flow)              
!                                'first'   = Dirichlet                  
!                                'second'  = Neumann                    
!                                'seepage' = seepage face               
!           section_header     = section header                      * +
!                                                                       
! local:    real*8:                                                     
!           -------                                                     
!           r0                 = constant                               
!           r1                 = constant                               
!           tiny               = small increment                        
!           xbmin              = min. x-coordinate of boundary          
!                                zone                                   
!           xbmax              = max. x-coordinate of boundary          
!                                zone                                   
!           ybmin              = min. y-coordinate of boundary          
!                                zone                                   
!           ybmax              = max. y-coordinate of boundary          
!                                zone                                   
!           zbmin              = min. z-coordinate of boundary          
!                                zone                                   
!           zbmax              = max. z-coordinate of boundary          
!                                zone                                   
!                                                                       
!           integer*4:                                                  
!           ----------                                                  
!           ibvs               = counter (boundary control volumes)     
!           ibz                = counter (zones)                        
!           ierr               = 0 -> memory allocation successful      
!           ivol               = counter (control volumes)              
!           istart             = pointer (control volume)               
!           iend               = pointer (control volume)               
!           l_string           = length of text string                  
!           nbvsp              = start of boundary zone                 
!                                (temporary)                            
!           nbz                = number of boundary zones               
!                                                                       
!           logical:                                                    
!           --------                                                    
!           found              = logical variable to exit search        
!           found_section      = .true.  -> section header was          
!                                           found in input file         
!           found_subsection   = .true.  -> subsection header was       
!                                           found in input file         
!           xy_plane           = boundary zone parallel tp xy-plane     
!           xz_plane           = boundary zone parallel to xz-plane     
!           yz_plane           = boundary zone parallel to yz-plane     
!                                                                       
!           character:                                                  
!           ----------                                                  
!           bcond              = btypevs = 'first'                      
!                                -> hydraulic head                      
!                                btypevs = 'second'                     
!                                -> specified flux                      
!                                btypevs = 'seepage'                    
!                                -> initial seepage face heigth         
!           btypezn            = boundary type of zone                  
!           subsection         = name of subsection in input file       
!                                                                       
! external: checkerr  = check for error during memory allocation        
!           findstrg  = find text string in file                        
!           findzone  = find zone in input section                      
!           readbloc  = read section of input file and write to         
!                       temporary file                                  
!           readzone  = read zone in section of input file and          
!                       write to temporary file                         
! ----------------------------------------------------------------------
                                                                        
      subroutine initbcenergybal 
                                                                        
      use parm 
      use gen 
      use dens 
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif                                                            
      implicit none
                                                                        
      external checkerr, findstrg, findzone, readbloc, readzone 
      
      real*8 :: r0, r1, tiny, r86400, r1000
      real*8 :: ddens_temp, ddens_c, areaf, temp0_grad, slope_grad,    &
                bcond, xbmin, xbmax, ybmin, ybmax, zbmin, zbmax,       &
                pos_grad
      integer :: i, ibheat, ibz, ibvs, ivolvs, ierr, ivol, l_string,   &
                nbheatp, nbz 
                                                                        
      parameter (r0=0.0d0,r1=1.0d0,tiny=1.0d-8,r86400=86400.0d0,       &
     &           r1000=1000.0d0)                                        
                                                                        
      logical xy_plane,xz_plane,yz_plane,found,found_section,          &
     &        found_subsection                                          
      character*12 btypezn 
      character*72 subsection,dir_grad 
      real*8  factiny 
                                                                        
      nbz=0 
!cprovi-----------------------------------------------------------------
!cprovi Set initial values for themal gradient                          
!cprovi-----------------------------------------------------------------
      temp0_grad=r0 
      slope_grad=r1 
      dir_grad='z' 
      
      areaf = r0
      pos_grad = r0
      xy_plane = .false.
      xz_plane = .false.
      yz_plane = .false.
                                                                        
!  define defaults                                                      
          
      if(rank == 0 .and. b_enable_output) then
        write(*,*) 'boundary conditions - ',                           &
     &             'energy balance'                                       
        write(*,*) ('-',i=1,72) 
                                                                        
        write(ilog,'(2a)') 'boundary conditions - ',                     &
     &                     'energy balance'                               
        write(ilog,'(72a/)')('-',i=1,72) 
      end if  
                                                                        
!  read section header for boundary conditions of variably saturated    
!  flow simulation                                                      
                                                                        
      section_header = 'boundary conditions - energy balance' 
      call readbloc (idat,itmp,section_header,found_section,.true.) 
                                                                        
!  define length of section header                                      
                                                                        
      l_string = index(section_header,'  ')-1 
      if (l_string.eq.-1.or.l_string.gt.72) then 
         l_string=72 
      end if 
                                                                        
!  terminate program if section header not found                        
                                                                        
      if (.not.found_section) then 
        if (rank == 0) then
          write(ilog,*) 'SIMULATION TERMINATED' 
          write(ilog,*) 'error reading input file' 
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop 
      end if 
                                                                        
!  write section header to generic output file                          
      if (b_enable_output .and. b_enable_output_gen) then                                                          
        write(igen,'(/72a)')('-',i=1,72) 
        write(igen,'(a)') section_header(:l_string) 
        write(igen,'(72a/)')('-',i=1,72) 
      end if
                                                                        
!  initialize variables for seepage face iteration                      
                                                                        
      seepage_face = .false. 
      nseep_first = 0 
                                                                        
!  preliminary allocation of memory for boundary conditions             
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp parallel private(ierr)
    !$omp sections
#endif
#endif

#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif                                                                    
      allocate (bcondheat(nngl), stat = ierr) 
      bcondheat=r0 
      call checkerr(ierr,'bcondheat',ilog) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif                                                                          
      allocate (bcondheat0(nngl), stat = ierr) 
      bcondheat0=r0 
      call checkerr(ierr,'bcondheat0',ilog) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif                                                                    
      allocate (iabheat(nngl), stat = ierr) 
      iabheat=0 
      call checkerr(ierr,'iabheat',ilog) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif                                                                   
      allocate (iabheat0(nngl), stat = ierr) 
      iabheat0=0 
      call checkerr(ierr,'iabheat0',ilog) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp section
#endif
#endif                                                                   
      allocate (btypeheat(nngl), stat = ierr) 
      btypeheat=' ' 
      call checkerr(ierr,'btypeheat',ilog) 
#ifdef OPENMP
#ifdef PARALLEL_SECTION
    !$omp end sections
    !$omp end parallel
#endif
#endif 
                                                                        
!  read number of boundary zones                                        
                                                                        
      read(itmp,*,err=999,end=999) nbz 
      if (b_enable_output .and. b_enable_output_gen) then
        write(igen,'(a,i10)')                                          &
     &  'number of boundary zones                        = ',nbz
      end if
                                                                        
!  initialize pointer array for storage of boundary conditions          
                                                                        
      nbheat = 0 
      iabheat(1) = 1 
                                                                        
!  read name of zone                                                    
                                                                        
                                  !loop over number of zones            
      do ibz=1,nbz 
                                                                        
                                      !temporary pointer for output     
        nbheatp = nbheat+1 
                                                                        
!  find current zone in input file and write to temporary file          
                                                                        
        subsection = 'number and name of zone' 
                                                                        
        call findzone(subsection,itmp,found_subsection,ibz,zone_name) 
                                                                        
        if (found_subsection) then 
                                                                        
          call readzone(itmp,icnv,ilog,zone_name,found_subsection) 
                                                                        
        else 
          if (rank == 0) then                                                              
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error in input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone number "',ibz, '" missing or erroneous'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define length of zone name                                           
                                                                        
        l_zone_name = index(zone_name,'  ')-1 
        if (l_zone_name.lt.0.or.l_zone_name.gt.72) then 
          l_zone_name = 72 
        end if 
                                                                        
                                                                        
!  define type and value of boundary condition                          
                                                                        
        subsection = 'boundary type' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 
                                                                        
        if (found_subsection) then 
                                                                        
          read(icnv,*,err=999,end=999) btypezn, bcond 
          if (btypezn=='gradient') then 
             read(icnv,*,err=999,end=999) dir_grad 
             read(icnv,*,err=999,end=999) temp0_grad 
             read(icnv,*,err=999,end=999) slope_grad 
             if (dir_grad/='x'.and.                                     &
     &           dir_grad/='y'.and.                                     &
     &           dir_grad/='z') then    
               if (rank == 0) then  
                 write(ilog,*) 'SIMULATION TERMINATED' 
                 write(ilog,*) 'error in input file' 
                 write(ilog,*) 'section "',section_header(:l_string),'"' 
                 write(ilog,*) 'Error in gradient direction'
                 close(ilog)
               end if
#ifdef PETSC
               call petsc_mpi_finalize
#endif
               stop 
             end if 
          end if 
                                                                        
        else 
              
          if (rank == 0) then  
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "',section_header(:l_string),'"' 
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
            l_string = index(subsection,'  ')-1 
            if (l_string.eq.-1.or.l_string.gt.72) then 
               l_string=72 
            end if 
            write(ilog,*) 'subsection "',subsection(:l_string),           &
     &                    '" missing' 
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  read coordiantes defining boundary zone,                             
                                                                        
        subsection = 'extent of zone' 
                                                                        
        call findstrg(subsection,icnv,found_subsection) 
                                                                        
        if (found_subsection) then 
                                                                        
          read(icnv,*,err=999,end=999) xbmin,xbmax,ybmin,ybmax,        &
     &                                 zbmin,zbmax                      
                                                                        
        elseif (.not.found_subsection) then 
                 
          if (rank == 0) then  
            write(ilog,*) 'SIMULATION TERMINATED' 
            write(ilog,*) 'error reading input file' 
            write(ilog,*) 'section "', section_header(:l_string),'"' 
            write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
            l_string = index(subsection,'  ')-1 
            if (l_string.eq.-1.or.l_string.gt.72) then 
               l_string=72 
            end if 
            write(ilog,*) 'subsection "',subsection(:l_string),        &
     &                 '" missing' 
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop 
                                                                        
        end if 
                                                                        
!  define boundary face to be considered (only needed for calculation   
!  of boundary face area for second type boundary conditions)           
                                                                        
        if (btypezn.eq.'second') then 
                                                                        
          found = .false. 
          xy_plane = .false. 
          xz_plane = .false. 
          yz_plane = .false. 
                                                                        
                                                  !xy_plane             
          if (dabs(zbmax-zbmin).lt.tiny) then 
            if ((dabs(xbmax-xbmin).lt.tiny).or.                         &
     &          (dabs(ybmax-ybmin).lt.tiny)) then 
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED' 
                write(ilog,*) 'error in input file' 
                write(ilog,*) 'section "', section_header(:l_string),'"' 
                write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                write(ilog,*) 'unable to specify boundary face' 
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            else 
              xy_plane = .true. 
              found = .true. 
            end if 
          end if 
                                                                        
                                                   !xz_plane            
          if (.not.found) then 
            if (dabs(ybmax-ybmin).lt.tiny) then 
              if ((dabs(xbmax-xbmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then 
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "', section_header(:l_string),'"' 
                  write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face' 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                xz_plane = .true. 
                if (xy_plane) then
                  if (rank == 0) then  
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                            &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
                                                   !yz_plane            
          if (.not.found) then 
            if (dabs(xbmax-xbmin).lt.tiny) then 
              if ((dabs(ybmax-ybmin).lt.tiny).or.                       &
     &            (dabs(zbmax-zbmin).lt.tiny)) then  
                if (rank == 0) then  
                  write(ilog,*) 'SIMULATION TERMINATED' 
                  write(ilog,*) 'error in input file' 
                  write(ilog,*) 'section "',section_header(:l_string),'"' 
                  write(ilog,*) 'zone "',zone_name(:l_zone_name),'"' 
                  write(ilog,*) 'unable to specify boundary face'
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              else 
                yz_plane = .true. 
                if (xy_plane.or.xz_plane) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'error in input file' 
                    write(ilog,*) 'section "',                         &
     &                             section_header(:l_string),'"'          
                    write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
                    write(ilog,*) 'unable to specify boundary face'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                found = .true. 
              end if 
            end if 
          end if 
                                                                        
!  exit if boundary face was not found                                  
                                                                        
          if (.not.found) then
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED' 
              write(ilog,*) 'error in input file' 
              write(ilog,*) 'section "', section_header(:l_string),'"' 
              write(ilog,*) 'zone "', zone_name(:l_zone_name),'"' 
              write(ilog,*) 'unable to specify boundary face' 
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
          end if 
                                                                        
                                  !(btypezn.eq.'second')                
        end if 
                                                                        
!  increment boundary coordinates                                       
                                                                        
        factiny=dabs(xbmax-xbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        xbmin = xbmin-factiny 
        xbmax = xbmax+factiny 
        factiny=dabs(ybmax-ybmin)*tiny 
        if (factiny==r0) factiny=tiny 
        ybmin = ybmin-factiny 
        ybmax = ybmax+factiny 
        factiny=dabs(zbmax-zbmin)*tiny 
        if (factiny==r0) factiny=tiny 
        zbmin = zbmin-factiny 
        zbmax = zbmax+factiny 
                                                                        
!  store type of boundary condition and boundary condition              
!  for global system in compressed storage                              
                                                                        
        do ivol = 1,nngl 
                                                                        
!  check limits of boundary zone                                        
                                                                        
          if ((xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)) then 
            if ((yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)) then 
              if ((zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)) then 
                                                                        
!  assign boundary type and boundary condition                          
                                                                        
                nbheat = nbheat + 1 
                                                                        
!  exit if nbvs > nn                                                    
                                                                        
                if (nbheat.gt.nngl) then 
                  if (rank == 0) then
                    write(ilog,*) 'SIMULATION TERMINATED' 
                    write(ilog,*) 'nbheat > nn ...' 
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop 
                end if 
                                                                        
!  assign pointer and                                                   
                                                                        
                iabheat(nbheat) = ivol 
                btypeheat(nbheat) = btypezn 
                                                                        
!  first type boundary condition - constant temperature 

                if (btypeheat(nbheat).eq.'first') then
                    
                    tempnew(ivol) = bcond
                    tempold(ivol) = bcond 
                    bcondheat(nbheat) = bcond
                
                elseif (btypeheat(nbheat).eq.'gradient')then
                    
                    select case(dir_grad)
                    case ('x')
                      pos_grad=xg(ivol) 
                    case ('y')
                      pos_grad=yg(ivol) 
                    case ('z')
                      pos_grad=zg(ivol) 
                    end select
                    
                    
                    tempnew(ivol) = temp0_grad + slope_grad*pos_grad
                    tempold(ivol) = tempnew(ivol)
                    bcondheat(nbheat) = tempnew(ivol)
                    btypeheat(nbheat) = 'first' 
                    
                    
                elseif (btypeheat(nbheat).eq.'free') then
                     
                    bcondheat(nbheat) = bcond    
                    
                    do ibvs = 1,nbvs
                     ivolvs = iabvs(ibvs)
                     if (ivolvs==ivol.and.btypevs(ibvs)=='second') then
                       ddens_temp = drho_dt*(bcond-tempref_dens)        
                       ddens_c = drho_dc * (tds_new(ivol) - ref_tds)
                 !    ssdens(ivol) = ref_dens + ddens_temp + ddens_c 
                   end if      
                    end do
                    

!c  second type boundary condition - specified flux

                elseif (btypezn.eq.'second') then

!c  calculate flux area

                  if (xy_plane) then
                    areaf = dimcv(1,ivol) * dimcv(2,ivol)
                  elseif (xz_plane) then
                    areaf = dimcv(1,ivol) * dimcv(3,ivol)
                  elseif (yz_plane) then
                    areaf = dimcv(2,ivol) * dimcv(3,ivol)
                  end if
!cprovi---------------------------------------------------------
!cprovi assign second type boundary condition
!cprovi Transform J => Kj 
!cprovi---------------------------------------------------------
                  bcondheat(nbheat) = areaf*bcond/r1000 

                elseif (btypezn.eq.'point') then
                  
                  bcondheat(nbheat) = bcond

                end if !(btypezn.eq.'first'.or.btypezn.eq.'second'.or.
                       ! btypezn.eq.'seepage')
              end if   !(zg(ivol).gt.zbmin).and.(zg(ivol).lt.zbmax)
            end if     !(yg(ivol).gt.ybmin).and.(yg(ivol).lt.ybmax)
          end if       !(xg(ivol).gt.xbmin).and.(xg(ivol).lt.xbmax)
        end do         !loop over control volumes

!c  write header for boundary zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/a,i1,a,1x,a)') 'zone ',ibz,':',zone_name
          write(igen,'(72a)')('-',i=1,72)
          
          if (btypezn.eq.'first') then
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',  &
     &                                     'temperature'
          elseif (btypezn.eq.'second') then
            write(igen,'(a,3x,a,3x,a/)') 'volume','boundary type',  &
     &                                   'specified flux'
          end if
        end if

!c  write boundary condition for zone to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          if (btypezn.ne.'seepage') then         !first and second type
            do ibheat=nbheatp,nbheat
              ivol = iabheat(ibheat)
              write(igen,'(i6,3x,a12,1pe13.3)') ivol,btypeheat(ibheat), &
     &                                          bcondheat(ibheat)
            end do
          end if
        end if

!c  conversion of time units for computation in days
!c  if second type boundary condition is specified

        if ((btypezn.eq.'second') .or.    &
     &      (btypezn.eq.'point')) then
          do ibheat=nbheatp,nbheat
            bcondheat(ibheat) = bcondheat(ibheat)*sec_per_days
          end do
        end if

      end do            !end loop over zones

!c  minimize memory requirement for boundary arrays
!c  array bcondvs    

      nbheat0=nbheat

      allocate (rwork(nbheat,1), stat = ierr)
      call checkerr(ierr,'rwork',ilog)

      do ibheat = 1,nbheat
        rwork(ibheat,1) = bcondheat(ibheat)
      end do

      deallocate (bcondheat, stat = ierr)
      call checkerr(ierr,'bcondheat',ilog)

      allocate (bcondheat(nbheat), stat = ierr)
      call checkerr(ierr,'bcondheat',ilog)
      
      deallocate (bcondheat0, stat = ierr)
      call checkerr(ierr,'bcondheat0',ilog)

      allocate (bcondheat0(nbheat), stat = ierr)
      call checkerr(ierr,'bcondheat0',ilog)

      do ibheat = 1,nbheat
        bcondheat(ibheat) = rwork(ibheat,1)
        bcondheat0(ibheat) = rwork(ibheat,1)
      end do

      deallocate (rwork, stat = ierr)
      call checkerr(ierr,'rwork',ilog)

!c  array iabvs

      allocate (iwork(nbheat), stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      do ibheat = 1,nbheat
        iwork(ibheat) = iabheat(ibheat)
      end do

      deallocate (iabheat, stat = ierr)
      call checkerr(ierr,'iabheat',ilog)

      allocate (iabheat(nbheat), stat = ierr)
      call checkerr(ierr,'iabheat',ilog)
      
      deallocate (iabheat0, stat = ierr)
      call checkerr(ierr,'iabheat',ilog)

      allocate (iabheat0(nbheat), stat = ierr)
      call checkerr(ierr,'iabheat',ilog)

      do ibheat = 1,nbheat
        iabheat(ibheat) = iwork(ibheat)
        iabheat0(ibheat) = iwork(ibheat)
      end do

      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)
      
      !allocate (bvalid_iabheat(nbheat), stat = ierr)
      !call checkerr(ierr,'bvalid_iabheat',ilog)
      !bvalid_iabheat = .true.
      
      !do ibheat = 1,nbheat
      !    do ibheat2 = ibheat +1, nbheat
      !        if(iabheat(ibheat) == iabheat(ibheat2)) then
      !            bvalid_iabheat(ibheat) = .false.
      !            exit
      !        end if
      !    end do
      !end do

      goto 1000

!997   write(ilog,*) 'SIMULATION TERMINATED' 
!      write(ilog,*) 'file ', prefix(:l_prfx)//'.bcheat missing'
!#ifdef PETSC
!      call petsc_mpi_finalize
!#endif
!      stop

!998   write(ilog,*) 'SIMULATION TERMINATED' 
!      write(ilog,*) 'error reading file ', prefix(:l_prfx)//'.bcvs'
!      close(ilog)
!
!#ifdef PETSC
!      call petsc_mpi_finalize
!#endif
!      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED' 
        write(ilog,*) 'error reading input file'
        write(ilog,*) 'section "',section_header(:l_string),'"'
        write(ilog,*) 'zone "', zone_name(:l_zone_name),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
