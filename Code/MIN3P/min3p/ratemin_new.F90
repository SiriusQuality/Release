!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 491 $
!> $Author: fgerard $
!> $Date: 2017-07-18 00:06:39 +0200 (Tue, 18 Jul 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/ratemin_new.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine ratemin_new
!c ----------------------
!c
!c compute absolute dissolution-precipitation rates of minerals
!c based on new database format
!c
!c sign convention: dissolution -
!c                  precipitation +
!c
!c written by:      Uli Mayer - November 11, 01
!c
!c last modified:   Uli Mayer - February 3, 02
!c                  added hyperbolic and inhibition terms
!c                  for minerals
!c                  Uli Mayer - August 8, 02
!c                  added hyperbolic and inhibition terms 
!c                  for components as species in solution 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           aream              = reactivity term                     + -
!c           c(nc)              = concentrations of free species      + -
!c                                - new time level [moles/l h2o]
!c           cx(nx)             = concentrations of secondary         + -
!c                                aqueous species
!c           gammac(nc)         = activity coefficients of free       + -
!c                                species
!c           gammax(nx)         = activity coefficient of             + -
!c                                secondary aqueous species
!c           phim               = volume fractions of minerals        + -
!c           phimold            = volume fractions of minerals        + -
!c                                - old time level
!c           ratem              = absolute dissolution-precipitation  * +
!c                                rate of mineral
!c                                [moles/(l bulk*day)
!c           totc(nc)           = total aqueous component             + -
!c                                concentrations - new time level
!c                                [moles/l h2o]
!c
!c common:
!c biol.f:   real*8:
!c           -------
!c           rootdens           = root density at a given ivol !FG sept 2021
!c chem.f:   real*8:
!c           -------
!c           diffm(ndr*nm)      = free diffusion coefficient of       + -
!c                                primary reactant in water
!c                                (transport controlled reactions)
!c           eqm(nm,nthreads)   = equilibrium constants for minerals  + -
!c           fmdi(nrc*nc)       = inhibition constants - T^a          + - 
!c           fmdm(nrc*nc)       = half saturation constants - T^a     + -
!c           fmic(nrc*nc)       = inhibition constants - C^c          + - 
!c           fmhc(nrc*nc)       = half saturation constants - C^c     + -
!c           fmdpi(nrc*nm)      = inhibition constants - phi^m        + - 
!c           fmdpm(nrc*nm)      = half saturation constants - phi^m   + -
!c           orddc(nrc*nm)      = order of free species in            + -
!c                                dissolution reaction
!c           orddcx(nrc*nm)     = order of secondary aqueous          + -
!c                                species in dissolution reaction
!c           orddt(nrc*nm)      = order of total aqueous component    + -
!c                                concentration in dissolution
!c                                reaction
!c           ordmdi(nrc*nc)     = order of inhibition terms for       + -
!c                                dissolution-precipitation reactions
!c                                - T^a
!c           ordmdm(nrc*nc)     = order of hyperbolic terms for       + -
!c                                dissolution-precipitation reactions
!c                                - T^a
!c           ordmic(nrc*nc)     = order of inhibition terms for       + -
!c                                dissolution-precipitation reactions
!c                                - C^c
!c           ordmhc(nrc*nc)     = order of hyperbolic terms for       + -
!c                                dissolution-precipitation reactions
!c                                - C^c
!c           ordmdpi(nrc*nm)    = order of inhibition terms for       + -
!c                                dissolution-precipitation reactions
!c                                - phi^m
!c           ordmdpm(nrc*nm)    = order of hyperbolic terms for       + -
!c                                dissolution-precipitation reactions
!c                                - phi^m
!c           ordm(ndr*nm)       = exponent m for reaction rate law    + -
!c           ordn(ndr*nm)       = exponent n for reaction rate law    + -
!c           rated(ndr*nm,nthreads)      
!c                              = rate constants for dissolution      + -
!c                                reactions
!c           ratemp(ndr*nm,nthreads)
!c                              = reaction rates for minerals         * +
!c                                including parallel reactions
!c           satm(nm,nthreads)  = saturation indices                  * +
!c           xnud(ndr*nm)       = stoichiometric coefficients of      + -
!c                                reacting species in transport
!c                                controlled dissolution reaction
!c           xnum(nm*nc)        = stoichiometric coefficients of      + +
!c                                components in mineral
!c
!c           integer*4:
!c           ----------
!c           iam(nm+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in mineral
!c           iamd(nm+1)         = pointer array to dissolution        + -
!c                                reactions
!c           iamdc(ndr*nm+1)    = pointer array to free species       + -
!c                                involved in dissolution reactions
!c           iamdcx(ndr*nm+1)   = pointer array to secondary aqueous  + -
!c                                species involved in dissolution
!c                                reactions
!c           iamdi(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - T^a)
!c           iamdm(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - T^a)
!c           iamic(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - C^c)
!c           iamhc(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - C^c)
!c           iamdpi(ndr*nm+1)   = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms 
!c                                - phi^m)
!c           iamdpm(ndr*nm+1)   = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms 
!c                                - phi^m)
!c           iamdt(ndr*nm+1)    = pointer array to total aqueous      + -
!c                                component concentrations involved
!c                                in dissolution reactions
!c           jam(nm*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           jamd(nrc*nm)       = pointer array to parallel reactions + -
!c                                involved in dissolution reactions
!c           jamdc(nrc*nm)      = pointer array to free species       + -
!c                                involved in dissolution reactions
!c           jamdcx(nrc*nm)     = pointer array to secondary aqueous  + -
!c                                species involved in dissolution
!c                                reactions
!c           jamdi(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - T^a)
!c           jamdm(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - T^a)
!c           jamic(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - C^c)
!c           jamhc(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - C^c)
!c           jamdpi(nrc*nm)     = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - 
!c                                phi^m)
!c           jamdpm(nrc*nm)     = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - phi^m)
!c           jamdt(nrc*nm)      = pointer array to total aqueous      + -
!c                                component concentrations involved
!c                                in dissolution reactions
!c           nm                 = number of minerals specified        + -
!c           nc                 = number of components                + -
!c           nx                 = number of aqueous complexes         + -
!c
!c
!c           logical:
!c           --------
!c           far_from_equil(nm) = .true.  -> far from equilibrium     + -
!crevaff           
!c           reverse_affinity_term(nm) = .true. -> reverse affinity   + - 
!c                                                 term if IAP/K > 1                   
!crevaff
!c
!c           character:
!c           ----------
!c           rate_control(nm)   = rate controlling process for        + -
!c                                dissolution-precipitation reaction
!c                                'surface'   = surface controlled
!c                                              reaction
!c                                'transport' = transport controlled
!c                                              reaction
!c                                'mixed'     = mixed control
!c           reaction_type(nm)  = type of dissolution-precipitation   + -
!c                                reaction
!c
!c local:    real*8:
!c           -------
!c           prodrc             = product of reacting species
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           istart             = pointer (start of reaction set) 
!c           istop              = pointer (end of reaction set)
!c           ireac              = counter (number of dissolution/ 
!c                                         precipitation reactions)
!c           istart2            = pointer (start of species involved) 
!c           istop2             = pointer (end of species involved)
!c           ic                 = counter (components)
!c           im2                = counter (minerals)
!c           ix                 = counter (secondary aqueous species)
!c
!c external: raoult   = compute dissolution rate of organic compound
!c                      from organic mixture based on raoult's law
!c ----------------------------------------------------------------------
  
      subroutine ratemin_new(totc,c,cx,gammac,gammax,ratem,phim,    &
                             phimold,aream,im)
 
      use parm
      use chem
      use biol !FG sept 2021
      use gen, only : idbg, rank, b_enable_output, ilog
#ifdef OPENMP
      use omp_lib 
#endif  
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif      
      integer :: im 
      integer :: tid, i, i1, ic, ic2, i2, i3, ii, im2, icur, icount,   &
                 itemp, info_debug, ireac, istart, istop, istart2,     &
                 istop2, istart3, istop3, itop, ibottom, next, ix, im3 
      
      real*8 :: totc, c, cx, gammac, gammax, ratem, phim, phimold      
      real*8 :: aream, r1_iap_k, prodrc, prodrcinc
      real*8 :: alphar, alphartot, alphartop, gammatemp, sumic, sumix
      real*8 :: salinity, sar
      logical :: summed_species

      dimension c(*),cx(*),gammac(*),gammax(*),totc(*),phim(*)

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
      
      !This is not needed when interface is declared
      !external raoult
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
        subroutine raoult(c,gammac,ratem,phim,phimold,aream,im)
          use parm, only: type_i4, type_r8
          integer(type_i4) :: im
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8) :: ratem
          real(type_r8) :: phim
          real(type_r8) :: phimold
          real(type_r8) :: aream
        end subroutine
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
      
      r1_iap_k = 0.0d0

!c  compute dissolution rate for organic compound based on Raoult's law
      

      if (reaction_type(im).eq.'raoult') then

        call raoult(c,gammac,ratem,phim(im),phimold,aream,im)
        return

      end if

!c  initialize total reaction rate

      ratem = r0

!c  initialize parallel reaction rates

      istart = iamd(im)
      istop = iamd(im+1)-1

      do ireac = istart,istop
        ratemp(ireac,tid) = r0
      end do

!c  calculate saturation index for current mineral except for
!c  far from equilibrium dissolution-precipitation reactions

!c_isotope
!c calculate the saturation index for isotopes     
!c need to total isotopes to get accurate activity for the component  
      if (.not.far_from_equil(im)) then
        if (isofrac(im)) then
          satm(im,tid) = eqm(im,tid)**(-r1)          
          ireac = iamd(im)            
          istart = iam(im)
          istop = iam(im+1)-1 
                    
          do i1 = istart, istop ! loop through components in mineral
            icount = 0
            ic = jam(i1)
            next = 0
            do i = 1, nifrm(im)  ! loop through isotope sets
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                gammatemp = r0
                !loop through isotope compents in set
                do i2 = istart2, istop2 
                  ii = jamdiso(i2)
                  !check to see if component is an isotope
                  if (ii.eq.ic) then 
                    icount = icount + 1
                    !if so sum the isotope activities
                    do i3 = istart2, istop2 
                        ic2 = jamdiso(i3)
                        gammatemp = gammatemp + c(ic2)
                    end do 
                    gammatemp = gammac(ic)*gammatemp
                    satm(im,tid) = satm(im,tid) *(gammatemp**xnum(i1))
                  end if
                end do
            end do  !i2
          !if not calculate the saturaton index the normal way  
            if (icount.eq.0) then    
              satm(im,tid) = satm(im,tid) * (gammac(ic)*c(ic))**xnum(i1)
            end if
          end do   !i1    
        else 
          satm(im,tid) = eqm(im,tid)**(-r1)          
          istart = iam(im)
          istop = iam(im+1)-1
          do i1 = istart,istop
            ic = jam(i1)
            satm(im,tid) = satm(im,tid) * (gammac(ic)*c(ic))**xnum(i1)
          end do
        end if
      end if

!c  compute total dissolution/precipitation rate for surface controlled
!c  dissolution/precipitation reactions
!c  also for active uptake by roots (type = 'root') !FG sept 2021

      if ((rate_control(im).eq.'surface').or.                         &
     &    (rate_control(im).eq.'root')) then !FG sept 2021

!c  compute rates only for specified reaction direction

        if (reaction_type(im).eq.'reversible' .or.                    &
     &      reaction_type(im).eq.                                     &
     &       'dissolution_far_from_equilibrium' .or.                  &
     &      (reaction_type(im).eq.'dissolution_to_equilibrium'.and.   &
     &       dg_lim(im)-satm(im,tid).gt.r0) .or.                      &
     &      reaction_type(im).eq.                                     &
     &      'precipitation_far_from_equilibrium' .or.                 &
     &      (reaction_type(im).eq.'precipitation_to_equilibrium'.and. &
     &       dg_lim(im)-satm(im,tid).lt.r0)) then

!c  loop over parallel dissolution reactions

          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop
  
!c  scale reaction rate depending on equilibrium condition except
!c  for far-from-equilibrium reactions 

            if (reaction_type(im).eq.                                 &
     &          'dissolution_far_from_equilibrium') then
                                                                       
              prodrc = -rated(ireac,tid)
                                                                       
            elseif (reaction_type(im).eq.                             &
     &             'precipitation_far_from_equilibrium') then

              prodrc = rated(ireac,tid)
              
              if (rate_control(im).eq.'root') then !FG Sept 2021 - root density term if type 'root'
                  !write(*,*) 'root prev', rootdens,rated(ireac,tid)
                  prodrc = rootdens*rated(ireac,tid)
               
              endif !root 

!culi 18/05/06 modified formulation for precipitation_to_equilibrium   !MX sept2012
!culi to avoid excessively large precipitation rates 
            elseif (reaction_type(im).eq.                             &
     &             'precipitation_to_equilibrium') then                
              prodrc = rated(ireac,tid)                               &
     &               * (r1 - satm(im,tid)**(-r1))
            else

!c  commented out to avoid NaN problems              
              ! prodrc = -rated(ireac)                                 &
              !        * (r1 - satm(im)**ordm(ireac))**ordn(ireac)
              ! 
              !if(isnan(prodrc)) then
              !    write(*,*) "prodrc is nan4: ", r1 - satm(im)**ordm(ireac),  ordn(ireac)
              !end if
              
              !Lasaga et al. (1994) equation. dsu, 2012-12-20
              
              if (b_ratelaw_exponent_n) then

                if (reverse_affinity_term(im).and.                    &
                    satm(im,tid).gt.r1) then
!crevaff
                    prodrc = rated(ireac,tid) *                       &
                             (r1 - satm(im,tid)**(-ordm(ireac)))**    &
                             ordn(ireac)
!crevaff
                else
                    
                  r1_iap_k = dg_lim(im) - satm(im,tid)**ordm(ireac)
                  if(r1_iap_k>0) then       !satm(im) < 1 as ordm(ireac) is positive
                      if (reaction_type(im) == 'precipitation_to_equilibrium') then
                          prodrc = 0.0d0
                      else
                          prodrc = -rated(ireac,tid) *                &
                                   r1_iap_k**ordn(ireac)
                      end if
                  else                      !satm(im) >= 1 as ordm(ireac) is positive 
                      if (reaction_type(im) == 'dissolution_to_equilibrium') then
                          prodrc = 0.0d0
                      else
                          prodrc = rated(ireac,tid) *                 &
                                   (abs(r1_iap_k))**ordn(ireac)
                      end if
                  end if
                  
                end if  
                  
              else
!crevaff
                if (reverse_affinity_term(im).and.                    &
                    satm(im,tid).gt.r1) then
                    
                    prodrc = rated(ireac,tid) *                       &
                             (dg_lim(im) - satm(im,tid)**(-ordm(ireac)))
                else
                    prodrc = -rated(ireac,tid) *                      &
                             (dg_lim(im) - satm(im,tid)**ordm(ireac))
                end if    
!crevaff                
              end if
              
     !--old--
     !         prodrc = -rated(ireac)                                  &
     !&               * (r1 - satm(im)**ordm(ireac))
                 
            end if

          
!c  form product of reacting components in terms of total 
!c  aqueous component concentrations

            istart2 = iamdt(ireac)
            istop2 = iamdt(ireac+1)-1

            do i1 = istart2,istop2

              ic = jamdt(i1)
              prodrc = prodrc * totc(ic)**orddt(i1)

            end do

!c  form product of reacting components as species in solution

            istart2 = iamdc(ireac)
            istop2 = iamdc(ireac+1)-1

            do i1 = istart2,istop2

              ic = jamdc(i1)
              prodrc = prodrc * (gammac(ic)*c(ic))**orddc(i1)

            end do

!c  form product of reacting complexed species

            istart2 = iamdcx(ireac)
            istop2 = iamdcx(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdcx(i1)
              prodrc = prodrc * (gammax(ix)*cx(ix))**orddcx(i1)

            end do
            
!c form product of reacting minerals
            
            istart2 = iamdphm(ireac)
            istop2 = iamdphm(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdphm(i1)
              prodrc = prodrc * (phim(ix)**ordmdphm(i1))

            end do

!c_uranium
!c  form product of summed reacting complexed species

            istart2 = iamdscx(ireac)
            istop2 = iamdscx(ireac+1)-1
            summed_species = .false.
            sumix = r0

            do i1 = istart2,istop2
              ix = jamdscx(i1)
              sumix = sumix + (gammax(ix)*cx(ix)*orddscx(i1))
              summed_species = .true.
            end do

            if (summed_species) then
              prodrc = prodrc * sumix**orddsumx(im)     
            end if       

!c  hyperbolic terms - T^a

            istart2 = iamdm(ireac)
            istop2 = iamdm(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamdm(i1)

                prodrc = prodrc                                       &
     &                 * (totc(ic)/(fmdm(i1) + totc(ic)))**ordmdm(i1)

              end do

            end if
            
!c_isotopes
!c  hyperbolic terms - sum T^a

            istart2 = iamdsta2(ireac)
            istop2 = iamdsta2(ireac+1)-1
            itemp = r0
            
            do i1 = istart2, istop2                  

               istart3 = iamdsta(ireac)+itemp
               istop3 = istart3+ntsc(i1)-1
               sumic = r0
               do i2 = istart3, istop3
                 ic = jamdsta(i2)
                 sumic = sumic + totc(ic)
              end do

              prodrc = prodrc                                          &
     &              * (sumic/(fmdsta(i1) + sumic))**orddsta(i1)
               
              itemp = itemp + ntsc(i1)

            end do

!c_isotopes
!c  isotope fractionation - compute rate fractions for isotope dependent reactions
            
            !determine ratios and combine with alphas
            if ((.not.far_from_equil(im)).and.(satm(im,tid).lt.r1)) then
              next = 0 
              do i = 1, nifrm(im)  ! loop through isotope sets 
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                ibottom = jamdpair(istart2)
                alphartot = r1
                alphartop = r1
                !loop through isotope compents in set
                do i2 = istart2+1, istop2 
                    itop = jamdpair(i2)
                    alphar = phim(itop)/phim(ibottom)*jamdalpha(i2)
                    alphartot = alphartot + alphar
                    if (itop.eq.im) then
                      alphartop = alphar
                    end if
                end do
                
                prodrc = prodrc*alphartop/alphartot

              end do
            else
              next = 0 
              do i = 1, nifrm(im)  ! loop through isotope sets
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                ibottom = jamdiso(istart2)
                alphartot = r1
                alphartop = r1
                !loop through isotope compents in set
                do i2 = istart2+1, istop2 
                    itop = jamdiso(i2)
                    alphar = totc(itop)/totc(ibottom)*jamdalpha(i2)
                    alphartot = alphartot + alphar
                
                    istart = iam(im)
                    istop = iam(im+1)-1 
                    do i1 = istart, istop
                        ic = jam(i1)
                        if (ic.eq.itop) then
                           alphartop = alphar
                        end if
                    end do
                end do
                
                prodrc = prodrc*alphartop/alphartot

              end do
            end if

!c  inhibition terms - T^a

            istart2 = iamdi(ireac)
            istop2 = iamdi(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamdi(i1)

                prodrc = prodrc                                       &
     &                 * (fmdi(i1)/(fmdi(i1)+totc(ic)))**ordmdi(i1)

              end do

            end if

!c  hyperbolic terms - C^c

            istart2 = iamhc(ireac)
            istop2 = iamhc(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamhc(i1)

                prodrc = prodrc                                       &
     &                 * (gammac(ic)*c(ic)                            &
     &                 / (fmhc(i1) + gammac(ic)*c(ic)))**ordmhc(i1)

              end do

            end if

!c  inhibition terms - C^c

            istart2 = iamic(ireac)
            istop2 = iamic(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamic(i1)

                prodrc = prodrc                                       &
     &                 * (fmic(i1)                                    &
     &                 / (fmic(i1)+gammac(ic)*c(ic)))**ordmic(i1)

              end do

            end if

!c  hyperbolic terms - phi^m

            istart2 = iamdpm(ireac)
            istop2 = iamdpm(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                im2 = jamdpm(i1)

                prodrc = prodrc * (phim(im2) /                        &
     &                   (fmdpm(i1) + phim(im2)))**ordmdpm(i1)

              end do

            end if

!c  inhibition terms - phi^m

            istart2 = iamdpi(ireac)
            istop2 = iamdpi(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                im2 = jamdpi(i1)

                prodrc = prodrc * (fmdpi(i1) /                        &
     &                   (fmdpi(i1) + phim(im2)))**ordmdpi(i1)

              end do

            end if

!cmx compute the influence of salinity dependent mineral dissolution 
!      on the reaction rate for the case of sulfur bacteria reaction

            im3 = jamd(ireac)

            if (salinity_dependent(im3)) then
                salinity = 0.0
                do ic = 1, nc-1
                    if (namec(ic) .ne. 'o2(aq)') then
                        salinity = salinity + gfwc(ic)*totc(ic)
                    end if
                end do
          
                if (sdtype(im3) .eq. 'equation') then
                    sar = 0.0d0
              
                    if (salinity .le. min_salinity(im3)) then
                        sar = min_sar(im3)
                    else if (salinity .ge. max_salinity(im3)) then
                        sar = max_sar(im3)
                    else
                        do i = 1, nfac(im3)
                            sar = sar + sfac_sdmin(im3,i)*(salinity**(i-1))
                        end do
                    end if 
                end if
          
                if (sar .gt. 0.0 .and. sar .le. 1.0) then
                    prodrc = prodrc*sar
                else if (sar .le. 0.0) then
                    prodrc = prodrc*1.0d-10
                else
                    if (rank == 0 .and. b_enable_output) then
                        write(ilog,'(3a)') 'In file ratemin_new: error calculating ',&
                              'salinity dependent factor of mineral  ',namem(im3)
                        write(ilog,'(a,e12.5)') 'sfac_sdmin(im,1) ',sfac_sdmin(im3,1)
                        write(ilog,'(a,e12.5)') 'The salinity = ',salinity
                        write(ilog,'(a,e12.5)') 'The coefficient = ',sar
                        write(ilog,*) 'It should be between 0.0 to less or equal to 1.0.'                
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                end if
            end if

            
            
!c  compute total rate for surface controlled reactions
!c  [moles/(l bulk*day)] = [m^2 mineral/l bulk]
!c                          ----------- 
!c                       * [moles/(m^2 mineral * day)]
!c                                 -----------

            ratemp(ireac,tid) = aream * prodrc

!c  sum up parallel reaction rates for surface controlled
!c  dissolution/precipitation reactions

            ratem = ratem + ratemp(ireac,tid)

          end do       !loop over parallel diss/prec reactions

        else           !reaction_type

          ratem = r0
 
        end if         !reaction_type

!c  compute total dissolution rate for transport 
!c  controlled dissolution reactions

      elseif (rate_control(im).eq.'transport') then

        if (reaction_type(im).eq.'dissolution_far_from_equilibrium'.or.&
     &      reaction_type(im).eq.'reversible'.or.                      &
     &      (reaction_type(im).eq.'dissolution_to_equilibrium'.and.    &
     &       dg_lim(im)-satm(im,tid).gt.r0)) then

!c  compute total dissolution rate 
 
          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop

!c  scale reaction rate, if dissolution reaction is limited by
!c  equilibrium conditions 

            if (far_from_equil(im)) then
              prodrc = r1
            else
              prodrc = dg_lim(im)-satm(im,tid) 
            end if

!c  form product of reacting components in terms of total
!c  aqueous component concentrations

            istart2 = iamdt(ireac)
            istop2 = iamdt(ireac+1)-1

            do i1 = istart2,istop2
              ic = jamdt(i1)
              prodrc = prodrc * totc(ic)**orddt(i1)
            end do

!c  form product of reacting component species for current dissolution
!c  reaction, activity coefficients are here not considered explicitely,
!c  but are by definition included in the effective diffusion coefficient
 
            istart2 = iamdc(ireac)
            istop2 = iamdc(ireac+1)-1

            do i1 = istart2,istop2
              ic = jamdc(i1)
              prodrc = prodrc * c(ic)**orddc(i1)
            end do
 
!c  include complexed species in product of reacting species for current
!c  dissolution reaction
 
            istart2 = iamdcx(ireac)
            istop2 = iamdcx(ireac+1)-1
            do i1 = istart2,istop2
              ix = jamdcx(i1)
              prodrc = prodrc * cx(ix)**orddcx(i1)
            end do
 
!cmx compute the influence of salinity dependent mineral dissolution 
!      on the reaction rate for the case of sulfur bacteria reaction

            im3 = jamd(ireac)

            if (salinity_dependent(im3)) then
                salinity = 0.0
                do ic = 1, nc-1
                    if (namec(ic) .ne. 'o2(aq)') then
                        salinity = salinity + gfwc(ic)*totc(ic)
                    end if
                end do
          
                if (sdtype(im3) .eq. 'equation') then
                    sar = 0.0d0
              
                    if (salinity .le. min_salinity(im3)) then
                        sar = min_sar(im3)
                    else if (salinity .ge. max_salinity(im3)) then
                        sar = max_sar(im3)
                    else
                        do i = 1, nfac(im3)
                            sar = sar + sfac_sdmin(im3,i)*(salinity**(i-1))
                        end do
                    end if 
                end if
          
                if (sar .gt. 0.0 .and. sar .le. 1.0) then
                    prodrc = prodrc*sar
                else if (sar .le. 0.0) then
                    prodrc = prodrc*1.0d-10
                else
                    if (rank == 0 .and. b_enable_output) then
                        write(ilog,'(3a)') 'In file ratemin_new: error calculating ', &
                              'salinity dependent factor of mineral  ',namem(im3)
                        write(ilog,'(a,e12.5)') 'sfac_sdmin(im,1) ',sfac_sdmin(im3,1)
                        write(ilog,'(a,e12.5)') 'The salinity = ',salinity
                        write(ilog,'(a,e12.5)') 'The coefficient = ',sar
                        write(ilog,*) 'It should be between 0.0 to less or equal to 1.0.'                
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                end if
            end if
            
!c  compute rate
!c  [moles/(l bulk*day)] = [m mineral / m^3 bulk]
!c                          ---------   ---
!c                       * [m^3 h2o/m^3 mineral * m^2 mineral/day]
!c                          --- --- -----------   -----------
!c                       * [moles/l h2o]
!c                                  ---

            ratemp(ireac,tid) = - aream * diffm(ireac)/xnud(ireac)    &
     &                    * prodrc

!c  sum up parallel rates

            ratem = ratem + ratemp(ireac,tid)

          end do  
 
!c  set reaction rate to zero for all other conditions
 
        else

          ratem = r0
 
        end if          !(reaction_type(im))

      end if            !(rate_control(im))



      return
    end
    
      subroutine ratemin_new_dbg(totc,c,cx,gammac,gammax,ratem,phim,  &
                             phimold,aream,im)
 
      use parm
      use chem
      use gen, only : idbg, rank, b_enable_output, ilog
#ifdef OPENMP
      use omp_lib 
#endif  
 
      implicit none
      
      integer :: im 
      integer :: tid, i, i1, ic, ic2, i2, i3, ii, im2, icur, icount,   &
                 itemp, info_debug, ireac, istart, istop, istart2,     &
                 istop2, istart3, istop3, itop, ibottom, next, ix, im3 
      
      real*8 :: totc, c, cx, gammac, gammax, ratem, phim, phimold      
      real*8 :: aream, r1_iap_k, prodrc, prodrcinc
      real*8 :: alphar, alphartot, alphartop, gammatemp, sumic, sumix
      real*8 :: salinity, sar
      logical :: summed_species

      dimension c(*),cx(*),gammac(*),gammax(*),totc(*),phim(*)

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
      
      !This is not needed when interface is declared
      !external raoult
      
      !For the shared-memory parallel version, the variables defined in the module
      !are shared variables by different threads. So as to avoid race condition, 
      !these variable should be passed by dummy arguments. Danyang Su, 2013-05.
      interface
        subroutine raoult(c,gammac,ratem,phim,phimold,aream,im)
          use parm, only: type_i4, type_r8
          integer(type_i4) :: im
          real(type_r8), dimension(*) :: c
          real(type_r8), dimension(*) :: gammac
          real(type_r8) :: ratem
          real(type_r8) :: phim
          real(type_r8) :: phimold
          real(type_r8) :: aream
        end subroutine
      end interface
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif
      
      r1_iap_k = 0.0d0

!c  compute dissolution rate for organic compound based on Raoult's law

      if (reaction_type(im).eq.'raoult') then

        call raoult(c,gammac,ratem,phim(im),phimold,aream,im)
        return

      end if

!c  initialize total reaction rate

      ratem = r0

!c  initialize parallel reaction rates

      istart = iamd(im)
      istop = iamd(im+1)-1

      do ireac = istart,istop
        ratemp(ireac,tid) = r0
      end do

!c  calculate saturation index for current mineral except for
!c  far from equilibrium dissolution-precipitation reactions

!c_isotope
!c calculate the saturation index for isotopes     
!c need to total isotopes to get accurate activity for the component  
      if (.not.far_from_equil(im)) then
        if (isofrac(im)) then
          satm(im,tid) = eqm(im,tid)**(-r1)          
          ireac = iamd(im)            
          istart = iam(im)
          istop = iam(im+1)-1 
                    
          do i1 = istart, istop ! loop through components in mineral
            icount = 0
            ic = jam(i1)
            next = 0
            do i = 1, nifrm(im)  ! loop through isotope sets
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                gammatemp = r0
                !loop through isotope compents in set
                do i2 = istart2, istop2 
                  ii = jamdiso(i2)
                  !check to see if component is an isotope
                  if (ii.eq.ic) then 
                    icount = icount + 1
                    !if so sum the isotope activities
                    do i3 = istart2, istop2 
                        ic2 = jamdiso(i3)
                        gammatemp = gammatemp + c(ic2)
                    end do 
                    gammatemp = gammac(ic)*gammatemp
                    satm(im,tid) = satm(im,tid) *(gammatemp**xnum(i1))
                  end if
                end do
            end do  !i2
          !if not calculate the saturaton index the normal way  
            if (icount.eq.0) then    
              satm(im,tid) = satm(im,tid) * (gammac(ic)*c(ic))**xnum(i1)
            end if
          end do   !i1    
        else 
          satm(im,tid) = eqm(im,tid)**(-r1)          
          istart = iam(im)
          istop = iam(im+1)-1
          do i1 = istart,istop
            ic = jam(i1)
            satm(im,tid) = satm(im,tid) * (gammac(ic)*c(ic))**xnum(i1)
          end do          
        end if
      end if

!c  compute total dissolution/precipitation rate for surface controlled
!c  dissolution/precipitation reactions
#ifdef DEBUG
      write(idbg,'(a,1x,i6,2(1x,e16.8))')                              &
            "-->ratemin_new->im,satm,dg_lim(im)",                      &
            im,satm(im,tid),dg_lim(im)
      write(idbg,'(3(a,1x))') "-->rate_control(im),reaction_type(im)", &
            rate_control(im),reaction_type(im)
#endif

      if (rate_control(im).eq.'surface') then

!c  compute rates only for specified reaction direction

        if (reaction_type(im).eq.'reversible' .or.                    &
     &      reaction_type(im).eq.                                     &
     &       'dissolution_far_from_equilibrium' .or.                  &
     &      (reaction_type(im).eq.'dissolution_to_equilibrium'.and.   &
     &       dg_lim(im)-satm(im,tid).gt.r0) .or.                      &
     &      reaction_type(im).eq.                                     &
     &      'precipitation_far_from_equilibrium' .or.                 &
     &      (reaction_type(im).eq.'precipitation_to_equilibrium'.and. &
     &       dg_lim(im)-satm(im,tid).lt.r0)) then

!c  loop over parallel dissolution reactions

          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop
  
!c  scale reaction rate depending on equilibrium condition except
!c  for far-from-equilibrium reactions 

            if (reaction_type(im).eq.                                 &
     &          'dissolution_far_from_equilibrium') then
                                                                       
              prodrc = -rated(ireac,tid)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->A ireac,prodrc ", ireac,prodrc
#endif
                                                                       
            elseif (reaction_type(im).eq.                             &
     &             'precipitation_far_from_equilibrium') then

              prodrc = rated(ireac,tid)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->B ireac,prodrc ", ireac,prodrc
#endif

!culi 18/05/06 modified formulation for precipitation_to_equilibrium   !MX sept2012
!culi to avoid excessively large precipitation rates 
            elseif (reaction_type(im).eq.                             &
     &             'precipitation_to_equilibrium') then                
              prodrc = rated(ireac,tid)                               &
     &               * (r1 - satm(im,tid)**(-r1))
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->C ireac,prodrc ", ireac,prodrc
#endif
            else

!c  commented out to avoid NaN problems              
              ! prodrc = -rated(ireac)                                 &
              !        * (r1 - satm(im)**ordm(ireac))**ordn(ireac)
              ! 
              !if(isnan(prodrc)) then
              !    write(*,*) "prodrc is nan4: ", r1 - satm(im)**ordm(ireac),  ordn(ireac)
              !end if
              
              !Lasaga et al. (1994) equation. dsu, 2012-12-20
              
              if (b_ratelaw_exponent_n) then

                if (reverse_affinity_term(im).and.                    &
                    satm(im,tid).gt.r1) then
!crevaff
                    prodrc = rated(ireac,tid) *                       &
                             (r1 - satm(im,tid)**(-ordm(ireac)))**    &
                             ordn(ireac)
!crevaff
                else
                    
                  r1_iap_k = dg_lim(im) - satm(im,tid)**ordm(ireac)
                  if(r1_iap_k>0) then       !satm(im) < 1 as ordm(ireac) is positive
                      if (reaction_type(im) == 'precipitation_to_equilibrium') then
                          prodrc = 0.0d0
                      else
                          prodrc = -rated(ireac,tid) *                &
                                   r1_iap_k**ordn(ireac)
                      end if
                  else                      !satm(im) >= 1 as ordm(ireac) is positive 
                      if (reaction_type(im) == 'dissolution_to_equilibrium') then
                          prodrc = 0.0d0
                      else
                          prodrc = rated(ireac,tid) *                 &
                                   (abs(r1_iap_k))**ordn(ireac)
                      end if
                  end if
                  
                end if  
                  
              else
!crevaff
                if (reverse_affinity_term(im).and.                    &
                    satm(im,tid).gt.r1) then
                    
                    prodrc = rated(ireac,tid) *                       &
                             (dg_lim(im) - satm(im,tid)**(-ordm(ireac)))
                else
                    prodrc = -rated(ireac,tid) *                      &
                             (dg_lim(im) - satm(im,tid)**ordm(ireac))
                end if    
!crevaff                
              end if
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->D ireac,prodrc ", ireac,prodrc
#endif
              
     !--old--
     !         prodrc = -rated(ireac)                                  &
     !&               * (r1 - satm(im)**ordm(ireac))
                 
            end if

          
!c  form product of reacting components in terms of total 
!c  aqueous component concentrations

            istart2 = iamdt(ireac)
            istop2 = iamdt(ireac+1)-1

            do i1 = istart2,istop2

              ic = jamdt(i1)
              prodrc = prodrc * totc(ic)**orddt(i1)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->E i1,prodrc ", i1,prodrc
#endif

            end do

!c  form product of reacting components as species in solution

            istart2 = iamdc(ireac)
            istop2 = iamdc(ireac+1)-1

            do i1 = istart2,istop2

              ic = jamdc(i1)
              prodrc = prodrc * (gammac(ic)*c(ic))**orddc(i1)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->F i1,prodrc ", i1,prodrc
#endif

            end do

!c  form product of reacting complexed species

            istart2 = iamdcx(ireac)
            istop2 = iamdcx(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdcx(i1)
              prodrc = prodrc * (gammax(ix)*cx(ix))**orddcx(i1)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->G i1,prodrc ", i1,prodrc
#endif

            end do
            
!c form product of reacting minerals
            
            istart2 = iamdphm(ireac)
            istop2 = iamdphm(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdphm(i1)
              prodrc = prodrc * (phim(ix)**ordmdphm(i1))
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->H i1,prodrc ", i1,prodrc
#endif

            end do

!c_uranium
!c  form product of summed reacting complexed species

            istart2 = iamdscx(ireac)
            istop2 = iamdscx(ireac+1)-1
            summed_species = .false.
            sumix = r0

            do i1 = istart2,istop2
              ix = jamdscx(i1)
              sumix = sumix + (gammax(ix)*cx(ix)*orddscx(i1))
              summed_species = .true.
            end do

            if (summed_species) then
              prodrc = prodrc * sumix**orddsumx(im)    
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->I i1,prodrc ", i1,prodrc
#endif
            end if       

!c  hyperbolic terms - T^a

            istart2 = iamdm(ireac)
            istop2 = iamdm(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamdm(i1)

                prodrc = prodrc                                       &
     &                 * (totc(ic)/(fmdm(i1) + totc(ic)))**ordmdm(i1)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->J i1,prodrc ", i1,prodrc
#endif
              end do

            end if
            
!c_isotopes
!c  hyperbolic terms - sum T^a

            istart2 = iamdsta2(ireac)
            istop2 = iamdsta2(ireac+1)-1
            itemp = r0
            
            do i1 = istart2, istop2                  

               istart3 = iamdsta(ireac)+itemp
               istop3 = istart3+ntsc(i1)-1
               sumic = r0
               do i2 = istart3, istop3
                 ic = jamdsta(i2)
                 sumic = sumic + totc(ic)
              end do

              prodrc = prodrc                                          &
     &              * (sumic/(fmdsta(i1) + sumic))**orddsta(i1)
               
              itemp = itemp + ntsc(i1)
#ifdef DEBUG
              write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                    "-->ratemin_new->K i1,prodrc ", i1,prodrc
#endif
            end do

!c_isotopes
!c  isotope fractionation - compute rate fractions for isotope dependent reactions
            
            !determine ratios and combine with alphas
            if ((.not.far_from_equil(im)).and.(satm(im,tid).lt.r1)) then
              next = 0 
              do i = 1, nifrm(im)  ! loop through isotope sets 
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                ibottom = jamdpair(istart2)
                alphartot = r1
                alphartop = r1
                !loop through isotope compents in set
                do i2 = istart2+1, istop2 
                    itop = jamdpair(i2)
                    alphar = phim(itop)/phim(ibottom)*jamdalpha(i2)
                    alphartot = alphartot + alphar
                    if (itop.eq.im) then
                      alphartop = alphar
                    end if
                end do
                
                prodrc = prodrc*alphartop/alphartot
#ifdef DEBUG
                write(idbg,'(a,1x,i6,1x,e16.8)')                        &
                      "-->ratemin_new->L i1,prodrc ", i,prodrc
#endif
              end do
            else
              next = 0 
              do i = 1, nifrm(im)  ! loop through isotope sets
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                ibottom = jamdiso(istart2)
                alphartot = r1
                alphartop = r1
                !loop through isotope compents in set
                do i2 = istart2+1, istop2 
                    itop = jamdiso(i2)
                    alphar = totc(itop)/totc(ibottom)*jamdalpha(i2)
                    alphartot = alphartot + alphar
                
                    istart = iam(im)
                    istop = iam(im+1)-1 
                    do i1 = istart, istop
                        ic = jam(i1)
                        if (ic.eq.itop) then
                           alphartop = alphar
                        end if
                    end do
                end do
                
                prodrc = prodrc*alphartop/alphartot
#ifdef DEBUG
                write(idbg,'(a,1x,i6,1x,e16.8)')                       &
                      "-->ratemin_new->M i1,prodrc ", i,prodrc
#endif
              end do
            end if

!c  inhibition terms - T^a

            istart2 = iamdi(ireac)
            istop2 = iamdi(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamdi(i1)

                prodrc = prodrc                                       &
     &                 * (fmdi(i1)/(fmdi(i1)+totc(ic)))**ordmdi(i1)
#ifdef DEBUG
                write(idbg,'(a,1x,i6,1x,e16.8)')                      &
                      "-->ratemin_new->N i1,prodrc ", i1,prodrc
#endif
              end do

            end if

!c  hyperbolic terms - C^c

            istart2 = iamhc(ireac)
            istop2 = iamhc(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamhc(i1)

                prodrc = prodrc                                       &
     &                 * (gammac(ic)*c(ic)                            &
     &                 / (fmhc(i1) + gammac(ic)*c(ic)))**ordmhc(i1)
#ifdef DEBUG
                write(idbg,'(a,1x,i6,1x,e16.8)')                      &
                      "-->ratemin_new->O i1,prodrc ", i1,prodrc
#endif
              end do

            end if

!c  inhibition terms - C^c

            istart2 = iamic(ireac)
            istop2 = iamic(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamic(i1)

                prodrc = prodrc                                       &
     &                 * (fmic(i1)                                    &
     &                 / (fmic(i1)+gammac(ic)*c(ic)))**ordmic(i1)
#ifdef DEBUG
                write(idbg,'(a,1x,i6,1x,e16.8)')                      &
                      "-->ratemin_new->P i1,prodrc ", i1,prodrc
#endif
              end do

            end if

!c  hyperbolic terms - phi^m

            istart2 = iamdpm(ireac)
            istop2 = iamdpm(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                im2 = jamdpm(i1)

                prodrc = prodrc * (phim(im2) /                        &
     &                   (fmdpm(i1) + phim(im2)))**ordmdpm(i1)
#ifdef DEBUG
                write(idbg,'(a,1x,i6,1x,e16.8)')                      &
                      "-->ratemin_new->Q i1,prodrc ", i1,prodrc
#endif
              end do

            end if

!c  inhibition terms - phi^m

            istart2 = iamdpi(ireac)
            istop2 = iamdpi(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                im2 = jamdpi(i1)

                prodrc = prodrc * (fmdpi(i1) /                        &
     &                   (fmdpi(i1) + phim(im2)))**ordmdpi(i1)
#ifdef DEBUG
                write(idbg,'(a,3e16.8)')                              &
                      "fmdpi(i1),phim(im2),ordmdpi(i1)",              &
                      fmdpi(i1),phim(im2),ordmdpi(i1)
                
                write(idbg,'(a,1x,i6,1x,e16.8)')                      &
                      "-->ratemin_new->R i1,prodrc ", i1,prodrc
#endif
              end do

            end if
            
!cmx compute the influence of salinity dependent mineral dissolution 
!      on the reaction rate for the case of sulfur bacteria reaction

            im3 = jamd(ireac)

            if (salinity_dependent(im3)) then
                salinity = 0.0
                do ic = 1, nc-1
                    if (namec(ic) .ne. 'o2(aq)') then
                        salinity = salinity + gfwc(ic)*totc(ic)
                    end if
                end do
          
                if (sdtype(im3) .eq. 'equation') then
                    sar = 0.0d0
              
                    if (salinity .le. min_salinity(im3)) then
                        sar = min_sar(im3)
                    else if (salinity .ge. max_salinity(im3)) then
                        sar = max_sar(im3)
                    else
                        do i = 1, nfac(im3)
                            sar = sar + sfac_sdmin(im3,i)*(salinity**(i-1))
                        end do
                    end if 
                end if
          
                if (sar .gt. 0.0 .and. sar .le. 1.0) then
                    prodrc = prodrc*sar
                else if (sar .le. 0.0) then
                    prodrc = prodrc*1.0d-10
                else
                    if (rank == 0 .and. b_enable_output) then
                        write(ilog,'(3a)') 'In file ratemin_new: error calculating ', &
                              'salinity dependent factor of mineral  ',namem(im3)
                        write(ilog,'(a,e12.5)') 'sfac_sdmin(im,1) ',sfac_sdmin(im3,1)
                        write(ilog,'(a,e12.5)') 'The salinity = ',salinity
                        write(ilog,'(a,e12.5)') 'The coefficient = ',sar
                        write(ilog,*) 'It should be between 0.0 to less or equal to 1.0.'                
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                end if
            end if            

!c  compute total rate for surface controlled reactions
!c  [moles/(l bulk*day)] = [m^2 mineral/l bulk]
!c                          ----------- 
!c                       * [moles/(m^2 mineral * day)]
!c                                 -----------

            ratemp(ireac,tid) = aream * prodrc

!c  sum up parallel reaction rates for surface controlled
!c  dissolution/precipitation reactions

            ratem = ratem + ratemp(ireac,tid)            
            

          end do       !loop over parallel diss/prec reactions

        else           !reaction_type

          ratem = r0
 
        end if         !reaction_type

!c  compute total dissolution rate for transport 
!c  controlled dissolution reactions

      elseif (rate_control(im).eq.'transport') then

        if (reaction_type(im).eq.'dissolution_far_from_equilibrium'.or.&
     &      reaction_type(im).eq.'reversible'.or.                      &
     &      (reaction_type(im).eq.'dissolution_to_equilibrium'.and.    &
     &       dg_lim(im)-satm(im,tid).gt.r0)) then

!c  compute total dissolution rate 
 
          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop

!c  scale reaction rate, if dissolution reaction is limited by
!c  equilibrium conditions 

            if (far_from_equil(im)) then
              prodrc = r1
            else
              prodrc = dg_lim(im)-satm(im,tid) 
            end if
#ifdef DEBUG
            write(idbg,'(a,1x,i6,1x,e16.8)')                         &             
                  "-->ratemin_new->S ireac,prodrc ", ireac,prodrc
#endif
!c  form product of reacting components in terms of total
!c  aqueous component concentrations

            istart2 = iamdt(ireac)
            istop2 = iamdt(ireac+1)-1

            do i1 = istart2,istop2
              ic = jamdt(i1)
              prodrc = prodrc * totc(ic)**orddt(i1)
            end do
#ifdef DEBUG
            write(idbg,'(a,1x,i6,1x,e16.8)')                         &             
                  "-->ratemin_new->T ireac,prodrc ", ireac,prodrc
#endif
!c  form product of reacting component species for current dissolution
!c  reaction, activity coefficients are here not considered explicitely,
!c  but are by definition included in the effective diffusion coefficient
 
            istart2 = iamdc(ireac)
            istop2 = iamdc(ireac+1)-1

            do i1 = istart2,istop2
              ic = jamdc(i1)
              prodrc = prodrc * c(ic)**orddc(i1)
            end do
#ifdef DEBUG
            write(idbg,'(a,1x,i6,1x,e16.8)')                         &             
                  "-->ratemin_new->U ireac,prodrc ", ireac,prodrc
#endif
!c  include complexed species in product of reacting species for current
!c  dissolution reaction
 
            istart2 = iamdcx(ireac)
            istop2 = iamdcx(ireac+1)-1
            do i1 = istart2,istop2
              ix = jamdcx(i1)
              prodrc = prodrc * cx(ix)**orddcx(i1)
            end do
            
            im3 = jamd(ireac)

            if (salinity_dependent(im3)) then
                salinity = 0.0
                do ic = 1, nc-1
                    if (namec(ic) .ne. 'o2(aq)') then
                        salinity = salinity + gfwc(ic)*totc(ic)
                    end if
                end do
          
                if (sdtype(im3) .eq. 'equation') then
                    sar = 0.0d0
              
                    if (salinity .le. min_salinity(im3)) then
                        sar = min_sar(im3)
                    else if (salinity .ge. max_salinity(im3)) then
                        sar = max_sar(im3)
                    else
                        do i = 1, nfac(im3)
                            sar = sar + sfac_sdmin(im3,i)*(salinity**(i-1))
                        end do
                    end if 
                end if
          
                if (sar .gt. 0.0 .and. sar .le. 1.0) then
                    prodrc = prodrc*sar
                else if (sar .le. 0.0) then
                    prodrc = prodrc*1.0d-10
                else
                    if (rank == 0 .and. b_enable_output) then
                        write(ilog,'(3a)') 'In file ratemin_new: error calculating ', &
                              'salinity dependent factor of mineral  ',namem(im3)
                        write(ilog,'(a,e12.5)') 'sfac_sdmin(im,1) ',sfac_sdmin(im3,1)
                        write(ilog,'(a,e12.5)') 'The salinity = ',salinity
                        write(ilog,'(a,e12.5)') 'The coefficient = ',sar
                        write(ilog,*) 'It should be between 0.0 to less or equal to 1.0.'                
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                end if
            end if            
            
#ifdef DEBUG
            write(idbg,'(a,1x,i6,1x,e16.8)')                         &             
                  "-->ratemin_new->V ireac,prodrc ", ireac,prodrc
#endif
!c  compute rate
!c  [moles/(l bulk*day)] = [m mineral / m^3 bulk]
!c                          ---------   ---
!c                       * [m^3 h2o/m^3 mineral * m^2 mineral/day]
!c                          --- --- -----------   -----------
!c                       * [moles/l h2o]
!c                                  ---

            ratemp(ireac,tid) = - aream * diffm(ireac)/xnud(ireac)    &
     &                    * prodrc

!c  sum up parallel rates

            ratem = ratem + ratemp(ireac,tid)

          end do  
 
!c  set reaction rate to zero for all other conditions
 
        else

          ratem = r0
 
        end if          !(reaction_type(im))

      end if            !(rate_control(im))

!cdbg
#ifdef DEBUG
      info_debug = 0
      if (rank == 0 .and. b_enable_output .and. info_debug.gt.0) then
          if (salinity_dependent(im)) then 
              write(*,'(a,i6)') 'im=',im
        write(*,'(a,e12.5)') 'ratem = ',ratem
        write(*,'(a,e12.5)') 'phim = ', phim(im)
        write(*,'(a,e12.5)') 'phimold = ', phimold
        write(*,'(a,e12.5)') 'aream = ', aream
          end if
          
      end if
      if (info_debug.eq.1) then
        !pause
      end if
#endif
!cdbg

      return
      end
