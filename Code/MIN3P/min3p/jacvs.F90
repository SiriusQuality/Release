!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 497 $
!> $Author: fgerard $
!> $Date: 2017-07-19 22:40:29 +0200 (mer., 19 juil. 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/min3p/jacvs.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacvs
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (variably saturated flow)
!c
!c written by:      Uli Mayer - May 29, 96
!c
!c last modified:   Uli Mayer - May 25, 01 
!c                  Sergi Molins - January 18,2003
!c                  added new var -> passed to soilparm
!c                  Sergi Molins - May 15, 2006
!c                  added new var -> passed to soilparm 
!c                  Sergi Molins - June 7, 2006
!c                  added chemical_water, qwater
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common: 
!c bbls.f    logical
!c           -------
!c           gas_bubbles         =.true. -> gas phase saturation is calculated      
!c                                below the water table   
!c 
!c phys.f    real*8
!c           -------
!c           aentry(nzn)        = air entry pressure 
!c   
!c	     logical:
!c           --------
!c           pure_evaporation   = .true.  -> physical evaporation only ! CBF ADDED
!c
!c gen.f:    real*8:
!c           -------
!c           avs(njavs)         = jacobian matrix                     - +
!c           bvs(nn)            = rhs vector                          - +
!c           cinfvs(njavs)      = influence coefficients              + -
!c           cvol(nn)           = nodal volumes                       + -
!c           delt               = time step                           + -
!c           dinc_vs            = increment for numerical             + -
!c                                differentiation
!c           hhead(nn)          = hydraulic head                      + -
!c           pornew(nn)         = porosity (new time level)           + -
!c           qwater(nn)         = rate of water production/consumpt.  + -
!c                                due to geochemical reactions 
!c           relperm(nn)        = relative permeability               * +
!c           relpinc(nn)        = relative permeability (incremented) * *
!c           sainc(nn)          = aqueous phase saturation            * *
!c                                - incremented
!c           sanew(nn)          = aqueous phase saturation            * +
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           uvsinc(nn)         = solution vector (incremented)       * *
!c           uvsnew(nn)         = solution vector (new time level)    * +
!c           uvsold(nn)         = solution vector (old time level)    + -
!c           vsflux(ncon-1)     = interfacial fluxes                  * *
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c added for gas transport:
!c
!c           relpermg(nn)       = relative gas permeability           + -
!c ------------------------
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        + -
!c
!c           logical:
!c           --------
!c           chemical_water     = .true.  -> account for production   + -
!c                                           or consumption of water
!c                                           due to geochemical 
!c                                           reactions in flow eq.
!c           root_uptake        = .true.  -> compute root water       + -
!c                                           uptake 
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c           character:
!c           ----------
!c           iups(ncon-1)       = upstream pointer                    * *
!c
!c
!c local:    real*8:
!c           -------
!c           dqroot             = derivative of root water uptake
!c           dtotvsflux         = derivative of total flux into
!c                                current control volume
!c           dvsstor            = derivative of storage term
!c           dvsflux            = derivative of flux term
!c           hhinc              = hydraulic head (incremented)
!c           qroot              = root water uptake for current
!c                                control volume
!c           qrootinc           = root water uptake for current 
!c                                control volume (incremented)
!c           totvsflux          = total flux into current control 
!c                                volume
!c           vsstor             = storage term for current control 
!c                                volume
!c           vsstorinc          = storage term for current control
!c                                volume (incremented variables)
!c           vsfluxinc          = interfacial flux (incremented 
!c                                variables)
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           ivol               = counter (control volumes)
!c           istart             = pointer (start of row)
!c           iend               = pointer (end of row)
!c           idiag              = pointer (diagonal)
!c           icon               = pointer (connections - local)
!c           isym               = symmetry pointer
!c           jvol               = row-column pointer
!c
!c external: rhsvs     = assembly of rhs vector
!c           rootwat   = function for computing root water uptake
!c           evapo : CBF
!c           storvs    = storage function for variably saturated 
!c                       flow 
!c           fluxvs    = flux function for variably saturated flow
!c           soilparm  = soil hydraulic parameters
!c ----------------------------------------------------------------------
 
      subroutine jacvs
 
      use parm
      use gen
      use phys
      use bbls
      use biol ! CBF at least for rewm     
 
#ifdef OPENMP
      use omp_lib 
#endif 
 
      implicit none
      
      integer :: i1, icon, ivol, idiag, istart, iend, isym, izn, jvol
      
      real*8 :: dvsflux, dvsstor, totvsflux, & !CBF  qroot, dqroot, qrootinc, & 
                vsstor, vsstorinc, vsfluxinc, fluxvs, storvs, rootwat, &
                hhinc, dtotvsflux, sa_eff_old, vsum, rew, evapo !CBF ADDED vsum, rew, evap
      integer :: chunk
      integer :: ivoll ! CBF 

      external storvs, fluxvs, rhsvs, rootwat, soilparm, evapo ! CBF ADDED evap

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
     
      totvsflux = r0 
      vsstor = r0 
      vsstorinc = r0


#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_flow

      if(mod(nngl, numofthreads_matrix_flow) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if

      if (i_chunksize_factor_flow > 1) then
            if(mod(chunk, i_chunksize_factor_flow) > 0) then
                chunk = chunk/i_chunksize_factor_flow + 1
            else
                chunk = chunk/i_chunksize_factor_flow
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_flow == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif 
     
!c_trap determine if imbibition is occuring
      
      if (trap_bubbles) then
        drainage = .false.
        main_drain = .false.
        
        do ivol=1,nngl
          izn = mpropvs(ivol)
          if (uvsnew(ivol).lt.aentry(izn)) then
            if (uvsnew(ivol).le.uvsold(ivol)) then
              drainage(ivol) = .true.
            end if
!c_trap set minimum effective saturation for trapped gas calculation
            sa_eff_old = (saold(ivol)-swr(izn))/(r1-swr(izn))
            if (sa_eff_old.le.sa_min(ivol)) then
               main_drain(ivol) = .true.
               sa_min(ivol) = sa_eff_old
            end if
          end if
        end do
      end if


!c  compute soil hydraulic parameters

      call soilparm(uvsnew,sanew,relperm,relpermg,sonew,mpropvs,nngl)


!c  compute total potential root uptake and estimate 
!c  scaling factor
!c  This part is not necessary, DSU 2014-07-09
      !if (root_uptake) then     
      !  do ivol = 1,nngl        
      !      qroot = cvol(ivol)*rootwat(sanew(ivol),mpropvs(ivol))        
      !  end do        
      !end if

!c  increment primary unknown
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol)                  
    !$omp do schedule(static)
#endif
      do ivol=1,nngl
        uvsinc(ivol) = uvsnew(ivol) + dinc_vs
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  compute incremented soil hydraulic parameters

       call soilparm(uvsinc,sainc,relpinc,relpincg,sonew,mpropvs,nngl)


!c_bubbles if change in permeability is due to gas bubble growth
!c_bubbles then relpinc = relperm, i.e. permeability is not a function of 
!c_bubbles hydraulic head
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, izn)                  
    !$omp do schedule(static)
#endif


   do ivol=1,nngl

	izn = mpropvs(ivol) 

        if (gas_bubbles.and.((uvsnew(ivol).ge.aentry(izn))             &
                 .and.(.not.unsaturated(ivol)))) then
          	relpinc(ivol) = relperm(ivol)
          	sainc(ivol)=sanew(ivol)
        end if

   end do


#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  build jacobian matrix
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_flow == 1)                       &
    !$omp num_threads(numofthreads_matrix_flow)                       &
    !$omp default(shared)                                             &
    !$omp private (i1, icon, idiag, iend, istart, isym, ivol, izn,    &
    !$omp jvol, dtotvsflux, dvsflux, dvsstor, hhinc,                  &
    !$omp totvsflux, vsflux, vsfluxinc)                               &
    !$omp firstprivate (iups, vsstor, qroot, vsstorinc, qrootinc,     &
    !$omp dqroot)
#endif

#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)    
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif

	
	

  do ivol = 1,nngl           !loop over control volumes

        idiag = iavs(ivol)       !pointer - diagonal 
        istart = iavs(ivol)+1    !pointer - start (off-diagonal entries)
        iend = iavs(ivol+1)-1    !pointer - end (off-diagonal entries)

!c  calculate storage and flux terms for current control volume

        totvsflux = r0           !initialize total influx
        icon = 0                 !counter (connections)


        do i1=istart,iend        !loop over connected control volumes 

		jvol = javs(i1)        !column pointer

!c  compute fluxes between current control volume and adjacent 
!c  control volumes

		icon = icon+1          !counter (row entries)

!c  assign pointer array for upstream weighting
 
		if (upstream) then
			iups(icon) = 'i' !h_i >= h_j

			if (hhead(jvol).gt.hhead(ivol)) then  !h_j > h_i
				iups(icon) = 'j'
			end if

		end if

!c  flux calculations
       
		vsflux(icon) = - fluxvs(upstream,hhead(ivol),hhead(jvol),   &
		&                            relperm(ivol),relperm(jvol),        &
		&                            iups(icon),cinfvs_a(i1))
		totvsflux = totvsflux + vsflux(icon)

	
          
!#ifdef DEBUG
!          if(ivol > 0 .and. ivol < 20) then
!            write(idbg,'(3(a,1x,i,1x),a,1x,l1,1x,2(a,1x),7(a,1x,e,1x))') & 
!                  "-->jacvs ivol",ivol,"jvol",jvol,"icon",icon,          &
!                  "upstream",upstream,"iups(icon)",iups(icon),           & 
!                  "hhead(ivol)",hhead(ivol),"hhead(jvol)",hhead(jvol),   &
!                  "relperm(ivol)",relperm(ivol),                         &
!                  "relperm(jvol)",relperm(jvol),"cinfvs(i1)",cinfvs(i1), &
!                  "vsflux(icon)",vsflux(icon),"totvsflux",totvsflux
!          end if
!#endif

        end do                   !loop over connected control volumes

	

!c  compute storage term (lumped) for current control volume, 
!c  only for transient conditions

        if (transient_flow) then
 
		vsstor = cvol(ivol)                                         &
		&           * storvs(uvsnew(ivol),uvsold(ivol),                  &
		&                    sanew(ivol),saold(ivol),                    &
		&                    mpropvs(ivol),stor(ivol))/delt              
      
        end if                   


!#ifdef DEBUG
!        if(ivol > 0 .and. ivol < 20) then
!            write(idbg,'(a,1x,i,1x,8(a,1x,e,1x))') "-->jacvs A ivol",  &
!                  ivol,"vsstor",vsstor,"cvol(ivol)",cvol(ivol),        &
!                  "uvsnew(ivol)",uvsnew(ivol),                         &
!                  "uvsold(ivol)",uvsold(ivol),                         &
!                  "sanew(ivol)",sanew(ivol),"saold(ivol)",saold(ivol), &
!                  "mpropvs(ivol)",mpropvs(ivol),"stor(ivol)",stor(ivol)
!        end if
!#endif


!c  compute root water uptake for current control volume

      	if (root_uptake) then

!CBF c  calculate mean reserve of extractible water : correction method for water stress = 2 
 
		rewm = r0 !CBF
		vsum = r0 !CBF non declare

		do ivoll = 1,nn
        	      vsum = vsum + cvol(ivoll)
 		enddo

		! CBF : vsum OK

		do ivoll = 1,nn
        	      rewm = rewm + (cvol(ivoll)*rew(sanew,ivoll))/vsum
		end do

		! CBF : rewm OK

		qroot(ivol) = r0

		!write(*,*) ' '
		!write(*,*) '***************************************************'
		!write(*,*) 'JACVS - ivol =', ivol
	
		qroot(ivol) = cvol(ivol)*(rootwat(sanew,ivol)+evapo(sanew,ivol))

!		write(*,*) ' '
!		write(*,*) 'JACVS - R.U. - qroot (', ivol,') =', qroot(ivol)
!		write(*,*) 'JACVS - R.U. - rootwat (', ivol,') =', rootwat(sanew,ivol)
!        write(*,*) 'JACVS - R.U. - evapo (', ivol,') =', evapo(sanew,ivol)
                
	  else ! to allow for phys. evaporation only CBF

		qroot(ivol) = r0

	    	qroot(ivol) = cvol(ivol)*evapo(sanew,ivol) 

		!write(*,*) 'JACVS - NOT R.U. - qroot (', ivol,') =', qroot(ivol) 

     	 end if


	

	!CBF
	
	!if(ivol.eq.20)then
	!	stop
	!endif
	!if(ivol.eq.300)then
        !       write(*,*) 'JACVS - R.U. - qroot (', ivol,') =', qroot(ivol)
        !endif



!c  assembly of storage and flux terms in rhs vector
!c  Anna Harrison added qh2o term Jan 24 2014

        if(water_removal) then
		totvsflux = totvsflux+qh2o(ivol)/delt  
        end if

        call rhsvs(vsstor,totvsflux,bvs(ivol))
        
!#ifdef DEBUG
!        if(ivol > 0 .and. ivol < 20) then
!            write(idbg,'(a,1x,i,1x,3(a,1x,e,1x))') "-->jacvs B ivol",  &
!                  ivol,"vsstor",vsstor,"totvsflux",totvsflux,          &
!                  "bvs(ivol)",bvs(ivol)
!        end if
!#endif

!c  add root water uptake (including evaporation if considered) or pure evaporation to rhs vector ! CBF ADDED

        if (root_uptake.or.pure_evaporation) then	! CBF ADDED pure_evaporation
          
		bvs(ivol) = bvs(ivol)-qroot(ivol)

		! CBF
        	!write(*,*) 'JACVS - bvs (', ivol,') =', bvs(ivol) 
	
        end if
        

        if (chemical_water) then

		bvs(ivol) = bvs(ivol)-qwater(ivol)

	endif


!c  calculate derivatives of storage and flux terms for current 
!c  control volume (assembly columnwise)


        hhinc = hhead(ivol)+dinc_vs  !increment hydraulic head
        dtotvsflux = r0          !initialize derivative of total influx
        icon = 0                 !counter (connections)


        do i1=istart,iend        !loop over connected control volumes

		jvol = javs(i1)        !column pointer
		isym = isymvs(i1)      !symmetry pointer

 
!c  assembly of flux terms (loop over adjacent control volumes)
!c  for steady state and transient conditions
!c  flux with incremented variables and derivative of flux
 
		icon = icon+1

		vsfluxinc = - fluxvs(upstream,hhinc,hhead(jvol),            &
		&              relpinc(ivol),relperm(jvol),iups(icon),cinfvs_a(i1))
		dvsflux = (vsfluxinc-vsflux(icon))/dinc_vs
		dtotvsflux = dtotvsflux+vsfluxinc

!c  assembly of flux terms in jacobian matrix (off diagonal entries)
 
  		avs(isym) = avs(isym) - dvsflux    !off-diagonal entries 

        end do                  !loop over connected control volumes


!c  compute storage term with incremented variables (lumped) 
!c  for current control volume, only for transient conditions


        if (transient_flow) then

		vsstorinc = cvol(ivol)                                      &
		&              * storvs(uvsinc(ivol),uvsold(ivol),               &
		&                       sainc(ivol),saold(ivol),                 &
		&                       mpropvs(ivol),stor(ivol))/delt
 
        end if                   !(transient_flow)


!c  assembly of diagonal entry in jacobian matrix
!c  storage term and total influx

        dvsstor = (vsstorinc - vsstor)/dinc_vs          !derivatives

!c_bubbles if change in storage is due to gas bubble growth
!c_bubbles then derivative of the storage is 0

        if (gas_bubbles) then
		izn = mpropvs(ivol) 

		if (uvsnew(ivol).ge.aentry(izn).and.(.not.unsaturated(ivol))) then
			dvsstor = r0
		end if

        end if
        
        dtotvsflux = (dtotvsflux - totvsflux)/dinc_vs

        avs(idiag) = avs(idiag) + dvsstor + dtotvsflux  !diagonal entry

!c  compute derivative of root water uptake (with evaporation) or only evaporation for current control volume ! CBF


      if (root_uptake) then
	
		 qrootinc(ivol) = cvol(ivol)*	&
     &                    (rootwat(sainc,ivol)+evapo(sainc,ivol))  ! CBF ADDED evap

		! CBF added (ivol) to *qroot* variables :

		dqroot(ivol) = (qrootinc(ivol)-qroot(ivol))/dinc_vs 

		avs(idiag) = avs(idiag) + dqroot(ivol)


		!write(*,*) ' '
		!write(*,*) 'JACVS - R.U. - qroot(ivol) =', qroot(ivol)
		!write(*,*) 'JACVS - R.U. - dqroot(ivol) =', dqroot(ivol)
		!write(*,*) 'JACVS - R.U. - avs (', idiag,') =', avs(idiag) 

	else ! to allow for phys. evaporation only

		qrootinc(ivol) = cvol(ivol)*evapo(sainc,ivol)

		dqroot(ivol) = (qrootinc(ivol)-qroot(ivol))/dinc_vs 
	   
		avs(idiag) = avs(idiag) + dqroot(ivol)

		!write(*,*) ' '
		!write(*,*) 'JACVS - NOT R.U. - qroot(ivol) =', qroot(ivol)
	 	!write(*,*) 'JACVS - NOT R.U. - dqroot(ivol) =', dqroot(ivol)
		!write(*,*) 'JACVS -NOT R.U.- avs (', idiag,') =', avs(idiag) 

      end if


  end do                        !loop over control volumes
  


#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
 
!  pause
!cdbg
!c     do ivol=1,nngl
!c       istart = iavs(ivol)
!c       iend = iavs(ivol+1)-1
!c       write(idbg,'(8e10.3)')(avs(i1),i1=istart,iend),bvs(ivol) 
!c     end do
!c     stop
!cdbg

  return

  end
