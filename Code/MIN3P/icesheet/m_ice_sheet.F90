!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/icesheet/m_ice_sheet.F90 $
!---------------------------------------------------------------------
!********************************************************************!

module m_ice_sheet

implicit none

!-------------------------------------------------------------------------
!
!   $Description: 
!
!   $Use:  
!
!   $Author: Sergio Andrï¿½s Bea Jofr?
!
!   $License: UBC
!
!-------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!private         ::
!% Parameters used to control maximum update in boundary pressure
!% to avoid extreme boundary condition update, DSU, 2015-12-15
real*8 :: max_update_pw
logical :: b_check_update_pw

real*8 :: max_update_pice
logical :: b_check_update_pice
!%------------------------------------------------------------------------
!% Public services 
!%------------------------------------------------------------------------
public:: &
 create_  &        ! Create ice sheet object 
,destroy_ &        ! Destroy ice sheet object
,set_ &
,compute_pice_ &
,compute_pw_ &
,compute_dpicedt_ &
,get_new_bc_ &
,read_ice_sheet_block_ &
,modify_for_permafrost_ &
,write_
!%------------------------------------------------------------------------
!% Private services 
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!% Type variable definition 
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
type, public::t_ice_sheet
 
!private                              :: 
 
character(len=100)                   :: name          ! Name of the species 
  
real*8                               :: a             ! Ice sheet constant 

real*8                               :: b             ! Ice sheet constant 

real*8                               :: logkxx        

real*8                               :: logkyy        

real*8                               :: logkzz 

real*8                               :: temp         

real*8                               :: lsource 

real*8                               :: zsource 

real*8                               :: densice

real*8                               :: densfresh

integer                              :: nstages 

logical, pointer, dimension(:)       :: isbc

real*8, pointer, dimension(:,:)      :: timestages

real*8, pointer, dimension(:,:)      :: hstages

real*8, pointer, dimension(:,:)      :: lstages

real*8, pointer, dimension(:,:)      :: thickpermstages

real*8, pointer, dimension(:,:)      :: l1permstages

real*8, pointer, dimension(:,:)      :: l2permstages

real*8, pointer, dimension(:)        :: hslope

real*8, pointer, dimension(:)        :: lslope

real*8, pointer, dimension(:)        :: facpw              ! Factor in order to scale the hydraulic head

real*8, pointer, dimension(:)        :: facpice            ! Factor in order to scale the ice sheet pressure

real*8, pointer, dimension(:)        :: l1permslope

real*8, pointer, dimension(:)        :: l2permslope

real*8, pointer, dimension(:)        :: thickpermslope

logical                              :: isconstant         
 
end type t_ice_sheet
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface create_
 
module procedure create_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface destroy_
 
module procedure destroy_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface set_
 
module procedure set_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface compute_pice_
 
module procedure compute_pice_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface compute_pw_
 
module procedure compute_pw_ice_sheet
module procedure compute_pw_ice_sheet_b
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface compute_dpicedt_
 
module procedure compute_dpicedt_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface read_ice_sheet_block_
 
module procedure read_ice_sheet_block_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface get_new_bc_
 
module procedure get_new_bc_ice_sheet
module procedure get_new_bc_ice_sheet_b
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface modify_for_permafrost_
 
module procedure modify_for_permafrost_k_ice_sheet 
module procedure modify_for_permafrost_temp_ice_sheet  

end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface write_
 
module procedure write_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface give_stage_
 
module procedure give_stage_ice_sheet
module procedure give_stage_ice_sheet_b
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface check_pointer_ice_sheet_
 
module procedure check_pointer_vr
module procedure check_pointer_ar 
module procedure check_pointer_vi 
module procedure check_pointer_vlogical 
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
contains
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine create_ice_sheet &
  (this)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Create  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this ! Type 
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8, parameter             :: &
 r0=0.0d0, &
 r1000=1.0d3, &
 r1=1.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
this%name=' '
this%a=r0
this%b=r0
this%densice=r1000
this%densfresh=r1000
this%lsource=r0
this%zsource=r0
this%nstages=0
this%temp=r0
this%logkxx=r0
this%logkyy=r0
this%logkzz=r0
this%isconstant=.false. 
!%------------------------------------------------------------
!% Nullify pointers 
!%------------------------------------------------------------
this%thickpermstages => null ()
this%l1permstages => null ()
this%l2permstages => null () 
this%l1permslope => null ()
this%l2permslope => null ()
this%thickpermslope => null ()
this%timestages => null ()
this%lstages => null ()
this%hstages => null ()
this%lslope => null ()
this%hslope => null ()
this%facpw => null ()
this%facpice => null ()
this%isbc => null ()
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine set_ice_sheet &
  (this, &
   name, &
   lsource, &
   zsource, &
   a, &
   b, &
   logkxx, &
   logkyy, &
   logkzz, &
   temp, &
   densice, &
   densfresh, &
   nstages, &
   isbc, &
   timestages, &
   hstages, &
   lstages, &
   facpw, &
   facpice, &
   l1permstages, &
   l2permstages, &
   thickpermstages, &
   isconstant, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this                     ! Type 

character(len=*), intent(in)     :: name

integer, intent(in)              :: nstages

real*8, intent(in)               :: a

real*8, intent(in)               :: b

real*8, intent(in)               :: logkxx

real*8, intent(in)               :: logkyy

real*8, intent(in)               :: logkzz

real*8, intent(in)               :: temp

real*8, intent(in)               :: lsource

real*8, intent(in)               :: zsource

real*8, intent(in)               :: densice

real*8, intent(in)               :: densfresh

real*8, intent(in)               :: timestages(2,nstages)

real*8, intent(in)               :: hstages(2,nstages)

real*8, intent(in)               :: lstages(2,nstages)

real*8, intent(in)               :: facpw(nstages)

real*8, intent(in)               :: facpice(nstages)

real*8, intent(in)               :: l1permstages(2,nstages)

real*8, intent(in)               :: l2permstages(2,nstages)

real*8, intent(in)               :: thickpermstages(2,nstages)

logical, intent(in)              :: isconstant

logical, intent(in)              :: isbc(nstages)

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i
real*8, parameter             :: &
 r0=0.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
this%name=name
this%a=a
this%b=b
this%lsource=lsource
this%zsource=zsource
this%densice=densice
this%densfresh=densfresh
this%nstages=nstages
this%logkxx=logkxx
this%logkyy=logkyy
this%logkzz=logkzz
this%temp=temp 
this%isconstant=isconstant 
!%------------------------------------------------------------
call check_pointer_ice_sheet_ (this%timestages,2,nstages,.true.)
this%timestages = timestages
call check_pointer_ice_sheet_ (this%hstages,2,nstages,.true.)
this%hstages = hstages
call check_pointer_ice_sheet_ (this%lstages,2,nstages,.true.)
this%lstages = lstages
call check_pointer_ice_sheet_ (this%l1permstages,2,nstages,.true.)
this%l1permstages = l1permstages
call check_pointer_ice_sheet_ (this%l2permstages,2,nstages,.true.)
this%l2permstages = l2permstages
call check_pointer_ice_sheet_ (this%thickpermstages,2,nstages,.true.)
this%thickpermstages = thickpermstages
call check_pointer_ice_sheet_ (this%facpw,nstages,.true.)
this%facpw = facpw
call check_pointer_ice_sheet_ (this%facpice,nstages,.true.)
this%facpice = facpice
call check_pointer_ice_sheet_ (this%hslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%lslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%l1permslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%l2permslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%thickpermslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%isbc,nstages,.true.)
this%isbc = isbc
!%------------------------------------------------------------
!% Compute slopes 
!%------------------------------------------------------------
do i=1,this%nstages

 this%hslope(i)=this%hstages(2,i)-this%hstages(1,i)
 this%hslope(i)=this%hslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%lslope(i)=this%lstages(2,i)-this%lstages(1,i)
 this%lslope(i)=this%lslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%l1permslope(i)=this%l1permstages(2,i)-this%l1permstages(1,i)
 this%l1permslope(i)=this%l1permslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%l2permslope(i)=this%l2permstages(2,i)-this%l2permstages(1,i)
 this%l2permslope(i)=this%l2permslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%thickpermslope(i)=this%thickpermstages(2,i)-this%thickpermstages(1,i)
 this%thickpermslope(i)=this%thickpermslope(i)/(this%timestages(2,i)-this%timestages(1,i))

end do
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine compute_pice_ice_sheet &
  (this, &
   pice, &
   time, &
   timeb, &
   l, &
   typedata, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     ! Type 

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: time

real*8, intent(in)               :: timeb

real*8, intent(out)              :: pice

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istages
real*8                        :: &
 htime, &
 ltime, &
 time1, &
 l1, &
 facpice
real*8, parameter             :: &
 r0=0.0d0, &
 r1=1.0d0, &
 g=9.81d0
character(len=100), parameter :: &
 pressure='pressure' 
real*8, parameter             :: &
 small=1.0d-10 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!%  
!%------------------------------------------------------------
istages=0
pice=r0
do i=1,this%nstages

 if (time>=this%timestages(1,i).and.time<=this%timestages(2,i) .and. &
     timeb>=this%timestages(1,i).and.timeb<=this%timestages(2,i)) then
   istages=i
   exit
 end if

end do

!%------------------------------------------------------------
if (istages==0) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istages) 
htime=this%hslope(istages)*time1 + this%hstages(1,istages)
ltime=this%lslope(istages)*time1 + this%lstages(1,istages)
facpice=this%facpice(istages)
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
l1=dabs(l-this%lsource)

if (l1<=ltime) then
    
    if (this%isconstant) then
       pice = htime
    else
       pice = htime * (r1 - (l1/ltime)**this%a )**(r1/this%b) 
    end if 
    
    pice = facpice * pice
    
    if (typedata==pressure) then
        pice=pice*this%densice*g
    end if

end if

!%------------------------------------------------------------
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine compute_pw_ice_sheet &
  (this, &
   pw, &
   time, &
   l, &
   z, &
   typedata, &
   iserror)

implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object
!
!   $Arguments:
!

type(t_ice_sheet), intent(in)    :: this                     ! Type

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: z

real*8, intent(in)               :: time

real*8, intent(out)              :: pw

logical, intent(out)             :: iserror

!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage
real*8                        :: &
 htime, &
 ltime, &
 time1, &
 l1, &
 z1, &
 facpw
logical                       :: &
 isbestage
real*8, parameter             :: &
 r0=0.0d0, &
 r1=1.0d0, &
 g=9.81d0, &
 small=1.0d-10
character(len=100), parameter :: &
 pressure='pressure'
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false.
!%------------------------------------------------------------
pw = r0
facpw = r1
!%------------------------------------------------------------
!% Check if the cell is corresponding to boundary
!%------------------------------------------------------------
z1=dabs(z-this%zsource)
if (z1>small) return
!%------------------------------------------------------------
!%
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)

!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage)
htime=this%hslope(istage)*time1 + this%hstages(1,istage)
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
facpw=this%facpw(istage)
!%------------------------------------------------------------
l1=dabs(l-this%lsource)
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
if (l1<=ltime) then

    if (this%isconstant) then
      pw = (this%densice/this%densfresh)*htime
    else
      pw = (this%densice/this%densfresh)*htime * (r1 - (l1/ltime)**this%a )**(r1/this%b)
    end if
    pw = facpw * pw
    if (typedata==pressure) then
        pw = pw * this%densice * g
    end if

end if
!%------------------------------------------------------------
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine compute_pw_ice_sheet_b &
  (this, &
   pw, &
   time, &
   timeb, &
   l, &
   z, &
   typedata, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     ! Type 

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: z

real*8, intent(in)               :: time

real*8, intent(in)               :: timeb

real*8, intent(out)              :: pw

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage
real*8                        :: &
 htime, &
 ltime, &
 time1, &
 l1, &
 z1, &
 facpw
logical                       :: &
 isbestage
real*8, parameter             :: &
 r0=0.0d0, &
 r1=1.0d0, &
 g=9.81d0, &
 small=1.0d-10 
character(len=100), parameter :: &
 pressure='pressure' 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
pw = r0
facpw = r1
!%------------------------------------------------------------
!% Check if the cell is corresponding to boundary 
!%------------------------------------------------------------
z1=dabs(z-this%zsource)
if (z1>small) return
!%------------------------------------------------------------
!%  
!%------------------------------------------------------------
call give_stage_ (this,istage,time,timeb, isbestage)

!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage) 
htime=this%hslope(istage)*time1 + this%hstages(1,istage)
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
facpw=this%facpw(istage)
!%------------------------------------------------------------
l1=dabs(l-this%lsource)
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
if (l1<=ltime) then
    
    if (this%isconstant) then
      pw = (this%densice/this%densfresh)*htime
    else 
      pw = (this%densice/this%densfresh)*htime * (r1 - (l1/ltime)**this%a )**(r1/this%b)
    end if
    pw = facpw * pw  
    if (typedata==pressure) then
        pw = pw * this%densice * g
    end if
    
end if
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine get_new_bc_ice_sheet &
  (this, &
   ivolbc, &
   valuebc, &
   ivolbc1, &
   valuebc1, &
   nvolbc, &
   xvol, &
   zvol, &
   nvol, &
   time, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description:  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     

integer, intent(in)              :: nvol

integer, intent(inout)           :: nvolbc

integer, intent(inout)           :: ivolbc(nvolbc)

real*8, intent(inout)            :: valuebc(nvolbc)

integer, intent(inout)           :: ivolbc1(nvolbc)     !work space

real*8,  intent(inout)           :: valuebc1(nvolbc)    !work space

real*8, intent(in)               :: xvol(nvol)

real*8, intent(in)               :: zvol(nvol)

real*8, intent(in)               :: time

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage, &
 ivol, &
 ibc
real*8                        :: &
 ltime, &
 time1, &
 l1, &
 z1
logical                       :: &
 isbestage
!integer, pointer              :: &
! ivolbc1(:) => null()
!real*8, pointer               :: &
! valuebc1(:) => null ()
real*8, parameter             :: &
 small=1.0d-10 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!% If the number of boundary conditions is equal to zero, 
!% return 
!%------------------------------------------------------------
if (nvolbc==0) return
!%------------------------------------------------------------
!% Determine the stage  
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
!% If the satge is not found return 
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage) 
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
!%------------------------------------------------------------
!call check_pointer_ice_sheet_ (ivolbc1,nvolbc,.true.)
!call check_pointer_ice_sheet_ (valuebc1,nvolbc,.true.)
ibc=0
do i=1,nvolbc
   ivol=ivolbc(i)
   l1=dabs(xvol(ivol)-this%lsource)
   z1=dabs(zvol(ivol)-this%zsource)
   if (z1<small) then
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
     if (l1>ltime.or.(l1<=ltime.and.this%isbc(istage))) then
        ibc = ibc + 1
        ivolbc1(ibc)=ivol
        valuebc1(ibc)=valuebc(i)
     end if
   else
     ibc = ibc + 1
     ivolbc1(ibc)=ivol   
     valuebc1(ibc)=valuebc(i)
   end if
end do
!%------------------------------------------------------------
!% Set the new number of boundary conditions 
!%------------------------------------------------------------
nvolbc=ibc
ivolbc=0
!%------------------------------------------------------------
!% Be carefully, number of boundary conditions could be zero!!
!%------------------------------------------------------------
if (nvolbc>0) then
   ivolbc(1:nvolbc)=ivolbc1(1:nvolbc)
   valuebc(1:nvolbc)=valuebc1(1:nvolbc)
end if
!%------------------------------------------------------------
!% Deallocate local pointers
!%------------------------------------------------------------
!call check_pointer_ice_sheet_ (ivolbc1,1,.false.)
!call check_pointer_ice_sheet_ (valuebc1,1,.false.)
!%------------------------------------------------------------
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine get_new_bc_ice_sheet_b &
  (this, &
   ivolbc, &
   valuebc, &
   ivolbc1, &
   valuebc1, &
   nvolbc, &
   xvol, &
   zvol, &
   nvol, &
   time, &
   timeb, &
   iserror)

implicit none
!-------------------------------------------------------------------------
!
!   $Description:
!
!   $Arguments:
!

type(t_ice_sheet), intent(in)    :: this

integer, intent(in)              :: nvol

integer, intent(inout)           :: nvolbc

integer, intent(inout)           :: ivolbc(nvolbc)

real*8, intent(inout)            :: valuebc(nvolbc)

integer, intent(inout)           :: ivolbc1(nvolbc)     !work space

real*8,  intent(inout)           :: valuebc1(nvolbc)    !work space

real*8, intent(in)               :: xvol(nvol)

real*8, intent(in)               :: zvol(nvol)

real*8, intent(in)               :: time

real*8, intent(in)               :: timeb

logical, intent(out)             :: iserror

!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage, &
 ivol, &
 ibc
real*8                        :: &
 ltime, &
 time1, &
 l1, &
 z1
logical                       :: &
 isbestage
!integer, pointer              :: &
! ivolbc1(:) => null()
!real*8, pointer               :: &
! valuebc1(:) => null ()
real*8, parameter             :: &
 small=1.0d-10
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false.
!%------------------------------------------------------------
!% If the number of boundary conditions is equal to zero,
!% return
!%------------------------------------------------------------
if (nvolbc==0) return
!%------------------------------------------------------------
!% Determine the stage
!%------------------------------------------------------------
call give_stage_ (this,istage,time,timeb,isbestage)
!%------------------------------------------------------------
!% If the satge is not found return
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage)
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
!%------------------------------------------------------------
!call check_pointer_ice_sheet_ (ivolbc1,nvolbc,.true.)
!call check_pointer_ice_sheet_ (valuebc1,nvolbc,.true.)
ibc=0
do i=1,nvolbc
   ivol=ivolbc(i)
   l1=dabs(xvol(ivol)-this%lsource)
   z1=dabs(zvol(ivol)-this%zsource)
   if (z1<small) then
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
     if (l1>ltime.or.(l1<=ltime.and.this%isbc(istage))) then
        ibc = ibc + 1
        ivolbc1(ibc)=ivol
        valuebc1(ibc)=valuebc(i)
     end if
   else
     ibc = ibc + 1
     ivolbc1(ibc)=ivol
     valuebc1(ibc)=valuebc(i)
   end if
end do
!%------------------------------------------------------------
!% Set the new number of boundary conditions
!%------------------------------------------------------------
nvolbc=ibc
ivolbc=0
!%------------------------------------------------------------
!% Be carefully, number of boundary conditions could be zero!!
!%------------------------------------------------------------
if (nvolbc>0) then
   ivolbc(1:nvolbc)=ivolbc1(1:nvolbc)
   valuebc(1:nvolbc)=valuebc1(1:nvolbc)
end if
!%------------------------------------------------------------
!% Deallocate local pointers
!%------------------------------------------------------------
!call check_pointer_ice_sheet_ (ivolbc1,1,.false.)
!call check_pointer_ice_sheet_ (valuebc1,1,.false.)
!%------------------------------------------------------------
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine read_ice_sheet_block_ice_sheet &
  (this, &
   idat, &
   istemp, &
   icetimeline, &
   iserror)
 
implicit none

external findstrg

!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this                     ! Type 

integer, intent(in)              :: idat

logical, intent(out)             :: iserror

logical, intent(in)              :: istemp 

real*8, allocatable              :: icetimeline(:,:)
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 nstages, &
 istage
real*8                        :: &
 a, &
 b, &
 densice, &
 densfresh, &
 logkxx, &
 logkyy, &
 logkzz, &
 lsource, &
 zsource, &
 temp
logical, pointer              :: &
 isbc(:) => null () 
real*8, pointer               :: &
 time(:,:) => null (), &
 h(:,:) => null (), &
 l(:,:) => null (), &
 l1perm(:,:) => null (), &
 l2perm(:,:) => null (), &
 thickperm(:,:) => null (), &
 facpw(:) => null (), & 
 facpice(:) => null () 
character(len=100)            :: &
 header, &
 subsection
logical                       :: &
 found, &
 isconstant 
real*8, parameter             :: &
 r0=0.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false.
temp=r0 
!%------------------------------------------------------------
header = 'ice sheet loading/unloading'
call findstrg(header,idat,found)
if (found) then
 read(idat,*,err=10) isconstant
 read(idat,*,err=10) lsource
 read(idat,*,err=10) zsource
 read(idat,*,err=10) a
 read(idat,*,err=10) b
 read(idat,*,err=10) logkxx
 read(idat,*,err=10) logkyy
 read(idat,*,err=10) logkzz
 if (istemp) then
  read(idat,*,err=10) temp
 end if
 read(idat,*,err=10) densice
 read(idat,*,err=10) densfresh
 read(idat,*,err=10) nstages
!%------------------------------------------------------------
!% Allocate local pointers 
!%------------------------------------------------------------ 
 call check_pointer_ice_sheet_ (time,2,nstages,.true.)
 call check_pointer_ice_sheet_ (h,2,nstages,.true.)
 call check_pointer_ice_sheet_ (l,2,nstages,.true.)
 call check_pointer_ice_sheet_ (l1perm,2,nstages,.true.)
 call check_pointer_ice_sheet_ (l2perm,2,nstages,.true.)
 call check_pointer_ice_sheet_ (thickperm,2,nstages,.true.)
 call check_pointer_ice_sheet_ (facpw,nstages,.true.)
 call check_pointer_ice_sheet_ (facpice,nstages,.true.)
 call check_pointer_ice_sheet_ (isbc,nstages,.true.)
 
!%------------------------------------------------------------
!% Get the timeline of ice loading/unloading, modify timestep when
!% this timeline is met. DSU, 2015-12-09
!%------------------------------------------------------------
if (allocated(icetimeline)) then
  deallocate(icetimeline)
end if
allocate(icetimeline(2,nstages))

!% Read ice loading/unloading stages
 do i=1,nstages
   read(idat,*,err=10) istage
   read(idat,*,err=10) isbc(i)
   read(idat,*,err=10) facpw(i)
   read(idat,*,err=10) facpice(i)
   read(idat,*,err=10) time(1,i),time(2,i)
   read(idat,*,err=10) l(1,i),l(2,i)
   read(idat,*,err=10) h(1,i),h(2,i) 
   read(idat,*,err=10) l1perm(1,i),l1perm(2,i) 
   read(idat,*,err=10) l2perm(1,i),l2perm(2,i) 
   read(idat,*,err=10) thickperm(1,i),thickperm(2,i) 

!% Set the value for ice timeline
   icetimeline(1,i) = time(1,i)
   icetimeline(2,i) = time(2,i)
 end do
else
 goto 20 
end if

!% Maximum pressure update in each timestep
subsection = 'maximum ice loading boundary pressure update'
call findstrg(subsection,idat,found)
if (found) then
  read(idat,*,err=10) max_update_pw
  b_check_update_pw = .true.
else
  b_check_update_pw = .false.
end if

!% Maximum pressure update in each timestep
subsection = 'maximum ice loading internal pressure update'
call findstrg(subsection,idat,found)
if (found) then
  read(idat,*,err=10) max_update_pice
  b_check_update_pice = .true.
else
  b_check_update_pice = .false.
end if


!%------------------------------------------------------------
!% Set the ice sheet object 
!%------------------------------------------------------------
call set_ (this,'ice sheet',lsource,zsource,a,b,logkxx,logkyy,logkzz, &
           temp,densice,densfresh,nstages,isbc,time,h,l,facpw,facpice, &
           l1perm,l2perm,thickperm,isconstant,iserror)
!%------------------------------------------------------------
!% Deallocate local pointers 
!%------------------------------------------------------------
call check_pointer_ice_sheet_ (time,1,1,.false.)
call check_pointer_ice_sheet_ (h,1,1,.false.)
call check_pointer_ice_sheet_ (l,1,1,.false.)
call check_pointer_ice_sheet_ (facpw,1,.false.)
call check_pointer_ice_sheet_ (facpice,1,.false.)
call check_pointer_ice_sheet_ (l1perm,1,1,.false.)
call check_pointer_ice_sheet_ (l2perm,1,1,.false.)
call check_pointer_ice_sheet_ (thickperm,1,1,.false.)
call check_pointer_ice_sheet_ (isbc,1,.false.)
if (iserror) goto 30  
!%------------------------------------------------------------
return
10 continue
iserror=.true.
write(*,*) 'Error when read ice sheet loading/unloding block'
return 
20 continue
iserror=.true.
write(*,*) 'Error ice sheet loading/unloding block not found'
return 
30 continue
iserror=.true.
write(*,*) 'Error when call service set_'
return 
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine write_ice_sheet &
  (this, &
   ioutput, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Write ice sheet information 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     ! Type 

integer, intent(in)              :: ioutput

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
write(ioutput,*) '-------------------------------------------------'
write(ioutput,*) 'Ice sheet object information'
write(ioutput,*) '-------------------------------------------------'
write(ioutput,*) 'Constant ice sheet loading:',this%isconstant
write(ioutput,*) 'Ice Sheet point source (x):',this%lsource,'[m]'
write(ioutput,*) 'Ice Sheet point source (z):',this%zsource,'[m]'
write(ioutput,*) 'Ice density:',this%densice
write(ioutput,*) 'Fresh-water density:',this%densfresh
write(ioutput,*) 'Log scale factor to kxx:',this%logkxx
write(ioutput,*) 'Log scale factor to kyy:',this%logkyy
write(ioutput,*) 'Log scale factor to kzz:',this%logkzz
write(ioutput,*) 'Temperature:',this%temp,'[oC]'
write(ioutput,*) 'Number of stages',this%nstages
!%------------------------------------------------------------
!% Loop for number of stages
!%------------------------------------------------------------
write(ioutput,*) '---------------------------------------------------------------------------' 
do istage=1,this%nstages
  write(ioutput,*) '---------------------------------------------------------------------------' 
  write(ioutput,30) 'Stage:',istage
  write(ioutput,10) 'Init and final time:',this%timestages(1,istage),this%timestages(2,istage)
  write(ioutput,10) 'Init and final max. thickness:',this%hstages(1,istage),this%hstages(2,istage)
  write(ioutput,10) 'Init and final max. extension:',this%lstages(1,istage),this%lstages(2,istage)
  write(ioutput,20) 'Scale factor for pw:',this%facpw(istage)
  write(ioutput,20) 'Scale factor for pice:',this%facpice(istage)
end do
write(ioutput,*) '---------------------------------------------------------------------------' 
write(ioutput,*) '---------------------------------------------------------------------------' 
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
return 
10 format (a30,2e15.7)
20 format (a30,e15.7)
30 format (a10,i5)
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine compute_dpicedt_ice_sheet &
  (this, &
   dpicedt, &
   time1, &
   time2, &
   l, &
   storcoeff, &
   density, &
   beta, &
   typedata, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this           ! Type ice sheet object

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: storcoeff

real*8, intent(in)               :: density 

real*8, intent(in)               :: time1

real*8, intent(in)               :: time2

real*8, intent(in)               :: beta          ! Skepton's coeffcient

real*8, intent(out)              :: dpicedt

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8                        :: &
 pice1, &
 pice2
real*8, parameter             :: &
 r0=0.0d0
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
dpicedt=r0
!%------------------------------------------------------------

call compute_pice_ (this,pice2,time2,time1,l,typedata,iserror)
if (iserror) return
call compute_pice_ (this,pice1,time1,time2,l,typedata,iserror)
if (iserror) return
!%------------------------------------------------------------
!% 
!%------------------------------------------------------------
dpicedt = density*storcoeff*beta*(pice2-pice1)
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine destroy_ice_sheet &
  (this)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Destroy  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this ! Type  
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8, parameter             :: &
 r0=0.0d0
!-------------------------------------------------------------------------
!
!   $code
!
!%-----------------------------------------------------------
this%name=' '
this%a=r0
this%b=r0
this%densice=r0
this%densfresh=r0
this%nstages=0
this%logkxx=r0
this%logkyy=r0
this%logkzz=r0
this%temp=r0
this%isconstant=.false. 
!%-----------------------------------------------------------
!% Deallocate and nullify pointers 
!%-----------------------------------------------------------
call check_pointer_ice_sheet_ (this%timestages,1,1,.false.)
call check_pointer_ice_sheet_ (this%lstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%hstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%lslope,1,.false.)
call check_pointer_ice_sheet_ (this%hslope,1,.false.)
call check_pointer_ice_sheet_ (this%facpw,1,.false.)
call check_pointer_ice_sheet_ (this%facpice,1,.false.)
call check_pointer_ice_sheet_ (this%thickpermstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%l1permstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%l2permstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%l1permslope,1,.false.)
call check_pointer_ice_sheet_ (this%l2permslope,1,.false.)
call check_pointer_ice_sheet_ (this%thickpermslope,1,.false.)
!%-----------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine modify_for_permafrost_k_ice_sheet &
  (this, &
   kxx, &
   kyy, &
   kzz, &
   ncells, &
   time, &
   x, &
   z, &
   nthreads, &
   numofloops_thred, &
   iserror)

#ifdef OPENMP
   use omp_lib 
#endif
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Modify hydraulic conductivity vector. The hidraulic 
! conductivity is reduced according to log cycles specified by user
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)              :: this            

integer, intent(in)                        :: ncells

real*8, intent(inout), dimension(ncells)   :: kxx

real*8, intent(inout), dimension(ncells)   :: kyy

real*8, intent(inout), dimension(ncells)   :: kzz

real*8, intent(in), dimension(ncells)      :: x

real*8, intent(in), dimension(ncells)      :: z

real*8, intent(in)                         :: time

integer*4, intent(in)                      :: nthreads

integer*8, intent(in)                      :: numofloops_thred

logical, intent(out)                       :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8                        :: &
 xloc, &
 zloc, &
 zperm, &
 l1perm, &
 l2perm, &
 l, &
 time1, &
 theta, &
 theta1 
logical                       :: &
 isbestage 
integer                       :: &
 icell, &
 i, &
 istage 
real*8, parameter             :: &
 r0=0.0d0, &
 r10=10.0d0 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
if (ncells==0) return
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage) 
l=this%lslope(istage)*time1 + this%lstages(1,istage)
l1perm=this%l1permslope(istage)*time1 + this%l1permstages(1,istage) 
l2perm=this%l2permstages(1,istage) - this%l2permslope(istage)*time1 
zperm = this%thickpermslope(istage)*time1 + this%thickpermstages(1,istage)  
theta=datan(zperm/l1perm)
!%------------------------------------------------------------
!% Loop for cells 
!%------------------------------------------------------------
#ifdef OPENMP
    !$omp parallel                                                    &                                                              
    !$omp if (ncells > numofloops_thred)                              & 
    !$omp num_threads(nthreads)                                       &
    !$omp default(shared)                                             &
    !$omp private (icell, xloc, zloc, theta1)
    !$omp do schedule(static)
#endif
do icell=1,ncells

  xloc=dabs(x(icell)-this%lsource)
  zloc=dabs(z(icell)-this%zsource)
  
  theta1 = datan(zloc/xloc)
  if(theta1<=theta &
       .and.xloc<=l1perm &
       .and.xloc>=l2perm &
       .and.zloc<=zperm) then
     
      kxx(icell) = kxx(icell) * r10**this%logkxx
      kyy(icell) = kyy(icell) * r10**this%logkyy
      kzz(icell) = kzz(icell) * r10**this%logkzz          
  
  end if
       
end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif  
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine modify_for_permafrost_temp_ice_sheet &
  (this, &
   temp, &
   x, &
   z, &
   time, &
   iserror)
   
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Modify temperature in the permafrost zone
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)              :: this            

real*8, intent(inout)                      :: temp

real*8, intent(in)                         :: x

real*8, intent(in)                         :: z

real*8, intent(in)                         :: time

logical, intent(out)                       :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8                        :: &
 xloc, &
 zloc, &
 l1perm, &
 l2perm, &
 l, &
 time1, &
 zperm, &
 theta, &
 theta1 
logical                       :: &
 isbestage 
integer                       :: &
 istage 
real*8, parameter             :: &
 r0=0.0d0, &
 r10=10.0d0 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage) 
l=this%lslope(istage)*time1 + this%lstages(1,istage)
l1perm=this%l1permslope(istage)*time1 + this%l1permstages(1,istage) 
l2perm=this%l2permslope(istage)*time1 + this%l2permstages(1,istage)
zperm = this%thickpermslope(istage)*time1 + this%thickpermstages(1,istage)  
theta=datan(zperm/l1perm)
!%------------------------------------------------------------
!%  
!%------------------------------------------------------------
xloc=dabs(x-this%lsource)
zloc=dabs(z-this%zsource)
theta1 = datan(zloc/xloc)
  
if(theta1<=theta &
       .and.xloc<=l1perm &
       .and.xloc>=l2perm &
       .and.zloc<=zperm) then
     
       temp = this%temp
      
end if 
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine give_stage_ice_sheet &
  (this, &
   istage, &
   time, &
   isbe)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description:  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)              :: this            

integer,intent(out)                        :: istage

real*8, intent(in)                         :: time

logical, intent(out)                       :: isbe

!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
isbe=.false. 
!%------------------------------------------------------------
!%------------------------------------------------------------
istage=0
do i=1,this%nstages

 if (time>=this%timestages(1,i).and.time<=this%timestages(2,i)) then
   istage=i
   isbe=.true.
   exit
 end if

end do
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine give_stage_ice_sheet_b &
  (this, &
   istage, &
   time, &
   timeb, &
   isbe)

implicit none
!-------------------------------------------------------------------------
!
!   $Description:
!
!   $Arguments:
!

type(t_ice_sheet), intent(in)              :: this

integer,intent(out)                        :: istage

real*8, intent(in)                         :: time

real*8, intent(in)                         :: timeb

logical, intent(out)                       :: isbe

!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
isbe=.false.
!%------------------------------------------------------------
!%------------------------------------------------------------
istage=0
do i=1,this%nstages

 if (time>=this%timestages(1,i).and.time<=this%timestages(2,i) .and. &
     timeb>=this%timestages(1,i).and.timeb<=this%timestages(2,i)) then
   istage=i
   isbe=.true.
   exit
 end if

end do
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_vi (pa,ndim,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif

    implicit none
      ! External variables
    integer(4), intent(in)         :: ndim
    integer(4), pointer            :: pa(:)
    logical, intent(in)            :: isallocate
    integer                        :: stat

      if (isallocate) then
     if (associated(pa)) then
         if (size(pa).ne.ndim) then

           deallocate (pa,stat=stat)
           if (stat>0) goto 10
           allocate (pa(ndim),stat=stat) 

           if (stat>0) goto 10
         end if
     else
        allocate (pa(ndim),stat=stat)

      if (stat>0) goto 10
     end if
       pa=0
    else
      if (associated(pa)) then
       deallocate (pa,stat=stat)
         if (stat>0) goto 10
      end if
      pa => null () 
      
    end if

!c-----------------------------------------------------------
      return
10    print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
    end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_vlogical (pa,ndim,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif

    implicit none
      ! External variables
    integer(4), intent(in)         :: ndim
    logical, pointer               :: pa(:)
    logical, intent(in)            :: isallocate
    integer                        :: stat

      if (isallocate) then
     if (associated(pa)) then
         if (size(pa).ne.ndim) then

           deallocate (pa,stat=stat)
           if (stat>0) goto 10
           allocate (pa(ndim),stat=stat) 

           if (stat>0) goto 10
         end if
     else
        allocate (pa(ndim),stat=stat)

      if (stat>0) goto 10
     end if
       pa=.false.
    else
      if (associated(pa)) then
       deallocate (pa,stat=stat)
         if (stat>0) goto 10
      end if
      pa => null () 
      
    end if

!c-----------------------------------------------------------
      return
10    print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
    end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************    
subroutine check_pointer_vr (pa,ndim,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif
    implicit none
      ! External variables
    integer(4), intent(in)         :: ndim
    real(8), pointer               :: pa(:)
    logical, intent(in)            :: isallocate
    integer                        :: stat

      if (isallocate) then
     if (associated(pa)) then
         if (size(pa).ne.ndim) then

           deallocate (pa,stat=stat)
           if (stat>0) goto 10
           allocate (pa(ndim),stat=stat) 

           if (stat>0) goto 10
         end if
     else
        allocate (pa(ndim),stat=stat)

      if (stat>0) goto 10
     end if
       pa=0.0d0   
    else
      if (associated(pa)) then
       deallocate (pa,stat=stat)
         if (stat>0) goto 10
      end if
      pa => null () 
      
    end if

!c-----------------------------------------------------------
      return
10    print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
    end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_ar (pa,ndim1,ndim2,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
    implicit none

      ! External variables
    real(8), pointer    :: pa(:,:)
    integer(4)          :: ndim1,ndim2
    logical             :: isallocate
    integer             :: stat

      if (isallocate) then
     if (associated(pa)) then
        if (size(pa,1).ne.ndim1.or.size(pa,2).ne.ndim2) then
        deallocate (pa,stat=stat)
       
        if (stat>0) goto 10
        allocate (pa(ndim1,ndim2),stat=stat)
       
        if (stat>0) goto 10
        end if 
     else
        allocate (pa(ndim1,ndim2),stat=stat) 
      
      if (stat>0) goto 10
     end if
       
      pa=0.0d0
    
    else
      if (associated(pa)) then
        deallocate (pa,stat=stat)
        if (stat>0) goto 10
      end if
      pa => null () 
      
    end if
!c-----------------------------------------------------------
      return
10    print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop 
    end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************    
! subroutine findstrg(subsection,itmp,found_subsection)
!
!      logical found_subsection
!      character*72 subsection,string
! 
!!c  rewind input file
!
!      rewind(itmp)
!
!!c  search for test string in input file
!
!      found_subsection = .false.
!      do while (.not.found_subsection)
!        read(itmp,*,end=999) string
!        if (string.eq.subsection) then
!          found_subsection = .true.
!        end if
!      end do
!
!999   return
!      end subroutine
!%************************************************************
!%************************************************************
!%************************************************************
!%************************************************************
!%************************************************************
end module m_ice_sheet 
