!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 296 $
!> $Author: dsu $
!> $Date: 2015-04-07 22:22:37 +0200 (Tue, 07 Apr 2015) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/dgm/drt_hubb.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function drt_hubb
!c ------------------------
!c
!c derivative of flux calculated as hubbert potential
!c
!c written by:  Sergi Molins - January 18,2003    
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           totc_i             = total aqueous component             + -
!c                                concentration in control volume i
!c           totc_j             = total aqueous component             + -
!c                                concentration in control volume j
!c           cinfrt_v           = influence coeffcient for            + -
!c                                advective flux
!c           fluxv_vl           = advective flux                      * +
!c
!c           integer*4:
!c           ----------
!c           i                  = pointer to control volume i         + -
!c           j                  = pointer to control volume j         + -
!c           ic                 = pointer to current component        + -
!c
!c
!c gen.f:    real*8:
!c           -------
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c
!c           integer*4:
!c           ----------
!c                        = pointer to control volume           + -
!c                                (upstream point), 
!c
!c           character:
!c           ----------
!c           spt_weight         = 'upstream' -> upstream weigthing    + -
!c                                'centered' -> centered weighting
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           eps              = constant
!c           r0               = constant
!c           r1               = constant
!c           r2               = constant
!c           rhalf            = constant
!c           rquarter         = constant
!c
!c external: -  
!c ----------------------------------------------------------------------
 
      real*8 function drt_hubb(totg_i    ,totg_j    ,    &
                               gpi       ,gpj       ,    &
                               zgi       ,zgj       ,    &
                               relpermg_i,relpermg_j,    &
                               dens_i    ,dens_j    ,    &
                               visc_i    ,visc_j    ,    &
                               i         ,j         ,    &
                               cinfvs_gx ,ic        ,    &
                               iupsgx    ,spt_weight,    &
                               ddens_i   ,dp_i      )
 
      use gen
	
	  implicit none

!c  constants
      real*8, parameter :: r0 = 0.0d0, rhalf = 0.5d0,    &
                           eps = 1.0d-30, gref = 1.01d+5

!c  passed
      real*8       totg_i    ,totg_j    ,                &
                   gpi       ,gpj       ,                &
                   zgi       ,zgj       ,                &
                   relpermg_i,relpermg_j,                &
                   dens_i    ,dens_j    ,                &
                   visc_i    ,visc_j    ,                &
                   cinfvs_gx ,ddens_g   ,                &
                   dp      
      
	  integer*4    i, j, ic        
	  character*1  iupsgx
	  character*12 spt_weight
	
!c  internal
      real*8       hi        ,hj,                        &
                   hubbi     ,hubbj,                     &
                   totg_ij   ,relp,                      &
                   visc      ,grad,                      &
                   dens      ,ddens,                     &
                   dpx       ,fluxvg,                    &
                   fluxvg2
      
      real*8 :: gpix, gpjx, ddens_i, dp_i

       
      gpix = gpi
      gpjx = gpj 
	  
      if (gpix.lt.eps) gpix = 1.01d5
      if (gpjx.lt.eps) gpjx = 1.01d5

!c     hubbert potential
      hi = log(gpix/gref) * gpix / dens_i + gacc * zgi
      hj = log(gpjx/gref) * gpjx / dens_j + gacc * zgj
 
!c  compute relative permeability
 
      if (iupsgx.eq.'a') then
        
	    if ((hi-hj).gt.r0) then
          totg_ij = totg_i
	      relp    = relpermg_i
	      visc    = visc_i
	      dens    = dens_i
		  ddens   = ddens_i
		  dpx     = dp_i	   
        else
          totg_ij = totg_j
	      relp    = relpermg_j
	      visc    = visc_j
	      dens    = dens_j
	      ddens   = r0
	      dpx     = r0	   
        end if
	
	  else if (iupsgx.eq.'i') then

	    totg_ij = totg_i
	    relp    = relpermg_i
	    visc    = visc_i
	    dens    = dens_i
	    ddens   = ddens_i
	    dpx     = dp_i	   

      else if (iupsgx.eq.'j') then
	  
	    totg_ij = totg_j
	    relp    = relpermg_j
	    visc    = visc_j 
        dens    = dens_j
	    ddens   = r0
	    dpx     = r0

      endif     

!c first component 

!c     compute gradient
      grad = - (hj - hi)     !sign

!c     compute specific discharge
      fluxvg = cinfvs_gx * relp * grad * ddens / visc

!c     compute advective flux
      fluxvg = fluxvg * totg_ij

!c second component
      fluxvg2 = cinfvs_gx * relp * dens * gref * dpx * totg_ij /       &
                visc / dens
      
      drt_hubb = fluxvg + fluxvg2
     	
      return
      end