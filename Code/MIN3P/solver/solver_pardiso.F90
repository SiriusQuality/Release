!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/solver/solver_pardiso.F90 $
!---------------------------------------------------------------------
!********************************************************************!

#ifdef PARDISO

include 'mkl_pardiso.f90'

!> module: solver_pardiso
!>
!> written by: Danyang Su
!>
!> module description:
!>
!> module of pardiso solver for unsymmetric linear systems  
!> meaning of the parameters for pardiso can be found via
!> http://software.intel.com/en-us/articles/pardiso-parameter-table
!> http://software.intel.com/sites/products/documentation/doclib/mkl_sa/11/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm#IPARM34
!> Pardiso vs iterative solver with ILU preconditioning
!> PTSc is an iterative solver whereas PARDISO direct one. Iterative methods with ILU preconditioned 
!> for good conditioner number converge faster than direct on the other hand direct return near exact 
!> solution. For ill condition matrix situation change a bit - converge of iterative solver become poor 
!> and direct method return solution quicker (its speed doesn't depend on condition number) but residual
!> can be bad. These reasoning depend on preconditioner - so that's a hard to compare this 2 absolutely 
!> different approach of solving system of linear equation. 
module solver_pardiso


    use mkl_pardiso

    use gen, only : ilog, rank, b_enable_output
    use matrix_utility, only : remap_matrix_ja, remap_matrix_a_ja            !for test, dsu
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif
    
    implicit none
        
    integer, parameter :: dp = kind(1.0d0)
    
    !********************************************************************!
    !> Pardiso solver parameters
    !> pt(64) -> pardiso solver internal data address pointer,  must be initialized with zeros and never be modified later

    type(MKL_PARDISO_HANDLE) :: pt(64)
    type(MKL_PARDISO_HANDLE) :: ptvs(64)
    type(MKL_PARDISO_HANDLE) :: ptglob(64)
    type(MKL_PARDISO_HANDLE) :: ptrt(64)


    !> Number of unknows 
    integer :: n_unknown_vs     = -1
    integer :: n_unknown_glob   = -1
    integer :: n_unknown_rt     = -1

    !> iparm(64) -> This array is used to pass various parameters to Intel MKL PARDISO and to return some useful information
    !> after execution of the solver (see pardiso iparm Parameter for more details) 
    !> If iparm(1)=0 , Intel MKL PARDISO fills iparm(2) through iparm(64) with default values and uses them. 
    integer :: iparm(64)
    integer :: iparm_vs(64)
    integer :: iparm_glob(64)
    integer :: iparm_rt(64)
    
    !> maxfct -> Maximal number of factors in memory, generally used value is 1
    integer :: maxfct
    
    !> mnum -> The number of matrix (from 1 to maxfct) to solve, generally used value is 1
    integer :: mnum
    
    !> mtype -> Matrix type, 
    !>      1         Real and structurally symmetric
    !>      2         Real and symmetric positive definite
    !>      -2         Real and symmetric indefinite
    !>      3         Complex and structurally symmetric
    !>      4         Complex and Hermitian positive definite
    !>      -4         Complex and Hermitian indefinite
    !>      6         Complex and symmetric matrix
    !>      11         Real and nonsymmetric matrix 
    !>      13         Complex and nonsymmetric matrix 
    integer :: mtype
    
    !> phase -> Controls the execution of the solver
    !>      11        Analysis
    !>      12         Analysis, numerical factorization
    !>      13         Analysis, numerical factorization, solve
    !>      22         Numerical factorization
    !>      23         Numerical factorization, solve
    !>      33         Solve, iterative refinement
    !>      331     phase=33, but only forward substitution
    !>      332     phase=33, but only diagonal substitution
    !>      333     phase=33, but only backward substitution
    !>      0         Release internal memory for L and U of the matrix number mnum
    !>      -1         Release all internal memory for all matrices 
    integer :: phase
    
    !> nrhs -> Number of right-hand sides that need to be solved for, generally used value is 1 
    integer :: nrhs
    
    !> error -> Error indicator 
    !>      0         No error
    !>      -1         Input inconsistent
    !>      -2         Not enough memory
    !>      -3         Reordering problem
    !>      -4         Zero pivot, numerical factorization or iterative refinement problem
    !>      -5         Unclassified (internal) error
    !>      -6         Reordering failed (matrix types 11 and 13 only)
    !>      -7         Diagonal matrix is singular
    !>      -8         32-bit integer overflow problem
    !>      -9         Not enough memory for OOC
    !>      -10     Problems with opening OOC temporary files
    !>      -11     Read/write problems with the OOC data file  
    integer :: error
    
    !> msglvl -> Message level information 
    !>      0         Intel MKL PARDISO generates no output 
    !>      1       Intel MKL PARDISO prints statistical information
    integer :: msglvl
    
    !> idum(1)
    integer :: idum(1)
    
    !> ddum(1)
    real(kind = dp) ::  ddum(1)
    
    
    !> number of threads
    integer :: numofthreads_pardiso = 1
    !> maximum number of iterative refinement steps in flow
    integer :: max_refine_itersteps_flow = 9
    !> maximum number of iterative refinement steps in reactive transport
    integer :: max_refine_itersteps_react = 9    
    
    !> pivoting perturbation in flow
    integer :: npivotpertubation_flow  = 13
    
    !> pivoting perturbation in reactive transport
    integer :: npivotpertubation_react = 13
    
    !> preconditioned CGS in flow
    integer :: i_cgs_criterion_flow = 0
    
    !> preconditioned CGS in reactive transport
    integer :: i_cgs_criterion_react = 0
    
    
    !********************************************************************!
    !> matrix variables
    integer, allocatable :: ia(:)
    integer, allocatable :: ja(:)
    integer, allocatable :: index_ja(:)
    real(kind = dp), allocatable :: a(:)
    real(kind = dp), allocatable :: b(:)    
    real(kind = dp), allocatable :: x(:)
    real(kind = dp), allocatable :: res(:)
    real(kind = dp), allocatable :: errb(:)
    
    !********************************************************************!
    !> file relative variables
    integer :: inum = 0
    integer :: iunit
    character(12) :: strnum
    
    !********************************************************************!
   
    !> interface for pardiso symbolic factorization
    interface pardiso_symbolicfactorization
        module procedure pardiso_symbfactor_1
        module procedure pardiso_symbfactor_2
    end interface pardiso_symbolicfactorization
    
    !> interface for pardiso numerical factorization
    interface pardiso_numfactorization
        module procedure pardiso_numfactor_1
        module procedure pardiso_numfactor_2
    end interface pardiso_numfactorization
    
    !> interface for pardiso substitution
    interface pardiso_substitution
        module procedure pardiso_substitution_1
        module procedure pardiso_substitution_2
        module procedure pardiso_substitution_test
    end interface pardiso_substitution
    
    !> interface for pardiso solver memory release
    interface pardiso_release_memory
        module procedure pardiso_release_memory_1
        module procedure pardiso_release_memory_all
    end interface pardiso_release_memory
        
    contains
    
   
    !> Initialize pardiso solver
 
    subroutine pardiso_initialize
    
        implicit none
       
        pt%DUMMY = 0         
        !set up PARDISO control parameter
        iparm= 0
        iparm(1) = 1 ! no solver default
        iparm(2) = 3 ! fill-in reordering from METIS ,0-MIN DEGREE, 2-METIS, 3-OPENMP VERSION
        iparm(3) = 0 ! numbers of processors. Input the next call mkl_set_dynamic(0), mkl_set_num_threads(n);    
        iparm(4) = 0 ! 0-no iterative-direct algorithm; 10*L+1 - CGS; 10*L+2 - CG; 10^-L is the tolerance.
        iparm(5) = 0 ! no user fill-in reducing permutation
        iparm(6) = 0 ! if == 1, the array of b is replaced with the solution x.
        iparm(7) = 0 ! not in use
        iparm(8) = 9 ! numbers of iterative refinement steps, must be 0 if a solution is calculated with separate substitutions (phase = 331, 332, 333)
        iparm(9) = 0 ! not in use
        iparm(10) = 13 ! Default value 13, perturbe the pivot elements with 1E-13
        iparm(11) = 1 ! use nonsymmetric permutation and scaling MPS
        iparm(12) = 0 ! not in use
        iparm(13) = 1 ! maximum weighted matching algorithm is switched-on (default for non-symmetric)
        iparm(14) = 0 ! Output: number of perturbed pivots
        iparm(15) = 0 ! not in use
        iparm(16) = 0 ! not in use
        iparm(17) = 0 ! not in use
        iparm(18) = -1 ! Output: number of nonzeros in the factor LU
        iparm(19) = -1 ! Output: Mflops for LU factorization
        iparm(20) = 0  ! Output: Numbers of CG Iterations
        iparm(27) = 0   !check matrix error, 0-without check, 1-check
        
        if (rank == 0 .and. b_enable_output) then
          write(*,*) "Pardiso solver initialization completed ... "
        end if
        
    end subroutine pardiso_initialize  
    
    !initialize pardiso common
    subroutine pardiso_initialize_common
    
        implicit none
       
        maxfct = 1        
        mnum = 1        
        nrhs = 1        
        error = 0 ! initialize error flag        
        msglvl = 0 ! print statistical information        
        mtype = 11 ! real unsymmetric 
        
        if (numofthreads_pardiso > 0) then
            call mkl_set_dynamic(0);
            call mkl_set_num_threads(numofthreads_pardiso);
        end if
    
    end subroutine pardiso_initialize_common
    
    !> Initialize pardiso for flow problem
    subroutine pardiso_initialize_flow
    
        implicit none
        
        ptvs%DUMMY = 0
        !set up PARDISO control parameter for flow
        iparm_vs= 0
        iparm_vs(1) = 1 ! no solver default
        iparm_vs(2) = 3 ! fill-in reordering from METIS ,0-MIN DEGREE, 2-METIS, 3-OPENMP VERSION
        iparm_vs(3) = 0 ! numbers of processors. Input the next call mkl_set_dynamic(0), mkl_set_num_threads(n);    
        iparm_vs(4) = i_cgs_criterion_flow ! 0-no iterative-direct algorithm; 10*L+K, K=1 CGS, K=2 CGS for symmetric, 1.0E-L: stopping criterion 
        iparm_vs(5) = 0 ! no user fill-in reducing permutation
        iparm_vs(6) = 0 ! if == 1, the array of b is replaced with the solution x.
        iparm_vs(7) = 0 ! Output, Number of iterative refinement steps performed
        iparm_vs(8) = max_refine_itersteps_flow ! numbers of iterative refinement steps, must be 0 if a solution is calculated with separate substitutions (phase = 331, 332, 333)
        iparm_vs(9) = 0 ! not in use
        iparm_vs(10) = npivotpertubation_flow ! Default value 13, perturbe the pivot elements with 1E-13
        iparm_vs(11) = 1 ! use nonsymmetric permutation and scaling MPS
        iparm_vs(12) = 0 ! not in use
        iparm_vs(13) = 1 ! maximum weighted matching algorithm is switched-on (default for non-symmetric)
        iparm_vs(14) = 0 ! Output: number of perturbed pivots
        iparm_vs(15) = 0 ! Output, Peak memory on symbolic factorization. 
        iparm_vs(16) = 0 ! Output, Permanent memory on symbolic factorization. This value is only computed in phase 1.
        iparm_vs(17) = 0 ! Output, Size of factors/Peak memory on numerical factorization and solution.
        iparm_vs(18) = 0 ! Input/output. Report the number of non-zero elements in the factors. >= 0 Disable reporting.
        iparm_vs(19) = 0 ! Input/output. Report number of floating point operations to factor matrix A. >= 0 Disable reporting.
        iparm_vs(20) = 0 ! Output: Numbers of CG Iterations. >0 CGS succeeded, reports the number of completed iterations.
        iparm_vs(24) = 1 ! Parallel factorization control, 0: classic algorithm, 1: two-level factorization algorithm, improve scalability on many threads.
        iparm_vs(25) = 0 ! Parallel forward/backward solve control. 0: Use parallel algorithm for the solve step; 1: Use the sequential forward/backward solve. 
        iparm_vs(27) = 0 !check matrix error, 0-without check, 1-check 
        
        ptglob%DUMMY = 0
        !set up PARDISO control parameter for flow
        iparm_glob= 0
        iparm_glob(1) = 1 ! no solver default
        iparm_glob(2) = 3 ! fill-in reordering from METIS ,0-MIN DEGREE, 2-METIS, 3-OPENMP VERSION
        iparm_glob(3) = 0 ! numbers of processors. Input the next call mkl_set_dynamic(0), mkl_set_num_threads(n);    
        iparm_glob(4) = i_cgs_criterion_flow ! 0-no iterative-direct algorithm; 10*L+K, K=1 CGS, K=2 CGS for symmetric, 1.0E-L: stopping criterion 
        iparm_glob(5) = 0 ! no user fill-in reducing permutation
        iparm_glob(6) = 0 ! if == 1, the array of b is replaced with the solution x.
        iparm_glob(7) = 0 ! Output, Number of iterative refinement steps performed
        iparm_glob(8) = max_refine_itersteps_flow ! numbers of iterative refinement steps, must be 0 if a solution is calculated with separate substitutions (phase = 331, 332, 333)
        iparm_glob(9) = 0 ! not in use
        iparm_glob(10) = npivotpertubation_flow ! Default value 13, perturbe the pivot elements with 1E-13
        iparm_glob(11) = 1 ! use nonsymmetric permutation and scaling MPS
        iparm_glob(12) = 0 ! not in use
        iparm_glob(13) = 1 ! maximum weighted matching algorithm is switched-on (default for non-symmetric)
        iparm_glob(14) = 0 ! Output: number of perturbed pivots
        iparm_glob(15) = 0 ! Output, Peak memory on symbolic factorization. 
        iparm_glob(16) = 0 ! Output, Permanent memory on symbolic factorization. This value is only computed in phase 1.
        iparm_glob(17) = 0 ! Output, Size of factors/Peak memory on numerical factorization and solution.
        iparm_glob(18) = 0 ! Input/output. Report the number of non-zero elements in the factors. >= 0 Disable reporting.
        iparm_glob(19) = 0 ! Input/output. Report number of floating point operations to factor matrix A. >= 0 Disable reporting.
        iparm_glob(20) = 0 ! Output: Numbers of CG Iterations. >0 CGS succeeded, reports the number of completed iterations.
        iparm_glob(24) = 1 ! Parallel factorization control, 0: classic algorithm, 1: two-level factorization algorithm, improve scalability on many threads.
        iparm_glob(25) = 0 ! Parallel forward/backward solve control. 0: Use parallel algorithm for the solve step; 1: Use the sequential forward/backward solve. 
        iparm_glob(27) = 0 !check matrix error, 0-without check, 1-check 
        
        if (rank == 0 .and. b_enable_output) then
          write(*,*) "Pardiso solver initialization for flow solver completed ... "
        end if
    
    end subroutine pardiso_initialize_flow

    !> Initialize pardiso for reactive transport problem
    subroutine pardiso_initialize_react
    
        implicit none
        
        ptrt%DUMMY = 0  
    
        !set up PARDISO control parameter for reactive transport
        iparm_rt= 0
        iparm_rt(1) = 1 ! no solver default
        iparm_rt(2) = 3 ! fill-in reordering from METIS ,0-MIN DEGREE, 2-METIS, 3-OPENMP VERSION
        iparm_rt(3) = 0 ! numbers of processors. Input the next call mkl_set_dynamic(0), mkl_set_num_threads(n);    
        iparm_rt(4) = i_cgs_criterion_react ! 0-no iterative-direct algorithm; 10*L+K, K=1 CGS, K=2 CGS for symmetric, 1.0E-L: stopping criterion 
        iparm_rt(5) = 0 ! no user fill-in reducing permutation
        iparm_rt(6) = 0 ! if == 1, the array of b is replaced with the solution x.
        iparm_rt(7) = 0 ! Output, Number of iterative refinement steps performed
        iparm_rt(8) = max_refine_itersteps_react ! numbers of iterative refinement steps, must be 0 if a solution is calculated with separate substitutions (phase = 331, 332, 333)
        iparm_rt(9) = 0 ! not in use
        iparm_rt(10) = npivotpertubation_react ! Default value 13, perturbe the pivot elements with 1E-13
        iparm_rt(11) = 1 ! use nonsymmetric permutation and scaling MPS
        iparm_rt(12) = 0 ! not in use
        iparm_rt(13) = 1 ! maximum weighted matching algorithm is switched-on (default for non-symmetric)
        iparm_rt(14) = 0 ! Output: number of perturbed pivots
        iparm_rt(15) = 0 ! Output, Peak memory on symbolic factorization. 
        iparm_rt(16) = 0 ! Output, Permanent memory on symbolic factorization. This value is only computed in phase 1.
        iparm_rt(17) = 0 ! Output, Size of factors/Peak memory on numerical factorization and solution.
        iparm_rt(18) = 0 ! Input/output. Report the number of non-zero elements in the factors. >= 0 Disable reporting.
        iparm_rt(19) = 0 ! Input/output. Report number of floating point operations to factor matrix A. >= 0 Disable reporting.
        iparm_rt(20) = 0 ! Output: Numbers of CG Iterations. >0 CGS succeeded, reports the number of completed iterations.
        iparm_rt(24) = 1 ! Parallel factorization control, 0: classic algorithm, 1: two-level factorization algorithm, improve scalability on many threads.
        iparm_rt(25) = 0 ! Parallel forward/backward solve control. 0: Use parallel algorithm for the solve step; 1: Use the sequential forward/backward solve.         
        iparm_rt(27) = 0 !check matrix error, 0-without check, 1-check
        
        if (rank == 0 .and. b_enable_output) then
          write(*,*) "Pardiso solver initialization for reactive transport solver completed ... "
        end if
        
    end subroutine pardiso_initialize_react
    
   
    !> pardiso symbolic factorization
    subroutine pardiso_symbfactor_1(pt_in, n_in, nnz_in, ia_in, ja_in, a_in)    
 
        implicit none
        
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in
        integer :: nnz_in
        integer :: ia_in(n_in + 1)
        integer :: ja_in(nnz_in)
        real(kind = dp) :: a_in(nnz_in)
        
        phase = 11 ! only reordering and symbolic factorization        

        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
        idum, nrhs, iparm, msglvl, ddum, ddum, error)

        !write(ilog,*) 'Symbolic factorization completed ... '
        if (error /= 0) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'The following ERROR was detected during symbolic factorization: ', error
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 1
        end if
        
        !if (rank == 0 .and. b_enable_output) then
        !write(ilog,*) 'Number of nonzeros in factors = ',iparm(18)
        !write(ilog,*) 'Number of factorization MFLOPS = ',iparm(19)
        !end if
        
    end subroutine pardiso_symbfactor_1
    
    !> pardiso symbolic factorization
    subroutine pardiso_symbfactor_2(iparm_in, pt_in, n_in, nnz_in, ia_in, ja_in, a_in)    
 
        implicit none
        
        integer :: iparm_in(64)
        type(MKL_PARDISO_HANDLE) :: pt_in(64)        
        integer :: n_in
        integer :: nnz_in
        integer :: ia_in(n_in + 1)
        integer :: ja_in(nnz_in)
        real(kind = dp) :: a_in(nnz_in)
        
        phase = 11 ! only reordering and symbolic factorization        
        
        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
        idum, nrhs, iparm_in, msglvl, ddum, ddum, error)
        
        if (error /= 0) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'The following ERROR was detected during symbolic factorization: ', error
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 1
        end if
        !if (rank == 0 .and. b_enable_output) then
        !write(ilog,*) 'Number of nonzeros in factors = ',iparm(18)
        !write(ilog,*) 'Number of factorization MFLOPS = ',iparm(19)
        !end if
        
    end subroutine pardiso_symbfactor_2
    
    !> pardiso numerical factorization
    subroutine pardiso_numfactor_1(pt_in, n_in, nnz_in, ia_in, ja_in, a_in)    
    
        implicit none
        
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in
        integer :: nnz_in
        integer :: ia_in(n_in + 1)
        integer :: ja_in(nnz_in)
        real(kind = dp) :: a_in(nnz_in)
      
   
        !Factorization.
        phase = 22 ! only factorization
        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
        idum, nrhs, iparm, msglvl, ddum, ddum, error)

        if (error /= 0) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'The following ERROR was detected during numerical factorization: ', error
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 1
        end if
    
    end subroutine pardiso_numfactor_1
    
    !> pardiso numerical factorization
    subroutine pardiso_numfactor_2(iparm_in, pt_in, n_in, nnz_in, ia_in, ja_in, a_in)    
    
        implicit none
  
        integer :: iparm_in(64)
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in
        integer :: nnz_in
        integer :: ia_in(n_in + 1)
        integer :: ja_in(nnz_in)
        real(kind = dp) :: a_in(nnz_in)
      
   
        !Factorization.
        phase = 22 ! only factorization

        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
        idum, nrhs, iparm_in, msglvl, ddum, ddum, error)
        
        if (error /= 0) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'The following ERROR was detected during numerical factorization: ', error
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 1
        end if
    
    end subroutine pardiso_numfactor_2
    
    !> pardiso substitution
    subroutine pardiso_substitution_1(pt_in, n_in, nnz_in, ia_in, ja_in, a_in, b_in, x_out)    
    
        implicit none
        
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in
        integer :: nnz_in
        integer :: ia_in(n_in + 1)
        integer :: ja_in(nnz_in)
        real(kind = dp) :: a_in(nnz_in)
        real(kind = dp) :: b_in(n_in) 
        real(kind = dp) :: x_out(n_in)
    
        !Back substitution and iterative refinement
        phase = 33 ! only substitution
        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
        idum, nrhs, iparm, msglvl, b_in, x_out, error)

        !check if solve failed, x_out = nan
        
        if (error /= 0) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'The following ERROR was detected during substitution: ', error
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 1
        end if
        
    end subroutine pardiso_substitution_1
    

    !> pardiso substitution
    subroutine pardiso_substitution_2(lfile, nitmax, numit, idetail,                        &
                                        res, restol, deltol, over_flow, rnorm, rmupdate,    &
                                        iparm_in, pt_in, n_in, nnz_in, ia_in, ja_in, a_in, b_in, x_out)    
    
        implicit none
 
        integer :: iparm_in(64)
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in                     ! number of unknowns
        integer :: nnz_in                   ! number of global connections
        integer :: ia_in(n_in + 1)          ! row start pointers for a()
        integer :: ja_in(nnz_in)            ! global connection list for a()
        real(kind = dp) :: a_in(nnz_in)     ! coefficient matrix
        real(kind = dp) :: b_in(n_in)       ! forcing vector
        real(kind = dp) :: x_out(n_in)      ! approximate solution            *
        
        integer :: lfile                    ! output unit number
        integer :: nitmax                   ! max num of iterations
        integer :: numit                    ! number of solver iterations     *
        integer :: idetail                  ! solver information level
        real(kind = dp) :: res(n_in)        ! residual                        *
        real(kind = dp) :: restol           ! solver residual tolerance
        real(kind = dp) :: deltol           ! solver update tolerance (i.e. 0.1*picard)
        real(kind = dp) :: rnorm            ! residual 2-norm
        real(kind = dp) :: rmupdate         ! maximum solution update
!c!                                                             modified on return = *
!c!-----------------------------------------------------------------------
!c! Local variables       
        logical :: over_flow
        logical :: converged
        integer :: i, i0, i1
        real(kind = dp) :: r0, huge         ! upper bound - determination of overflow
        
        parameter (i0 = 0, i1 = 1, r0 = 0.0d0, huge = 1.d300)
        
        over_flow = .false.
        
        if (idetail > i1 .and. rank == 0 .and. b_enable_output) then
            write (lfile,9)
            write (lfile,10)
            write (lfile,11)
        endif
        
        numit = i0
        rnorm = r0
        
        do i = i1, n_in
            rnorm = rnorm + b_in(i)**2
        end do
        
        rnorm = sqrt(rnorm)

!culi
        if (rnorm > huge) then                  !overflow occurred
            over_flow = .true.                  !reduce timestep or stop execution
            !if (rank == 0 .and. b_enable_output) then
            !write(ilog,*) "calculated rnorm is two large, overflow occurred: ", rnorm
            !end if
            return                              !in calling routine

!cjoel IF (rnorm.GT.r0) THEN
!culi
        else if (rnorm > r0) then               !solve system of equations
!c! Solve system of equations start of:
            
            converged = .false. 
            !Back substitution and iterative refinement
            phase = 33                          ! only factorization
            call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
            idum, nrhs, iparm_in, msglvl, b_in, x_out, error)
            !write(ilog,*) 'Substitution completed ... '
            
            if (iparm_in(4) > 0) then
                if (iparm_in(20) < 0) then     !CG/CGS failed
                    over_flow = .true.
                    return
                end if            
                numit = iparm_in(20)            
            else
                numit = iparm_in(7)
            end if            
            
            !check if solve failed, x_out = nan        
            if (error /= 0) then
                if (rank == 0 .and. b_enable_output) then
                  write(ilog,*) 'The following ERROR was detected during substitution: ', error
                end if
                !stop 1
                over_flow = .true.
                return
            end if
            
            !Check residual, residual to norm and maximum update of x
            !Note: the residual norm rnorm here is different from WatSolv, the norm here is norm of residual |ax-b|^2.
            !For some simulation, this value will be larger than the preset maximum acceptable norm. 
            !if (rank == 0 .and. b_enable_output) then
            !write(ilog,*) 'Check residual, residual to norm and maximum update of x ... '
            !end if
            rmupdate = r0 
            rnorm = r0            
            call mkl_dcsrgemv('N', n_in, a_in, ia_in, ja_in, x_out, res) 
            res = res-b_in
            rnorm = sqrt(sum(res**2))
            !call pardiso_check_result(n_in, nnz_in, ia_in, ja_in, a_in, b_in, x_out, res, rnorm, rmupdate) 
            !if (rank == 0 .and. b_enable_output) then
            !write(ilog,*) 'Finished checking residual, residual to norm and maximum update of x'
            !end if
            
!cintellinux  *** relapce isnan by huge = 1.0d300 ***
            if (isnan(rnorm)) then              !rnorm = NaN, Check Nan
                over_flow = .true.              !reduce timestep or stop execution
                !if (rank == 0 .and. b_enable_output) then
                !write(ilog,*) "calculated rnorm is nan, overflow occurred: ", rnorm
                !end if
                return                          !in calling routine
            end if
            
            !converged = (.not. (rnorm > restol) .or. .not. (rmupdate > deltol))
            converged = .true.
            
            if (idetail > i1 .and. rank == 0 .and. b_enable_output) then
              write (lfile,2) numit,rmupdate,rnorm
            endif
         
        else         !rnorm.le.r0 -> converged   
            if (rank == 0 .and. idetail > i1 .and. b_enable_output) then
              write (lfile,14)
            end if
            converged = .true.
        end if

        if (idetail > i1 .and. rank == 0 .and. b_enable_output) then
            write (lfile,*)
        endif
        
 2      format (1x,i5,4x,2(2x,1pd11.4))       
 9      format (/1x,'Solver Iteration Convergence Summary:')
 10     format (1x,'solver        total        total   ')
 11     format (1x,'iteration    update       residual  ')
 14     format (/1x,'Maximum error from previous solution is less',        &
        &        /1x,'than the specified convergence tolerance.')       
        
    end subroutine pardiso_substitution_2

    !> calculate residual, residual to norm and maximum update of x
    !> this function is not of high efficiency at present, should update to BLAS2 level
    subroutine pardiso_check_result(n_in, nnz_in, ia_in, ja_in, a_in, b_in, x_in, res, rnorm, rmupdate)
    
#ifdef OPENMP
      use omp_lib 
#endif
    
        implicit none
        integer :: n_in                     ! number of unknowns
        integer :: nnz_in                   ! number of global connections
        integer :: ia_in(n_in + 1)          ! row start pointers for a()
        integer :: ja_in(nnz_in)            ! global connection list for a()
        real(kind = dp) :: a_in(nnz_in)     ! coefficient matrix
        real(kind = dp) :: b_in(n_in)       ! forcing vector
        real(kind = dp) :: x_in(n_in)       ! approximate solution
        real(kind = dp) :: res(n_in)        ! residual
        real(kind = dp) :: rnorm            ! residual 2-norm
        real(kind = dp) :: rmupdate         ! maximum solution update
        
        integer         :: i, j, k
        !---------------------------------------------------------------------------
        ! An external BLAS function is taken from MKL BLAS to use
        !---------------------------------------------------------------------------
        !DOUBLE PRECISION DNRM2
        !EXTERNAL DNRM2
        
        !definition of residual. r = B - AX_computed
        rnorm = 0.0d0
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp num_threads(numofthreads_pardiso)                           &
    !$omp default(shared)                                             &
    !$omp private (i, j, k)                                           &
    !$omp reduction(+:rnorm)
    !$omp do schedule(static) 
#endif
        do i = 1, n_in
            res(i) = -b_in(i)
            do j = ia_in(i), ia_in(i+1) - 1
                k = ja_in(j)
                res(i) = res(i) + a_in(j) * x_in(k)
            end do
            rnorm = rnorm + res(i)**2
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif                        
        rnorm = sqrt(rnorm)
        
        !Compute the current true residual via MKL (Sparse) BLAS routines
          !CALL MKL_DCSRGEMV('N', n_in, a_in, ia_in, ja_in, x_in, res)
          !CALL DAXPY(n_in, -1.0D0, b_in, 1, res, 1)
        
        !residual to norm, method 1: The L^1 vector norm, ||x||_1 = |x1| + |x2| + ... + |xn|
        !rnorm = 0.0d0
        !do i = 1, n_in
        !    rnorm = sum(abs(res))
        !end do
               
        !residual to norm, method 2: The L^2 (or Euclidean) vector norm, ||x||_2 = sqrt(x1*x1 + x2*x2 + ... + xn*xn)
        !rnorm = 0.0d0
        !rnorm = sum(res**2)
        !rnorm = sqrt(rnorm)
        
        !residual to norm, method 3:The  L^infty vector norm, ||x||_infty = max|xi|, i=1, 2, ..., n
        !rnorm = maxval(abs(res))

        !compute rnorm via MKL routine
          !rnorm=DNRM2(res)
    
    end subroutine pardiso_check_result
    
    !> pardiso substitution
    subroutine pardiso_substitution_test(pt_in, n_in, nnz_in, ia_in, ja_in, a_in, b_in)    
    
        implicit none
        
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in
        integer :: nnz_in
        integer :: ia_in(n_in + 1)
        integer :: ja_in(nnz_in)
        real(kind = dp) :: a_in(nnz_in)
        real(kind = dp) :: b_in(n_in) 

        if(.not. allocated(x)) then
            allocate(x((n_in)))
            x = 0.0d0
        end if
        if(size(x, 1) /= n_in) then
            deallocate(x)
            allocate(x((n_in)))
            x = 0.0d0
        end if
        
        !Back substitution and iterative refinement
        phase = 33 ! only substitution
       
        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, a_in, ia_in, ja_in,     &
        idum, nrhs, iparm, msglvl, b_in, x, error)
       
        if (error /= 0) then
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'The following ERROR was detected during substitution: ', error
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 1
        end if
        
    end subroutine pardiso_substitution_test
    
    !> pardiso release internal memory
    subroutine pardiso_release_memory_1(pt_in, n_in)    
    
        implicit none
        
        type(MKL_PARDISO_HANDLE) :: pt_in(64)
        integer :: n_in
        integer :: nnz_in
    
        phase = -1 ! release internal memory
        call pardiso (pt_in, maxfct, mnum, mtype, phase, n_in, ddum, idum,    &
        idum, idum, nrhs, iparm, msglvl, ddum, ddum, error)
    
    end subroutine pardiso_release_memory_1
    
    !> pardiso release internal memory
    subroutine pardiso_release_memory_all
    
        implicit none
            
        phase = -1 ! release internal memory 
        
        if(n_unknown_vs > 0) then
            call pardiso (ptvs, maxfct, mnum, mtype, phase, n_unknown_vs, ddum, idum,    &
            idum, idum, nrhs, iparm_vs, msglvl, ddum, ddum, error)
        end if
        
        if(n_unknown_glob > 0) then
            call pardiso (ptglob, maxfct, mnum, mtype, phase, n_unknown_glob, ddum, idum,    &
            idum, idum, nrhs, iparm_vs, msglvl, ddum, ddum, error)    
        end if
        
        if(n_unknown_rt > 0) then
            call pardiso (ptrt, maxfct, mnum, mtype, phase, n_unknown_rt, ddum, idum,    &
            idum, idum, nrhs, iparm_rt, msglvl, ddum, ddum, error)    
        end if        
    
    end subroutine pardiso_release_memory_all
      
end module solver_pardiso

#endif
