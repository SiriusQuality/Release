!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 453 $
!> $Author: dsu $
!> $Date: 2017-02-21 19:54:05 +0100 (Tue, 21 Feb 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/fgerard_new/src/solver/matrix_utility.F90 $
!---------------------------------------------------------------------
!********************************************************************!
module matrix_utility

  use file_unit, only : lun_get, lun_free

  implicit none

    integer, parameter :: dp = kind(1.0d0)
    

    contains
    
    !> 
    !> Export matrix to Matrix Market (MM) exchange format.
    !> For formats, please look into http://math.nist.gov/MatrixMarket/formats.html
    subroutine export_mmformat(n, nnz, ia_in, ja_in, a_in, b_in, x_in, &
                               flag_a, flag_b, flag_x, strsuffix, inum)
        use gen, only : str_rank, node_idx_lg2g
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), intent(in) :: x_in(n)
        logical, intent(in) :: flag_a
        logical, intent(in) :: flag_b
        logical, intent(in) :: flag_x
        character(*), intent(in) :: strsuffix
        integer, optional :: inum
        character(72) :: strinum
        character(256) :: strpathsurfix
        integer :: iunit
        integer :: i, j
        
        if(present(inum)) then
            write(strinum, *) inum
            strinum = "_"//trim(adjustl(strinum))
        else
            strinum = ""
        end if
        
        strpathsurfix = trim(adjustl(strsuffix))//trim(strinum)//trim(str_rank)
        
        !iunit = 93
        iunit = lun_get()
        
        !Export matrix a
        if(flag_a) then
        
        open (unit = iunit, file = "a_"//trim(strpathsurfix)//".mtx")
        
        !Write head
        write(iunit, '(a)') "%%MatrixMarket matrix coordinate real general                                     "
        write(iunit, '(a)') "%================================================================================="
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% This ASCII file represents a sparse MxN matrix with L                           "
        write(iunit, '(a)') "% nonzeros in the following Matrix Market format:                                 "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "% |%%MatrixMarket matrix coordinate real general | <--- header line               "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |% comments                                    |    |-- 0 or more comment lines "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |    M  N  L                                   | <--- rows, columns, entries    "
        write(iunit, '(a)') "% |    I1  J1  A(I1, J1)                         | <--+                           "
        write(iunit, '(a)') "% |    I2  J2  A(I2, J2)                         |    |                           "
        write(iunit, '(a)') "% |    I3  J3  A(I3, J3)                         |    |-- L lines                 "
        write(iunit, '(a)') "% |        . . .                                 |    |                           "
        write(iunit, '(a)') "% |    IL JL  A(IL, JL)                          | <--+                           "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% Indices are 1-based, i.e. A(1,1) is the first element.                          "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "%================================================================================="        
        
        !Write value
        write(iunit, '(3(i10, 1x))') n, n, nnz
        
        do i = 1, n
            do j = ia_in(i), ia_in(i+1)-1
                write(iunit,'(2(i10,1x), e16.8)') i, ja_in(j), a_in(j)
            end do
        end do        
        
        close(iunit)

        end if  !end of export matrix a
        
        
        !Export right hand side b
        if(flag_b) then        
            open (unit = iunit, file = "b_"//trim(strpathsurfix)//".txt")
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) b_in(i)
            end do
            close(iunit)
        end if  !end of exprot right hand side b
        
        !Export solution x        
        if(flag_x) then        
            open (unit = iunit, file = "x_"//trim(strpathsurfix)//".txt")
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) x_in(i)
            end do
            close(iunit)
        end if  !end of export solution x

        call lun_free(iunit)

    end subroutine

    !>
    !> Export matrix to Matrix Market (MM) exchange format.
    !> For formats, please look into http://math.nist.gov/MatrixMarket/formats.html
    subroutine export_mmformat_gbl(n, nnz, ia_in, ja_in, a_in, b_in,   &
                                   x_in, flag_a, flag_b, flag_x,       &
                                   strsuffix, nvols, nvols_gbl,        &
                                   isreact, inum)

#ifdef PETSC
        use gen, only : str_rank, node_idx_lg2l, node_idx_lg2g
#else
        use gen, only : str_rank
#endif

        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), intent(in) :: x_in(n)
        logical, intent(in) :: flag_a
        logical, intent(in) :: flag_b
        logical, intent(in) :: flag_x
        character(*), intent(in) :: strsuffix
        integer, intent(in) :: nvols
        integer, intent(in) :: nvols_gbl
        logical, intent(in) :: isreact
        integer, optional :: inum
        character(72) :: strinum
        character(256) :: strpathsurfix
        integer :: iunit
        integer :: i, j, ivol, jvol, k, dof, row_offset, col_offset

        if(present(inum)) then
            write(strinum, *) inum
            strinum = "_"//trim(adjustl(strinum))
        else
            strinum = ""
        end if



        strpathsurfix = trim(adjustl(strsuffix))//trim(strinum)//trim(str_rank)

        dof = n/nvols

        !iunit = 93
        iunit = lun_get()
        
        !Export matrix a
        if(flag_a) then
        
        open (unit = iunit, file = "a_"//trim(strpathsurfix)//"_natgbl.mtx")    !Export in natural global ordering

        !Write head
        write(iunit, '(a)') "%%MatrixMarket matrix coordinate real general                                     "
        write(iunit, '(a)') "%================================================================================="
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% This ASCII file represents a sparse MxN matrix with L                           "
        write(iunit, '(a)') "% nonzeros in the following Matrix Market format:                                 "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "% |%%MatrixMarket matrix coordinate real general | <--- header line               "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |% comments                                    |    |-- 0 or more comment lines "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |    M  N  L                                   | <--- rows, columns, entries    "
        write(iunit, '(a)') "% |    I1  J1  A(I1, J1)                         | <--+                           "
        write(iunit, '(a)') "% |    I2  J2  A(I2, J2)                         |    |                           "
        write(iunit, '(a)') "% |    I3  J3  A(I3, J3)                         |    |-- L lines                 "
        write(iunit, '(a)') "% |        . . .                                 |    |                           "
        write(iunit, '(a)') "% |    IL JL  A(IL, JL)                          | <--+                           "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% Indices are 1-based, i.e. A(1,1) is the first element.                          "
        write(iunit, '(a)') "% The indices are in global mode                                                  "
        write(iunit, '(a)') "%================================================================================="

        !Write value
        write(iunit, '(3(i10, 1x))') n, n, nnz

        row_offset = 0
        col_offset = 0

        do i = 1, n
          if (dof > 1) then
            if (isreact) then
              ivol = ceiling(i*1.0/dof)
              row_offset = i -ivol*dof
            else
              if (i <= nvols) then
                ivol = i
                row_offset = 0
              else
                ivol = i - nvols
                row_offset = nvols_gbl
              end if
            end if
          else
            ivol = i
            row_offset = 0
          end if

#ifdef PETSC
          if (node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif


          do j = ia_in(i), ia_in(i+1)-1

            if (dof > 1) then
              if (isreact) then
                jvol = ceiling(ja_in(j)*1.0/dof)
                col_offset = ja_in(j) -jvol*dof
              else
                if (ja_in(j) <= nvols) then
                  jvol = ja_in(j)
                  col_offset = 0
                else
                  jvol = ja_in(j) - nvols
                  col_offset = nvols_gbl
                end if
              end if
            else
              jvol = ja_in(j)
              col_offset = 0
            end if

#ifdef PETSC
            if (isreact) then
              write(iunit,*) node_idx_lg2g(ivol)*dof+row_offset, &
                    node_idx_lg2g(jvol)*dof+col_offset, a_in(j)
            else
              write(iunit,*) node_idx_lg2g(ivol)+row_offset, &
                    node_idx_lg2g(jvol)+col_offset, a_in(j)
            end if
#else
            if (isreact) then
              write(iunit,*) ivol*dof+row_offset, &
                    jvol*dof+col_offset, a_in(j)
            else
              write(iunit,*) ivol+row_offset, &
                    jvol+col_offset, a_in(j)
            end if
#endif

          end do
        end do

        close(iunit)
        
        end if  !end of export matrix a
        
        
        !Export right hand side b
        if(flag_b) then        

            open (unit = iunit, file = "b_"//trim(strpathsurfix)//"_natgbl.txt")

            write(iunit, *) n

            do i = 1, n
              if (dof > 1) then
                if (isreact) then
                  ivol = ceiling(i*1.0/dof)
                  row_offset = i -ivol*dof
                else
                  if (i <= nvols) then
                    ivol = i
                    row_offset = 0
                  else
                    ivol = i - nvols
                    row_offset = nvols_gbl
                  end if
                end if
              else
                ivol = i
                row_offset = 0
              end if

#ifdef PETSC
              if (node_idx_lg2l(ivol) < 0) then
                cycle
              end if
#endif

#ifdef PETSC
              if (isreact) then
                write(iunit, *) node_idx_lg2g(ivol)*dof+row_offset, b_in(i)
              else
                write(iunit, *) node_idx_lg2g(ivol)+row_offset, b_in(i)
              end if
#else
              if (isreact) then
                write(iunit, *) ivol*dof+row_offset, b_in(i)
              else
                write(iunit, *) ivol+row_offset, b_in(i)
              end if
#endif

            end do

            close(iunit)

        end if  !end of exprot right hand side b
        
        !Export solution x        
        if(flag_x) then

            open (unit = iunit, file = "x_"//trim(strpathsurfix)//"_natgbl.txt")
            write(iunit, *) n

            do i = 1, n
              if (dof > 1) then
                if (isreact) then
                  ivol = ceiling(i*1.0/dof)
                  row_offset = i -ivol*dof
                else
                  if (i <= nvols) then
                    ivol = i
                    row_offset = 0
                  else
                    ivol = i - nvols
                    row_offset = nvols_gbl
                  end if
                end if
              else
                ivol = i
                row_offset = 0
              end if

#ifdef PETSC
              if (node_idx_lg2l(ivol) < 0) then
                cycle
              end if
#endif

#ifdef PETSC
              if (isreact) then
                write(iunit, *) node_idx_lg2g(ivol)*dof+row_offset, x_in(i)
              else
                write(iunit, *) node_idx_lg2g(ivol)+row_offset, x_in(i)
              end if
#else
              if (isreact) then
                write(iunit, *) ivol*dof+row_offset, x_in(i)
              else
                write(iunit, *) ivol+row_offset, x_in(i)
              end if
#endif

            end do

            close(iunit)

        end if  !end of export solution x

        call lun_free(iunit)
        
    end subroutine 
    
    !export 1d array data to file
    subroutine export_arrays1d(n, nnz, ia_in, ja_in, a_in, b_in, x_in, &
                               flag_a, flag_b, flag_x, strsuffix, inum)
        use gen, only : str_rank    
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), intent(in) :: x_in(n)
        logical, intent(in) :: flag_a
        logical, intent(in) :: flag_b
        logical, intent(in) :: flag_x
        character(*), intent(in) :: strsuffix
        character(256) :: strpathsurfix
        integer, optional :: inum
        
        character(72) :: strinum
        integer :: iunit
        integer :: i
        
        if(present(inum)) then
            write(strinum, *) inum
            strinum = "_"//trim(adjustl(strinum))
        else
            strinum = ""
        end if
        
        strpathsurfix = trim(adjustl(strsuffix))//trim(strinum)//trim(str_rank)//".txt"
        
        !iunit = 93 
        iunit = lun_get()
        
        !Export matrix a
        if(flag_a) then        
            open (unit = iunit, file = "ia_"//trim(strpathsurfix))
            write(iunit, *) n + 1 
            do i = 1, n + 1
                write(iunit, *) ia_in(i)
            end do
            close(iunit)        

            open (unit = iunit, file = "ja_"//trim(strpathsurfix))

            write(iunit, *) nnz
            do i = 1, nnz
                write(iunit, *) ja_in(i)
            end do
            close(iunit)
            
            open (unit = iunit, file = "a_"//trim(strpathsurfix))

            write(iunit, *) nnz
            do i = 1, nnz
                write(iunit, *) a_in(i)
            end do
            close(iunit)
        end if  !end of export matrix a
        
        
        !Export right hand side b
        if(flag_b) then            
            open (unit = iunit, file = "b_"//trim(strpathsurfix))
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) b_in(i)
            end do
            close(iunit)        
        end if  !end of exprot right hand side b
        
        !Export solution x        
        if(flag_x) then
            open (unit = iunit, file = "x_"//trim(strpathsurfix))
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) x_in(i)
            end do
            close(iunit)        
        end if  !end of export solution x
        
        call lun_free(iunit)
    
    end subroutine
    
    !export sparse matrix to 2d format, just for a easier view
    subroutine export_matrix2d_1(iunit, n, nnz,ia_in, ja_in, a_in, b_in)
    
        implicit none
        
        integer, intent(in) :: iunit
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), allocatable :: mat2d(:)
        integer :: i, j, k, istart, iend
        
        allocate(mat2d(n*(n+1)))
        
        !set value
        mat2d = 0.0d0        
        do i = 1, n
            istart = ia_in(i)
            iend = ia_in(i+1)-1
            do j = istart, iend
                k = (i-1)*n + ja_in(j)
                mat2d(k) = a_in(j)
            end do
        end do
        
        mat2d(n*n + 1:) = b_in(1:)
        
        !write data
        do i = 1, n
            write(iunit,"(100(e10.3, 1x))") (mat2d(j), j = (i-1)*n+1, i*n), mat2d(n*n + i)
        end do
        
        !write(idbg,'(100(e10.3,1x))')(0.0e0,i1=1,jafvs(istart)-1),(avs(i1),i1=istart,iend),(0.0e0,i1=jafvs(iend) + 1,nn),bvs(ivol)
        
        deallocate(mat2d)
        
    end subroutine export_matrix2d_1
    
    
    !export sparse matrix to 2d format, just for a easier view
    subroutine export_matrix2d_2(strsuffix, n, nnz,ia_in, ja_in, a_in, b_in)
    
        implicit none
        
        character(*), intent(in) :: strsuffix
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)        
        integer :: iunit
        
        !iunit = 93
        iunit = lun_get()
        
        open (unit = iunit, file = "matrix_"//trim(adjustl(strsuffix))//".txt", position = 'append')
            write(iunit, *)"matrix: ", n, " x ", n 
            call export_matrix2d_1(iunit, n, nnz,ia_in, ja_in, a_in, b_in)
        close(iunit)
        
        call lun_free(iunit)
        
    end subroutine export_matrix2d_2
    
    !> remap matrix ja locations and values of a 
    subroutine remap_matrix_a_ja (n, ia, nja, ja, a)
#ifdef OPENMP   
        use gen, only : numofthreads_global, numofloops_thred_matrix_uti_1
#endif
    
        implicit none
        
        integer, intent(in) :: n
        integer, intent(in) :: ia(n+1)
        integer, intent(in) :: nja
        integer, intent(inout) :: ja(nja)
        real(kind = dp), intent(inout) :: a(nja)
        integer :: i
                
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (n > numofloops_thred_matrix_uti_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)                  
    !$omp do schedule(static)
#endif
        do i = 1, n
            call qsort(ja(ia(i):ia(i+1)-1),a(ia(i):ia(i+1)-1))
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
 
    end subroutine remap_matrix_a_ja
    
    
    !> remap matrix structure to generate standard sparse matrix pointer array
    subroutine remap_matrix_ja(n, ia, nja, ja, imap)
#ifdef OPENMP    
        use gen, only : numofthreads_global, numofloops_thred_matrix_uti_1
#endif
    
        implicit none
        
        integer, intent(in) :: n
        integer, intent(in) :: ia(n+1)
        integer, intent(in) :: nja
        integer, intent(inout) :: ja(nja)
        integer, intent(inout) :: imap(nja)
        
        integer :: i
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (n > numofloops_thred_matrix_uti_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)                  
    !$omp do schedule(static)
#endif
        do i = 1, n
            call qsort2(ja(ia(i):ia(i+1)-1),imap(ia(i):ia(i+1)-1))
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
        
        write(*,*) "Remapping matrix structure completed ... "
    
    end subroutine remap_matrix_ja
    
    !> quick sort ja in each row to make column indices ja should in increasing order per row
    recursive subroutine qsort(ja, a)
        
        implicit none
        
        integer, intent(inout), dimension(:) :: ja
        real(kind = dp), intent(inout), dimension(:) :: a
        integer :: iq

        if(size(ja,1) > 1) then
            call partition(ja, a, iq)
            call qsort(ja(:iq-1),a(:iq-1))
            call qsort(ja(iq:),a(iq:))
        endif
        
    end subroutine qsort

    !> subroutine for quicksort
    subroutine partition(ja,a, marker)
    
        implicit none
      
        integer, intent(inout), dimension(:) :: ja
        real(kind = dp), intent(inout), dimension(:) :: a
        integer, intent(out) :: marker
        integer :: i, j
        integer :: tempi
        integer :: x      ! pivot point
        real(kind = dp) :: tempr
        x = ja(1)
        i= 0
        j= size(ja, 1) + 1

        do
            j = j-1
            do
            if (ja(j) <= x) exit
            j = j-1
            end do
            i = i+1
            do
            if (ja(i) >= x) exit
            i = i+1
            end do
            if (i < j) then
            ! exchange ja_in(i), ja_in(j) and a_in(i), a_in(j)
            
            tempr = a(i)
            a(i) = a(j)
            a(j) = tempr
            
            tempi = ja(i)            
            ja(i) = ja(j)
            ja(j) = tempi            
            
            elseif (i == j) then
            marker = i+1
            return
            else
            marker = i
            return
            endif
        end do
        
    end subroutine partition   
    
    !> quick sort ja in each row to make column indices ja in increasing order per row
    recursive subroutine qsort2(ja, imap)
        
        implicit none
        
        integer, intent(inout), dimension(:) :: ja
        integer, intent(inout), dimension(:) :: imap
        integer :: iq

        if(size(ja,1) > 1) then
            call partition2(ja, imap, iq)
            call qsort2(ja(:iq-1),imap(:iq-1))
            call qsort2(ja(iq:),imap(iq:))
        endif
        
    end subroutine qsort2

    !> subroutine for quicksort
    subroutine partition2(ja, imap, marker)
    
        implicit none
      
        integer, intent(inout), dimension(:) :: ja
        integer, intent(inout), dimension(:) :: imap
        integer, intent(out) :: marker
        integer :: i, j
        integer :: tempi
        integer :: x      ! pivot point
        real(kind = dp) :: tempr
        x = ja(1)
        i= 0
        j= size(ja, 1) + 1

        do
            j = j-1
            do
                if (ja(j) <= x) exit
                j = j-1
            end do
            i = i+1
            do
                if (ja(i) >= x) exit
                i = i+1
            end do
            if (i < j) then
                tempi = imap(i)
                imap(i) = imap(j)
                imap(j) = tempi
                
                tempi = ja(i)            
                ja(i) = ja(j)
                ja(j) = tempi
            elseif (i == j) then
                marker = i+1
                return
            else
                marker = i
                return
            endif
            
        end do
        
    end subroutine partition2  

end module matrix_utility